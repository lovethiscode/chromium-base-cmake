// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ANDROID_SURFACEFLINGER_COMMON_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ANDROID_SURFACEFLINGER_COMMON_PROTO_H_

#include <stddef.h>
#include <stdint.h>

#include "perfetto/protozero/field_writer.h"
#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {
class RectProto;
class RegionProto;
class TransformProto;
} // Namespace pbzero.
} // Namespace protos.
} // Namespace perfetto.

namespace perfetto {
namespace protos {
namespace pbzero {

enum TrustedOverlay : int32_t {
  UNSET = 0,
  DISABLED = 1,
  ENABLED = 2,
};

constexpr TrustedOverlay TrustedOverlay_MIN = TrustedOverlay::UNSET;
constexpr TrustedOverlay TrustedOverlay_MAX = TrustedOverlay::ENABLED;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* TrustedOverlay_Name(::perfetto::protos::pbzero::TrustedOverlay value) {
  switch (value) {
  case ::perfetto::protos::pbzero::TrustedOverlay::UNSET:
    return "UNSET";

  case ::perfetto::protos::pbzero::TrustedOverlay::DISABLED:
    return "DISABLED";

  case ::perfetto::protos::pbzero::TrustedOverlay::ENABLED:
    return "ENABLED";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

class ColorTransformProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ColorTransformProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ColorTransformProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ColorTransformProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_val() const { return at<1>().valid(); }
  ::protozero::PackedRepeatedFieldIterator<::protozero::proto_utils::ProtoWireType::kFixed32, float> val(bool* parse_error_ptr) const { return GetPackedRepeated<::protozero::proto_utils::ProtoWireType::kFixed32, float>(1, parse_error_ptr); }
};

class ColorTransformProto : public ::protozero::Message {
 public:
  using Decoder = ColorTransformProto_Decoder;
  enum : int32_t {
    kValFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ColorTransformProto"; }


  using FieldMetadata_Val =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kRepeatedPacked,
      ::protozero::proto_utils::ProtoSchemaType::kFloat,
      float,
      ColorTransformProto>;

  static constexpr FieldMetadata_Val kVal{};
  void set_val(const ::protozero::PackedFixedSizeInt<float>& packed_buffer) {
    AppendBytes(FieldMetadata_Val::kFieldId, packed_buffer.data(),
                packed_buffer.size());
  }
};

class BlurRegion_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlurRegion_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlurRegion_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlurRegion_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_blur_radius() const { return at<1>().valid(); }
  uint32_t blur_radius() const { return at<1>().as_uint32(); }
  bool has_corner_radius_tl() const { return at<2>().valid(); }
  uint32_t corner_radius_tl() const { return at<2>().as_uint32(); }
  bool has_corner_radius_tr() const { return at<3>().valid(); }
  uint32_t corner_radius_tr() const { return at<3>().as_uint32(); }
  bool has_corner_radius_bl() const { return at<4>().valid(); }
  uint32_t corner_radius_bl() const { return at<4>().as_uint32(); }
  bool has_corner_radius_br() const { return at<5>().valid(); }
  float corner_radius_br() const { return at<5>().as_float(); }
  bool has_alpha() const { return at<6>().valid(); }
  float alpha() const { return at<6>().as_float(); }
  bool has_left() const { return at<7>().valid(); }
  int32_t left() const { return at<7>().as_int32(); }
  bool has_top() const { return at<8>().valid(); }
  int32_t top() const { return at<8>().as_int32(); }
  bool has_right() const { return at<9>().valid(); }
  int32_t right() const { return at<9>().as_int32(); }
  bool has_bottom() const { return at<10>().valid(); }
  int32_t bottom() const { return at<10>().as_int32(); }
};

class BlurRegion : public ::protozero::Message {
 public:
  using Decoder = BlurRegion_Decoder;
  enum : int32_t {
    kBlurRadiusFieldNumber = 1,
    kCornerRadiusTlFieldNumber = 2,
    kCornerRadiusTrFieldNumber = 3,
    kCornerRadiusBlFieldNumber = 4,
    kCornerRadiusBrFieldNumber = 5,
    kAlphaFieldNumber = 6,
    kLeftFieldNumber = 7,
    kTopFieldNumber = 8,
    kRightFieldNumber = 9,
    kBottomFieldNumber = 10,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.BlurRegion"; }


  using FieldMetadata_BlurRadius =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      BlurRegion>;

  static constexpr FieldMetadata_BlurRadius kBlurRadius{};
  void set_blur_radius(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_BlurRadius::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_CornerRadiusTl =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      BlurRegion>;

  static constexpr FieldMetadata_CornerRadiusTl kCornerRadiusTl{};
  void set_corner_radius_tl(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_CornerRadiusTl::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_CornerRadiusTr =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      BlurRegion>;

  static constexpr FieldMetadata_CornerRadiusTr kCornerRadiusTr{};
  void set_corner_radius_tr(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_CornerRadiusTr::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_CornerRadiusBl =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      BlurRegion>;

  static constexpr FieldMetadata_CornerRadiusBl kCornerRadiusBl{};
  void set_corner_radius_bl(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_CornerRadiusBl::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_CornerRadiusBr =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kFloat,
      float,
      BlurRegion>;

  static constexpr FieldMetadata_CornerRadiusBr kCornerRadiusBr{};
  void set_corner_radius_br(float value) {
    static constexpr uint32_t field_id = FieldMetadata_CornerRadiusBr::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kFloat>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Alpha =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kFloat,
      float,
      BlurRegion>;

  static constexpr FieldMetadata_Alpha kAlpha{};
  void set_alpha(float value) {
    static constexpr uint32_t field_id = FieldMetadata_Alpha::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kFloat>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Left =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      BlurRegion>;

  static constexpr FieldMetadata_Left kLeft{};
  void set_left(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Left::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Top =
    ::protozero::proto_utils::FieldMetadata<
      8,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      BlurRegion>;

  static constexpr FieldMetadata_Top kTop{};
  void set_top(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Top::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Right =
    ::protozero::proto_utils::FieldMetadata<
      9,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      BlurRegion>;

  static constexpr FieldMetadata_Right kRight{};
  void set_right(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Right::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Bottom =
    ::protozero::proto_utils::FieldMetadata<
      10,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      BlurRegion>;

  static constexpr FieldMetadata_Bottom kBottom{};
  void set_bottom(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Bottom::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

class InputWindowInfoProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/17, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  InputWindowInfoProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit InputWindowInfoProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit InputWindowInfoProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_layout_params_flags() const { return at<1>().valid(); }
  uint32_t layout_params_flags() const { return at<1>().as_uint32(); }
  bool has_layout_params_type() const { return at<2>().valid(); }
  int32_t layout_params_type() const { return at<2>().as_int32(); }
  bool has_frame() const { return at<3>().valid(); }
  ::protozero::ConstBytes frame() const { return at<3>().as_bytes(); }
  bool has_touchable_region() const { return at<4>().valid(); }
  ::protozero::ConstBytes touchable_region() const { return at<4>().as_bytes(); }
  bool has_surface_inset() const { return at<5>().valid(); }
  int32_t surface_inset() const { return at<5>().as_int32(); }
  bool has_visible() const { return at<6>().valid(); }
  bool visible() const { return at<6>().as_bool(); }
  bool has_can_receive_keys() const { return at<7>().valid(); }
  bool can_receive_keys() const { return at<7>().as_bool(); }
  bool has_focusable() const { return at<8>().valid(); }
  bool focusable() const { return at<8>().as_bool(); }
  bool has_has_wallpaper() const { return at<9>().valid(); }
  bool has_wallpaper() const { return at<9>().as_bool(); }
  bool has_global_scale_factor() const { return at<10>().valid(); }
  float global_scale_factor() const { return at<10>().as_float(); }
  bool has_window_x_scale() const { return at<11>().valid(); }
  float window_x_scale() const { return at<11>().as_float(); }
  bool has_window_y_scale() const { return at<12>().valid(); }
  float window_y_scale() const { return at<12>().as_float(); }
  bool has_crop_layer_id() const { return at<13>().valid(); }
  int32_t crop_layer_id() const { return at<13>().as_int32(); }
  bool has_replace_touchable_region_with_crop() const { return at<14>().valid(); }
  bool replace_touchable_region_with_crop() const { return at<14>().as_bool(); }
  bool has_touchable_region_crop() const { return at<15>().valid(); }
  ::protozero::ConstBytes touchable_region_crop() const { return at<15>().as_bytes(); }
  bool has_transform() const { return at<16>().valid(); }
  ::protozero::ConstBytes transform() const { return at<16>().as_bytes(); }
  bool has_input_config() const { return at<17>().valid(); }
  uint32_t input_config() const { return at<17>().as_uint32(); }
};

class InputWindowInfoProto : public ::protozero::Message {
 public:
  using Decoder = InputWindowInfoProto_Decoder;
  enum : int32_t {
    kLayoutParamsFlagsFieldNumber = 1,
    kLayoutParamsTypeFieldNumber = 2,
    kFrameFieldNumber = 3,
    kTouchableRegionFieldNumber = 4,
    kSurfaceInsetFieldNumber = 5,
    kVisibleFieldNumber = 6,
    kCanReceiveKeysFieldNumber = 7,
    kFocusableFieldNumber = 8,
    kHasWallpaperFieldNumber = 9,
    kGlobalScaleFactorFieldNumber = 10,
    kWindowXScaleFieldNumber = 11,
    kWindowYScaleFieldNumber = 12,
    kCropLayerIdFieldNumber = 13,
    kReplaceTouchableRegionWithCropFieldNumber = 14,
    kTouchableRegionCropFieldNumber = 15,
    kTransformFieldNumber = 16,
    kInputConfigFieldNumber = 17,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.InputWindowInfoProto"; }


  using FieldMetadata_LayoutParamsFlags =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      InputWindowInfoProto>;

  static constexpr FieldMetadata_LayoutParamsFlags kLayoutParamsFlags{};
  void set_layout_params_flags(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_LayoutParamsFlags::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_LayoutParamsType =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      InputWindowInfoProto>;

  static constexpr FieldMetadata_LayoutParamsType kLayoutParamsType{};
  void set_layout_params_type(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_LayoutParamsType::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Frame =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      InputWindowInfoProto>;

  static constexpr FieldMetadata_Frame kFrame{};
  template <typename T = RectProto> T* set_frame() {
    return BeginNestedMessage<T>(3);
  }


  using FieldMetadata_TouchableRegion =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RegionProto,
      InputWindowInfoProto>;

  static constexpr FieldMetadata_TouchableRegion kTouchableRegion{};
  template <typename T = RegionProto> T* set_touchable_region() {
    return BeginNestedMessage<T>(4);
  }


  using FieldMetadata_SurfaceInset =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      InputWindowInfoProto>;

  static constexpr FieldMetadata_SurfaceInset kSurfaceInset{};
  void set_surface_inset(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SurfaceInset::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Visible =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      InputWindowInfoProto>;

  static constexpr FieldMetadata_Visible kVisible{};
  void set_visible(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_Visible::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_CanReceiveKeys =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      InputWindowInfoProto>;

  static constexpr FieldMetadata_CanReceiveKeys kCanReceiveKeys{};
  void set_can_receive_keys(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_CanReceiveKeys::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Focusable =
    ::protozero::proto_utils::FieldMetadata<
      8,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      InputWindowInfoProto>;

  static constexpr FieldMetadata_Focusable kFocusable{};
  void set_focusable(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_Focusable::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_HasWallpaper =
    ::protozero::proto_utils::FieldMetadata<
      9,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      InputWindowInfoProto>;

  static constexpr FieldMetadata_HasWallpaper kHasWallpaper{};
  void set_has_wallpaper(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_HasWallpaper::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_GlobalScaleFactor =
    ::protozero::proto_utils::FieldMetadata<
      10,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kFloat,
      float,
      InputWindowInfoProto>;

  static constexpr FieldMetadata_GlobalScaleFactor kGlobalScaleFactor{};
  void set_global_scale_factor(float value) {
    static constexpr uint32_t field_id = FieldMetadata_GlobalScaleFactor::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kFloat>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_WindowXScale =
    ::protozero::proto_utils::FieldMetadata<
      11,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kFloat,
      float,
      InputWindowInfoProto>;

  static constexpr FieldMetadata_WindowXScale kWindowXScale{};
  void set_window_x_scale(float value) {
    static constexpr uint32_t field_id = FieldMetadata_WindowXScale::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kFloat>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_WindowYScale =
    ::protozero::proto_utils::FieldMetadata<
      12,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kFloat,
      float,
      InputWindowInfoProto>;

  static constexpr FieldMetadata_WindowYScale kWindowYScale{};
  void set_window_y_scale(float value) {
    static constexpr uint32_t field_id = FieldMetadata_WindowYScale::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kFloat>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_CropLayerId =
    ::protozero::proto_utils::FieldMetadata<
      13,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      InputWindowInfoProto>;

  static constexpr FieldMetadata_CropLayerId kCropLayerId{};
  void set_crop_layer_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_CropLayerId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ReplaceTouchableRegionWithCrop =
    ::protozero::proto_utils::FieldMetadata<
      14,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      InputWindowInfoProto>;

  static constexpr FieldMetadata_ReplaceTouchableRegionWithCrop kReplaceTouchableRegionWithCrop{};
  void set_replace_touchable_region_with_crop(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_ReplaceTouchableRegionWithCrop::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_TouchableRegionCrop =
    ::protozero::proto_utils::FieldMetadata<
      15,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      InputWindowInfoProto>;

  static constexpr FieldMetadata_TouchableRegionCrop kTouchableRegionCrop{};
  template <typename T = RectProto> T* set_touchable_region_crop() {
    return BeginNestedMessage<T>(15);
  }


  using FieldMetadata_Transform =
    ::protozero::proto_utils::FieldMetadata<
      16,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      TransformProto,
      InputWindowInfoProto>;

  static constexpr FieldMetadata_Transform kTransform{};
  template <typename T = TransformProto> T* set_transform() {
    return BeginNestedMessage<T>(16);
  }


  using FieldMetadata_InputConfig =
    ::protozero::proto_utils::FieldMetadata<
      17,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      InputWindowInfoProto>;

  static constexpr FieldMetadata_InputConfig kInputConfig{};
  void set_input_config(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_InputConfig::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }
};

class ColorProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ColorProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ColorProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ColorProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_r() const { return at<1>().valid(); }
  float r() const { return at<1>().as_float(); }
  bool has_g() const { return at<2>().valid(); }
  float g() const { return at<2>().as_float(); }
  bool has_b() const { return at<3>().valid(); }
  float b() const { return at<3>().as_float(); }
  bool has_a() const { return at<4>().valid(); }
  float a() const { return at<4>().as_float(); }
};

class ColorProto : public ::protozero::Message {
 public:
  using Decoder = ColorProto_Decoder;
  enum : int32_t {
    kRFieldNumber = 1,
    kGFieldNumber = 2,
    kBFieldNumber = 3,
    kAFieldNumber = 4,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ColorProto"; }


  using FieldMetadata_R =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kFloat,
      float,
      ColorProto>;

  static constexpr FieldMetadata_R kR{};
  void set_r(float value) {
    static constexpr uint32_t field_id = FieldMetadata_R::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kFloat>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_G =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kFloat,
      float,
      ColorProto>;

  static constexpr FieldMetadata_G kG{};
  void set_g(float value) {
    static constexpr uint32_t field_id = FieldMetadata_G::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kFloat>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_B =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kFloat,
      float,
      ColorProto>;

  static constexpr FieldMetadata_B kB{};
  void set_b(float value) {
    static constexpr uint32_t field_id = FieldMetadata_B::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kFloat>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_A =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kFloat,
      float,
      ColorProto>;

  static constexpr FieldMetadata_A kA{};
  void set_a(float value) {
    static constexpr uint32_t field_id = FieldMetadata_A::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kFloat>
        ::Append(*this, field_id, value);
  }
};

class TransformProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TransformProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TransformProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TransformProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dsdx() const { return at<1>().valid(); }
  float dsdx() const { return at<1>().as_float(); }
  bool has_dtdx() const { return at<2>().valid(); }
  float dtdx() const { return at<2>().as_float(); }
  bool has_dsdy() const { return at<3>().valid(); }
  float dsdy() const { return at<3>().as_float(); }
  bool has_dtdy() const { return at<4>().valid(); }
  float dtdy() const { return at<4>().as_float(); }
  bool has_type() const { return at<5>().valid(); }
  int32_t type() const { return at<5>().as_int32(); }
};

class TransformProto : public ::protozero::Message {
 public:
  using Decoder = TransformProto_Decoder;
  enum : int32_t {
    kDsdxFieldNumber = 1,
    kDtdxFieldNumber = 2,
    kDsdyFieldNumber = 3,
    kDtdyFieldNumber = 4,
    kTypeFieldNumber = 5,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.TransformProto"; }


  using FieldMetadata_Dsdx =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kFloat,
      float,
      TransformProto>;

  static constexpr FieldMetadata_Dsdx kDsdx{};
  void set_dsdx(float value) {
    static constexpr uint32_t field_id = FieldMetadata_Dsdx::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kFloat>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Dtdx =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kFloat,
      float,
      TransformProto>;

  static constexpr FieldMetadata_Dtdx kDtdx{};
  void set_dtdx(float value) {
    static constexpr uint32_t field_id = FieldMetadata_Dtdx::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kFloat>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Dsdy =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kFloat,
      float,
      TransformProto>;

  static constexpr FieldMetadata_Dsdy kDsdy{};
  void set_dsdy(float value) {
    static constexpr uint32_t field_id = FieldMetadata_Dsdy::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kFloat>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Dtdy =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kFloat,
      float,
      TransformProto>;

  static constexpr FieldMetadata_Dtdy kDtdy{};
  void set_dtdy(float value) {
    static constexpr uint32_t field_id = FieldMetadata_Dtdy::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kFloat>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Type =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      TransformProto>;

  static constexpr FieldMetadata_Type kType{};
  void set_type(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Type::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

class SizeProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SizeProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SizeProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SizeProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_w() const { return at<1>().valid(); }
  int32_t w() const { return at<1>().as_int32(); }
  bool has_h() const { return at<2>().valid(); }
  int32_t h() const { return at<2>().as_int32(); }
};

class SizeProto : public ::protozero::Message {
 public:
  using Decoder = SizeProto_Decoder;
  enum : int32_t {
    kWFieldNumber = 1,
    kHFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.SizeProto"; }


  using FieldMetadata_W =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      SizeProto>;

  static constexpr FieldMetadata_W kW{};
  void set_w(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_W::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_H =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      SizeProto>;

  static constexpr FieldMetadata_H kH{};
  void set_h(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_H::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

class RegionProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  RegionProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RegionProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RegionProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_rect() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> rect() const { return GetRepeated<::protozero::ConstBytes>(2); }
};

class RegionProto : public ::protozero::Message {
 public:
  using Decoder = RegionProto_Decoder;
  enum : int32_t {
    kRectFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.RegionProto"; }


  using FieldMetadata_Rect =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      RegionProto>;

  static constexpr FieldMetadata_Rect kRect{};
  template <typename T = RectProto> T* add_rect() {
    return BeginNestedMessage<T>(2);
  }

};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
