// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_GPU_COUNTER_DESCRIPTOR_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_GPU_COUNTER_DESCRIPTOR_PROTO_H_

#include <stddef.h>
#include <stdint.h>

#include "perfetto/protozero/field_writer.h"
#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {
class GpuCounterDescriptor_GpuCounterBlock;
class GpuCounterDescriptor_GpuCounterSpec;
namespace perfetto_pbzero_enum_GpuCounterDescriptor {
enum GpuCounterGroup : int32_t;
}  // namespace perfetto_pbzero_enum_GpuCounterDescriptor
using GpuCounterDescriptor_GpuCounterGroup = perfetto_pbzero_enum_GpuCounterDescriptor::GpuCounterGroup;
namespace perfetto_pbzero_enum_GpuCounterDescriptor {
enum MeasureUnit : int32_t;
}  // namespace perfetto_pbzero_enum_GpuCounterDescriptor
using GpuCounterDescriptor_MeasureUnit = perfetto_pbzero_enum_GpuCounterDescriptor::MeasureUnit;
} // Namespace pbzero.
} // Namespace protos.
} // Namespace perfetto.

namespace perfetto {
namespace protos {
namespace pbzero {

namespace perfetto_pbzero_enum_GpuCounterDescriptor {
enum GpuCounterGroup : int32_t {
  UNCLASSIFIED = 0,
  SYSTEM = 1,
  VERTICES = 2,
  FRAGMENTS = 3,
  PRIMITIVES = 4,
  MEMORY = 5,
  COMPUTE = 6,
};
} // namespace perfetto_pbzero_enum_GpuCounterDescriptor
using GpuCounterDescriptor_GpuCounterGroup = perfetto_pbzero_enum_GpuCounterDescriptor::GpuCounterGroup;


constexpr GpuCounterDescriptor_GpuCounterGroup GpuCounterDescriptor_GpuCounterGroup_MIN = GpuCounterDescriptor_GpuCounterGroup::UNCLASSIFIED;
constexpr GpuCounterDescriptor_GpuCounterGroup GpuCounterDescriptor_GpuCounterGroup_MAX = GpuCounterDescriptor_GpuCounterGroup::COMPUTE;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* GpuCounterDescriptor_GpuCounterGroup_Name(::perfetto::protos::pbzero::GpuCounterDescriptor_GpuCounterGroup value) {
  switch (value) {
  case ::perfetto::protos::pbzero::GpuCounterDescriptor_GpuCounterGroup::UNCLASSIFIED:
    return "UNCLASSIFIED";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_GpuCounterGroup::SYSTEM:
    return "SYSTEM";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_GpuCounterGroup::VERTICES:
    return "VERTICES";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_GpuCounterGroup::FRAGMENTS:
    return "FRAGMENTS";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_GpuCounterGroup::PRIMITIVES:
    return "PRIMITIVES";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_GpuCounterGroup::MEMORY:
    return "MEMORY";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_GpuCounterGroup::COMPUTE:
    return "COMPUTE";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_GpuCounterDescriptor {
enum MeasureUnit : int32_t {
  NONE = 0,
  BIT = 1,
  KILOBIT = 2,
  MEGABIT = 3,
  GIGABIT = 4,
  TERABIT = 5,
  PETABIT = 6,
  BYTE = 7,
  KILOBYTE = 8,
  MEGABYTE = 9,
  GIGABYTE = 10,
  TERABYTE = 11,
  PETABYTE = 12,
  HERTZ = 13,
  KILOHERTZ = 14,
  MEGAHERTZ = 15,
  GIGAHERTZ = 16,
  TERAHERTZ = 17,
  PETAHERTZ = 18,
  NANOSECOND = 19,
  MICROSECOND = 20,
  MILLISECOND = 21,
  SECOND = 22,
  MINUTE = 23,
  HOUR = 24,
  VERTEX = 25,
  PIXEL = 26,
  TRIANGLE = 27,
  PRIMITIVE = 38,
  FRAGMENT = 39,
  MILLIWATT = 28,
  WATT = 29,
  KILOWATT = 30,
  JOULE = 31,
  VOLT = 32,
  AMPERE = 33,
  CELSIUS = 34,
  FAHRENHEIT = 35,
  KELVIN = 36,
  PERCENT = 37,
  INSTRUCTION = 40,
};
} // namespace perfetto_pbzero_enum_GpuCounterDescriptor
using GpuCounterDescriptor_MeasureUnit = perfetto_pbzero_enum_GpuCounterDescriptor::MeasureUnit;


constexpr GpuCounterDescriptor_MeasureUnit GpuCounterDescriptor_MeasureUnit_MIN = GpuCounterDescriptor_MeasureUnit::NONE;
constexpr GpuCounterDescriptor_MeasureUnit GpuCounterDescriptor_MeasureUnit_MAX = GpuCounterDescriptor_MeasureUnit::INSTRUCTION;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* GpuCounterDescriptor_MeasureUnit_Name(::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit value) {
  switch (value) {
  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::NONE:
    return "NONE";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::BIT:
    return "BIT";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::KILOBIT:
    return "KILOBIT";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::MEGABIT:
    return "MEGABIT";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::GIGABIT:
    return "GIGABIT";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::TERABIT:
    return "TERABIT";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::PETABIT:
    return "PETABIT";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::BYTE:
    return "BYTE";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::KILOBYTE:
    return "KILOBYTE";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::MEGABYTE:
    return "MEGABYTE";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::GIGABYTE:
    return "GIGABYTE";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::TERABYTE:
    return "TERABYTE";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::PETABYTE:
    return "PETABYTE";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::HERTZ:
    return "HERTZ";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::KILOHERTZ:
    return "KILOHERTZ";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::MEGAHERTZ:
    return "MEGAHERTZ";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::GIGAHERTZ:
    return "GIGAHERTZ";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::TERAHERTZ:
    return "TERAHERTZ";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::PETAHERTZ:
    return "PETAHERTZ";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::NANOSECOND:
    return "NANOSECOND";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::MICROSECOND:
    return "MICROSECOND";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::MILLISECOND:
    return "MILLISECOND";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::SECOND:
    return "SECOND";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::MINUTE:
    return "MINUTE";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::HOUR:
    return "HOUR";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::VERTEX:
    return "VERTEX";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::PIXEL:
    return "PIXEL";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::TRIANGLE:
    return "TRIANGLE";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::PRIMITIVE:
    return "PRIMITIVE";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::FRAGMENT:
    return "FRAGMENT";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::MILLIWATT:
    return "MILLIWATT";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::WATT:
    return "WATT";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::KILOWATT:
    return "KILOWATT";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::JOULE:
    return "JOULE";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::VOLT:
    return "VOLT";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::AMPERE:
    return "AMPERE";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::CELSIUS:
    return "CELSIUS";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::FAHRENHEIT:
    return "FAHRENHEIT";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::KELVIN:
    return "KELVIN";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::PERCENT:
    return "PERCENT";

  case ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit::INSTRUCTION:
    return "INSTRUCTION";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

class GpuCounterDescriptor_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  GpuCounterDescriptor_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GpuCounterDescriptor_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GpuCounterDescriptor_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_specs() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> specs() const { return GetRepeated<::protozero::ConstBytes>(1); }
  bool has_blocks() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> blocks() const { return GetRepeated<::protozero::ConstBytes>(2); }
  bool has_min_sampling_period_ns() const { return at<3>().valid(); }
  uint64_t min_sampling_period_ns() const { return at<3>().as_uint64(); }
  bool has_max_sampling_period_ns() const { return at<4>().valid(); }
  uint64_t max_sampling_period_ns() const { return at<4>().as_uint64(); }
  bool has_supports_instrumented_sampling() const { return at<5>().valid(); }
  bool supports_instrumented_sampling() const { return at<5>().as_bool(); }
};

class GpuCounterDescriptor : public ::protozero::Message {
 public:
  using Decoder = GpuCounterDescriptor_Decoder;
  enum : int32_t {
    kSpecsFieldNumber = 1,
    kBlocksFieldNumber = 2,
    kMinSamplingPeriodNsFieldNumber = 3,
    kMaxSamplingPeriodNsFieldNumber = 4,
    kSupportsInstrumentedSamplingFieldNumber = 5,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.GpuCounterDescriptor"; }

  using GpuCounterSpec = ::perfetto::protos::pbzero::GpuCounterDescriptor_GpuCounterSpec;
  using GpuCounterBlock = ::perfetto::protos::pbzero::GpuCounterDescriptor_GpuCounterBlock;

  using GpuCounterGroup = ::perfetto::protos::pbzero::GpuCounterDescriptor_GpuCounterGroup;
  static inline const char* GpuCounterGroup_Name(GpuCounterGroup value) {
    return ::perfetto::protos::pbzero::GpuCounterDescriptor_GpuCounterGroup_Name(value);
  }

  using MeasureUnit = ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit;
  static inline const char* MeasureUnit_Name(MeasureUnit value) {
    return ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit_Name(value);
  }
  static inline const GpuCounterGroup UNCLASSIFIED = GpuCounterGroup::UNCLASSIFIED;
  static inline const GpuCounterGroup SYSTEM = GpuCounterGroup::SYSTEM;
  static inline const GpuCounterGroup VERTICES = GpuCounterGroup::VERTICES;
  static inline const GpuCounterGroup FRAGMENTS = GpuCounterGroup::FRAGMENTS;
  static inline const GpuCounterGroup PRIMITIVES = GpuCounterGroup::PRIMITIVES;
  static inline const GpuCounterGroup MEMORY = GpuCounterGroup::MEMORY;
  static inline const GpuCounterGroup COMPUTE = GpuCounterGroup::COMPUTE;
  static inline const MeasureUnit NONE = MeasureUnit::NONE;
  static inline const MeasureUnit BIT = MeasureUnit::BIT;
  static inline const MeasureUnit KILOBIT = MeasureUnit::KILOBIT;
  static inline const MeasureUnit MEGABIT = MeasureUnit::MEGABIT;
  static inline const MeasureUnit GIGABIT = MeasureUnit::GIGABIT;
  static inline const MeasureUnit TERABIT = MeasureUnit::TERABIT;
  static inline const MeasureUnit PETABIT = MeasureUnit::PETABIT;
  static inline const MeasureUnit BYTE = MeasureUnit::BYTE;
  static inline const MeasureUnit KILOBYTE = MeasureUnit::KILOBYTE;
  static inline const MeasureUnit MEGABYTE = MeasureUnit::MEGABYTE;
  static inline const MeasureUnit GIGABYTE = MeasureUnit::GIGABYTE;
  static inline const MeasureUnit TERABYTE = MeasureUnit::TERABYTE;
  static inline const MeasureUnit PETABYTE = MeasureUnit::PETABYTE;
  static inline const MeasureUnit HERTZ = MeasureUnit::HERTZ;
  static inline const MeasureUnit KILOHERTZ = MeasureUnit::KILOHERTZ;
  static inline const MeasureUnit MEGAHERTZ = MeasureUnit::MEGAHERTZ;
  static inline const MeasureUnit GIGAHERTZ = MeasureUnit::GIGAHERTZ;
  static inline const MeasureUnit TERAHERTZ = MeasureUnit::TERAHERTZ;
  static inline const MeasureUnit PETAHERTZ = MeasureUnit::PETAHERTZ;
  static inline const MeasureUnit NANOSECOND = MeasureUnit::NANOSECOND;
  static inline const MeasureUnit MICROSECOND = MeasureUnit::MICROSECOND;
  static inline const MeasureUnit MILLISECOND = MeasureUnit::MILLISECOND;
  static inline const MeasureUnit SECOND = MeasureUnit::SECOND;
  static inline const MeasureUnit MINUTE = MeasureUnit::MINUTE;
  static inline const MeasureUnit HOUR = MeasureUnit::HOUR;
  static inline const MeasureUnit VERTEX = MeasureUnit::VERTEX;
  static inline const MeasureUnit PIXEL = MeasureUnit::PIXEL;
  static inline const MeasureUnit TRIANGLE = MeasureUnit::TRIANGLE;
  static inline const MeasureUnit PRIMITIVE = MeasureUnit::PRIMITIVE;
  static inline const MeasureUnit FRAGMENT = MeasureUnit::FRAGMENT;
  static inline const MeasureUnit MILLIWATT = MeasureUnit::MILLIWATT;
  static inline const MeasureUnit WATT = MeasureUnit::WATT;
  static inline const MeasureUnit KILOWATT = MeasureUnit::KILOWATT;
  static inline const MeasureUnit JOULE = MeasureUnit::JOULE;
  static inline const MeasureUnit VOLT = MeasureUnit::VOLT;
  static inline const MeasureUnit AMPERE = MeasureUnit::AMPERE;
  static inline const MeasureUnit CELSIUS = MeasureUnit::CELSIUS;
  static inline const MeasureUnit FAHRENHEIT = MeasureUnit::FAHRENHEIT;
  static inline const MeasureUnit KELVIN = MeasureUnit::KELVIN;
  static inline const MeasureUnit PERCENT = MeasureUnit::PERCENT;
  static inline const MeasureUnit INSTRUCTION = MeasureUnit::INSTRUCTION;

  using FieldMetadata_Specs =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      GpuCounterDescriptor_GpuCounterSpec,
      GpuCounterDescriptor>;

  static constexpr FieldMetadata_Specs kSpecs{};
  template <typename T = GpuCounterDescriptor_GpuCounterSpec> T* add_specs() {
    return BeginNestedMessage<T>(1);
  }


  using FieldMetadata_Blocks =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      GpuCounterDescriptor_GpuCounterBlock,
      GpuCounterDescriptor>;

  static constexpr FieldMetadata_Blocks kBlocks{};
  template <typename T = GpuCounterDescriptor_GpuCounterBlock> T* add_blocks() {
    return BeginNestedMessage<T>(2);
  }


  using FieldMetadata_MinSamplingPeriodNs =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      GpuCounterDescriptor>;

  static constexpr FieldMetadata_MinSamplingPeriodNs kMinSamplingPeriodNs{};
  void set_min_sampling_period_ns(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_MinSamplingPeriodNs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_MaxSamplingPeriodNs =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      GpuCounterDescriptor>;

  static constexpr FieldMetadata_MaxSamplingPeriodNs kMaxSamplingPeriodNs{};
  void set_max_sampling_period_ns(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_MaxSamplingPeriodNs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SupportsInstrumentedSampling =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      GpuCounterDescriptor>;

  static constexpr FieldMetadata_SupportsInstrumentedSampling kSupportsInstrumentedSampling{};
  void set_supports_instrumented_sampling(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_SupportsInstrumentedSampling::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }
};

class GpuCounterDescriptor_GpuCounterBlock_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  GpuCounterDescriptor_GpuCounterBlock_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GpuCounterDescriptor_GpuCounterBlock_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GpuCounterDescriptor_GpuCounterBlock_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_block_id() const { return at<1>().valid(); }
  uint32_t block_id() const { return at<1>().as_uint32(); }
  bool has_block_capacity() const { return at<2>().valid(); }
  uint32_t block_capacity() const { return at<2>().as_uint32(); }
  bool has_name() const { return at<3>().valid(); }
  ::protozero::ConstChars name() const { return at<3>().as_string(); }
  bool has_description() const { return at<4>().valid(); }
  ::protozero::ConstChars description() const { return at<4>().as_string(); }
  bool has_counter_ids() const { return at<5>().valid(); }
  ::protozero::RepeatedFieldIterator<uint32_t> counter_ids() const { return GetRepeated<uint32_t>(5); }
};

class GpuCounterDescriptor_GpuCounterBlock : public ::protozero::Message {
 public:
  using Decoder = GpuCounterDescriptor_GpuCounterBlock_Decoder;
  enum : int32_t {
    kBlockIdFieldNumber = 1,
    kBlockCapacityFieldNumber = 2,
    kNameFieldNumber = 3,
    kDescriptionFieldNumber = 4,
    kCounterIdsFieldNumber = 5,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.GpuCounterDescriptor.GpuCounterBlock"; }


  using FieldMetadata_BlockId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      GpuCounterDescriptor_GpuCounterBlock>;

  static constexpr FieldMetadata_BlockId kBlockId{};
  void set_block_id(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_BlockId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_BlockCapacity =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      GpuCounterDescriptor_GpuCounterBlock>;

  static constexpr FieldMetadata_BlockCapacity kBlockCapacity{};
  void set_block_capacity(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_BlockCapacity::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Name =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      GpuCounterDescriptor_GpuCounterBlock>;

  static constexpr FieldMetadata_Name kName{};
  void set_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Name::kFieldId, data, size);
  }
  void set_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Name::kFieldId, chars.data, chars.size);
  }
  void set_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Name::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Description =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      GpuCounterDescriptor_GpuCounterBlock>;

  static constexpr FieldMetadata_Description kDescription{};
  void set_description(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Description::kFieldId, data, size);
  }
  void set_description(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Description::kFieldId, chars.data, chars.size);
  }
  void set_description(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Description::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_CounterIds =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      GpuCounterDescriptor_GpuCounterBlock>;

  static constexpr FieldMetadata_CounterIds kCounterIds{};
  void add_counter_ids(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_CounterIds::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }
};

class GpuCounterDescriptor_GpuCounterSpec_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  GpuCounterDescriptor_GpuCounterSpec_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GpuCounterDescriptor_GpuCounterSpec_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GpuCounterDescriptor_GpuCounterSpec_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_counter_id() const { return at<1>().valid(); }
  uint32_t counter_id() const { return at<1>().as_uint32(); }
  bool has_name() const { return at<2>().valid(); }
  ::protozero::ConstChars name() const { return at<2>().as_string(); }
  bool has_description() const { return at<3>().valid(); }
  ::protozero::ConstChars description() const { return at<3>().as_string(); }
  bool has_int_peak_value() const { return at<5>().valid(); }
  int64_t int_peak_value() const { return at<5>().as_int64(); }
  bool has_double_peak_value() const { return at<6>().valid(); }
  double double_peak_value() const { return at<6>().as_double(); }
  bool has_numerator_units() const { return at<7>().valid(); }
  ::protozero::RepeatedFieldIterator<int32_t> numerator_units() const { return GetRepeated<int32_t>(7); }
  bool has_denominator_units() const { return at<8>().valid(); }
  ::protozero::RepeatedFieldIterator<int32_t> denominator_units() const { return GetRepeated<int32_t>(8); }
  bool has_select_by_default() const { return at<9>().valid(); }
  bool select_by_default() const { return at<9>().as_bool(); }
  bool has_groups() const { return at<10>().valid(); }
  ::protozero::RepeatedFieldIterator<int32_t> groups() const { return GetRepeated<int32_t>(10); }
};

class GpuCounterDescriptor_GpuCounterSpec : public ::protozero::Message {
 public:
  using Decoder = GpuCounterDescriptor_GpuCounterSpec_Decoder;
  enum : int32_t {
    kCounterIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kIntPeakValueFieldNumber = 5,
    kDoublePeakValueFieldNumber = 6,
    kNumeratorUnitsFieldNumber = 7,
    kDenominatorUnitsFieldNumber = 8,
    kSelectByDefaultFieldNumber = 9,
    kGroupsFieldNumber = 10,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.GpuCounterDescriptor.GpuCounterSpec"; }


  using FieldMetadata_CounterId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      GpuCounterDescriptor_GpuCounterSpec>;

  static constexpr FieldMetadata_CounterId kCounterId{};
  void set_counter_id(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_CounterId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Name =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      GpuCounterDescriptor_GpuCounterSpec>;

  static constexpr FieldMetadata_Name kName{};
  void set_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Name::kFieldId, data, size);
  }
  void set_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Name::kFieldId, chars.data, chars.size);
  }
  void set_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Name::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Description =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      GpuCounterDescriptor_GpuCounterSpec>;

  static constexpr FieldMetadata_Description kDescription{};
  void set_description(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Description::kFieldId, data, size);
  }
  void set_description(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Description::kFieldId, chars.data, chars.size);
  }
  void set_description(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Description::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IntPeakValue =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      GpuCounterDescriptor_GpuCounterSpec>;

  static constexpr FieldMetadata_IntPeakValue kIntPeakValue{};
  void set_int_peak_value(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_IntPeakValue::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_DoublePeakValue =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kDouble,
      double,
      GpuCounterDescriptor_GpuCounterSpec>;

  static constexpr FieldMetadata_DoublePeakValue kDoublePeakValue{};
  void set_double_peak_value(double value) {
    static constexpr uint32_t field_id = FieldMetadata_DoublePeakValue::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kDouble>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_NumeratorUnits =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      GpuCounterDescriptor_MeasureUnit,
      GpuCounterDescriptor_GpuCounterSpec>;

  static constexpr FieldMetadata_NumeratorUnits kNumeratorUnits{};
  void add_numerator_units(GpuCounterDescriptor_MeasureUnit value) {
    static constexpr uint32_t field_id = FieldMetadata_NumeratorUnits::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_DenominatorUnits =
    ::protozero::proto_utils::FieldMetadata<
      8,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      GpuCounterDescriptor_MeasureUnit,
      GpuCounterDescriptor_GpuCounterSpec>;

  static constexpr FieldMetadata_DenominatorUnits kDenominatorUnits{};
  void add_denominator_units(GpuCounterDescriptor_MeasureUnit value) {
    static constexpr uint32_t field_id = FieldMetadata_DenominatorUnits::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SelectByDefault =
    ::protozero::proto_utils::FieldMetadata<
      9,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      GpuCounterDescriptor_GpuCounterSpec>;

  static constexpr FieldMetadata_SelectByDefault kSelectByDefault{};
  void set_select_by_default(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_SelectByDefault::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Groups =
    ::protozero::proto_utils::FieldMetadata<
      10,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      GpuCounterDescriptor_GpuCounterGroup,
      GpuCounterDescriptor_GpuCounterSpec>;

  static constexpr FieldMetadata_Groups kGroups{};
  void add_groups(GpuCounterDescriptor_GpuCounterGroup value) {
    static constexpr uint32_t field_id = FieldMetadata_Groups::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
