// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_IPC_RELAY_PORT_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_IPC_RELAY_PORT_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class SyncClockResponse;
class SyncClockRequest;
class SyncClockRequest_Clock;
enum SyncClockRequest_Phase : int;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {
enum SyncClockRequest_Phase : int {
  SyncClockRequest_Phase_PING = 1,
  SyncClockRequest_Phase_UPDATE = 2,
};

class PERFETTO_EXPORT_COMPONENT SyncClockResponse : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
  };

  SyncClockResponse();
  ~SyncClockResponse() override;
  SyncClockResponse(SyncClockResponse&&) noexcept;
  SyncClockResponse& operator=(SyncClockResponse&&);
  SyncClockResponse(const SyncClockResponse&);
  SyncClockResponse& operator=(const SyncClockResponse&);
  bool operator==(const SyncClockResponse&) const;
  bool operator!=(const SyncClockResponse& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

 private:

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT SyncClockRequest : public ::protozero::CppMessageObj {
 public:
  using Clock = SyncClockRequest_Clock;
  using Phase = SyncClockRequest_Phase;
  static constexpr auto PING = SyncClockRequest_Phase_PING;
  static constexpr auto UPDATE = SyncClockRequest_Phase_UPDATE;
  static constexpr auto Phase_MIN = SyncClockRequest_Phase_PING;
  static constexpr auto Phase_MAX = SyncClockRequest_Phase_UPDATE;
  enum FieldNumbers {
    kPhaseFieldNumber = 1,
    kClocksFieldNumber = 2,
  };

  SyncClockRequest();
  ~SyncClockRequest() override;
  SyncClockRequest(SyncClockRequest&&) noexcept;
  SyncClockRequest& operator=(SyncClockRequest&&);
  SyncClockRequest(const SyncClockRequest&);
  SyncClockRequest& operator=(const SyncClockRequest&);
  bool operator==(const SyncClockRequest&) const;
  bool operator!=(const SyncClockRequest& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_phase() const { return _has_field_[1]; }
  SyncClockRequest_Phase phase() const { return phase_; }
  void set_phase(SyncClockRequest_Phase value) { phase_ = value; _has_field_.set(1); }

  const std::vector<SyncClockRequest_Clock>& clocks() const { return clocks_; }
  std::vector<SyncClockRequest_Clock>* mutable_clocks() { return &clocks_; }
  int clocks_size() const;
  void clear_clocks();
  SyncClockRequest_Clock* add_clocks();

 private:
  SyncClockRequest_Phase phase_{};
  std::vector<SyncClockRequest_Clock> clocks_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT SyncClockRequest_Clock : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kClockIdFieldNumber = 1,
    kTimestampFieldNumber = 2,
  };

  SyncClockRequest_Clock();
  ~SyncClockRequest_Clock() override;
  SyncClockRequest_Clock(SyncClockRequest_Clock&&) noexcept;
  SyncClockRequest_Clock& operator=(SyncClockRequest_Clock&&);
  SyncClockRequest_Clock(const SyncClockRequest_Clock&);
  SyncClockRequest_Clock& operator=(const SyncClockRequest_Clock&);
  bool operator==(const SyncClockRequest_Clock&) const;
  bool operator!=(const SyncClockRequest_Clock& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_clock_id() const { return _has_field_[1]; }
  uint32_t clock_id() const { return clock_id_; }
  void set_clock_id(uint32_t value) { clock_id_ = value; _has_field_.set(1); }

  bool has_timestamp() const { return _has_field_[2]; }
  uint64_t timestamp() const { return timestamp_; }
  void set_timestamp(uint64_t value) { timestamp_ = value; _has_field_.set(2); }

 private:
  uint32_t clock_id_{};
  uint64_t timestamp_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_IPC_RELAY_PORT_PROTO_CPP_H_
