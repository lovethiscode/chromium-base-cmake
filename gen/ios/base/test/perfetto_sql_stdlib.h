/*
 * Copyright (C) 2023 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 *******************************************************************************
 * AUTOGENERATED BY tools/gen_amalgamated_sql.py - DO NOT EDIT
 *******************************************************************************
 */

 #include <string.h>

namespace perfetto {
namespace trace_processor {
namespace chrome_stdlib {

const char kChromeScrolls[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

INCLUDE PERFETTO MODULE chrome.scroll_jank.utils;

-- Defines slices for all of the individual scrolls in a trace based on the
-- LatencyInfo-based scroll definition.
--
-- NOTE: this view of top level scrolls is based on the LatencyInfo definition
-- of a scroll, which differs subtly from the definition based on
-- EventLatencies.
-- TODO(b/278684408): add support for tracking scrolls across multiple Chrome/
-- WebView instances. Currently gesture_scroll_id unique within an instance, but
-- is not unique across multiple instances. Switching to an EventLatency based
-- definition of scrolls should resolve this.
CREATE PERFETTO TABLE chrome_scrolls(
  -- The unique identifier of the scroll.
  id INT,
  -- The start timestamp of the scroll.
  ts INT,
  -- The duration of the scroll.
  dur INT,
  -- The earliest timestamp of the EventLatency slice of the GESTURE_SCROLL_BEGIN type for the
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- corresponding scroll id.
  gesture_scroll_begin_ts INT,
  -- The earliest timestamp of the EventLatency slice of the GESTURE_SCROLL_END type /
  -- the latest timestamp of the EventLatency slice of the GESTURE_SCROLL_UPDATE type for the
  -- corresponding scroll id.
  gesture_scroll_end_ts INT
) AS
WITH all_scrolls AS (
  SELECT
    args.string_value AS name,
    S.ts AS ts,
    S.dur AS dur,
    chrome_get_most_recent_scroll_begin_id(S.ts) AS scroll_id
  FROM slice AS S JOIN args USING(arg_set_id)
  WHERE name="EventLatency"
  AND args.string_value GLOB "*GESTURE_SCROLL*"
),
scroll_starts AS (
  SELECT
    scroll_id,
    MIN(ts) AS gesture_scroll_begin_ts
  FROM all_scrolls
  WHERE name = "GESTURE_SCROLL_BEGIN"
  GROUP BY scroll_id
),
scroll_ends AS (
  SELECT
    scroll_id,
    MAX(ts) AS gesture_scroll_end_ts
  FROM all_scrolls
  WHERE name GLOB "*GESTURE_SCROLL_UPDATE"
    OR name = "GESTURE_SCROLL_END"
  GROUP BY scroll_id
)
SELECT
  sa.scroll_id AS id,
  MIN(ts) AS ts,
  CAST(MAX(ts + dur) - MIN(ts) AS INT) AS dur,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ss.gesture_scroll_begin_ts AS gesture_scroll_begin_ts,
  se.gesture_scroll_end_ts AS gesture_scroll_end_ts
FROM all_scrolls sa
  LEFT JOIN scroll_starts ss ON
    sa.scroll_id = ss.scroll_id
  LEFT JOIN scroll_ends se ON
    sa.scroll_id = se.scroll_id
GROUP BY sa.scroll_id;

-- Defines slices for all of scrolls intervals in a trace based on the scroll
-- definition in chrome_scrolls. Note that scrolls may overlap (particularly in
-- cases of jank/broken traces, etc); so scrolling intervals are not exactly the
-- same as individual scrolls.
CREATE PERFETTO VIEW chrome_scrolling_intervals(
  -- The unique identifier of the scroll interval. This may span multiple scrolls if they overlap.
  id INT,
  -- Comma-separated list of scroll ids that are included in this interval.
  scroll_ids STRING,
  -- The start timestamp of the scroll interval.
  ts INT,
  -- The duration of the scroll interval.
  dur INT
) AS
WITH all_scrolls AS (
  SELECT
    id AS scroll_id,
    s.ts AS start_ts,
    s.ts + s.dur AS end_ts
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  FROM chrome_scrolls s),
ordered_end_ts AS (
  SELECT
    *,
    MAX(end_ts) OVER (ORDER BY start_ts) AS max_end_ts_so_far
  FROM all_scrolls),
range_starts AS (
  SELECT
    *,
    CASE
      WHEN start_ts <= 1 + LAG(max_end_ts_so_far) OVER (ORDER BY start_ts) THEN 0
      ELSE 1
    END AS range_start
  FROM ordered_end_ts),
range_groups AS (
  SELECT
    *,
    SUM(range_start) OVER (ORDER BY start_ts) AS range_group
  FROM range_starts)
SELECT
  range_group AS id,
  GROUP_CONCAT(scroll_id) AS scroll_ids,
  MIN(start_ts) AS ts,
  MAX(end_ts) - MIN(start_ts) AS dur
FROM range_groups
GROUP BY range_group;

)_d3l1m1t3r_"
;

const char kCpuPowerups[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- Find causes for CPUs powering up.
--
-- The scripts below analyse traces with the following tracing options
-- enabled:
--
--  - Linux kernel:
---    "power/*", "sched/*", "task/*",
--  - Chromium:
--      "toplevel", "toplevel.flow".

-- Noteworthy tables:
--
--   chrome_cpu_power_first_toplevel_slice_after_powerup :: The top-level
--      slices that ran after a CPU power-up.

-- The CPU power transitions in the trace.
-- Power states are encoded as non-negative integers, with zero representing
-- full-power operation and positive values representing increasingly deep
-- sleep states.
--
-- On ARM systems, power state 1 represents the WFI (Wait For Interrupt) sleep
-- state that the CPU enters while idle.
CREATE PERFETTO VIEW chrome_cpu_power_slice(
  -- The timestamp at the start of the slice.
  ts INT,
  -- The duration of the slice.
  dur INT,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- The CPU on which the transition occurred
  cpu INT,
  -- The power state that the CPU was in at time 'ts' for duration 'dur'.
  power_state INT,
  -- The power state that the CPU was previously in.
  previous_power_state INT,
  -- A unique ID for the CPU power-up.
  powerup_id INT
) AS
  WITH cpu_power_states AS (
    SELECT
      c.id AS id,
      cct.cpu AS cpu,
      c.ts,
      -- Encode the 'value' field as a power state.
      CAST((CASE c.value WHEN 4294967295 THEN 0 ELSE c.value + 1 END)
        AS INT) AS power_state
    FROM counter AS c
    JOIN cpu_counter_track AS cct
      ON c.track_id = cct.id
    WHERE cct.name = 'cpuidle'
  )
  SELECT *
  FROM (
    SELECT
      ts,
      LEAD(ts) OVER (PARTITION BY cpu ORDER BY ts ASC) - ts
        AS dur,
      cpu,
      power_state,
      LAG(power_state) OVER (PARTITION BY cpu ORDER BY ts ASC)
        AS previous_power_state,
      id AS powerup_id
    FROM cpu_power_states
  )
  WHERE dur IS NOT NULL
    AND previous_power_state IS NOT NULL
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    AND power_state = 0                      -- Track full-power states.
    AND power_state != previous_power_state  -- Skip missing spans.
    ORDER BY ts ASC;

-- We do not want scheduler slices with utid = 0 (the 'swapper' kernel thread).
CREATE PERFETTO VIEW _cpu_power_valid_sched_slice AS
  SELECT *
  FROM sched_slice
  WHERE utid != 0;

-- Join scheduler slices with the spans with CPU power slices.
--
-- There multiple scheduler slices could fall into one CPU power slice.
--
---  CPU Power:
--   |----------------------------|....................|---------|
--   A       <cpu active>         B     <cpu idling>   C         D

--   Scheduler slices on that CPU:
--     |-----T1-----| |....T2....|                      |---T3--|
--     E            F G          H                      I       J
--
-- Here threads T1 and T2 executed in CPU power slice [A,B].  The
-- time between F and G represents time between threads in the kernel.
CREATE VIRTUAL TABLE _cpu_power_and_sched_slice
USING
  SPAN_JOIN(chrome_cpu_power_slice PARTITIONED cpu,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(            _cpu_power_valid_sched_slice PARTITIONED cpu);

-- The Linux scheduler slices that executed immediately after a
-- CPU power up.
CREATE PERFETTO TABLE chrome_cpu_power_first_sched_slice_after_powerup(
  -- The timestamp at the start of the slice.
  ts INT,
  -- The duration of the slice.
  dur INT,
  -- The cpu on which the slice executed.
  cpu INT,
  -- Id for the sched_slice table.
  sched_id INT,
  -- Unique id for the thread that ran within the slice.
  utid INT,
  -- The CPU's power state before this slice.
  previous_power_state INT,
  -- A unique ID for the CPU power-up.
  powerup_id INT
) AS
SELECT
  ts,
  dur,
  cpu,
  id AS sched_id,
  utid,
  previous_power_state,
  powerup_id
FROM _cpu_power_and_sched_slice
WHERE power_state = 0     -- Power-ups only.
GROUP BY cpu, powerup_id
HAVING ts = MIN(ts)       -- There will only be one MIN sched slice
                          -- per CPU power up.
ORDER BY ts ASC;

-- A view joining thread tracks and top-level slices.
--
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- This view is intended to be intersected by time with the scheduler
-- slices scheduled after a CPU power up.
--
--   utid      Thread unique id.
--   slice_id  The slice_id for the top-level slice.
--   ts        Starting timestamp for the slice.
--   dur       The duration for the slice.
CREATE PERFETTO VIEW _cpu_power_thread_and_toplevel_slice AS
  SELECT
    t.utid AS utid,
    s.id AS slice_id,
    s.ts,
    s.dur
  FROM slice AS s
  JOIN thread_track AS t
    ON s.track_id = t.id
  WHERE s.depth = 0   -- Top-level slices only.
  ORDER BY ts ASC;

-- A table holding the slices that executed within the scheduler
-- slice that ran on a CPU immediately after power-up.
--
-- @column  ts        Timestamp of the resulting slice
-- @column dur        Duration of the slice.
-- @column cpu        The CPU the sched slice ran on.
-- @column utid       Unique thread id for the slice.
-- @column sched_id   'id' field from the sched_slice table.
-- @column type       From the sched_slice table, always 'sched_slice'.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column end_state  The ending state for the sched_slice
-- @column priority   The kernel thread priority
-- @column slice_id   Id of the top-level slice for this (sched) slice.
CREATE VIRTUAL TABLE chrome_cpu_power_post_powerup_slice
USING
  SPAN_JOIN(chrome_cpu_power_first_sched_slice_after_powerup PARTITIONED utid,
            _cpu_power_thread_and_toplevel_slice PARTITIONED utid);

-- The first top-level slice that ran after a CPU power-up.
CREATE PERFETTO VIEW chrome_cpu_power_first_toplevel_slice_after_powerup(
  -- ID of the slice in the slice table.
  slice_id INT,
  -- The power state of the CPU prior to power-up.
  previous_power_state INT
) AS
  SELECT slice_id, previous_power_state
  FROM chrome_cpu_power_post_powerup_slice
  GROUP BY cpu, powerup_id
  HAVING ts = MIN(ts)
  ORDER BY ts ASC;

)_d3l1m1t3r_"
;

const char kEventLatencyDescription[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- Source of truth of the descriptions of EventLatency stages.
CREATE PERFETTO TABLE chrome_event_latency_stage_descriptions (
    -- The name of the EventLatency stage.
    name STRING,
    -- A description of the EventLatency stage.
    description STRING
) AS
WITH event_latency_descriptions(
  name,
  description)
AS (
VALUES
  ('TouchRendererHandlingToBrowserMain',
    'Interval between when the website handled blocking touch move to when ' ||
    'the browser UI thread started processing the input. Blocking touch ' ||
    'move happens when a touch event has to be handled by the website ' ||
    'before being converted to a scroll.'),
  ('GenerationToBrowserMain',
    'Interval between OS-provided hardware input timestamp to when the ' ||
    'browser UI thread began processing the input.'),
  ('GenerationToRendererCompositor',
    'Interval between OS-provided hardware input timestamp to when the ' ||
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'renderer compositor thread starts handling the artificial TOUCH_PRESS ' ||
    'browser injects in the kTouchScrollStarted event. See ' ||
    'PrependTouchScrollNotification for more info.'),
  ('BrowserMainToRendererCompositor',
    'Interval between when Browser UI thread starts to process the input to ' ||
    'renderer compositor thread starting to process it. This stage includes ' ||
    'browser UI thread processing, and task queueing times on the IO and ' ||
    'renderer compositor threads.'),
  ('RendererCompositorQueueingDelay',
    'Interval between when the input event is queued in the renderer ' ||
    'compositor and start of the BeginImplFrame producing a frame ' ||
    'containing this input.'),
  ('RendererCompositorToMain',
    'Interval between when the Renderer Compositor finishes processing the ' ||
    'event and when the Renderer Main (CrRendererMain) starts processing ' ||
    'the event, only seen when the compositor thread cannot handle the ' ||
    'scroll event by itself (known as "slow path"), usually caused by the ' ||
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'presence of blocking JS event listeners or complex page layout.'),
  ('RendererCompositorProcessing',
    'Interval corresponding to the Renderer Compositor thread processing ' ||
    'the frame updates.'),
  ('RendererMainProcessing',
    'Interval corresponding to the Renderer Main thread processing the ' ||
    'frame updates.'),
  ('EndActivateToSubmitCompositorFrame',
    'Interval that the Renderer Compositor waits for the GPU to flush a ' ||
    'frame to submit a new one.'),
  ('SubmitCompositorFrameToPresentationCompositorFrame',
    'Interval between the first Renderer Frame received to when the system ' ||
    'presented the fully composited frame on the screen. Note that on some ' ||
    'systems/apps this is incomplete/inaccurate due to lack of feedback ' ||
    'timestamps from the platform (Mac, iOS, Android Webview, etc).'),
  ('ArrivedInRendererCompositorToTermination',
    'Interval between when Renderer Compositor received the frame to when ' ||
    'this input was decided to either be ignored or merged into another ' ||
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'frame being produced. This could be a dropped frame, or just a normal ' ||
    'coalescing.'),
  ('RendererCompositorStartedToTermination',
    'Interval between when Renderer Compositor started processing the frame ' ||
    'to when this input was decided to either be ignored or merged into ' ||
    'another frame being produced. This could be a dropped frame, or just a ' ||
    'normal coalescing.'),
  ('RendererMainFinishedToTermination',
    'Interval between when Renderer Main finished processing the frame ' ||
    'to when this input was decided to either be ignored or merged into ' ||
    'another frame being produced. This could be a dropped frame, or just a ' ||
    'normal coalescing.'),
  ('RendererCompositorFinishedToTermination',
    'Interval between when Renderer Compositor finished processing the ' ||
    'frame to when this input was decided to either be ignored or merged ' ||
    'into another frame being produced. This could be just a normal ' ||
    'coalescing.'),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ('RendererMainStartedToTermination',
    'Interval between when Renderer Main started processing the frame ' ||
    'to when this input was decided to either be ignored or merged into ' ||
    'another frame being produced. This could be a dropped frame, or just a ' ||
    'normal coalescing.'),
  ('RendererCompositorFinishedToBeginImplFrame',
    'Interval when Renderer Compositor has finished processing a vsync ' ||
    '(with input), but did not end up producing a CompositorFrame due to ' ||
    'reasons such as waiting on main thread, and is now waiting for the ' ||
    'next BeginFrame from the GPU VizCompositor.'),
  ('RendererCompositorFinishedToCommit',
    'Interval between when the Renderer Compositor has finished its work ' ||
    'and the current tree state will be committed from the Renderer Main ' ||
    '(CrRendererMain) thread.'),
  ('RendererCompositorFinishedToEndCommit',
    'Interval between when the Renderer Compositor finishing processing to ' ||
    'the Renderer Main (CrRendererMain) both starting and finishing the ' ||
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'commit.'),
  ('RendererCompositorFinishedToActivation',
    'Interval of activation without a previous commit (not as a stage with ' ||
    'ToEndCommit). Activation occurs on the Renderer Compositor Thread ' ||
    'after it has been notified of a fully committed RendererMain tree.'),
  ('RendererCompositorFinishedToEndActivate',
    'Interval when the Renderer Compositor has finished processing and ' ||
    'activating the Tree.'),
  ('RendererCompositorFinishedToSubmitCompositorFrame',
    'Interval when processing does not need to wait for a commit (can do an ' ||
    'early out) for activation and can go straight to providing the frame ' ||
    'to the GPU VizCompositor. The Renderer Compositor is waiting for the ' ||
    'GPU to flush a frame so that it can then submit a new frame.'),
  ('RendererMainFinishedToBeginImplFrame',
    'Interval when the input was sent first to the RendererMain thread and ' ||
    'now requires the Renderer Compositor to react, aka it is is waiting ' ||
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'for a BeginFrame signal.'),
  ('RendererMainFinishedToSendBeginMainFrame',
    'Interval during which the Renderer Main (CrRendererMain) thread is ' ||
    'waiting for BeginMainFrame.'),
  ('RendererMainFinishedToCommit',
    'Interval when the Renderer Main (CrRendererMain) is ready to commit ' ||
    'its work to the Renderer Compositor.'),
  ('BeginImplFrameToSendBeginMainFrame',
    'Interval during which the Renderer Compositor has received the ' ||
    'BeginFrame signal from the GPU VizCompositor, and now needs to send it ' ||
    'to the Renderer Main thread (CrRendererMain).'),
  ('RendererCompositorFinishedToSendBeginMainFrame',
    'Interval during which the Renderer Compositor is waiting for a ' ||
    'BeginFrame from the GPU VizCompositor, and it expects to have to do ' ||
    'work on the Renderer Main thread (CrRendererMain), so we are waiting ' ||
    'for a BeginMainFrame'),
  ('SendBeginMainFrameToCommit',
    'Interval when updates (such as HandleInputEvents, Animate, StyleUpdate ' ||
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'and LayoutUpdate) are updatedon the Renderer Main thread ' ||
    '(CrRendererMain).'),
  ('Commit',
    'Interval during which the Renderer Main thread (CrRendererMain) ' ||
    'commits updates back to Renderer Compositor for activation. ' ||
    'Specifically, the main thread copies its own version of layer tree ' ||
    'onto the pending tree on the compositor thread. The main thread is ' ||
    'blocked during the copying process.'),
  ('EndCommitToActivation',
    'Interval when the commit is ready and waiting for activation.'),
  ('Activation',
    'Interval when the layer trees and properties are on the pending tree ' ||
    'is pused to the active tree on the Renderer Compositor.'),
  ('SubmitToReceiveCompositorFrame',
    'Interval of the delay b/w Renderer Compositor thread sending ' ||
    'CompositorFrame and then GPU VizCompositorThread receiving the ' ||
    'CompositorFrame.'),
  ('ReceiveCompositorFrameToStartDraw',
    'Interval between the first frame received to when all frames (or ' ||
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'timeouts have occurred) and we start drawing. It can be blocked by ' ||
    'other processes (e.g to draw a toolbar it waiting for information from ' ||
    'the Browser) as it waits for timeouts or frames to be provided. This ' ||
    'is the tree of dependencies that the GPU VizCompositor is waiting for ' ||
    'things to arrive. That is creating a single frame for multiple ' ||
    'compositor frames. '),
  ('StartDrawToSwapStart',
    'Interval when all compositing sources are done, or compositing ' ||
    'deadline passes - the viz thread takes all the latest composited ' ||
    'surfaces and issues the software draw instructions to layer the ' ||
    'composited tiles, this substage ends when the swap starts on Gpu ' ||
    'CompositorGpuThread.'),
  ('SwapStartToBufferAvailable',
    'Interval that is a substage of stage "Swap" when the framebuffer ' ||
    'is prepared by the system and the fence Chrome waits on before ' ||
    'writing is signalled, and Chrome can start transferring the new frame.'),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ('BufferAvailableToBufferReady',
    'Interval that is a Ssubstage of stage "Swap" when Chrome is ' ||
    'transferring a new frame to when it has finished completely sending a ' ||
    'frame to the framebuffer.'),
  ('BufferReadyToLatch',
    'Interval that is a substage of stage "Swap", when the system latches ' ||
    'and is ready to use the frame, and then it can get to work producing ' ||
    'the final frame.'),
  ('LatchToSwapEnd',
    'Intereval that is a substage of stage "Swap", when the latch has ' ||
    'finished until the frame is fully swapped and in the queue of frames ' ||
    'to be presented.'),
  ('SwapEndToPresentationCompositorFrame',
    'Interval that the frame is presented on the screen (and pixels became ' ||
    'visible).'))
SELECT
  name,
  description
FROM event_latency_descriptions;

)_d3l1m1t3r_"
;

const char kHistograms[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

DROP VIEW IF EXISTS chrome_histograms;

-- A helper view on top of the histogram events emitted by Chrome.
-- Requires "disabled-by-default-histogram_samples" Chrome category.
CREATE PERFETTO TABLE chrome_histograms(
  -- The name of the histogram.
  name STRING,
  -- The value of the histogram sample.
  value INT,
  -- Alias of |slice.ts|.
  ts INT,
  -- Thread name.
  thread_name STRING,
  -- Utid of the thread.
  utid INT,
  -- Tid of the thread.
  tid INT,
  -- Process name.
  process_name STRING,
  -- Upid of the process.
  upid INT,
  -- Pid of the process.
  pid INT
) AS
SELECT
  extract_arg(slice.arg_set_id, "chrome_histogram_sample.name") as name,
  extract_arg(slice.arg_set_id, "chrome_histogram_sample.sample") as value,
  ts,
  thread.name as thread_name,
  thread.utid as utid,
  thread.tid as tid,
  process.name as process_name,
  process.upid as upid,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  process.pid as pid
FROM slice
JOIN thread_track ON thread_track.id = slice.track_id
JOIN thread USING (utid)
JOIN process USING (upid)
WHERE
  slice.name = "HistogramSample"
  AND category = "disabled-by-default-histogram_samples";
)_d3l1m1t3r_"
;

const char kInteractions[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- This file specifies common metrics/tables for critical user interactions. It
-- is expected to be in flux as metrics are added across different CUI types.
-- Currently we only track Chrome page loads and their associated metrics.

INCLUDE PERFETTO MODULE chrome.page_loads;
INCLUDE PERFETTO MODULE chrome.startups;
INCLUDE PERFETTO MODULE chrome.web_content_interactions;

-- All critical user interaction events, including type and table with
-- associated metrics.
CREATE PERFETTO TABLE chrome_interactions(
  -- Identifier of the interaction; this is not guaranteed to be unique to the table -
  -- rather, it is unique within an individual interaction type. Combine with type to get
  -- a unique identifier in this table.
  scoped_id INT,
  -- Type of this interaction, which together with scoped_id uniquely identifies this
  -- interaction. Also corresponds to a SQL table name containing more details specific
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- to this type of interaction.
  type STRING,
  -- Interaction name - e.g. 'PageLoad', 'Tap', etc. Interactions will have unique metrics
  -- stored in other tables.
  name STRING,
  -- Timestamp of the CUI event.
  ts INT,
  -- Duration of the CUI event.
  dur INT
) AS
SELECT
  id AS scoped_id,
  'chrome_page_loads' AS type,
  'PageLoad' AS name,
  navigation_start_ts AS ts,
  IFNULL(lcp, fcp) AS dur
FROM chrome_page_loads
UNION ALL
SELECT
  id AS scoped_id,
  'chrome_startups' AS type,
  name,
  startup_begin_ts AS ts,
  CASE
    WHEN first_visible_content_ts IS NOT NULL
      THEN first_visible_content_ts - startup_begin_ts
    ELSE 0
  END AS dur
FROM chrome_startups
UNION ALL
SELECT
  id AS scoped_id,
  'chrome_web_content_interactions' AS type,
  'InteractionToFirstPaint' AS name,
  ts,
  dur
FROM chrome_web_content_interactions;

)_d3l1m1t3r_"
;

const char kMetadata[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- Returns hardware class of the device, often use to find device brand
-- and model.
CREATE PERFETTO FUNCTION chrome_hardware_class()
-- Hardware class name.
RETURNS STRING AS
SELECT
  str_value
  FROM metadata
WHERE name = "cr-hardware-class";
)_d3l1m1t3r_"
;

const char kPageLoads[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- TODO(b/306300843): The recorded navigation ids are not guaranteed to be
-- unique within a trace; they are only guaranteed to be unique within a single
-- chrome instance. Chrome instance id needs to be recorded, and used here in
-- combination with navigation id to uniquely identify page load metrics.

INCLUDE PERFETTO MODULE slices.with_context;

CREATE PERFETTO VIEW _fcp_metrics AS
SELECT
  ts,
  dur,
  EXTRACT_ARG(arg_set_id, 'page_load.navigation_id') AS navigation_id,
  EXTRACT_ARG(arg_set_id, 'page_load.url') AS url,
  upid AS browser_upid
FROM process_slice
WHERE name = 'PageLoadMetrics.NavigationToFirstContentfulPaint';

CREATE PERFETTO FUNCTION _page_load_metrics(event_name STRING)
RETURNS TABLE(
  ts LONG,
  dur LONG,
  navigation_id INT,
  browser_upid INT
) AS
SELECT
  ts,
  dur,
  EXTRACT_ARG(arg_set_id, 'page_load.navigation_id')
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    AS navigation_id,
  upid AS browser_upid
FROM process_slice
WHERE name = $event_name;

-- Chrome page loads, including associated high-level metrics and properties.
CREATE PERFETTO TABLE chrome_page_loads(
  -- ID of the navigation and Chrome browser process; this combination is
  -- unique to every individual navigation.
  id INT,
  -- ID of the navigation associated with the page load (i.e. the cross-document
  -- navigation in primary main frame which created this page's main document).
  -- Also note that navigation_id is specific to a given Chrome browser process,
  -- and not globally unique.
  navigation_id INT,
  -- Timestamp of the start of navigation.
  navigation_start_ts INT,
  -- Duration between the navigation start and the first contentful paint event
  -- (web.dev/fcp).
  fcp INT,
  -- Timestamp of the first contentful paint.
  fcp_ts INT,
  -- Duration between the navigation start and the largest contentful paint event
  -- (web.dev/lcp).
  lcp INT,
  -- Timestamp of the largest contentful paint.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  lcp_ts INT,
  -- Timestamp of the DomContentLoaded event:
  -- https://developer.mozilla.org/en-US/docs/Web/API/Document/DOMContentLoaded_event
  dom_content_loaded_event_ts INT,
  -- Timestamp of the window load event:
  -- https://developer.mozilla.org/en-US/docs/Web/API/Window/load_event
  load_event_ts INT,
  -- Timestamp of the page self-reporting as fully loaded through the
  -- performance.mark('mark_fully_loaded') API.
  mark_fully_loaded_ts INT,
  -- Timestamp of the page self-reporting as fully visible through the
  -- performance.mark('mark_fully_visible') API.
  mark_fully_visible_ts INT,
  -- Timestamp of the page self-reporting as fully interactive through the
  -- performance.mark('mark_interactive') API.
  mark_interactive_ts INT,
  -- URL at the page load event.
  url STRING,
  -- The unique process id (upid) of the browser process where the page load occurred.
  browser_upid INT
) AS
SELECT
  ROW_NUMBER() OVER(ORDER BY fcp.ts) AS id,
  fcp.navigation_id,
  fcp.ts AS navigation_start_ts,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  fcp.dur AS fcp,
  fcp.ts + fcp.dur AS fcp_ts,
  lcp.dur AS lcp,
  lcp.dur + lcp.ts AS lcp_ts,
  load_fired.ts AS dom_content_loaded_event_ts,
  start_load.ts AS load_event_ts,
  timing_loaded.ts AS mark_fully_loaded_ts,
  timing_visible.ts AS mark_fully_visible_ts,
  timing_interactive.ts AS mark_interactive_ts,
  fcp.url,
  fcp.browser_upid
FROM _fcp_metrics fcp
LEFT JOIN
  _page_load_metrics('PageLoadMetrics.NavigationToLargestContentfulPaint') lcp
    USING (navigation_id, browser_upid)
LEFT JOIN
  _page_load_metrics('PageLoadMetrics.NavigationToDOMContentLoadedEventFired') load_fired
    USING (navigation_id, browser_upid)
LEFT JOIN
  _page_load_metrics('PageLoadMetrics.NavigationToMainFrameOnLoad') start_load
    USING (navigation_id, browser_upid)
LEFT JOIN
  _page_load_metrics('PageLoadMetrics.UserTimingMarkFullyLoaded') timing_loaded
    USING (navigation_id, browser_upid)
LEFT JOIN
  _page_load_metrics('PageLoadMetrics.UserTimingMarkFullyVisible') timing_visible
    USING (navigation_id, browser_upid)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(LEFT JOIN
  _page_load_metrics('PageLoadMetrics.UserTimingMarkInteractive') timing_interactive
    USING (navigation_id, browser_upid);

)_d3l1m1t3r_"
;

const char kSpeedometer[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

INCLUDE PERFETTO MODULE chrome.speedometer_2_1;
INCLUDE PERFETTO MODULE chrome.speedometer_3;

CREATE PERFETTO FUNCTION _chrome_speedometer_version()
RETURNS STRING
AS
WITH
  num_measures AS (
    SELECT '2.1' AS version, COUNT(*) AS num_measures
    FROM chrome_speedometer_2_1_measure
    UNION ALL
    SELECT '3' AS version, COUNT(*) AS num_measures
    FROM chrome_speedometer_3_measure
  )
SELECT version
FROM num_measures
ORDER BY num_measures DESC
LIMIT 1;

-- Augmented slices for Speedometer measurements.
-- These are the intervals of time Speedometer uses to compute the final score.
-- There are two intervals that are measured for every test: sync and async
CREATE PERFETTO TABLE chrome_speedometer_measure(
  -- Start timestamp of the measure slice
  ts INT,
  -- Duration of the measure slice
  dur INT,
  -- Full measure name
  name STRING,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Speedometer iteration the slice belongs to.
  iteration INT,
  -- Suite name
  suite_name STRING,
  -- Test name
  test_name STRING,
  -- Type of the measure (sync or async)
  measure_type STRING)
AS
WITH
  all_versions AS (
    SELECT '2.1' AS version, * FROM chrome_speedometer_2_1_measure
    UNION ALL
    SELECT '3' AS version, * FROM chrome_speedometer_3_measure
  )
SELECT ts, dur, name, iteration, suite_name, test_name, measure_type
FROM all_versions
WHERE version = _chrome_speedometer_version();

-- Slice that covers one Speedometer iteration.
-- Depending on the Speedometer version these slices might need to be estimated
-- as older versions of Speedometer to not emit marks for this interval. The
-- metrics associated are the same ones Speedometer would output, but note we
-- use ns precision (Speedometer uses ~100us) so the actual values might differ
-- a bit.
CREATE PERFETTO TABLE chrome_speedometer_iteration(
  -- Start timestamp of the iteration
  ts INT,
  -- Duration of the iteration
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  dur INT,
  -- Iteration name
  name STRING,
  -- Iteration number
  iteration INT,
  -- Geometric mean of the suite durations for this iteration.
  geomean DOUBLE,
  -- Speedometer score for this iteration (The total score for a run in the
  -- average of all iteration scores).
  score DOUBLE)
AS
WITH
  all_versions AS (
    SELECT '2.1' AS version, * FROM chrome_speedometer_2_1_iteration
    UNION ALL
    SELECT '3' AS version, * FROM chrome_speedometer_3_iteration
  )
SELECT ts, dur, name, iteration, geomean, score
FROM all_versions
WHERE version = _chrome_speedometer_version();

-- Returns the Speedometer score for all iterations in the trace
CREATE PERFETTO FUNCTION chrome_speedometer_score()
-- Speedometer score
RETURNS DOUBLE
AS
SELECT
  IIF(
    _chrome_speedometer_version() = '3',
    chrome_speedometer_3_score(),
    chrome_speedometer_2_1_score());

)_d3l1m1t3r_"
;

const char kSpeedometer21[] = R"_d3l1m1t3r_(-- Copyright 2024 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- List Speedometer 2.1 tests.
CREATE PERFETTO VIEW _chrome_speedometer_2_1_test_name(
  -- Suite name
  suite_name STRING,
  -- Test name
  test_name STRING)
AS
WITH
  data(suite_name, test_name) AS (
    VALUES('Angular2-TypeScript-TodoMVC', 'Adding100Items'),
    ('Angular2-TypeScript-TodoMVC', 'CompletingAllItems'),
    ('Angular2-TypeScript-TodoMVC', 'DeletingItems'),
    ('AngularJS-TodoMVC', 'Adding100Items'),
    ('AngularJS-TodoMVC', 'CompletingAllItems'),
    ('AngularJS-TodoMVC', 'DeletingAllItems'),
    ('BackboneJS-TodoMVC', 'Adding100Items'),
    ('BackboneJS-TodoMVC', 'CompletingAllItems'),
    ('BackboneJS-TodoMVC', 'DeletingAllItems'),
    ('Elm-TodoMVC', 'Adding100Items'),
    ('Elm-TodoMVC', 'CompletingAllItems'),
    ('Elm-TodoMVC', 'DeletingItems'),
    ('EmberJS-Debug-TodoMVC', 'Adding100Items'),
    ('EmberJS-Debug-TodoMVC', 'CompletingAllItems'),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    ('EmberJS-Debug-TodoMVC', 'DeletingItems'),
    ('EmberJS-TodoMVC', 'Adding100Items'),
    ('EmberJS-TodoMVC', 'CompletingAllItems'),
    ('EmberJS-TodoMVC', 'DeletingItems'),
    ('Flight-TodoMVC', 'Adding100Items'),
    ('Flight-TodoMVC', 'CompletingAllItems'),
    ('Flight-TodoMVC', 'DeletingItems'),
    ('Inferno-TodoMVC', 'Adding100Items'),
    ('Inferno-TodoMVC', 'CompletingAllItems'),
    ('Inferno-TodoMVC', 'DeletingItems'),
    ('Preact-TodoMVC', 'Adding100Items'),
    ('Preact-TodoMVC', 'CompletingAllItems'),
    ('Preact-TodoMVC', 'DeletingItems'),
    ('React-Redux-TodoMVC', 'Adding100Items'),
    ('React-Redux-TodoMVC', 'CompletingAllItems'),
    ('React-Redux-TodoMVC', 'DeletingItems'),
    ('React-TodoMVC', 'Adding100Items'),
    ('React-TodoMVC', 'CompletingAllItems'),
    ('React-TodoMVC', 'DeletingAllItems'),
    ('Vanilla-ES2015-Babel-Webpack-TodoMVC', 'Adding100Items'),
    ('Vanilla-ES2015-Babel-Webpack-TodoMVC', 'CompletingAllItems'),
    ('Vanilla-ES2015-Babel-Webpack-TodoMVC', 'DeletingItems'),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    ('Vanilla-ES2015-TodoMVC', 'Adding100Items'),
    ('Vanilla-ES2015-TodoMVC', 'CompletingAllItems'),
    ('Vanilla-ES2015-TodoMVC', 'DeletingItems'),
    ('VanillaJS-TodoMVC', 'Adding100Items'),
    ('VanillaJS-TodoMVC', 'CompletingAllItems'),
    ('VanillaJS-TodoMVC', 'DeletingAllItems'),
    ('VueJS-TodoMVC', 'Adding100Items'),
    ('VueJS-TodoMVC', 'CompletingAllItems'),
    ('VueJS-TodoMVC', 'DeletingAllItems'),
    ('jQuery-TodoMVC', 'Adding100Items'),
    ('jQuery-TodoMVC', 'CompletingAllItems'),
    ('jQuery-TodoMVC', 'DeletingAllItems')
  )
SELECT suite_name, test_name FROM data;

-- Augmented slices for Speedometer measurements.
-- These are the intervals of time Speedometer uses to compute the final score.
-- There are two intervals that are measured for every test: sync and async
-- sync is the time between the start and sync-end marks, async is the time
-- between the sync-end and async-end marks.
CREATE PERFETTO TABLE chrome_speedometer_2_1_measure(
  -- Start timestamp of the measure slice
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ts INT,
  -- Duration of the measure slice
  dur INT,
  -- Full measure name
  name STRING,
  -- Speedometer iteration the slice belongs to.
  iteration INT,
  -- Suite name
  suite_name STRING,
  -- Test name
  test_name STRING,
  -- Type of the measure (sync or async)
  measure_type STRING)
AS
WITH
  mark_type(mark_type) AS (
    VALUES('start'),
    ('sync-end'),
    ('async-end')
  ),
  -- Make sure we only look at slices with names we expect.
  mark_name AS (
    SELECT
      suite_name || '.' || test_name || '-' || mark_type AS name,
      suite_name,
      test_name,
      mark_type
    FROM
      _chrome_speedometer_2_1_test_name,
      mark_type
  ),
  mark AS (
    SELECT
      s.id AS slice_id,
      RANK() OVER (PARTITION BY name ORDER BY ts ASC) AS iteration,
      m.suite_name,
      m.test_name,
      m.mark_type
    FROM slice AS s
    JOIN mark_name AS m
      USING (name)
    WHERE category = 'blink.user_timing'
  ),
  -- Get the 3 test timestamps (start, sync-end, async-end) in one row. Using a
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- the LAG window function and partitioning by test. 2 out of the 3 rows
  -- generated per test will have some NULL ts values.
  augmented AS (
    SELECT
      iteration,
      suite_name,
      test_name,
      ts AS async_end_ts,
      LAG(ts, 1)
        OVER (PARTITION BY iteration, suite_name, test_name ORDER BY ts ASC)
        AS sync_end_ts,
      LAG(ts, 2)
        OVER (PARTITION BY iteration, suite_name, test_name ORDER BY ts ASC)
        AS start_ts,
      COUNT()
        OVER (PARTITION BY iteration, suite_name, test_name ORDER BY ts ASC)
        AS mark_count
    FROM mark
    JOIN slice
      USING (slice_id)
  ),
  filtered AS (
    SELECT *
    FROM augmented
    -- This server 2 purposes: make sure we have all the marks (think truncated
    -- trace), and remove the NULL ts values due to the LAG window function.
    WHERE mark_count = 3
  ),
  base AS (
    SELECT
      sync_end_ts AS ts,
      async_end_ts - sync_end_ts AS dur,
      iteration,
      suite_name,
      test_name,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      'async' AS measure_type
    FROM filtered
    UNION ALL
    SELECT
      start_ts AS ts,
      sync_end_ts - start_ts AS dur,
      iteration,
      suite_name,
      test_name,
      'sync' AS measure_type
    FROM filtered
  )
SELECT
  ts,
  dur,
  suite_name || '.' || test_name || '-' || measure_type AS name,
  iteration,
  suite_name,
  test_name,
  measure_type
FROM base;

-- Slice that covers one Speedometer iteration.
-- This slice is actually estimated as a default Speedometer run will not emit
-- marks to cover this interval. The metrics associated are the same ones
-- Speedometer would output, but note we use ns precision (Speedometer uses
-- ~100us) so the actual values might differ a bit. Also note Speedometer
-- returns the values in ms these here and in ns.
CREATE PERFETTO TABLE chrome_speedometer_2_1_iteration(
  -- Start timestamp of the iteration
  ts INT,
  -- Duration of the iteration
  dur INT,
  -- Iteration name
  name STRING,
  -- Iteration number
  iteration INT,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Geometric mean of the suite durations for this iteration.
  geomean DOUBLE,
  -- Speedometer score for this iteration (The total score for a run in the
  -- average of all iteration scores).
  score DOUBLE)
AS
SELECT
  MIN(start) AS ts,
  MAX(END) - MIN(start) AS dur,
  'iteration-' || iteration AS name,
  iteration,
  -- Compute geometric mean using LN instead of multiplication to prevent
  -- overflows
  EXP(AVG(LN(suite_total))) AS geomean,
  1000 / EXP(AVG(LN(suite_total))) * 60 / 3 AS score
FROM
  (
    SELECT
      iteration,
      SUM(dur / (1000.0 * 1000.0)) AS suite_total,
      MIN(ts) AS start,
      MAX(ts + dur) AS END
    FROM chrome_speedometer_2_1_measure
    GROUP BY suite_name, iteration
  )
GROUP BY iteration;

-- Returns the Speedometer 2.1 score for all iterations in the trace
CREATE PERFETTO FUNCTION chrome_speedometer_2_1_score()
-- Speedometer 2.1 score
RETURNS DOUBLE
AS
SELECT AVG(score) FROM chrome_speedometer_2_1_iteration;

)_d3l1m1t3r_"
;

const char kSpeedometer3[] = R"_d3l1m1t3r_(-- Copyright 2024 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- List Speedometer 3 tests.
CREATE PERFETTO VIEW _chrome_speedometer_3_test_name(
  -- Suite name
  suite_name STRING,
  -- Test name
  test_name STRING)
AS
WITH
  data(suite_name, test_name) AS (
    VALUES('TodoMVC-JavaScript-ES5', 'Adding100Items'),
    ('TodoMVC-JavaScript-ES5', 'CompletingAllItems'),
    ('TodoMVC-JavaScript-ES5', 'DeletingAllItems'),
    ('TodoMVC-JavaScript-ES6-Webpack-Complex-DOM', 'Adding100Items'),
    ('TodoMVC-JavaScript-ES6-Webpack-Complex-DOM', 'CompletingAllItems'),
    ('TodoMVC-JavaScript-ES6-Webpack-Complex-DOM', 'DeletingAllItems'),
    ('TodoMVC-WebComponents', 'Adding100Items'),
    ('TodoMVC-WebComponents', 'CompletingAllItems'),
    ('TodoMVC-WebComponents', 'DeletingAllItems'),
    ('TodoMVC-React-Complex-DOM', 'Adding100Items'),
    ('TodoMVC-React-Complex-DOM', 'CompletingAllItems'),
    ('TodoMVC-React-Complex-DOM', 'DeletingAllItems'),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    ('TodoMVC-React-Redux', 'Adding100Items'),
    ('TodoMVC-React-Redux', 'CompletingAllItems'),
    ('TodoMVC-React-Redux', 'DeletingAllItems'),
    ('TodoMVC-Backbone', 'Adding100Items'),
    ('TodoMVC-Backbone', 'CompletingAllItems'),
    ('TodoMVC-Backbone', 'DeletingAllItems'),
    ('TodoMVC-Angular-Complex-DOM', 'Adding100Items'),
    ('TodoMVC-Angular-Complex-DOM', 'CompletingAllItems'),
    ('TodoMVC-Angular-Complex-DOM', 'DeletingAllItems'),
    ('TodoMVC-Vue', 'Adding100Items'),
    ('TodoMVC-Vue', 'CompletingAllItems'),
    ('TodoMVC-Vue', 'DeletingAllItems'),
    ('TodoMVC-jQuery', 'Adding100Items'),
    ('TodoMVC-jQuery', 'CompletingAllItems'),
    ('TodoMVC-jQuery', 'DeletingAllItems'),
    ('TodoMVC-Preact-Complex-DOM', 'Adding100Items'),
    ('TodoMVC-Preact-Complex-DOM', 'CompletingAllItems'),
    ('TodoMVC-Preact-Complex-DOM', 'DeletingAllItems'),
    ('TodoMVC-Svelte-Complex-DOM', 'Adding100Items'),
    ('TodoMVC-Svelte-Complex-DOM', 'CompletingAllItems'),
    ('TodoMVC-Svelte-Complex-DOM', 'DeletingAllItems'),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    ('TodoMVC-Lit-Complex-DOM', 'Adding100Items'),
    ('TodoMVC-Lit-Complex-DOM', 'CompletingAllItems'),
    ('TodoMVC-Lit-Complex-DOM', 'DeletingAllItems'),
    ('NewsSite-Next', 'NavigateToUS'),
    ('NewsSite-Next', 'NavigateToWorld'),
    ('NewsSite-Next', 'NavigateToPolitics'),
    ('NewsSite-Nuxt', 'NavigateToUS'),
    ('NewsSite-Nuxt', 'NavigateToWorld'),
    ('NewsSite-Nuxt', 'NavigateToPolitics'),
    ('Editor-CodeMirror', 'Long'),
    ('Editor-CodeMirror', 'Highlight'),
    ('Editor-TipTap', 'Long'),
    ('Editor-TipTap', 'Highlight'),
    ('Charts-observable-plot', 'Stacked by 6'),
    ('Charts-observable-plot', 'Stacked by 20'),
    ('Charts-observable-plot', 'Dotted'),
    ('Charts-chartjs', 'Draw scatter'),
    ('Charts-chartjs', 'Show tooltip'),
    ('Charts-chartjs', 'Draw opaque scatter'),
    ('React-Stockcharts-SVG', 'Render'),
    ('React-Stockcharts-SVG', 'PanTheChart'),
    ('React-Stockcharts-SVG', 'ZoomTheChart'),
    ('Perf-Dashboard', 'Render'),
    ('Perf-Dashboard', 'SelectingPoints'),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    ('Perf-Dashboard', 'SelectingRange')
  )
SELECT suite_name, test_name FROM data;

CREATE
  PERFETTO MACRO _chrome_speedometer_iteration_slice()
RETURNS TableOrSubquery
AS (
  SELECT
    *,
    substr(name, 1 + length('iteration-')) AS iteration
  FROM
    slice
  WHERE
    category = 'blink.user_timing'
    AND name GLOB 'iteration-*'
    AND iteration = CAST(iteration AS INTEGER)
);

-- Augmented slices for Speedometer measurements.
-- These are the intervals of time Speedometer uses to compute the final score.
-- There are two intervals that are measured for every test: sync and async.
CREATE PERFETTO TABLE chrome_speedometer_3_measure(
  -- Start timestamp of the measure slice
  ts INT,
  -- Duration of the measure slice
  dur INT,
  -- Full measure name
  name STRING,
  -- Speedometer iteration the slice belongs to.
  iteration INT,
  -- Suite name
  suite_name STRING,
  -- Test name
  test_name STRING,
  -- Type of the measure (sync or async)
  measure_type STRING)
AS
WITH
  measure_type(measure_type) AS (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    VALUES('sync'),
    ('async')
  ),
  measure_name AS (
    SELECT
      suite_name || '.' || test_name || '-' || measure_type AS name,
      suite_name,
      test_name,
      measure_type
    FROM
      _chrome_speedometer_3_test_name,
      measure_type
  ),
  measure_slice AS (
    SELECT
      s.ts,
      s.dur,
      s.name,
      m.suite_name,
      m.test_name,
      m.measure_type
    FROM
      slice s,
      measure_name AS m
    USING (name)
    WHERE
      s.category = 'blink.user_timing'
  )
SELECT
  s.ts,
  s.dur,
  s.name,
  i.iteration,
  s.suite_name,
  s.test_name,
  s.measure_type
FROM
  measure_slice AS s,
  _chrome_speedometer_iteration_slice !() AS i
ON (s.ts >= i.ts AND s.ts < i.ts + i.dur)
ORDER BY s.ts ASC;

-- Slice that covers one Speedometer iteration.
-- The metrics associated are the same ones
-- Speedometer would output, but note we use ns precision (Speedometer uses
-- ~100us) so the actual values might differ a bit.
CREATE PERFETTO TABLE chrome_speedometer_3_iteration(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Start timestamp of the iteration
  ts INT,
  -- Duration of the iteration
  dur INT,
  -- Iteration name
  name STRING,
  -- Iteration number
  iteration INT,
  -- Geometric mean of the suite durations for this iteration.
  geomean DOUBLE,
  -- Speedometer score for this iteration (The total score for a run in the
  -- average of all iteration scores).
  score DOUBLE)
AS
WITH
  suite AS (
    SELECT
      iteration, suite_name, SUM(dur / (1000.0 * 1000.0)) AS suite_total
    FROM chrome_speedometer_3_measure
    GROUP BY iteration, suite_name
  ),
  iteration AS (
    SELECT
      iteration,
      -- Compute geometric mean using LN instead of multiplication to prevent
      -- overflows
      EXP(AVG(LN(suite_total))) AS geomean
    FROM suite
    GROUP BY iteration
  )
SELECT
  s.ts,
  s.dur,
  s.name,
  i.iteration,
  i.geomean,
  1000.0 / i.geomean AS score
FROM iteration AS i, _chrome_speedometer_iteration_slice !() AS s
USING (iteration);

-- Returns the Speedometer 3 score for all iterations in the trace
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO FUNCTION chrome_speedometer_3_score()
-- Speedometer 3 score
RETURNS DOUBLE
AS
SELECT AVG(score) FROM chrome_speedometer_3_iteration;

)_d3l1m1t3r_"
;

const char kStartups[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

INCLUDE PERFETTO MODULE slices.with_context;

-- Access all startups, including those that don't lead to any visible content.
-- If TimeToFirstVisibleContent is available, then this event will be the
-- main event of the startup. Otherwise, the event for the start timestamp will
-- be used.
CREATE PERFETTO VIEW _startup_start_events AS
WITH
starts AS (
  SELECT
    name,
    EXTRACT_ARG(arg_set_id, 'startup.activity_id') AS activity_id,
    ts,
    dur,
    upid AS browser_upid
  FROM thread_slice
  WHERE name = 'Startup.ActivityStart'
),
times_to_first_visible_content AS (
  SELECT
    name,
    EXTRACT_ARG(arg_set_id, 'startup.activity_id') AS activity_id,
    ts,
    dur,
    upid AS browser_upid
  FROM process_slice
  WHERE name = 'Startup.TimeToFirstVisibleContent2'
),
all_activity_ids AS (
  SELECT
    DISTINCT activity_id,
    browser_upid
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  FROM starts
  UNION ALL
  SELECT
    DISTINCT activity_id,
    browser_upid
  FROM times_to_first_visible_content
),
activity_ids AS (
  SELECT
    DISTINCT activity_id,
    browser_upid
  FROM all_activity_ids
)
SELECT
  activity_ids.activity_id,
  'Startup' AS name,
  IFNULL(times_to_first_visible_content.ts, starts.ts) AS startup_begin_ts,
  times_to_first_visible_content.ts +
    times_to_first_visible_content.dur AS first_visible_content_ts,
  activity_ids.browser_upid
FROM activity_ids
  LEFT JOIN times_to_first_visible_content using(activity_id, browser_upid)
  LEFT JOIN starts using(activity_id, browser_upid);

-- Chrome launch causes, not recorded at start time; use the activity id to
-- join with the actual startup events.
CREATE PERFETTO VIEW _launch_causes AS
SELECT
  EXTRACT_ARG(arg_set_id, 'startup.activity_id') AS activity_id,
  EXTRACT_ARG(arg_set_id, 'startup.launch_cause') AS launch_cause,
  upid AS browser_upid
FROM thread_slice
WHERE name = 'Startup.LaunchCause';

)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- Chrome startups, including launch cause.
CREATE PERFETTO TABLE chrome_startups(
  -- Unique ID
  id INT,
  -- Chrome Activity event id of the launch.
  activity_id INT,
  -- Name of the launch start event.
  name STRING,
  -- Timestamp that the startup occurred.
  startup_begin_ts INT,
  -- Timestamp to the first visible content.
  first_visible_content_ts INT,
  -- Launch cause. See Startup.LaunchCauseType in chrome_track_event.proto.
  launch_cause STRING,
  -- Process ID of the Browser where the startup occurred.
  browser_upid INT
) AS
SELECT
  ROW_NUMBER() OVER (ORDER BY start_events.startup_begin_ts) AS id,
  start_events.activity_id,
  start_events.name,
  start_events.startup_begin_ts,
  start_events.first_visible_content_ts,
  launches.launch_cause,
  start_events.browser_upid
FROM _startup_start_events start_events
  LEFT JOIN _launch_causes launches
  USING(activity_id, browser_upid);

)_d3l1m1t3r_"
;

const char kTasks[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- Checks if slice has an ancestor with provided name.
CREATE PERFETTO FUNCTION _has_parent_slice_with_name(
  -- Id of the slice to check parents of.
  id INT,
  -- Name of potential ancestor slice.
  parent_name STRING)
-- Whether `parent_name` is a name of an ancestor slice.
RETURNS BOOL AS
SELECT EXISTS(
  SELECT 1
  FROM ancestor_slice($id)
  WHERE name = $parent_name
  LIMIT 1
);

-- Returns the mojo ipc hash for a given task, looking it up from the
-- argument of descendant ScopedSetIpcHash slice.
-- This is relevant only for the older Chrome traces, where mojo IPC
-- hash was reported in a separate ScopedSetIpcHash slice.
CREATE PERFETTO FUNCTION _extract_mojo_ipc_hash(slice_id INT)
RETURNS INT AS
SELECT EXTRACT_ARG(arg_set_id, "chrome_mojo_event_info.ipc_hash")
FROM descendant_slice($slice_id)
WHERE name="ScopedSetIpcHash"
ORDER BY id
LIMIT 1;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Returns the frame type (main frame vs subframe) for key navigation tasks
-- which capture the associated RenderFrameHost in an argument.
CREATE PERFETTO FUNCTION _extract_frame_type(slice_id INT)
RETURNS INT AS
SELECT EXTRACT_ARG(arg_set_id, "render_frame_host.frame_type")
FROM descendant_slice($slice_id)
WHERE name IN (
  "RenderFrameHostImpl::BeginNavigation",
  "RenderFrameHostImpl::DidCommitProvisionalLoad",
  "RenderFrameHostImpl::DidCommitSameDocumentNavigation",
  "RenderFrameHostImpl::DidStopLoading"
)
LIMIT 1;

-- Human-readable aliases for a few key navigation tasks.
CREATE PERFETTO FUNCTION _human_readable_navigation_task_name(
  task_name STRING)
RETURNS STRING AS
SELECT
  CASE
    WHEN $task_name = "content.mojom.FrameHost message (hash=2168461044)"
      THEN "FrameHost::BeginNavigation"
    WHEN $task_name = "content.mojom.FrameHost message (hash=3561497419)"
      THEN "FrameHost::DidCommitProvisionalLoad"
    WHEN $task_name = "content.mojom.FrameHost message (hash=1421450774)"
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      THEN "FrameHost::DidCommitSameDocumentNavigation"
    WHEN $task_name = "content.mojom.FrameHost message (hash=368650583)"
      THEN "FrameHost::DidStopLoading"
  END;

-- Takes a task name and formats it correctly for scheduler tasks.
CREATE PERFETTO FUNCTION _format_scheduler_task_name(task_name STRING)
RETURNS STRING AS
SELECT printf("RunTask(posted_from=%s)", $task_name);

-- Takes the category and determines whether it is "Java" only, as opposed to
-- "toplevel,Java".
CREATE PERFETTO FUNCTION _java_not_top_level_category(category STRING)
RETURNS BOOL AS
SELECT $category GLOB "*Java*" AND $category not GLOB "*toplevel*";

-- Takes the category and determines whether is any valid
-- toplevel category or combination of categories.
CREATE PERFETTO FUNCTION _any_top_level_category(category STRING)
RETURNS BOOL AS
SELECT $category IN ("toplevel", "toplevel,viz", "toplevel,Java");

-- TODO(altimin): the situations with kinds in this file is a bit of a mess.
-- The idea is that it should work as `type` in the `slice` table, pointing to
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- a "child" table with more information about the task (e.g. posted_from for
-- scheduler tasks). Currently this is not the case and needs a cleanup.
-- Also we should align this with how table inheritance should work for
-- `CREATE PERFETTO TABLE`.

-- Get task type for a given task kind.
CREATE PERFETTO FUNCTION _get_java_views_task_type(kind STRING)
RETURNS STRING AS
SELECT
  CASE $kind
    WHEN "Choreographer" THEN "choreographer"
    WHEN "SingleThreadProxy::BeginMainFrame" THEN "ui_thread_begin_main_frame"
  END;

-- All slices corresponding to receiving mojo messages.
-- On the newer Chrome versions, it's just "Receive mojo message" and
-- "Receive mojo reply" slices (or "Receive {mojo_message_name}" if
-- built with `extended_tracing_enabled`. On legacy Chrome versions,
-- other appropriate messages (like "Connector::DispatchMessage") are used.
--
-- @column STRING interface_name    Name of the IPC interface.
-- @column INT ipc_hash             Hash of a message name.
-- @column STRING message_type      Either 'message' or 'reply'.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column INT id                   Slice id.
--
-- Note: this might include messages received within a sync mojo call.
-- TODO(altimin): This should use EXTEND_TABLE when it becomes available.
CREATE PERFETTO TABLE _chrome_mojo_slices AS
WITH
-- Select all new-style (post crrev.com/c/3270337) mojo slices and
-- generate |task_name| for them.
-- If extended tracing is enabled, the slice name will have the full method
-- name (i.e. "Receive content::mojom::FrameHost::DidStopLoading") and we
-- should use it as a full name.
-- If extended tracing is not enabled, we should include the interface name
-- and method hash into the full name.
new_mojo_slices AS (
  SELECT
    EXTRACT_ARG(arg_set_id, "chrome_mojo_event_info.mojo_interface_tag") AS interface_name,
    EXTRACT_ARG(arg_set_id, "chrome_mojo_event_info.ipc_hash") AS ipc_hash,
    CASE name
      WHEN "Receive mojo message" THEN "message"
      WHEN "Receive mojo reply" THEN "reply"
    END AS message_type,
    id
  FROM slice
  WHERE
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    category GLOB '*toplevel*'
    AND name GLOB 'Receive *'
),
-- Select old-style slices for channel-associated mojo events.
old_associated_mojo_slices AS (
  SELECT
    name AS interface_name,
    _extract_mojo_ipc_hash(id) AS ipc_hash,
    "message" AS message_type,
    id
  FROM slice
  WHERE
    category GLOB "*mojom*"
    AND name GLOB '*.mojom.*'
),
-- Select old-style slices for non-(channel-associated) mojo events.
old_non_associated_mojo_slices AS (
  SELECT
    COALESCE(
      EXTRACT_ARG(arg_set_id, "chrome_mojo_event_info.watcher_notify_interface_tag"),
      EXTRACT_ARG(arg_set_id, "chrome_mojo_event_info.mojo_interface_tag")
    ) AS interface_name,
    _extract_mojo_ipc_hash(id) AS ipc_hash,
    "message" AS message_type,
    id
  FROM slice
  WHERE
    category GLOB "*toplevel*" AND name = "Connector::DispatchMessage"
),
merged AS (
-- Merge all mojo slices.
SELECT * FROM new_mojo_slices
UNION ALL
SELECT * FROM old_associated_mojo_slices
UNION ALL
SELECT * FROM old_non_associated_mojo_slices
)_d3l1m1t3r_"
R"_d3l1m1t3r_()
SELECT * FROM merged ORDER BY id;

-- This table contains a list of slices corresponding to the _representative_
-- Chrome Java view operations.
-- These are the outermost Java view slices after filtering out generic framework views
-- (like FitWindowsLinearLayout) and selecting the outermost slices from the remaining ones.
--
-- @column id INT                       Slice id.
-- @column ts INT                       Timestamp.
-- @column dur INT                      Duration.
-- @column name STRING                  Name of the view.
-- @column is_software_screenshot BOOL  Whether this slice is a part of non-accelerated
--                                      capture toolbar screenshot.
-- @column is_hardware_screenshot BOOL  Whether this slice is a part of accelerated
--                                      capture toolbar screenshot.
CREATE PERFETTO TABLE _chrome_java_views AS
WITH
-- .draw, .onLayout and .onMeasure parts of the java view names don't add much, strip them.
java_slices_with_trimmed_names AS (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  SELECT
    id,
    REPLACE(
      REPLACE(
        REPLACE(
          REPLACE(
            REPLACE(
              s1.name,
              ".draw", ""),
            ".onLayout", ""),
          ".onMeasure", ""),
        ".Layout", ""),
      ".Measure", "") AS name,
      ts,
      dur
    FROM
      slice s1
    -- Ensure that toplevel Java slices are not included, as they may be logged
    -- with either category = "toplevel" or category = "toplevel,Java".
    -- Also filter out the zero duration slices as an attempt to reduce noise as
    -- "Java" category contains misc events (as it's hard to add new categories).
    WHERE _java_not_top_level_category(category) AND dur > 0
  ),
  -- We filter out generic slices from various UI frameworks which don't tell us much about
  -- what exactly this view is doing.
  interesting_java_slices AS (
    SELECT
      id, name, ts, dur
    FROM java_slices_with_trimmed_names
    WHERE NOT name IN (
      -- AndroidX.
      "FitWindowsFrameLayout",
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      "FitWindowsLinearLayout",
      "ContentFrameLayout",
      "CoordinatorLayout",
      -- Other non-Chrome UI libraries.
      "ComponentHost",
      -- Generic Chrome frameworks.
      "CompositorView:finalizeLayers",
      "CompositorViewHolder",
      "CompositorViewHolder:layout",
      "CompositorViewHolder:updateContentViewChildrenDimension",
      "CoordinatorLayoutForPointer",
      "OptimizedFrameLayout",
      "ViewResourceAdapter:getBitmap",
      "ViewResourceFrameLayout",
      -- Non-specific Chrome slices.
      "AppCompatImageButton",
      "ScrollingBottomViewResourceFrameLayout",
      -- Screenshots get their custom annotations below.
      "ViewResourceAdapter:captureWithHardwareDraw",
      "ViewResourceAdapter:captureWithSoftwareDraw",
      -- Non-bytecode generated slices.
      "LayoutDriver:onUpdate"
    )
)
SELECT
  s1.*,
  -- While the parent slices are too generic to be used by themselves,
  -- they can provide some useful metadata.
  _has_parent_slice_with_name(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    s1.id,
    "ViewResourceAdapter:captureWithSoftwareDraw"
  ) AS is_software_screenshot,
  _has_parent_slice_with_name(
    s1.id,
    "ViewResourceAdapter:captureWithHardwareDraw"
  ) AS is_hardware_screenshot
FROM interesting_java_slices s1
-- We select "outermost" interesting slices: interesting slices which
-- do not another interesting slice in their parent chain.
WHERE (SELECT count()
  FROM ancestor_slice(s1.id) s2
  JOIN interesting_java_slices s3 ON s2.id = s3.id) = 0;

-- A list of slices corresponding to operations on interesting (non-generic)
-- Chrome Java views. The view is considered interested if it's not a system
-- (ContentFrameLayout) or generic library (CompositorViewHolder) views.
--
-- TODO(altimin): Add "columns_from slice" annotation.
-- TODO(altimin): convert this to EXTEND_TABLE when it becomes available.
CREATE PERFETTO VIEW chrome_java_views(
  -- Name of the view.
  filtered_name STRING,
  -- Whether this slice is a part of non-accelerated capture toolbar screenshot.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  is_software_screenshot BOOL,
  -- Whether this slice is a part of accelerated capture toolbar screenshot.
  is_hardware_screenshot BOOL,
  -- Slice id.
  slice_id INT
) AS
SELECT
  java_view.name AS filtered_name,
  java_view.is_software_screenshot,
  java_view.is_hardware_screenshot,
  slice.id as slice_id
FROM _chrome_java_views java_view
JOIN slice USING (id);

-- A list of Choreographer tasks (Android frame generation) in Chrome.
CREATE PERFETTO VIEW _chrome_choreographer_tasks
AS
SELECT
  id,
  "Choreographer" AS kind,
  ts,
  dur,
  name
FROM slice
WHERE name GLOB "Looper.dispatch: android.view.Choreographer$FrameHandler*";

-- Extract task's posted_from information from task's arguments.
CREATE PERFETTO FUNCTION _get_posted_from(arg_set_id INT)
RETURNS STRING AS
WITH posted_from as (
  SELECT
    EXTRACT_ARG($arg_set_id, "task.posted_from.file_name") AS file_name,
    EXTRACT_ARG($arg_set_id, "task.posted_from.function_name") AS function_name
)
SELECT file_name || ":" || function_name as posted_from
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM posted_from;

-- Selects the BeginMainFrame slices (which as posted from ScheduledActionSendBeginMainFrame),
-- used for root-level processing. In top-level/Java based slices, these will correspond to the
-- ancestor of descendant slices; in long-task tracking, these tasks will be
-- on a custom track and will need to be associated with children by timestamp
-- and duration. Corresponds with the Choreographer root slices in
-- chrome_choreographer_tasks below.
--
-- Schema:
-- @column is            The slice id.
-- @column kind          The type of Java slice.
-- @column ts            The timestamp of the slice.
-- @column name          The name of the slice.
CREATE PERFETTO FUNCTION _select_begin_main_frame_java_slices(
  name STRING)
RETURNS TABLE(id INT, kind STRING, ts LONG, dur LONG, name STRING) AS
SELECT
  id,
  "SingleThreadProxy::BeginMainFrame" AS kind,
  ts,
  dur,
  name
FROM slice
WHERE
  (name = $name
    AND _get_posted_from(arg_set_id) =
        "cc/trees/single_thread_proxy.cc:ScheduledActionSendBeginMainFrame");
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- A list of Chrome tasks which were performing operations with Java views,
-- together with the names of these views.
-- @column id INT            Slice id.
-- @column kind STRING       Type of the task.
-- @column java_views STRING Concatenated names of Java views used by the task.
CREATE PERFETTO VIEW _chrome_slices_with_java_views AS
WITH
  -- Select UI thread BeginMainFrames (which are Chrome scheduler tasks) and
  -- Choreographer frames (which are looper tasks).
  root_slices AS (
    SELECT id, kind
    FROM _SELECT_BEGIN_MAIN_FRAME_JAVA_SLICES('ThreadControllerImpl::RunTask')
    UNION ALL
    SELECT id, kind FROM _chrome_choreographer_tasks
  ),
  -- Intermediate step to allow us to sort java view names.
  root_slice_and_java_view_not_grouped AS (
    SELECT
      root.id, root.kind, java_view.name AS java_view_name
    FROM root_slices root
    JOIN descendant_slice(root.id) child
    JOIN _chrome_java_views java_view ON java_view.id = child.id
  )
SELECT
  root.id,
  root.kind,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  GROUP_CONCAT(DISTINCT java_view.java_view_name) AS java_views
FROM root_slices root
LEFT JOIN root_slice_and_java_view_not_grouped java_view USING (id)
GROUP BY root.id;

-- A list of tasks executed by Chrome scheduler.
CREATE PERFETTO TABLE _chrome_scheduler_tasks AS
SELECT
  id
FROM slice
WHERE
  category GLOB "*toplevel*"
  AND (name = "ThreadControllerImpl::RunTask" OR name = "ThreadPool_RunTask")
ORDER BY id;

-- A list of tasks executed by Chrome scheduler.
CREATE PERFETTO VIEW chrome_scheduler_tasks(
  -- Slice id.
  id INT,
  -- Type.
  type STRING,
  -- Name of the task.
  name STRING,
  -- Timestamp.
  ts INT,
  -- Duration.
  dur INT,
  -- Utid of the thread this task run on.
  utid INT,
  -- Name of the thread this task run on.
  thread_name STRING,
  -- Upid of the process of this task.
  upid INT,
  -- Name of the process of this task.
  process_name STRING,
  -- Same as slice.track_id.
  track_id INT,
  -- Same as slice.category.
  category STRING,
  -- Same as slice.depth.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  depth INT,
  -- Same as slice.parent_id.
  parent_id INT,
  -- Same as slice.arg_set_id.
  arg_set_id INT,
  -- Same as slice.thread_ts.
  thread_ts INT,
  -- Same as slice.thread_dur.
  thread_dur INT,
  -- Source location where the PostTask was called.
  posted_from STRING
) AS
SELECT
  task.id,
  "chrome_scheduler_tasks" as type,
  _format_scheduler_task_name(
    _get_posted_from(slice.arg_set_id)) as name,
  slice.ts,
  slice.dur,
  thread.utid,
  thread.name as thread_name,
  process.upid,
  process.name as process_name,
  slice.track_id,
  slice.category,
  slice.depth,
  slice.parent_id,
  slice.arg_set_id,
  slice.thread_ts,
  slice.thread_dur,
  _get_posted_from(slice.arg_set_id) as posted_from
FROM _chrome_scheduler_tasks task
JOIN slice using (id)
JOIN thread_track ON slice.track_id = thread_track.id
JOIN thread using (utid)
JOIN process using (upid)
ORDER BY task.id;

-- Select the slice that might be the descendant mojo slice for the given task
-- slice if it exists.
CREATE PERFETTO FUNCTION _get_descendant_mojo_slice_candidate(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  slice_id INT
)
RETURNS INT AS
SELECT
  id
FROM descendant_slice($slice_id)
WHERE
  -- The tricky case here is dealing with sync mojo IPCs: we do not want to
  -- pick up sync IPCs when we are in a non-IPC task.
  -- So we look at all toplevel events and pick up the first one:
  -- for sync mojo messages, it will be "Send mojo message", which then
  -- will fail.
  -- Some events are excluded as they can legimately appear under "RunTask"
  -- before "Receive mojo message".
  category GLOB "*toplevel*" AND
  name NOT IN (
    "SimpleWatcher::OnHandleReady",
    "MessagePipe peer closed")
ORDER by depth, ts
LIMIT 1;

CREATE PERFETTO FUNCTION _descendant_mojo_slice(slice_id INT)
RETURNS TABLE(task_name STRING) AS
SELECT
  printf("%s %s (hash=%d)",
    mojo.interface_name, mojo.message_type, mojo.ipc_hash) AS task_name
FROM slice task
JOIN _chrome_mojo_slices mojo
  ON mojo.id = _get_descendant_mojo_slice_candidate($slice_id)
WHERE task.id = $slice_id;

-- A list of "Chrome tasks": top-level execution units (e.g. scheduler tasks /
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- IPCs / system callbacks) run by Chrome. For a given thread, the tasks
-- will not intersect.
--
-- @column task_name STRING  Name for the given task.
-- @column task_type STRING  Type of the task (e.g. "scheduler").
-- @column scheduling_delay INT
CREATE PERFETTO TABLE _chrome_tasks AS
WITH
-- Select slices from "toplevel" category which do not have another
-- "toplevel" slice as ancestor. The possible cases include sync mojo messages
-- and tasks in nested runloops. Toplevel events may also be logged as with
-- the Java category.
non_embedded_toplevel_slices AS (
  SELECT * FROM slice
  WHERE
    _any_top_level_category(category)
    AND (SELECT count() FROM ancestor_slice(slice.id) anc
      WHERE anc.category GLOB "*toplevel*" or anc.category GLOB "*toplevel.viz*") = 0
),
-- Select slices from "Java" category which do not have another "Java" or
-- "toplevel" slice as parent. In the longer term they should probably belong
-- to "toplevel" category as well, but for now this will have to do. Ensure
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- that "Java" slices do not include "toplevel" slices as those would be
-- handled elsewhere.
non_embedded_java_slices AS (
  SELECT
    id,
    name AS task_name,
    "java" as task_type
  FROM slice s
  WHERE
    _java_not_top_level_category(category)
    AND (SELECT count()
      FROM ancestor_slice(s.id) s2
      WHERE s2.category GLOB "*toplevel*" OR s2.category GLOB "*Java*") = 0
),
-- Generate full names for tasks with java views.
java_views_tasks AS (
  SELECT
    id,
    printf('%s(java_views=%s)', kind, java_views) AS task_name,
    _get_java_views_task_type(kind) AS task_type
  FROM _chrome_slices_with_java_views
),
scheduler_tasks AS (
  SELECT
    id,
    name as task_name,
    "scheduler" as task_type
  FROM chrome_scheduler_tasks
),
-- Select scheduler tasks which are used to run mojo messages and use the mojo names
-- as full names for these slices.
-- We restrict this to specific scheduler tasks which are expected to run mojo
-- tasks due to sync mojo events, which also emit similar events.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(scheduler_tasks_with_mojo AS (
  SELECT
    -- We use the "RunTask" as the task, and pick up the name from its child
    -- "Receive mojo message" event.
    task.id,
    receive_message.task_name,
    "mojo" AS task_type
  FROM
    chrome_scheduler_tasks task
  JOIN _DESCENDANT_MOJO_SLICE(task.id) receive_message
  WHERE
    task.posted_from IN (
      "mojo/public/cpp/system/simple_watcher.cc:Notify",
      "mojo/public/cpp/system/simple_watcher.cc:ArmOrNotify",
      "mojo/public/cpp/bindings/lib/connector.cc:PostDispatchNextMessageFromPipe",
      "ipc/ipc_mojo_bootstrap.cc:Accept")
),
navigation_tasks AS (
  WITH tasks_with_readable_names AS (
    SELECT
      id,
      _human_readable_navigation_task_name(task_name) as readable_name,
      IFNULL(_extract_frame_type(id), 'unknown frame type') as frame_type
    FROM
      scheduler_tasks_with_mojo
  )
  SELECT
    id,
    printf("%s (%s)", readable_name, frame_type) as task_name,
    'navigation_task' AS task_type
  FROM tasks_with_readable_names
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  WHERE readable_name IS NOT NULL
),
-- Add scheduler and mojo full names to non-embedded slices from
-- the "toplevel" category, with mojo ones taking precedence.
non_embedded_toplevel_slices_with_task_name AS (
  SELECT
    task.id AS id,
    COALESCE(
        navigation.task_name,
        java_views.task_name,
        mojo.task_name,
        scheduler.task_name,
        task.name
    ) AS name,
    COALESCE(
        navigation.task_type,
        java_views.task_type,
        mojo.task_type,
        scheduler.task_type,
        "other"
    ) AS task_type
  FROM non_embedded_toplevel_slices task
  LEFT JOIN scheduler_tasks_with_mojo mojo ON mojo.id = task.id
  LEFT JOIN scheduler_tasks scheduler ON scheduler.id = task.id
  LEFT JOIN java_views_tasks java_views ON java_views.id = task.id
  LEFT JOIN navigation_tasks navigation ON navigation.id = task.id
)
-- Merge slices from toplevel and Java categories.
SELECT * FROM non_embedded_toplevel_slices_with_task_name
UNION ALL
SELECT * FROM non_embedded_java_slices
)_d3l1m1t3r_"
R"_d3l1m1t3r_(ORDER BY id;

-- A list of "Chrome tasks": top-level execution units (e.g. scheduler tasks /
-- IPCs / system callbacks) run by Chrome. For a given thread, the slices
-- corresponding to these tasks will not intersect.
CREATE PERFETTO VIEW chrome_tasks(
  -- Id for the given task, also the id of the slice this task corresponds to.
  id INT,
  -- Name for the given task.
  name STRING,
  -- Type of the task (e.g. "scheduler").
  task_type STRING,
  -- Thread name.
  thread_name STRING,
  -- Utid.
  utid INT,
  -- Process name.
  process_name STRING,
  -- Upid.
  upid INT,
  -- Alias of |slice.ts|.
  ts INT,
  -- Alias of |slice.dur|.
  dur INT,
  -- Alias of |slice.track_id|.
  track_id INT,
  -- Alias of |slice.category|.
  category INT,
  -- Alias of |slice.arg_set_id|.
  arg_set_id INT,
  -- Alias of |slice.thread_ts|.
  thread_ts INT,
  -- Alias of |slice.thread_dur|.
  thread_dur INT,
  -- STRING    Legacy alias for |name|.
  full_name STRING
) AS
SELECT
  cti.id,
  cti.name,
  task_type,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  thread.name AS thread_name,
  thread.utid,
  process.name AS process_name,
  thread.upid,
  s.ts,
  s.dur,
  s.track_id,
  s.category,
  s.arg_set_id,
  s.thread_ts,
  s.thread_dur,
  cti.name as full_name
FROM _chrome_tasks cti
JOIN slice s ON cti.id = s.id
JOIN thread_track tt ON s.track_id = tt.id
JOIN thread USING (utid)
JOIN process USING (upid);

)_d3l1m1t3r_"
;

const char kVsyncIntervals[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- A simple table that checks the time between VSync (this can be used to
-- determine if we're refreshing at 90 FPS or 60 FPS).
--
-- Note: In traces without the "Java" category there will be no VSync
--       TraceEvents and this table will be empty.
CREATE PERFETTO TABLE chrome_vsync_intervals(
  -- Slice id of the vsync slice.
  slice_id INT,
  -- Timestamp of the vsync slice.
  ts INT,
  -- Duration of the vsync slice.
  dur INT,
  -- Track id of the vsync slice.
  track_id INT,
  -- Duration until next vsync arrives.
  time_to_next_vsync INT
) AS
SELECT
  slice_id,
  ts,
  dur,
  track_id,
  LEAD(ts) OVER(PARTITION BY track_id ORDER BY ts) - ts AS time_to_next_vsync
FROM slice
WHERE name = "VSync"
ORDER BY track_id, ts;

-- Function: compute the average Vysnc interval of the
-- gesture (hopefully this would be either 60 FPS for the whole gesture or 90
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- FPS but that isnt always the case) on the given time segment.
-- If the trace doesnt contain the VSync TraceEvent we just fall back on
-- assuming its 60 FPS (this is the 1.6e+7 in the COALESCE which
-- corresponds to 16 ms or 60 FPS).
CREATE PERFETTO FUNCTION chrome_calculate_avg_vsync_interval(
  -- Interval start time.
  begin_ts LONG,
  -- Interval end time.
  end_ts LONG
)
-- The average vsync interval on this time segment
-- or 1.6e+7, if trace doesn't contain the VSync TraceEvent.
RETURNS FLOAT AS
SELECT
  COALESCE((
    SELECT
      CAST(AVG(time_to_next_vsync) AS FLOAT)
    FROM chrome_vsync_intervals in_query
    WHERE
      time_to_next_vsync IS NOT NULL AND
      in_query.ts > $begin_ts AND
      in_query.ts < $end_ts
  ), 1e+9 / 60);

)_d3l1m1t3r_"
;

const char kWebContentInteractions[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

INCLUDE PERFETTO MODULE slices.with_context;

-- Chrome web content interactions (InteractionToFirstPaint), including
-- associated high-level metrics and properties.
--
-- Multiple events may occur for the same interaction; each row in this table
-- represents the primary (longest) event for the interaction.
--
-- Web content interactions are discrete, as opposed to sustained (e.g.
-- scrolling); and only occur with the web content itself, as opposed to other
-- parts of Chrome (e.g. omnibox). Interaction events include taps, clicks,
-- keyboard input (typing), and drags.
CREATE PERFETTO TABLE chrome_web_content_interactions(
  -- Unique id for this interaction.
  id INT,
  -- Start timestamp of the event. Because multiple events may occur for the
  -- same interaction, this is the start timestamp of the longest event.
  ts INT,
  -- Duration of the event. Because multiple events may occur for the same
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- interaction, this is the duration of the longest event.
  dur INT,
  -- The interaction type.
  interaction_type STRING,
  -- The total duration of all events that occurred for the same interaction.
  total_duration_ms INT,
  -- The process id this event occurred on.
  renderer_upid INT
) AS
SELECT
  id,
  ts,
  dur,
  EXTRACT_ARG(arg_set_id, 'web_content_interaction.type') AS interaction_type,
  EXTRACT_ARG(
    arg_set_id,
    'web_content_interaction.total_duration_ms'
  ) AS total_duration_ms,
  upid AS renderer_upid
FROM process_slice
WHERE name = 'Web Interaction';

)_d3l1m1t3r_"
;

const char kScrollJankPredictorJank[] = R"_d3l1m1t3r_(-- Copyright 2024 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- This file implements the scrolling predictor jank metric, as is
-- implemented in cc/metrics/predictor_jank_tracker.cc. See comments in that
-- file to get additional context on how the metric is implemented.
--
-- "Delta" here refers to how much (in pixels) the page offset changed for a
-- given frame due to a scroll.
--
-- For more details please check the following document:
-- http://doc/1Y0u0Tq5eUZff75nYUzQVw6JxmbZAW9m64pJidmnGWsY.

INCLUDE PERFETTO MODULE chrome.scroll_jank.scroll_offsets;

-- The maximum delta value between three consecutive frames, used to determine
-- whether the sequence in the scroll is fast or slow; the sequence speed is
-- used to determine whether the sequence includes any predictor jank.
CREATE PERFETTO FUNCTION _get_slow_scroll_delta_threshold()
RETURNS DOUBLE AS
SELECT 7.0;

-- The threshold for the ratio of the delta of middle frame to tbe deltas of its
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- neighbors in a sequence of three frames, if the sequence is considered
-- "slow".
CREATE PERFETTO FUNCTION _get_slow_scroll_janky_threshold()
RETURNS DOUBLE AS
SELECT 1.4;

-- The threshold for the ratio of the delta of middle frame to tbe deltas of its
-- neighbors in a sequence of three frames, if the sequence is considered
-- "fast".
CREATE PERFETTO FUNCTION _get_fast_scroll_janky_threshold()
RETURNS DOUBLE AS
SELECT 1.2;

-- Determine the acceptable threshold (see _get_slow_scroll_janky_threshold()
-- and _get_fast_scroll_janky_threshold()) based on the maximum delta value
-- between three consecutive frames.
CREATE PERFETTO FUNCTION _get_scroll_jank_threshold(
  d1 DOUBLE,
  d2 DOUBLE,
  d3 DOUBLE
)
RETURNS DOUBLE AS
SELECT
  CASE
    WHEN MAX(MAX($d1, $d2), $d3) <= _get_slow_scroll_delta_threshold()
      THEN _get_slow_scroll_janky_threshold()
    ELSE _get_fast_scroll_janky_threshold()
  END;

-- Calculate the predictor jank of three consecutive frames, if it is above the
-- threshold. Anything below the threshold is not considered jank.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO FUNCTION _get_predictor_jank(
  d1 DOUBLE,
  d2 DOUBLE,
  d3 DOUBLE,
  threshold DOUBLE
)
RETURNS DOUBLE AS
SELECT
  CASE
    WHEN $d2/MAX($d1, $d3) >= $threshold
      THEN $d2/MAX($d1, $d3) - $threshold
    WHEN MIN($d1, $d3)/$d2 >= $threshold
      THEN MIN($d1, $d3)/$d2 - $threshold
    ELSE 0
  END;

-- The scrolling offsets and predictor jank values for the actual (applied)
-- scroll events.
CREATE PERFETTO TABLE chrome_predictor_jank(
  -- An ID that ties all EventLatencies in a particular scroll. (implementation
  -- note: This is the EventLatency TraceId of the GestureScrollbegin).
  scroll_id INT,
  -- An ID for this particular EventLatency regardless of it being presented or
  -- not.
  event_latency_id INT,
  -- An ID that ties this |event_latency_id| with the Trace Id (another
  -- event_latency_id) that it was presented with.
  scroll_update_id INT,
  -- Presentation timestamp.
  present_ts INT,
  -- The delta in raw coordinates between this presented EventLatency and the
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- previous presented frame.
  delta_y INT,
  -- The pixel offset of this presented EventLatency compared to the initial
  -- one.
  relative_offset_y INT,
  -- The delta in raw coordinates of the previous scroll update event.
  prev_delta INT,
  -- The delta in raw coordinates of the subsequent scroll update event.
  next_delta INT,
  -- The jank value based on the discrepancy between scroll predictor
  -- coordinates and the actual deltas between scroll update events.
  predictor_jank DOUBLE,
  -- The threshold used to determine if jank occurred.
  delta_threshold DOUBLE
)
AS
WITH
deltas_and_neighbors AS (
  SELECT
    scroll_id,
    event_latency_id,
    scroll_update_id,
    ts,
    delta_y,
    relative_offset_y,
    LAG(IFNULL(delta_y, 0.0))
      OVER (PARTITION BY scroll_id ORDER BY ts ASC) AS prev_delta,
    LEAD(IFNULL(delta_y, 0.0))
      OVER (PARTITION BY scroll_id ORDER BY ts ASC) AS next_delta
  FROM chrome_presented_scroll_offsets
),
deltas_and_neighbors_with_threshold AS (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  SELECT
    scroll_id,
    event_latency_id,
    scroll_update_id,
    ts,
    delta_y,
    relative_offset_y,
    prev_delta,
    next_delta,
    _get_scroll_jank_threshold(ABS(prev_delta), ABS(delta_y), ABS(next_delta))
      AS delta_threshold
  FROM deltas_and_neighbors
  WHERE delta_y IS NOT NULL
    AND prev_delta IS NOT NULL
    AND next_delta IS NOT NULL
)
SELECT
  scroll_id,
  event_latency_id,
  scroll_update_id,
  ts AS present_ts,
  delta_y,
  relative_offset_y,
  prev_delta,
  next_delta,
  _get_predictor_jank(
    ABS(prev_delta), ABS(delta_y), ABS(next_delta), delta_threshold)
      AS predictor_jank,
  delta_threshold
FROM deltas_and_neighbors_with_threshold;

)_d3l1m1t3r_"
;

const char kScrollJankScrollJankCauseMap[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

INCLUDE PERFETTO MODULE chrome.event_latency_description;

-- Source of truth of the descriptions of EventLatency-based scroll jank causes.
CREATE PERFETTO TABLE chrome_scroll_jank_cause_descriptions (
  -- The name of the EventLatency stage.
  event_latency_stage STRING,
  -- The process where the cause of scroll jank occurred.
  cause_process STRING,
  -- The thread where the cause of scroll jank occurred.
  cause_thread STRING,
  -- A description of the cause of scroll jank.
  cause_description STRING
) AS
WITH cause_descriptions(
  event_latency_stage,
  cause_process,
  cause_thread,
  cause_description)
AS (
VALUES
  ('GenerationToBrowserMain', 'Browser', 'CrBrowserMain',
    'This also corresponds to a matching InputLatency::TouchMove. Key ' ||
    'things to look for: Browser Main thread (CrBrowserMain) is busy, often ' ||
    'running tasks. The true cause can be confirmed by checking which tasks ' ||
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'are being run on CrBrowserMain, or checking any ScopedBlockingCall ' ||
    'slices during this stage from a ThreadPoolForegroundWorker, or ' ||
    'checking if the NetworkService is busy. Common causes may include page' ||
    'navigations (same document and new pages), slow BeginMainFrames, and ' ||
    'Java Choreographer slowdowns.'),
  ('RendererCompositorQueueingDelay', 'Renderer', 'Compositor',
    'The renderer needs to decide to produce a frame in response to a ' ||
    'BeginFrame signal. Sometimes it can not because it is waiting on the ' ||
    'RendererMain thread to do touch targeting or javascript handling or ' ||
    'other such things causing a long queuing delay after it has already ' ||
    'started the scroll (so the TouchStart has been processed).'),
  ('RendererCompositorQueueingDelay', 'GPU', 'VizCompositorThread',
    'Waiting for a BeginFrame to be sent. Key things to look for: check if ' ||
    'a fling occurred before or during the scroll; flings produce a single ' ||
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'input and result in multiple inputs coalescing into a single frame.'),
  ('ReceiveCompositorFrameToStartDraw', 'GPU', 'VizCompositorThread',
    'A delay when the VizCompositor is waiting for the frame, but may be ' ||
    'connected to other processes and threads. Key things to look for: ' ||
    'check the BeginFrame task that finished during this EventLatency. The ' ||
    'VizCompositor holds onto the frame/does not send it on. Alternately ' ||
    'the system may be holding on to the buffer.'),
  ('ReceiveCompositorFrameToStartDraw', 'GPU', 'CrGpuMain',
    'Key things to look for: if the GPU Main thread is busy, and does not ' ||
    'release the buffer; specific causes will be on the GPU Main thread. If ' ||
    'this thread is not busy, the buffer may be held by the system instead.'),
  ('ReceiveCompositorFrameToStartDraw', 'Browser', 'CrBrowserMain',
    'Key things to look for: the toolbar on the Browser may be blocked by ' ||
    'other tasks.'),
  ('BufferReadyToLatch', 'GPU', 'VizCompositorThread',
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'Often a scheduling issue. The frame was submitted, but missed the ' ||
    'latch in the system that was received from the previous frame. The ' ||
    'system only latches a buffer once per frame; when the latch deadline ' ||
    'is missed, the system is forced to wait for another vsync interval to ' ||
    'latch again. Key things to look for: whether the event duration before ' ||
    'BufferReadyToLatch stage of the previous EventLatency is longer or ' ||
    'shorter than the event duration before BufferReadyToLatch in the ' ||
    'current EventLatency. If this duration is longer, then this is a ' ||
    'System problem. If this duration is shorter, then it is a Chrome ' ||
    'problem. The previous frame may have been drawn too quickly, or the ' ||
    'GPU may be delayed.'),
  ('SwapEndToPresentationCompositorFrame', 'GPU', 'VizCompositorThread',
    'May be attributed to a scheduling issue as with BufferReadyToLatch. ' ||
    'The frame was submitted, but missed the latch in the system that was ' ||
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'received from the previous frame. The system only latches a buffer ' ||
    'once per frame; when the latch deadline is missed, the system is ' ||
    'forced to wait for another vsync interval to latch again. Key things ' ||
    'to look for: whether the event duration before BufferReadyToLatch ' ||
    'stage of the previous EventLatency is longer or shorter than the event ' ||
    'duration before BufferReadyToLatch in the current EventLatency. If ' ||
    'this duration is longer, then this is a System problem. If this ' ||
    'duration is shorter, then it is a Chrome problem. The previous frame ' ||
    'may have been drawn too quickly, or the GPU may be delayed.'),
  ('SwapEndToPresentationCompositorFrame', 'GPU', 'CrGpuMain',
    'Key things to look for: whether StartDrawToBufferAvailable is also ' ||
    'present during this EventLatency. If so, then the GPU main thread may ' ||
    'be descheduled or busy. If surfaceflinger is available, check there as ' ||
    'well.'),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ('SwapEndToPresentationCompositorFrame', 'GPU', 'surfaceflinger',
    'Key things to look for: whether StartDrawToBufferAvailable is also ' ||
    'present during this EventLatency. If so, then the VizCompositor has ' ||
    'not received a signal from surfaceflinger to start writing into the ' ||
    'buffer.'))
SELECT
  event_latency_stage,
  cause_process,
  cause_thread,
  cause_description
FROM cause_descriptions;

-- Combined description of scroll jank cause and associated event latency stage.
CREATE PERFETTO VIEW chrome_scroll_jank_causes_with_event_latencies(
  -- The name of the EventLatency stage.
  name STRING,
  -- Description of the EventLatency stage.
  description STRING,
  -- The process name that may cause scroll jank.
  cause_process STRING,
  -- The thread name that may cause scroll jank. The thread will be on the
  -- cause_process.
  cause_thread STRING,
  -- Description of the cause of scroll jank on this process and thread.
  cause_description STRING
) AS
SELECT
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  stages.name,
  stages.description,
  causes.cause_process,
  causes.cause_thread,
  causes.cause_description
FROM chrome_event_latency_stage_descriptions stages
LEFT JOIN chrome_scroll_jank_cause_descriptions causes
    ON causes.event_latency_stage = stages.name;

)_d3l1m1t3r_"
;

const char kScrollJankScrollJankCauseUtils[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

INCLUDE PERFETTO MODULE slices.with_context;

-- Function to retrieve the upid for a surfaceflinger, as these are attributed
-- to the GPU but are recorded on a different data source (and track group).
CREATE PERFETTO FUNCTION _get_process_id_for_surfaceflinger()
-- The process id for surfaceflinger.
RETURNS INT AS
SELECT
 upid
FROM process
WHERE name GLOB '*surfaceflinger*'
LIMIT 1;

-- Map a generic process type to a specific name or substring of a name that
-- can be found in the trace process table.
CREATE PERFETTO TABLE _process_type_to_name (
  -- The process type: one of 'Browser' or 'GPU'.
  process_type STRING,
  -- The process name for Chrome traces.
  process_name STRING,
  -- Substring identifying the process for system traces.
  process_glob STRING
) AS
WITH process_names (
  process_type,
  process_name,
  process_glob
  )
AS (
VALUES
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ('Browser', 'Browser', '*.chrome'),
  ('GPU', 'Gpu', '*.chrome*:privileged_process*'))
SELECT
  process_type,
  process_name,
  process_glob
FROM process_names;

CREATE PERFETTO FUNCTION _get_process_name(
  -- The process type: one of 'Browser' or 'GPU'.
  type STRING
)
-- The process name
RETURNS STRING AS
SELECT
    process_name
FROM _process_type_to_name
WHERE process_type = $type
LIMIT 1;

CREATE PERFETTO FUNCTION _get_process_glob(
  -- The process type: one of 'Browser' or 'GPU'.
  type STRING
)
-- A substring of the process name that can be used in GLOB calculations.
RETURNS STRING AS
SELECT
    process_glob
FROM _process_type_to_name
WHERE process_type = $type
LIMIT 1;

-- TODO(b/309937901): Add chrome instance id for multiple chromes/webviews in a
-- trace, as this may result in  multiple browser and GPU processes.
-- Function to retrieve the chrome process ID for a specific process type. Does
-- not retrieve the Renderer process, as this is determined when the
-- EventLatency is known. See function
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- _get_renderer_upid_for_event_latency below.
CREATE PERFETTO FUNCTION _get_process_id_by_type(
  -- The process type: one of 'Browser' or 'GPU'.
  type STRING
)
RETURNS TABLE (
    -- The process id for the process type.
    upid INT
) AS
SELECT
  upid
FROM process
WHERE name = _get_process_name($type)
  OR name GLOB _get_process_glob($type);

-- Function to retrieve the chrome process ID that a given EventLatency slice
-- occurred on. This is the Renderer process.
CREATE PERFETTO FUNCTION _get_renderer_upid_for_event_latency(
  -- The slice id for an EventLatency slice.
  id INT
)
-- The process id for an EventLatency slice. This is the Renderer process.
RETURNS INT AS
SELECT
  upid
FROM process_slice
WHERE id = $id;

-- Helper function to retrieve all of the upids for a given process, thread,
-- or EventLatency.
CREATE PERFETTO FUNCTION _processes_by_type_for_event_latency(
  -- The process type that the thread is on: one of 'Browser', 'Renderer' or
  -- 'GPU'.
  type STRING,
  -- The name of the thread.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  thread STRING,
  -- The slice id of an EventLatency slice.
  event_latency_id INT)
RETURNS TABLE (
    upid INT
) AS
WITH all_upids AS (
  -- Renderer process upids
  SELECT
    $type AS process,
    $thread AS thread,
    $event_latency_id AS event_latency_id,
    _get_renderer_upid_for_event_latency($event_latency_id) AS upid
  WHERE $type = 'Renderer'
  UNION ALL
  -- surfaceflinger upids
  SELECT
    $type AS process,
    $thread AS thread,
    $event_latency_id AS event_latency_id,
    _get_process_id_for_surfaceflinger() AS upid
  WHERE $type = 'GPU' AND $thread = 'surfaceflinger'
  UNION ALL
  -- Generic Browser and GPU process upids
  SELECT
    $type AS process,
    $thread AS thread,
    $event_latency_id AS event_latency_id,
    upid
  FROM _get_process_id_by_type($type)
  WHERE $type = 'Browser'
    OR ($type = 'GPU' AND $thread != 'surfaceflinger')
)
SELECT
  upid
FROM all_upids;

-- Function to retrieve the thread id of the thread on a particular process if
-- there are any slices during a particular EventLatency slice duration; this
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- upid/thread combination refers to a cause of Scroll Jank.
CREATE PERFETTO FUNCTION chrome_select_scroll_jank_cause_thread(
  -- The slice id of an EventLatency slice.
  event_latency_id INT,
  -- The process type that the thread is on: one of 'Browser', 'Renderer' or
  -- 'GPU'.
  process_type STRING,
  -- The name of the thread.
  thread_name STRING)
RETURNS TABLE (
  -- The utid associated with |thread| on the process with |upid|.
  utid INT
) AS
WITH threads AS (
  SELECT
    utid
  FROM thread
  WHERE upid IN
    (
      SELECT DISTINCT
        upid
      FROM _processes_by_type_for_event_latency(
        $process_type,
        $thread_name,
        $event_latency_id)
    )
    AND name = $thread_name
)
SELECT
 DISTINCT utid
FROM thread_slice
WHERE utid IN
  (
    SELECT
      utid
    FROM threads
  )
  AND ts >= (SELECT ts FROM slice WHERE id = $event_latency_id LIMIT 1)
  AND ts <= (SELECT ts + dur FROM slice WHERE id = $event_latency_id LIMIT 1);

)_d3l1m1t3r_"
;

const char kScrollJankScrollJankIntervals[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

INCLUDE PERFETTO MODULE chrome.chrome_scrolls;
INCLUDE PERFETTO MODULE chrome.scroll_jank.scroll_jank_v3;

-- Selects EventLatency slices that correspond with janks in a scroll. This is
-- based on the V3 version of scroll jank metrics.
CREATE PERFETTO TABLE chrome_janky_event_latencies_v3(
  -- The slice id.
  id INT,
  -- The start timestamp of the slice.
  ts INT,
  -- The duration of the slice.
  dur INT,
  -- The track_id for the slice.
  track_id INT,
  -- The name of the slice (EventLatency).
  name STRING,
  -- The stage of EventLatency that the caused the jank.
  cause_of_jank STRING,
  -- The stage of cause_of_jank that caused the jank.
  sub_cause_of_jank STRING,
  -- How many vsyncs this frame missed its deadline by.
  delayed_frame_count INT,
  -- The start timestamp where frame presentation was delayed.
  frame_jank_ts INT,
  -- The duration in ms of the delay in frame presentation.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  frame_jank_dur INT
) AS
SELECT
  s.id,
  s.ts,
  s.dur,
  s.track_id,
  s.name,
  e.cause_of_jank,
  e.sub_cause_of_jank,
  CAST((e.delay_since_last_frame/e.vsync_interval) - 1 AS INT) AS delayed_frame_count,
  CAST(s.ts + s.dur - ((e.delay_since_last_frame - e.vsync_interval) * 1e6) AS INT) AS frame_jank_ts,
  CAST((e.delay_since_last_frame - e.vsync_interval) * 1e6 AS INT) AS frame_jank_dur
FROM slice s
JOIN chrome_janky_frames e
  ON s.id = e. event_latency_id;

-- Frame presentation interval is the delta between when the frame was supposed
-- to be presented and when it was actually presented.
CREATE PERFETTO VIEW chrome_janky_frame_presentation_intervals(
  -- Unique id.
  id INT,
  -- The start timestamp of the slice.
  ts INT,
  -- The duration of the slice.
  dur INT,
  -- How many vsyncs this frame missed its deadline by.
  delayed_frame_count INT,
  -- The stage of EventLatency that the caused the jank.
  cause_of_jank INT,
  -- The stage of cause_of_jank that caused the jank.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  sub_cause_of_jank INT,
  -- The id of the associated event latency in the slice table.
  event_latency_id INT
) AS
SELECT
  ROW_NUMBER() OVER(ORDER BY frame_jank_ts) AS id,
  frame_jank_ts AS ts,
  frame_jank_dur AS dur,
  delayed_frame_count,
  cause_of_jank,
  sub_cause_of_jank,
  id AS event_latency_id
FROM chrome_janky_event_latencies_v3;

-- Scroll jank frame presentation stats for individual scrolls.
CREATE PERFETTO VIEW chrome_scroll_stats(
  -- Id of the individual scroll.
  scroll_id INT,
  -- The number of frames in the scroll.
  frame_count INT,
  -- The number of missed vsyncs in the scroll.
  missed_vsyncs INT,
  -- The number presented frames in the scroll.
  presented_frame_count INT,
  -- The number of janky frames in the scroll.
  janky_frame_count INT,
  -- The % of frames that janked in the scroll.
  janky_frame_percent FLOAT
) AS
WITH vsyncs AS (
  SELECT
    COUNT() AS presented_vsync_count,
    scroll.id AS scroll_id
  FROM chrome_unique_frame_presentation_ts frame
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  JOIN chrome_scrolls scroll
    ON frame.presentation_timestamp >= scroll.ts
    AND frame.presentation_timestamp <= scroll.ts + scroll.dur
  GROUP BY scroll_id),
missed_vsyncs AS (
  SELECT
    CAST(SUM((delay_since_last_frame / vsync_interval) - 1) AS INT)  AS total_missed_vsyncs,
    scroll_id
  FROM chrome_janky_frames
  GROUP BY scroll_id),
frame_stats AS (
  SELECT
    scroll_id,
    num_frames AS presented_frame_count,
    IFNULL(num_janky_frames, 0) AS janky_frame_count,
    ROUND(IFNULL(scroll_jank_percentage, 0), 2) AS janky_frame_percent
  FROM chrome_frames_per_scroll
)
SELECT
  vsyncs.scroll_id,
  presented_vsync_count + IFNULL(total_missed_vsyncs, 0) AS frame_count,
  total_missed_vsyncs AS missed_vsyncs,
  presented_frame_count,
  janky_frame_count,
  janky_frame_percent
FROM vsyncs
LEFT JOIN missed_vsyncs
  USING (scroll_id)
LEFT JOIN frame_stats
  USING (scroll_id);

-- Defines slices for all of janky scrolling intervals in a trace.
CREATE PERFETTO TABLE chrome_scroll_jank_intervals_v3(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- The unique identifier of the janky interval.
  id INT,
  -- The start timestamp of the janky interval.
  ts INT,
  -- The duration of the janky interval.
  dur INT
) AS
-- Sub-table to retrieve all janky slice timestamps. Ordering calculations are
-- based on timestamps rather than durations.
WITH janky_latencies AS (
  SELECT
    s.frame_jank_ts AS start_ts,
    s.frame_jank_ts + s.frame_jank_dur AS end_ts
  FROM chrome_janky_event_latencies_v3 s),
-- Determine the local maximum timestamp for janks thus far; this will allow
-- us to coalesce all earlier events up to the maximum.
ordered_jank_end_ts AS (
  SELECT
    *,
    MAX(end_ts) OVER (
      ORDER BY start_ts ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
      AS max_end_ts_so_far
  FROM janky_latencies),
-- Determine the local minimum timestamp for janks thus far; this will allow
-- us to coalesce all later events up to the nearest local maximum.
range_starts AS (
  SELECT
    *,
    CASE
      -- This is a two-pass calculation to calculate the first event in the
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      -- group. An event is considered the first event in a group if all events
      -- which started before it also finished the current one started.
      WHEN start_ts <= 1 + LAG(max_end_ts_so_far) OVER (ORDER BY start_ts) THEN 0
      ELSE 1
    END AS range_start
  FROM ordered_jank_end_ts),
-- Assign an id to allow coalescing of individual slices.
range_groups AS (
  SELECT
    *,
    SUM(range_start) OVER (ORDER BY start_ts) AS range_group
  FROM range_starts)
-- Coalesce all slices within an interval.
SELECT
  range_group AS id,
  MIN(start_ts) AS ts,
  MAX(end_ts) - MIN(start_ts) AS dur
FROM range_groups
GROUP BY range_group;

)_d3l1m1t3r_"
;

const char kScrollJankScrollJankV3Cause[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- Finds all slices with a direct parent with the given parent_id.
CREATE PERFETTO FUNCTION _direct_children_slice(
  -- Id of the parent slice.
  parent_id LONG)
RETURNS TABLE(
  -- Alias for `slice.id`.
  id LONG,
  -- Alias for `slice.type`.
  type STRING,
  -- Alias for `slice.ts`.
  ts LONG,
  -- Alias for `slice.dur`.
  dur LONG,
  -- Alias for `slice.category`.
  category LONG,
  -- Alias for `slice.name`.
  name STRING,
  -- Alias for `slice.track_id`.
  track_id LONG,
  -- Alias for `slice.depth`.
  depth LONG,
  -- Alias for `slice.parent_id`.
  parent_id LONG,
  -- Alias for `slice.arg_set_id`.
  arg_set_id LONG,
  -- Alias for `slice.thread_ts`.
  thread_ts LONG,
  -- Alias for `slice.thread_dur`.
  thread_dur LONG
) AS
SELECT
  slice.id,
  slice.type,
  slice.ts,
  slice.dur,
  slice.category,
  slice.name,
  slice.track_id,
  slice.depth,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  slice.parent_id,
  slice.arg_set_id,
  slice.thread_ts,
  slice.thread_dur
FROM slice
WHERE parent_id = $parent_id;

-- Given two slice Ids A and B, find the maximum difference
-- between the durations of it's direct children with matching names
-- for example if slice A has children named (X, Y, Z) with durations of (10, 10, 5)
-- and slice B has children named (X, Y) with durations of (9, 9), the function will return
-- the slice id of the slice named Z that is A's child, as no matching slice named Z was found
-- under B, making 5 - 0 = 5 the maximum delta between both slice's direct children
CREATE PERFETTO FUNCTION chrome_get_v3_jank_cause_id(
  -- The slice id of the parent slice that we want to cause among it's children.
  janky_slice_id LONG,
  -- The slice id of the parent slice that's the reference in comparison to
  -- |janky_slice_id|.
  prev_slice_id LONG
)
-- The slice id of the breakdown that has the maximum duration delta.
RETURNS LONG AS
WITH
  current_breakdowns AS (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    SELECT
      *
    FROM _direct_children_slice($janky_slice_id)
  ),
  prev_breakdowns AS (
    SELECT
      *
    FROM _direct_children_slice($prev_slice_id)
  ),
  joint_breakdowns AS (
    SELECT
      cur.id AS breakdown_id,
      (cur.dur - COALESCE(prev.dur, 0)) AS breakdown_delta
    FROM current_breakdowns cur
    LEFT JOIN prev_breakdowns prev ON
      cur.name = prev.name
  ),
  max_breakdown AS (
    SELECT
      MAX(breakdown_delta) AS breakdown_delta,
      breakdown_id
    FROM joint_breakdowns
  )
  SELECT
    breakdown_id
  FROM max_breakdown;

)_d3l1m1t3r_"
;

const char kScrollJankScrollJankV3[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

INCLUDE PERFETTO MODULE deprecated.v42.common.slices;

-- Hardware info is useful when using sql metrics for analysis
-- in BTP.
INCLUDE PERFETTO MODULE chrome.metadata;
INCLUDE PERFETTO MODULE chrome.scroll_jank.scroll_jank_v3_cause;
INCLUDE PERFETTO MODULE chrome.scroll_jank.utils;

-- Finds the end timestamp for a given slice's descendant with a given name.
-- If there are multiple descendants with a given name, the function will return the
-- first one, so it's most useful when working with a timeline broken down into phases,
-- where each subphase can happen only once.
CREATE PERFETTO FUNCTION _descendant_slice_end(
  -- Id of the parent slice.
  parent_id INT,
  -- Name of the child with the desired end TS.
  child_name STRING
)
-- End timestamp of the child or NULL if it doesn't exist.
RETURNS INT AS
SELECT
  CASE WHEN s.dur
    IS NOT -1 THEN s.ts + s.dur
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    ELSE NULL
  END
FROM descendant_slice($parent_id) s
WHERE s.name = $child_name
LIMIT 1;

-- Given a slice id, returns the name of the slice.
CREATE PERFETTO FUNCTION _slice_name_from_id(
  -- The slice id which we need the name for.
  id LONG
)
-- The name of slice with the given id.
RETURNS STRING AS
SELECT
  name
FROM slice
WHERE $id = id;

-- Grabs all gesture updates with respective scroll ids and start/end
-- timestamps, regardless of being presented.
CREATE PERFETTO TABLE chrome_gesture_scroll_updates(
  -- The start timestamp of the scroll.
  ts INT,
  -- The duration of the scroll.
  dur INT,
  -- Slice id for the scroll.
  id INT,
  -- The id of the scroll update event.
  scroll_update_id INT,
  -- The id of the scroll.
  scroll_id INT,
  -- Whether this input event was presented.
  is_presented BOOL,
  -- Frame presentation timestamp aka the timestamp of the
  -- SwapEndToPresentationCompositorFrame substage.
  -- TODO(b/341047059): temporarily use LatchToSwapEnd as a workaround if
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- SwapEndToPresentationCompositorFrame is missing due to b/247542163.
  presentation_timestamp INT,
  -- EventLatency event type.
  event_type INT
) AS
SELECT
  slice.ts,
  slice.dur,
  slice.id,
  EXTRACT_arg(arg_set_id, 'event_latency.event_latency_id') AS scroll_update_id,
  chrome_get_most_recent_scroll_begin_id(slice.ts) AS scroll_id,
  has_descendant_slice_with_name(slice.id, 'SubmitCompositorFrameToPresentationCompositorFrame')
  AS is_presented,
  CASE WHEN has_descendant_slice_with_name(slice.id, "SwapEndToPresentationCompositorFrame")
    THEN _descendant_slice_end(slice.id, "SwapEndToPresentationCompositorFrame")
    ELSE _descendant_slice_end(slice.id, "LatchToSwapEnd")
  END
  AS presentation_timestamp,
  EXTRACT_ARG(arg_set_id, 'event_latency.event_type') AS event_type
FROM slice JOIN args USING(arg_set_id)
WHERE name = "EventLatency"
AND (
  args.string_value GLOB '*GESTURE_SCROLL_UPDATE'
  -- Pinches are only relevant if the frame was presented.
  OR (args.string_value GLOB '*GESTURE_PINCH_UPDATE'
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    AND has_descendant_slice_with_name(
      slice.id,
      'SubmitCompositorFrameToPresentationCompositorFrame')
  )
);

CREATE PERFETTO TABLE _presented_gesture_scrolls AS
SELECT
  id,
  ts,
  dur,
  scroll_update_id,
  scroll_id,
  presentation_timestamp,
  event_type
FROM chrome_gesture_scroll_updates
WHERE is_presented = true
ORDER BY ts ASC;

-- Scroll updates, corresponding to all input events that were converted to a
-- presented scroll update.
CREATE PERFETTO TABLE chrome_presented_gesture_scrolls(
  -- Minimum slice id for input presented in this frame, the non-presented input.
  id INT,
  -- The start timestamp for producing the frame.
  ts INT,
  -- The duration between producing and presenting the frame.
  dur INT,
  -- The timestamp of the last input that arrived and got presented in the frame.
  last_presented_input_ts INT,
  -- The id of the scroll update event, a unique identifier to the gesture.
  scroll_update_id INT,
  -- The id of the ongoing scroll.
  scroll_id INT,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Frame presentation timestamp.
  presentation_timestamp INT,
  -- EventLatency event type.
  event_type INT
) AS
WITH
scroll_updates_with_presentation_info as MATERIALIZED (
  SELECT
    id,
    ts,
    -- For each scroll update, find the latest presented update which
    -- started before it.
    (
      SELECT id
      FROM _presented_gesture_scrolls _presented
      WHERE _presented.ts <= scroll_update.ts
      ORDER BY ts DESC
      LIMIT 1
     ) as presented_to_scroll_update_slice_id
  FROM chrome_gesture_scroll_updates scroll_update
  ORDER BY presented_to_scroll_update_slice_id, ts
)
SELECT
  id,
  ts,
  dur,
  -- Find the latest input that was presented in this scroll update.
  (
    SELECT presentation_info.ts
    FROM scroll_updates_with_presentation_info presentation_info
    WHERE
      presentation_info.presented_to_scroll_update_slice_id =
        _presented_gesture_scrolls.id
    ORDER BY ts DESC
    LIMIT 1
  ) as last_presented_input_ts,
  scroll_update_id,
  scroll_id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  presentation_timestamp,
  event_type
FROM _presented_gesture_scrolls;

-- Associate every trace_id with it's perceived delta_y on the screen after
-- prediction.
CREATE PERFETTO TABLE chrome_scroll_updates_with_deltas(
  -- The id of the scroll update event.
  scroll_update_id INT,
  -- The perceived delta_y on the screen post prediction.
  delta_y INT
) AS
SELECT
  EXTRACT_ARG(arg_set_id, 'scroll_deltas.trace_id') AS scroll_update_id,
  EXTRACT_ARG(arg_set_id, 'scroll_deltas.provided_to_compositor_delta_y') AS delta_y
FROM slice
WHERE name = "InputHandlerProxy::HandleGestureScrollUpdate_Result";

-- Obtain the subset of input events that were fully presented.
CREATE PERFETTO TABLE chrome_full_frame_view(
  -- ID of the frame.
  id INT,
  -- Start timestamp of the frame.
  ts INT,
  -- The timestamp of the last presented input.
  last_presented_input_ts INT,
  -- ID of the associated scroll.
  scroll_id INT,
  -- ID of the associated scroll update.
  scroll_update_id INT,
  -- ID of the associated EventLatency.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  event_latency_id INT,
  -- Duration of the associated EventLatency.
  dur INT,
  -- Frame presentation timestamp.
  presentation_timestamp INT
) AS
SELECT
  frames.id,
  frames.ts,
  frames.last_presented_input_ts,
  frames.scroll_id,
  frames.scroll_update_id,
  frames.id AS event_latency_id,
  frames.dur,
  frames.presentation_timestamp
FROM chrome_presented_gesture_scrolls frames
WHERE frames.event_type in (
          'GESTURE_SCROLL_UPDATE',
          'FIRST_GESTURE_SCROLL_UPDATE',
          'INERTIAL_GESTURE_SCROLL_UPDATE',
          'GESTURE_PINCH_UPDATE')
AND frames.presentation_timestamp IS NOT NULL;

-- Join deltas with EventLatency data.
CREATE PERFETTO TABLE chrome_full_frame_delta_view(
  -- ID of the frame.
  id INT,
  -- Start timestamp of the frame.
  ts INT,
  -- ID of the associated scroll.
  scroll_id INT,
  -- ID of the associated scroll update.
  scroll_update_id INT,
  -- The timestamp of the last presented input.
  last_presented_input_ts INT,
  -- The perceived delta_y on the screen post prediction.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  delta_y INT,
  -- ID of the associated EventLatency.
  event_latency_id INT,
  -- Duration of the associated EventLatency.
  dur INT,
  -- Frame presentation timestamp.
  presentation_timestamp INT
) AS
SELECT
  frames.id,
  frames.ts,
  frames.scroll_id,
  frames.scroll_update_id,
  frames.last_presented_input_ts,
  deltas.delta_y,
  frames.event_latency_id,
  frames.dur,
  frames.presentation_timestamp
FROM chrome_full_frame_view frames
LEFT JOIN chrome_scroll_updates_with_deltas deltas
  ON deltas.scroll_update_id = frames.scroll_update_id;

-- Group all gestures presented at the same timestamp together in
-- a single row.
CREATE PERFETTO VIEW chrome_merged_frame_view(
  -- ID of the frame.
  id INT,
  -- The timestamp of the last presented input.
  max_start_ts INT,
  -- The earliest frame start timestamp.
  min_start_ts INT,
  -- ID of the associated scroll.
  scroll_id INT,
  -- ID of the associated scroll update.
  scroll_update_id INT,
  -- All scroll updates associated with the frame presentation timestamp.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  encapsulated_scroll_ids INT,
  -- Sum of all perceived delta_y values at the frame presentation timestamp.
  total_delta INT,
  -- Lists all of the perceived delta_y values at the frame presentation timestamp.
  segregated_delta_y INT,
  -- ID of the associated EventLatency.
  event_latency_id INT,
  -- Maximum duration of the associated EventLatency.
  dur INT,
  -- Frame presentation timestamp.
  presentation_timestamp INT
) AS
SELECT
  id,
  MAX(last_presented_input_ts) AS max_start_ts,
  MIN(ts) AS min_start_ts,
  scroll_id,
  scroll_update_id,
  GROUP_CONCAT(scroll_update_id,',') AS encapsulated_scroll_ids,
  SUM(delta_y) AS total_delta,
  GROUP_CONCAT(delta_y, ',') AS segregated_delta_y,
  event_latency_id,
  MAX(dur) AS dur,
  presentation_timestamp
FROM chrome_full_frame_delta_view
GROUP BY presentation_timestamp
ORDER BY presentation_timestamp;

-- View contains all chrome presented frames during gesture updates
-- while calculating delay since last presented which usually should
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- equal to |VSYNC_INTERVAL| if no jank is present.
CREATE PERFETTO VIEW chrome_frame_info_with_delay(
  -- gesture scroll slice id.
  id INT,
  -- OS timestamp of the last touch move arrival within a frame.
  max_start_ts INT,
  -- OS timestamp of the first touch move arrival within a frame.
  min_start_ts INT,
  -- The scroll which the touch belongs to.
  scroll_id INT,
  -- ID of the associated scroll update.
  scroll_update_id INT,
  -- Trace ids of all frames presented in at this vsync.
  encapsulated_scroll_ids INT,
  -- Summation of all delta_y of all gesture scrolls in this frame.
  total_delta INT,
  -- All delta y of all gesture scrolls comma separated, summing those gives |total_delta|.
  segregated_delta_y INT,
  -- Event latency id of the presented frame.
  event_latency_id INT,
  -- Duration of the EventLatency.
  dur INT,
  -- Timestamp at which the frame was shown on the screen.
  presentation_timestamp INT,
  -- Time elapsed since the previous frame was presented, usually equals |VSYNC|
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- if no frame drops happened.
  delay_since_last_frame INT,
  -- Difference in OS timestamps of inputs in the current and the previous frame.
  delay_since_last_input INT,
  -- The event latency id that will be used as a reference to determine the
  -- jank cause.
  prev_event_latency_id INT
) AS
SELECT
  *,
  (presentation_timestamp -
  LAG(presentation_timestamp, 1, presentation_timestamp)
  OVER (PARTITION BY scroll_id ORDER BY presentation_timestamp)) / 1e6 AS delay_since_last_frame,
  (min_start_ts -
  LAG(max_start_ts, 1, min_start_ts)
  OVER (PARTITION BY scroll_id ORDER BY min_start_ts)) / 1e6 AS delay_since_last_input,
  LAG(event_latency_id, 1, -1) OVER (PARTITION BY scroll_id ORDER BY min_start_ts) AS prev_event_latency_id
FROM chrome_merged_frame_view;

-- Calculate |VSYNC_INTERVAL| as the lowest vsync seen in the trace or the
-- minimum delay between frames larger than zero.
--
-- TODO(~M130): Remove the lowest vsync since we should always have vsync_interval_ms.
CREATE PERFETTO VIEW chrome_vsyncs(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- The lowest delay between frames larger than zero.
  vsync_interval INT
) AS
WITH
  trace_vsyncs AS (
    SELECT EXTRACT_ARG(slice.arg_set_id, 'event_latency.vsync_interval_ms') AS vsync_interval_ms
    FROM
      slice JOIN chrome_frame_info_with_delay
        ON chrome_frame_info_with_delay.event_latency_id = slice.id
    WHERE EXTRACT_ARG(slice.arg_set_id, 'event_latency.vsync_interval_ms') > 0
  )
SELECT
  COALESCE(
    (SELECT MIN(vsync_interval_ms) FROM trace_vsyncs),
    MIN(delay_since_last_frame)) AS vsync_interval
FROM chrome_frame_info_with_delay
WHERE delay_since_last_frame > 0;

-- Filter the frame view only to frames that had missed vsyncs.
CREATE PERFETTO VIEW chrome_janky_frames_no_cause(
  -- Time elapsed since the previous frame was presented, will be more than |VSYNC| in this view.
  delay_since_last_frame INT,
  -- Event latency id of the presented frame.
  event_latency_id INT,
  -- Vsync interval at the time of recording the trace.
  vsync_interval INT,
  -- Device brand and model.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  hardware_class STRING,
  -- The scroll corresponding to this frame.
  scroll_id INT,
  -- The event latency id that will be used as a reference to determine the jank cause.
  prev_event_latency_id INT
) AS
SELECT
  delay_since_last_frame,
  event_latency_id,
  (SELECT vsync_interval FROM chrome_vsyncs) AS vsync_interval,
  chrome_hardware_class() AS hardware_class,
  scroll_id,
  prev_event_latency_id
FROM chrome_frame_info_with_delay
WHERE delay_since_last_frame > (select vsync_interval + vsync_interval / 2 from chrome_vsyncs)
      AND delay_since_last_input < (select vsync_interval + vsync_interval / 2 from chrome_vsyncs);

-- Janky frame information including the jank cause.
CREATE PERFETTO VIEW chrome_janky_frames_no_subcause(
  -- Time elapsed since the previous frame was presented, will be more than |VSYNC| in this view.
  delay_since_last_frame INT,
  -- Event latency id of the presented frame.
  event_latency_id INT,
  -- Vsync interval at the time of recording the trace.
  vsync_interval INT,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Device brand and model.
  hardware_class STRING,
  -- The scroll corresponding to this frame.
  scroll_id INT,
  -- The event latency id that will be used as a reference to determine the jank cause.
  prev_event_latency_id INT,
  -- Id of the slice corresponding to the offending stage.
  cause_id INT
) AS
SELECT
  *,
  chrome_get_v3_jank_cause_id(event_latency_id, prev_event_latency_id) AS cause_id
FROM chrome_janky_frames_no_cause;

-- Finds all causes of jank for all janky frames, and a cause of sub jank
-- if the cause of jank was GPU related.
CREATE PERFETTO VIEW chrome_janky_frames(
  -- The reason the Vsync was missed.
  cause_of_jank INT,
  -- Further breakdown if the root cause was GPU related.
  sub_cause_of_jank INT,
  -- Time elapsed since the previous frame was presented, will be more than |VSYNC| in this view.
  delay_since_last_frame INT,
  -- Event latency id of the presented frame.
  event_latency_id INT,
  -- Vsync interval at the time of recording the trace.
  vsync_interval INT,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Device brand and model.
  hardware_class STRING,
  -- The scroll corresponding to this frame.
  scroll_id INT
) AS
SELECT
  _slice_name_from_id(cause_id) AS cause_of_jank,
  _slice_name_from_id(
    -- Getting sub-cause
    chrome_get_v3_jank_cause_id(
      -- Here the cause itself is the parent.
      cause_id,
      -- Get the previous cause id as a child to the previous |EventLatency|.
     (SELECT
      id
      FROM slice
      WHERE name = _slice_name_from_id(cause_id)
        AND parent_id = prev_event_latency_id)
    )) AS sub_cause_of_jank,
  delay_since_last_frame,
  event_latency_id,
  vsync_interval,
  hardware_class,
  scroll_id
FROM chrome_janky_frames_no_subcause;

-- Counting all unique frame presentation timestamps.
CREATE PERFETTO VIEW chrome_unique_frame_presentation_ts(
  -- The unique frame presentation timestamp.
  presentation_timestamp INT
) AS
SELECT DISTINCT
presentation_timestamp
FROM chrome_presented_gesture_scrolls;

-- Dividing missed frames over total frames to get janky frame percentage.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- This represents the v3 scroll jank metrics.
-- Reflects Event.Jank.DelayedFramesPercentage UMA metric.
CREATE PERFETTO VIEW chrome_janky_frames_percentage(
  -- The percent of missed frames relative to total frames - aka the percent of janky frames.
  delayed_frame_percentage FLOAT
) AS
SELECT
(SELECT
  COUNT()
 FROM chrome_janky_frames) * 1.0
/ (SELECT
    COUNT()
  FROM chrome_unique_frame_presentation_ts) * 100 AS delayed_frame_percentage;

-- Number of frames and janky frames per scroll.
CREATE PERFETTO VIEW chrome_frames_per_scroll(
  -- The ID of the scroll.
  scroll_id INT,
  -- The number of frames in the scroll.
  num_frames INT,
  -- The number of delayed/janky frames.
  num_janky_frames INT,
  -- The percentage of janky frames relative to total frames.
  scroll_jank_percentage INT
) AS
WITH
  frames AS (
    SELECT scroll_id, COUNT(*) AS num_frames
    FROM
      chrome_frame_info_with_delay
    GROUP BY scroll_id
  ),
  janky_frames AS (
    SELECT scroll_id, COUNT(*) AS num_janky_frames
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    FROM
      chrome_janky_frames
    GROUP BY scroll_id
  )
SELECT
  frames.scroll_id AS scroll_id,
  frames.num_frames AS num_frames,
  janky_frames.num_janky_frames AS num_janky_frames,
  100.0 * janky_frames.num_janky_frames / frames.num_frames
    AS scroll_jank_percentage
FROM frames
LEFT JOIN janky_frames
  ON frames.scroll_id = janky_frames.scroll_id;

-- Scroll jank causes per scroll.
CREATE PERFETTO VIEW chrome_causes_per_scroll(
  -- The ID of the scroll.
  scroll_id INT,
  -- The maximum time a frame was delayed after the presentation of the previous
  -- frame.
  max_delay_since_last_frame INT,
  -- The expected vsync interval.
  vsync_interval INT,
  -- A proto amalgamation of each scroll jank cause including cause name, sub
  -- cause and the duration of the delay since the previous frame was presented.
  scroll_jank_causes BYTES
) AS
SELECT
  scroll_id,
  MAX(1.0 * delay_since_last_frame / vsync_interval)
    AS max_delay_since_last_frame,
  -- MAX does not matter, since `vsync_interval` is the computed as the
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- same value for a single trace.
  MAX(vsync_interval) AS vsync_interval,
  RepeatedField(
    ChromeScrollJankV3_Scroll_ScrollJankCause(
      'cause',
      cause_of_jank,
      'sub_cause',
      sub_cause_of_jank,
      'delay_since_last_frame',
      1.0 * delay_since_last_frame / vsync_interval))
    AS scroll_jank_causes
FROM
  chrome_janky_frames
GROUP BY scroll_id;
)_d3l1m1t3r_"
;

const char kScrollJankScrollOffsets[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- This file creates two public views:
--     - chrome_scroll_input_offsets and
--     - chrome_presented_scroll_offsets
--
-- These views store the pixel deltas and offsets for (respectively) all chrome
-- scroll inputs (coalesced and not coalesced), and for chrome presented frames
-- (not coalesced), along with the associated timestamp, and id.
--
-- Raw deltas are recorded as changes in pixel positions along the y-axis of a
-- screen, and are scaled to the viewport size. The corresponding trace event
-- for this is TranslateAndScaleWebInputEvent. These are the deltas for all
-- chrome scroll inputs.
--
-- For presented frames, the delta is calculated from the visual offset,
-- recorded once the input has been processed, in the
-- InputHandlerProxy::HandleGestureScrollUpdate_Result event. These values are
-- also scaled to the screen size.
--
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- Offsets are calculated by summing all of the deltas, ordered by timestamp.
-- For a given input/frame, the offset is the sum of its corresponding delta and
-- all previous deltas.
--
--
-- All values required for calculating deltas and offsets are recorded at
-- various stages of input processing, and are unified by a single
-- scroll_update_id value, recorded as scroll_deltas.trace_id in each event.

INCLUDE PERFETTO MODULE chrome.chrome_scrolls;
INCLUDE PERFETTO MODULE chrome.scroll_jank.scroll_jank_v3;

-- All (coalesced and non-coalesced) vertical scrolling deltas and their
-- associated scroll ids. Delta values are recorded after being scaled to the
-- device's screen size in the TranslateAndScaleWebInputEvent trace event. In
-- this trace event, the deltas recorded represent the true (read "original")
-- values that the Browser receives from Android, and the only processing is
-- scaling and translation.
CREATE PERFETTO TABLE _translate_and_scale_scroll_deltas AS
SELECT
  EXTRACT_ARG(arg_set_id, 'scroll_deltas.trace_id') AS scroll_update_id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  EXTRACT_ARG(arg_set_id, 'scroll_deltas.original_delta_y') AS delta_y
FROM slice
WHERE slice.name = 'TranslateAndScaleWebInputEvent';

-- Associate the gesture scroll update OS timestamp with the delta.
CREATE PERFETTO TABLE _scroll_deltas_with_timestamp AS
SELECT
  slice.id AS event_latency_id,
  slice.ts AS input_ts,
  data.scroll_update_id,
  data.delta_y
FROM _translate_and_scale_scroll_deltas data
  JOIN slice ON slice.name = 'EventLatency'
    AND data.scroll_update_id = EXTRACT_ARG(arg_set_id,
        'event_latency.event_latency_id');

-- Associate the scroll update/delta with the correct scroll.
CREATE PERFETTO TABLE _scroll_deltas_with_scroll_id AS
SELECT
  scrolls.id AS scroll_id,
  deltas.event_latency_id,
  deltas.input_ts,
  deltas.scroll_update_id,
  deltas.delta_y
FROM _scroll_deltas_with_timestamp deltas
  LEFT JOIN chrome_scrolls scrolls
    ON deltas.input_ts >= scrolls.ts
      AND deltas.input_ts <= scrolls.ts + scrolls.dur;

-- Associate the presentation timestamp/deltas with the user deltas.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO TABLE _scroll_deltas_with_delays AS
SELECT
  deltas.scroll_id,
  delay.total_delta,
  deltas.scroll_update_id,
  deltas.event_latency_id,
  delay.presentation_timestamp AS presentation_timestamp,
  deltas.input_ts,
  deltas.delta_y
FROM _scroll_deltas_with_scroll_id AS deltas
  LEFT JOIN chrome_frame_info_with_delay AS delay USING(scroll_update_id);

-- The raw coordinates and pixel offsets for all input events which were part of
-- a scroll.
CREATE PERFETTO TABLE chrome_scroll_input_offsets(
  -- An ID that ties all EventLatencies in a particular scroll. (implementation
  -- note: This is the EventLatency TraceId of the GestureScrollbegin).
  scroll_id INT,
  -- An ID for this particular EventLatency regardless of it being presented or
  -- not.
  event_latency_id INT,
  -- An ID that ties this |event_latency_id| with the Trace Id (another
  -- event_latency_id) that it was presented with.
  scroll_update_id INT,
  -- Timestamp the of the scroll input event.
  ts INT,
  -- The delta in raw coordinates between this scroll update event and the
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- previous.
  delta_y INT,
  -- The pixel offset of this scroll update event compared to the initial one.
  relative_offset_y INT
) AS
SELECT
  scroll_id,
  event_latency_id,
  scroll_update_id,
  input_ts AS ts,
  delta_y,
  SUM(IFNULL(delta_y, 0)) OVER ( PARTITION BY scroll_id
    ORDER BY scroll_update_id, input_ts
    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS relative_offset_y
FROM _scroll_deltas_with_delays;

-- The scrolling offsets for the actual (applied) scroll events. These are not
-- necessarily inclusive of all user scroll events, rather those scroll events
-- that are actually processed.
CREATE PERFETTO TABLE chrome_presented_scroll_offsets(
  -- An ID that ties all EventLatencies in a particular scroll. (implementation
  -- note: This is the EventLatency TraceId of the GestureScrollbegin).
  scroll_id INT,
  -- An ID for this particular EventLatency regardless of it being presented or
  -- not.
  event_latency_id INT,
  -- An ID that ties this |event_latency_id| with the Trace Id (another
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- event_latency_id) that it was presented with.
  scroll_update_id INT,
  -- Presentation timestamp.
  ts INT,
  -- The delta in raw coordinates between this scroll update event and the
  -- previous.
  delta_y INT,
  -- The pixel offset of this scroll update event compared to the initial one.
  relative_offset_y INT
) AS
SELECT
  scroll_id,
  event_latency_id,
  scroll_update_id,
  presentation_timestamp AS ts,
  total_delta AS delta_y,
  SUM(IFNULL(total_delta, 0)) OVER ( PARTITION BY scroll_id
    ORDER BY scroll_update_id, presentation_timestamp
    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS relative_offset_y
FROM _scroll_deltas_with_delays
WHERE presentation_timestamp IS NOT NULL
;
)_d3l1m1t3r_"
;

const char kScrollJankUtils[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.
--
-- Those are helper functions used in computing jank metrics

-- This function takes timestamps of two consecutive frames and determines if
-- its janky by a delay of more than 0.5 of a frame  in order to make sure that
-- the comparison does not filter out ratios that are precisely 0.5, which can
-- fall a little above or below exact value due to inherent inaccuracy of operations with
-- floating-point numbers. Value 1e-9 have been chosen as follows: the ratio has
-- nanoseconds in numerator and VSync interval in denominator. Assuming refresh
-- rate more than 1 FPS (and therefore VSync interval less than a second), this
-- ratio should increase with increments more than minimal value in numerator
-- (1ns) divided by maximum value in denominator, giving 1e-9.

-- Function : function takes scroll ids of frames to verify it's from
-- the same scroll, and makes sure the frame ts occurred within the scroll
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- timestamp of the neighbour and computes whether the frame was janky or not.
CREATE PERFETTO FUNCTION _is_janky_frame(cur_gesture_id LONG,
                                      neighbour_gesture_id LONG,
                                      neighbour_ts LONG,
                                      cur_gesture_begin_ts LONG,
                                      cur_gesture_end_ts LONG,
                                      cur_frame_exact FLOAT,
                                      neighbour_frame_exact FLOAT)
-- Returns true if the frame was janky, false otherwise
RETURNS BOOL AS
SELECT
    CASE WHEN
      $cur_gesture_id != $neighbour_gesture_id OR
      $neighbour_ts IS NULL OR
      $neighbour_ts < $cur_gesture_begin_ts OR
      $neighbour_ts > $cur_gesture_end_ts THEN
        FALSE ELSE
        $cur_frame_exact > $neighbour_frame_exact + 0.5 + 1e-9
    END;

-- Function : function takes the cur_frame_exact, prev_frame_exact and
-- next_frame_exact and returns the value of the jank budget of the current
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- frame.
--
-- jank_budget is the minimum amount of frames/time we need to reduce the frame
-- duration by for it to be no longer considered janky.
--
-- Returns the jank budget in percentage (i.e. 0.75) of vsync interval
-- percentage.
CREATE PERFETTO FUNCTION _jank_budget(
  cur_frame_exact FLOAT,
  prev_frame_exact FLOAT,
  next_frame_exact FLOAT
)
RETURNS FLOAT AS
-- We determine the difference between the frame count of the current frame
-- and its consecutive frames by subtracting with the frame_exact values. We
-- null check for cases when the neighbor frame count can be null for the
-- first and last frames.
--
-- Since a frame is considered janky, if the difference in the frame count
-- with its adjacent frame is greater than 0.5 (half a vsync) which means we
-- need to reduce the frame count by a value less than 0.5 of maximum
-- difference in frame count for it to be no longer janky. We subtract 1e-9 as
-- we want to output minimum amount required.
SELECT
  COALESCE(
    -- Could be null if next or previous is null.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    MAX(
      ($cur_frame_exact - $prev_frame_exact),
      ($cur_frame_exact - $next_frame_exact)
    ),
    -- If one of them is null output the first non-null.
    ($cur_frame_exact - $prev_frame_exact),
    ($cur_frame_exact - $next_frame_exact)
    -- Otherwise return null
  ) - 0.5 - 1e-9;

-- Extract mojo information for the long-task-tracking scenario for specific
-- names. For example, LongTaskTracker slices may have associated IPC
-- metadata, or InterestingTask slices for input may have associated IPC to
-- determine whether the task is fling/etc.
CREATE PERFETTO FUNCTION chrome_select_long_task_slices(
  -- The name of slice.
  name STRING)
RETURNS TABLE(
  -- Name of the interface of the IPC call.
  interface_name STRING,
  -- Hash of the IPC call.
  ipc_hash INT,
  -- Message type (e.g. reply).
  message_type STRING,
  -- The slice id.
  id INT
) AS
SELECT
  EXTRACT_ARG(s.arg_set_id, "chrome_mojo_event_info.mojo_interface_tag") AS interface_name,
  EXTRACT_ARG(arg_set_id, "chrome_mojo_event_info.ipc_hash") AS ipc_hash,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  CASE
    WHEN EXTRACT_ARG(arg_set_id, "chrome_mojo_event_info.is_reply") THEN "reply"
    ELSE "message"
  END AS message_type,
  s.id
FROM slice s
WHERE
  category GLOB "*scheduler.long_tasks*"
  AND name = $name;

-- Extracts scroll id for the EventLatency slice at `ts`.
CREATE PERFETTO FUNCTION chrome_get_most_recent_scroll_begin_id(
  -- Timestamp of the EventLatency slice to get the scroll id for.
  ts INT)
-- The event_latency_id of the EventLatency slice with the type
-- GESTURE_SCROLL_BEGIN that is the closest to `ts`.
RETURNS INT AS
SELECT EXTRACT_ARG(arg_set_id, "event_latency.event_latency_id")
FROM slice
WHERE name="EventLatency"
AND EXTRACT_ARG(arg_set_id, "event_latency.event_type") = "GESTURE_SCROLL_BEGIN"
AND ts<=$ts
ORDER BY ts DESC
LIMIT 1;

)_d3l1m1t3r_"
;

struct FileToSql {
  const char* path;
  const char* sql;
};

const FileToSql kFileToSql[] = {
  {"chrome_scrolls.sql", kChromeScrolls},

  {"cpu_powerups.sql", kCpuPowerups},

  {"event_latency_description.sql", kEventLatencyDescription},

  {"histograms.sql", kHistograms},

  {"interactions.sql", kInteractions},

  {"metadata.sql", kMetadata},

  {"page_loads.sql", kPageLoads},

  {"speedometer.sql", kSpeedometer},

  {"speedometer_2_1.sql", kSpeedometer21},

  {"speedometer_3.sql", kSpeedometer3},

  {"startups.sql", kStartups},

  {"tasks.sql", kTasks},

  {"vsync_intervals.sql", kVsyncIntervals},

  {"web_content_interactions.sql", kWebContentInteractions},

  {"scroll_jank/predictor_jank.sql", kScrollJankPredictorJank},

  {"scroll_jank/scroll_jank_cause_map.sql", kScrollJankScrollJankCauseMap},

  {"scroll_jank/scroll_jank_cause_utils.sql", kScrollJankScrollJankCauseUtils},

  {"scroll_jank/scroll_jank_intervals.sql", kScrollJankScrollJankIntervals},

  {"scroll_jank/scroll_jank_v3_cause.sql", kScrollJankScrollJankV3Cause},

  {"scroll_jank/scroll_jank_v3.sql", kScrollJankScrollJankV3},

  {"scroll_jank/scroll_offsets.sql", kScrollJankScrollOffsets},

  {"scroll_jank/utils.sql", kScrollJankUtils},
};

}  // namespace chrome_stdlib
}  // namespace trace_processor
}  // namespace perfetto
