/*
 * Copyright (C) 2023 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 *******************************************************************************
 * AUTOGENERATED BY tools/gen_amalgamated_sql.py - DO NOT EDIT
 *******************************************************************************
 */

 #include <string.h>

namespace perfetto {
namespace trace_processor {
namespace sql_metrics {

const char kTraceMetadata[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- Expose all clock snapshots as instant events.
DROP VIEW IF EXISTS trace_metadata_event;
CREATE PERFETTO VIEW trace_metadata_event AS
SELECT
  'slice' AS track_type,
  'Clock Snapshots' AS track_name,
  ts,
  0 AS dur,
  'Snapshot' AS slice_name
FROM clock_snapshot
GROUP BY ts;

DROP VIEW IF EXISTS trace_metadata_output;
CREATE PERFETTO VIEW trace_metadata_output AS
SELECT TraceMetadata(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  'trace_duration_ns', CAST(trace_dur() AS INT),
  'trace_uuid', (SELECT str_value FROM metadata WHERE name = 'trace_uuid'),
  'android_build_fingerprint', (
    SELECT str_value FROM metadata WHERE name = 'android_build_fingerprint'
  ),
  'statsd_triggering_subscription_id', (
    SELECT int_value FROM metadata
    WHERE name = 'statsd_triggering_subscription_id'
  ),
  'unique_session_name', (
    SELECT str_value FROM metadata
    WHERE name = 'unique_session_name'
  ),
  'trace_size_bytes', (
    SELECT int_value FROM metadata
    WHERE name = 'trace_size_bytes'
  ),
  'trace_trigger', (
    SELECT RepeatedField(slice.name)
    FROM track JOIN slice ON track.id = slice.track_id
    WHERE track.name = 'Trace Triggers'
  ),
  'trace_config_pbtxt', (
    SELECT str_value FROM metadata
    WHERE name = 'trace_config_pbtxt'
  ),
  'sched_duration_ns', (
    SELECT MAX(ts) - MIN(ts) FROM sched
  ),
  'tracing_started_ns', (
    SELECT int_value FROM metadata
    WHERE name='tracing_started_ns'
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  )
);

)_d3l1m1t3r_"
;

const char kTraceStats[] = R"_d3l1m1t3r_(--
-- Copyright 2021 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

DROP VIEW IF EXISTS trace_stats_output;
CREATE PERFETTO VIEW trace_stats_output AS
SELECT TraceAnalysisStats(
  'stat', (
    SELECT RepeatedField(TraceAnalysisStats_Stat(
      'name', name,
      'idx', idx,
      'count', value,
      'source', CASE source
        WHEN 'trace' THEN 'SOURCE_TRACE'
        WHEN 'analysis' THEN 'SOURCE_ANALYSIS'
        ELSE 'SOURCE_UNKNOWN'
      END,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      'severity', CASE severity
        WHEN 'info' THEN 'SEVERITY_INFO'
        WHEN 'data_loss' THEN 'SEVERITY_DATA_LOSS'
        WHEN 'error' THEN 'SEVERITY_ERROR'
        ELSE 'SEVERITY_UNKNOWN'
      END
      ))
    FROM stats ORDER BY name ASC
  )
);

)_d3l1m1t3r_"
;

const char kAndroidAdServicesMetric[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

CREATE OR REPLACE PERFETTO FUNCTION GET_LATENCY(tag STRING)
RETURNS DOUBLE AS
SELECT dur/1e6 FROM slices WHERE name = $tag ORDER BY dur DESC LIMIT 1;

DROP VIEW IF EXISTS ad_services_metric_output;

CREATE PERFETTO VIEW ad_services_metric_output
AS
SELECT
  AdServicesMetric(
    'ui_metric',
    (
      SELECT
        RepeatedField(
          AdServicesUiMetric(
            'main_activity_creation_latency',
)_d3l1m1t3r_"
R"_d3l1m1t3r_(            (GET_LATENCY('AdServicesSettingsMainActivity#OnCreate')),
            'consent_manager_read_latency',
            (GET_LATENCY('ConsentManager#ReadOperation')),
            'consent_manager_write_latency',
            (GET_LATENCY('ConsentManager#WriteOperation')),
            'consent_manager_initialization_latency',
            (GET_LATENCY('ConsentManager#Initialization'))))
    ),
    'app_set_id_metric',
    (
      SELECT
        RepeatedField(
          AdServicesAppSetIdMetric(
            'latency', GET_LATENCY('AdIdCacheEvent')))
    ),
    'ad_id_metric',
    (
      SELECT
        RepeatedField(
          AdServicesAdIdMetric('latency', GET_LATENCY('AppSetIdEvent')))
    ),
    'odp_metric',
    (
      SELECT
        RepeatedField(
          OnDevicePersonalizationMetric(
            'managing_service_initialization_latency',
            (GET_LATENCY('OdpManagingService#Initialization')),
            'service_delegate_execute_flow_latency',
            (GET_LATENCY('OdpManagingServiceDelegate#Execute')),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(            'service_delegate_request_surface_package_latency',
            (GET_LATENCY('OdpManagingServiceDelegate#RequestSurfacePackage')),
            'service_delegate_register_web_trigger_latency',
            (GET_LATENCY('OdpManagingServiceDelegate#RegisterWebTrigger'))))
    ));

)_d3l1m1t3r_"
;

const char kAndroidAndroidAnr[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE android.anrs;

DROP VIEW IF EXISTS android_anr_output;
CREATE PERFETTO VIEW android_anr_output AS
SELECT
  AndroidAnrMetric(
    'anr', (
      SELECT RepeatedField(
        AndroidAnrMetric_Anr(
          'process_name', process_name,
          'pid', pid,
          'subject', subject,
          'error_id', error_id,
          'ts', ts))
      FROM android_anrs
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    )
  );
)_d3l1m1t3r_"
;

const char kAndroidAndroidAutoMultiuser[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE android.auto.multiuser;
INCLUDE PERFETTO MODULE time.conversion;

DROP VIEW IF EXISTS android_auto_multiuser_output;
CREATE PERFETTO VIEW android_auto_multiuser_output AS
SELECT AndroidAutoMultiuserMetric(
    'user_switch', (
        SELECT RepeatedField(
            AndroidAutoMultiuserMetric_EventData(
                'user_id', cast_int!(event_start_user_id),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(                'start_event', event_start_name,
                'end_event', event_end_name,
                'duration_ms', time_to_ms(duration),
                'previous_user_info', AndroidAutoMultiuserMetric_EventData_UserData(
                    'user_id', user_id,
                    'total_cpu_time_ms', time_to_ms(total_cpu_time),
                    'total_memory_usage_kb', total_memory_usage_kb
                )
            )
        )
        FROM android_auto_multiuser_timing_with_previous_user_resource_usage
    )
);
)_d3l1m1t3r_"
;

const char kAndroidAndroidBatt[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
INCLUDE PERFETTO MODULE android.battery;
INCLUDE PERFETTO MODULE android.battery_stats;
INCLUDE PERFETTO MODULE android.suspend;
INCLUDE PERFETTO MODULE counters.intervals;

DROP VIEW IF EXISTS battery_view;
CREATE PERFETTO VIEW battery_view AS
SELECT * FROM android_battery_charge;

DROP TABLE IF EXISTS android_batt_wakelocks_merged;
CREATE PERFETTO TABLE android_batt_wakelocks_merged AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  MIN(ts) AS ts,
  MAX(ts_end) AS ts_end
FROM (
    SELECT
      *,
      SUM(new_group) OVER (ORDER BY ts) AS group_id
    FROM (
        SELECT
          ts,
          ts + dur AS ts_end,
          -- There is a new group if there was a gap before this wakelock.
          -- i.e. the max end timestamp of all preceding wakelocks is before
          -- the start timestamp of this one.
          -- The null check is for the first row which is always a new group.
          IFNULL(
            MAX(ts + dur) OVER (
              ORDER BY ts
              ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING
            ) < ts,
            TRUE
          ) AS new_group
        FROM slice
        WHERE slice.name GLOB 'WakeLock *' AND dur != -1
    )
)
GROUP BY group_id;

-- TODO(simonmacm) remove this shim once no longer used internally
DROP TABLE IF EXISTS suspend_slice_;
CREATE PERFETTO TABLE suspend_slice_ AS
SELECT ts, dur FROM android_suspend_state where power_state = 'suspended';

DROP TABLE IF EXISTS screen_state_span;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO TABLE screen_state_span AS
WITH screen_state AS (
  SELECT counter.id, ts, 0 AS track_id, value
  FROM counter
  JOIN counter_track ON counter_track.id = counter.track_id
  WHERE name = 'ScreenState'
)
SELECT * FROM counter_leading_intervals!(screen_state);

DROP TABLE IF EXISTS screen_state_span_with_suspend;
CREATE VIRTUAL TABLE screen_state_span_with_suspend
USING span_join(screen_state_span, suspend_slice_);

DROP VIEW IF EXISTS android_batt_output;
CREATE PERFETTO VIEW android_batt_output AS
SELECT AndroidBatteryMetric(
  'battery_counters', (
    SELECT RepeatedField(
      AndroidBatteryMetric_BatteryCounters(
        'timestamp_ns', ts,
        'charge_counter_uah', charge_uah,
        'capacity_percent', capacity_percent,
        'current_ua', current_ua,
        'current_avg_ua', current_avg_ua
      )
    )
    FROM android_battery_charge
  ),
  'battery_aggregates', (
    SELECT NULL_IF_EMPTY(AndroidBatteryMetric_BatteryAggregates(
      'total_screen_off_ns',
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      SUM(CASE WHEN state = 1.0 AND tbl = 'total' THEN dur ELSE 0 END),
      'total_screen_on_ns',
      SUM(CASE WHEN state = 2.0 AND tbl = 'total' THEN dur ELSE 0 END),
      'total_screen_doze_ns',
      SUM(CASE WHEN state = 3.0 AND tbl = 'total' THEN dur ELSE 0 END),
      'sleep_ns',
      (SELECT SUM(dur) FROM suspend_slice_),
      'sleep_screen_off_ns',
      SUM(CASE WHEN state = 1.0 AND tbl = 'sleep' THEN dur ELSE 0 END),
      'sleep_screen_on_ns',
      SUM(CASE WHEN state = 2.0 AND tbl = 'sleep' THEN dur ELSE 0 END),
      'sleep_screen_doze_ns',
      SUM(CASE WHEN state = 3.0 AND tbl = 'sleep' THEN dur ELSE 0 END),
      'total_wakelock_ns',
      (SELECT SUM(ts_end - ts) FROM android_batt_wakelocks_merged)
      ))
    FROM (
      SELECT dur, value AS state, 'total' AS tbl
      FROM screen_state_span
      UNION ALL
      SELECT dur, value AS state, 'sleep' AS tbl
      FROM screen_state_span_with_suspend
    )
  ),
  'suspend_period', (
    SELECT RepeatedField(
      AndroidBatteryMetric_SuspendPeriod(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(        'timestamp_ns', ts,
        'duration_ns', dur
      )
    )
    FROM suspend_slice_
  )
);

)_d3l1m1t3r_"
;

const char kAndroidAndroidBinder[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE android.binder;

-- Count Binder transactions per process
DROP VIEW IF EXISTS binder_metrics_by_process;
CREATE PERFETTO VIEW binder_metrics_by_process AS
SELECT * FROM android_binder_metrics_by_process;

DROP VIEW IF EXISTS android_binder_output;
CREATE PERFETTO VIEW android_binder_output AS
SELECT AndroidBinderMetric(
  'process_breakdown', (
    SELECT RepeatedField(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      AndroidBinderMetric_PerProcessBreakdown(
        'process_name', process_name,
        'pid', pid,
        'slice_name', slice_name,
        'count', event_count
      )
    )
    FROM android_binder_metrics_by_process
  ),
  'unaggregated_txn_breakdown', (
    SELECT RepeatedField(
      AndroidBinderMetric_UnaggregatedTxnBreakdown(
        'aidl_name', aidl_name,
        'aidl_ts', aidl_ts,
        'aidl_dur', aidl_dur,
        'client_process', client_process,
        'client_thread', client_thread,
        'is_main_thread', is_main_thread,
        'client_ts', client_ts,
        'client_dur', client_dur,
        'client_tid', client_tid,
        'client_pid', client_pid,
        'client_oom_score', client_oom_score,
        'server_process', server_process,
        'server_thread', server_thread,
        'server_ts', server_ts,
        'server_dur', server_dur,
        'server_tid', server_tid,
        'server_pid', server_pid,
        'server_oom_score', server_oom_score,
        'is_sync', is_sync,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(        'client_monotonic_dur', client_monotonic_dur,
        'server_monotonic_dur', server_monotonic_dur,
        'client_package_version_code', client_package_version_code,
        'server_package_version_code', server_package_version_code,
        'is_client_package_debuggable', is_client_package_debuggable,
        'is_server_package_debuggable', is_server_package_debuggable,
        'thread_states', (
          SELECT RepeatedField(
            AndroidBinderMetric_ThreadStateBreakdown(
              'thread_state_type', thread_state_type,
              'thread_state', thread_state,
              'thread_state_dur', thread_state_dur,
              'thread_state_count', thread_state_count
            )
          ) FROM android_sync_binder_thread_state_by_txn t WHERE t.binder_txn_id = android_binder_txns.binder_txn_id
        ),
        'blocked_functions', (
          SELECT RepeatedField(
            AndroidBinderMetric_BlockedFunctionBreakdown(
              'thread_state_type', thread_state_type,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(              'blocked_function', blocked_function,
              'blocked_function_dur', blocked_function_dur,
              'blocked_function_count', blocked_function_count
            )
          ) FROM android_sync_binder_blocked_functions_by_txn b WHERE b.binder_txn_id = android_binder_txns.binder_txn_id
        )
      )
    )
    FROM android_binder_txns
  )
);

)_d3l1m1t3r_"
;

const char kAndroidAndroidBlockingCallsCujMetric[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Create the base table (`android_jank_cuj`) containing all completed CUJs
-- found in the trace.
-- This script will use the `android_jank_cuj_main_thread_cuj_boundary`,
-- containing bounds of jank CUJs.
SELECT RUN_METRIC('android/android_jank_cuj.sql');

INCLUDE PERFETTO MODULE android.slices;
INCLUDE PERFETTO MODULE android.binder;
INCLUDE PERFETTO MODULE android.critical_blocking_calls;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Jank "J<*>" and latency "L<*>" cujs are put together in android_cujs table.
-- They are computed separately as latency ones are slightly different, don't
-- currently have the same way to be cancelled, and are not anchored to vsyncs.
DROP TABLE IF EXISTS android_cujs;
CREATE TABLE android_cujs AS
WITH latency_cujs AS (
    SELECT
        ROW_NUMBER() OVER (ORDER BY ts) AS cuj_id,
        process.upid AS upid,
        process.name AS process_name,
        process_metadata.metadata AS process_metadata,
        -- Extracts "CUJ_NAME" from "L<CUJ_NAME>"
        SUBSTR(slice.name, 3, LENGTH(slice.name) - 3) AS cuj_name,
        ts,
        dur,
        ts + dur AS ts_end,
        'completed' AS state
    FROM slice
        JOIN process_track
          ON slice.track_id = process_track.id
        JOIN process USING (upid)
        JOIN process_metadata USING (upid)
    WHERE
        slice.name GLOB 'L<*>'
    AND dur > 0
),
all_cujs AS (
    SELECT
        cuj_id,
        upid,
        process_name,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(        process_metadata,
        cuj_name,
        tb.ts,
        tb.dur,
        tb.ts_end
    FROM android_jank_cuj_main_thread_cuj_boundary tb
        JOIN android_jank_cuj using (cuj_id)
UNION
    SELECT
        cuj_id,
        upid,
        process_name,
        process_metadata,
        cuj_name,
        ts,
        dur,
        ts_end
    FROM latency_cujs
)
SELECT ROW_NUMBER() OVER (ORDER BY ts) AS cuj_id, *
FROM all_cujs;

-- We have:
--  (1) a list of slices from the main thread of each process from the
--  all_main_thread_relevant_slices table.
--  (2) a list of android cuj with beginning, end, and process
-- It's needed to:
--  (1) assign a cuj to each slice. If there are multiple cujs going on during a
--      slice, there needs to be 2 entries for that slice, one for each cuj id.
--  (2) each slice needs to be trimmed to be fully inside the cuj associated
--      (as we don't care about what's outside cujs)
DROP TABLE IF EXISTS android_blocking_calls_cuj_calls;
CREATE TABLE android_blocking_calls_cuj_calls AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(WITH
main_thread_slices_scoped_to_cujs AS (
SELECT
    s.id,
    s.id AS slice_id,
    s.name,
    max(s.ts, cuj.ts) AS ts,
    min(s.ts + s.dur, cuj.ts_end) as ts_end,
    min(s.ts + s.dur, cuj.ts_end) - max(s.ts, cuj.ts) AS dur,
    cuj.cuj_id,
    cuj.cuj_name,
    s.process_name,
    s.upid,
    s.utid
FROM _android_critical_blocking_calls s
    JOIN  android_cujs cuj
    -- only when there is an overlap
    ON s.ts + s.dur > cuj.ts AND s.ts < cuj.ts_end
        -- and are from the same process
        AND s.upid = cuj.upid
)
SELECT
    name,
    COUNT(*) AS occurrences,
    MAX(dur) AS max_dur_ns,
    MIN(dur) AS min_dur_ns,
    SUM(dur) AS total_dur_ns,
    upid,
    cuj_id,
    cuj_name,
    process_name
FROM
    main_thread_slices_scoped_to_cujs
GROUP BY name, upid, cuj_id, cuj_name, process_name
ORDER BY cuj_id;


DROP VIEW IF EXISTS android_blocking_calls_cuj_metric_output;
CREATE PERFETTO VIEW android_blocking_calls_cuj_metric_output AS
SELECT AndroidBlockingCallsCujMetric('cuj', (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    SELECT RepeatedField(
        AndroidBlockingCallsCujMetric_Cuj(
            'id', cuj_id,
            'name', cuj_name,
            'process', process_metadata,
            'ts',  cuj.ts,
            'dur', cuj.dur,
            'blocking_calls', (
                SELECT RepeatedField(
                    AndroidBlockingCall(
                        'name', b.name,
                        'cnt', b.occurrences,
                        'total_dur_ms', CAST(total_dur_ns / 1e6 AS INT),
                        'max_dur_ms', CAST(max_dur_ns / 1e6 AS INT),
                        'min_dur_ms', CAST(min_dur_ns / 1e6 AS INT),
                        'total_dur_ns', b.total_dur_ns,
                        'max_dur_ns', b.max_dur_ns,
                        'min_dur_ns', b.min_dur_ns
                    )
                )
                FROM android_blocking_calls_cuj_calls b
                WHERE b.cuj_id = cuj.cuj_id and b.upid = cuj.upid
                ORDER BY total_dur_ns DESC
            )
)_d3l1m1t3r_"
R"_d3l1m1t3r_(        )
    )
    FROM android_cujs cuj
    ORDER BY cuj.cuj_id ASC
));

)_d3l1m1t3r_"
;

const char kAndroidAndroidBlockingCallsUnagg[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

SELECT RUN_METRIC('android/process_metadata.sql');

INCLUDE PERFETTO MODULE android.slices;
INCLUDE PERFETTO MODULE android.binder;
INCLUDE PERFETTO MODULE android.critical_blocking_calls;

DROP TABLE IF EXISTS process_info;
CREATE TABLE process_info AS
SELECT
  process.upid AS upid,
  process.name AS process_name,
  process_metadata.metadata AS process_metadata
FROM process
JOIN process_metadata USING (upid);
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
DROP TABLE IF EXISTS android_blocking_calls_unagg_calls;
CREATE TABLE android_blocking_calls_unagg_calls AS
SELECT
  name,
  COUNT(*) AS occurrences,
  MAX(dur) AS max_dur_ns,
  MIN(dur) AS min_dur_ns,
  SUM(dur) AS total_dur_ns,
  AVG(dur) AS avg_dur_ns,
  upid,
  process_name
FROM
  _android_critical_blocking_calls
GROUP BY name, upid, process_name;

DROP TABLE IF EXISTS filtered_processes_with_non_zero_blocking_calls;
CREATE TABLE filtered_processes_with_non_zero_blocking_calls AS
SELECT pi.upid,
  pi.process_name,
  pi.process_metadata
FROM process_info pi WHERE pi.upid IN
  (SELECT DISTINCT upid FROM _android_critical_blocking_calls);


DROP TABLE IF EXISTS filtered_processes_with_non_zero_blocking_calls;
CREATE TABLE filtered_processes_with_non_zero_blocking_calls AS
SELECT pi.upid,
  pi.process_name,
  pi.process_metadata
FROM process_info pi WHERE pi.upid IN
  (SELECT DISTINCT upid FROM _android_critical_blocking_calls);

DROP VIEW IF EXISTS android_blocking_calls_unagg_output;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO VIEW android_blocking_calls_unagg_output AS
SELECT AndroidBlockingCallsUnagg(
  'process_with_blocking_calls', (
     SELECT RepeatedField(
       AndroidBlockingCallsUnagg_ProcessWithBlockingCalls(
         'process', e.process_metadata,
         'blocking_calls', (
            SELECT RepeatedField(
              AndroidBlockingCall(
                'name', d.name,
                'cnt', d.occurrences,
                'avg_dur_ms', CAST(avg_dur_ns / 1e6 AS INT),
                'total_dur_ms', CAST(total_dur_ns / 1e6 AS INT),
                'max_dur_ms', CAST(max_dur_ns / 1e6 AS INT),
                'min_dur_ms', CAST(min_dur_ns / 1e6 AS INT),
                'avg_dur_ns', CAST(d.avg_dur_ns AS INT),
                'total_dur_ns', d.total_dur_ns,
                'max_dur_ns', d.max_dur_ns,
                'min_dur_ns', d.min_dur_ns
              )
            ) FROM (
            SELECT b.name,
              b.occurrences,
              b.avg_dur_ns,
              b.total_dur_ns,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(              b.max_dur_ns,
              b.min_dur_ns
            FROM android_blocking_calls_unagg_calls b INNER JOIN filtered_processes_with_non_zero_blocking_calls c
            ON b.upid = c.upid WHERE b.upid = e.upid
            ORDER BY total_dur_ns DESC
            ) d
         )
       )
     )
     FROM filtered_processes_with_non_zero_blocking_calls e
  )
);

)_d3l1m1t3r_"
;

const char kAndroidAndroidBoot[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE android.app_process_starts;
INCLUDE PERFETTO MODULE android.broadcasts;
INCLUDE PERFETTO MODULE android.garbage_collection;
INCLUDE PERFETTO MODULE android.oom_adjuster;
INCLUDE PERFETTO MODULE android.process_metadata;

DROP VIEW IF EXISTS android_oom_adj_intervals_with_detailed_bucket_name;
CREATE PERFETTO VIEW android_oom_adj_intervals_with_detailed_bucket_name AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  ts,
  dur,
  score,
  android_oom_adj_score_to_detailed_bucket_name(score, android_appid) AS bucket,
  upid,
  process_name,
  oom_adj_id,
  oom_adj_ts,
  oom_adj_dur,
  oom_adj_track_id,
  oom_adj_thread_name,
  oom_adj_reason,
  oom_adj_trigger
FROM _oom_adjuster_intervals;

CREATE OR REPLACE PERFETTO FUNCTION get_durations(process_name STRING)
RETURNS TABLE(uint_sleep_dur LONG, total_dur LONG) AS
SELECT
    SUM(CASE WHEN thread_state.state="D" then thread_state.dur ELSE 0 END) AS uint_sleep_dur,
    SUM(thread_state.dur) as total_dur
FROM android_process_metadata
INNER JOIN thread ON thread.upid=android_process_metadata.upid
INNER JOIN thread_state ON thread.utid=thread_state.utid WHERE android_process_metadata.process_name=$process_name;

CREATE OR REPLACE PERFETTO FUNCTION first_user_unlocked() RETURNS INT AS
SELECT COALESCE(MIN(ts), 0) FROM thread_slice
WHERE name GLOB "*android.intent.action.USER_UNLOCKED*";

DROP TABLE IF EXISTS _oom_adj_events_with_src_bucket;
CREATE PERFETTO TABLE _oom_adj_events_with_src_bucket
)_d3l1m1t3r_"
R"_d3l1m1t3r_(AS
SELECT
  LAG(bucket) OVER (PARTITION BY upid ORDER BY ts) AS src_bucket,
  ts,
  bucket,
  process_name,
  oom_adj_reason
FROM android_oom_adj_intervals_with_detailed_bucket_name;

DROP VIEW IF EXISTS oom_adj_events_by_process_name;
CREATE PERFETTO VIEW oom_adj_events_by_process_name AS
SELECT
  src_bucket,
  bucket,
  count(ts) as count,
  process_name
FROM _oom_adj_events_with_src_bucket
  WHERE ts > first_user_unlocked()
GROUP BY process_name, bucket, src_bucket;

DROP VIEW IF EXISTS oom_adj_events_global_by_bucket;
CREATE PERFETTO VIEW oom_adj_events_global_by_bucket AS
SELECT
  src_bucket,
  bucket,
  count(ts) as count,
  NULL as name
FROM _oom_adj_events_with_src_bucket
WHERE
  ts > first_user_unlocked()
GROUP BY bucket, src_bucket;

DROP VIEW IF EXISTS oom_adj_events_by_oom_adj_reason;
CREATE PERFETTO VIEW oom_adj_events_by_oom_adj_reason AS
SELECT
  src_bucket,
  bucket,
  count(ts) as count,
  oom_adj_reason as name
FROM _oom_adj_events_with_src_bucket
WHERE ts > first_user_unlocked()
)_d3l1m1t3r_"
R"_d3l1m1t3r_(GROUP BY bucket, src_bucket, oom_adj_reason;

DROP VIEW IF EXISTS android_boot_output;
CREATE PERFETTO VIEW android_boot_output AS
SELECT AndroidBootMetric(
    'system_server_durations', (
        SELECT NULL_IF_EMPTY(ProcessStateDurations(
            'total_dur', total_dur,
            'uninterruptible_sleep_dur', uint_sleep_dur))
        FROM get_durations('system_server')),
    'systemui_durations', (
        SELECT NULL_IF_EMPTY(ProcessStateDurations(
            'total_dur', total_dur,
            'uninterruptible_sleep_dur', uint_sleep_dur))
        FROM get_durations('com.android.systemui')),
    'launcher_durations', (
        SELECT NULL_IF_EMPTY(ProcessStateDurations(
            'total_dur', total_dur,
            'uninterruptible_sleep_dur', uint_sleep_dur))
        FROM get_durations('com.google.android.apps.nexuslauncher')),
    'gms_durations', (
        SELECT NULL_IF_EMPTY(ProcessStateDurations(
            'total_dur', total_dur,
            'uninterruptible_sleep_dur', uint_sleep_dur))
)_d3l1m1t3r_"
R"_d3l1m1t3r_(        FROM get_durations('com.google.android.gms.persistent')),
    'launcher_breakdown', (
        SELECT NULL_IF_EMPTY(AndroidBootMetric_LauncherBreakdown(
            'cold_start_dur', dur))
        FROM slice where name="LauncherColdStartup"),
    'full_trace_process_start_aggregation', (
        SELECT NULL_IF_EMPTY(AndroidBootMetric_ProcessStartAggregation(
            'total_start_sum', (SELECT SUM(total_dur) FROM android_app_process_starts),
            'num_of_processes', (SELECT COUNT(*) FROM android_app_process_starts),
            'average_start_time', (SELECT AVG(total_dur) FROM android_app_process_starts)))
          FROM android_app_process_starts),
    'post_boot_process_start_aggregation', (
        SELECT NULL_IF_EMPTY(AndroidBootMetric_ProcessStartAggregation(
            'total_start_sum', (
              SELECT SUM(total_dur)
              FROM android_app_process_starts
              WHERE proc_start_ts > first_user_unlocked()
            ),
            'num_of_processes', (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(              SELECT COUNT(*)
              FROM android_app_process_starts
              WHERE proc_start_ts > first_user_unlocked()
            ),
            'average_start_time', (
              SELECT AVG(total_dur)
              FROM android_app_process_starts
              WHERE proc_start_ts > first_user_unlocked()
            )
        ))
    ),
    'full_trace_gc_aggregation', (
        SELECT NULL_IF_EMPTY(AndroidBootMetric_GarbageCollectionAggregation(
            'total_gc_count', (SELECT COUNT(*) FROM android_garbage_collection_events
            ),
            'num_of_processes_with_gc', (SELECT COUNT(process_name) FROM android_garbage_collection_events
            ),
            'num_of_threads_with_gc', (
              SELECT SUM(cnt) FROM (
                SELECT COUNT(*) AS cnt
                FROM android_garbage_collection_events
                GROUP by thread_name, process_name
              )
            ),
            'avg_gc_duration', (SELECT AVG(gc_dur) FROM android_garbage_collection_events),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(            'avg_running_gc_duration', (SELECT AVG(gc_running_dur) FROM android_garbage_collection_events),
            'full_gc_count', (
              SELECT COUNT(*)
              FROM android_garbage_collection_events
              WHERE gc_type = "full"
            ),
            'collector_transition_gc_count', (
              SELECT COUNT(*)
              FROM android_garbage_collection_events
              WHERE gc_type = "collector_transition"
            ),
            'young_gc_count', (SELECT COUNT(*) FROM android_garbage_collection_events
              WHERE gc_type = "young"
            ),
            'native_alloc_gc_count', (SELECT COUNT(*) FROM android_garbage_collection_events
              WHERE gc_type = "native_alloc"
            ),
            'explicit_gc_count', (SELECT COUNT(*) FROM android_garbage_collection_events
              WHERE gc_type = "explicit_gc"
            ),
            'alloc_gc_count', (SELECT COUNT(*) FROM android_garbage_collection_events
              WHERE gc_type = "alloc_gc"
)_d3l1m1t3r_"
R"_d3l1m1t3r_(            ),
            'mb_per_ms_of_gc', (SELECT SUM(reclaimed_mb)/SUM(gc_running_dur/1e6) AS mb_per_ms_dur
              FROM android_garbage_collection_events
            )
        ))
    ),
    'post_boot_gc_aggregation', (
        SELECT NULL_IF_EMPTY(AndroidBootMetric_GarbageCollectionAggregation(
            'total_gc_count', (SELECT COUNT(*) FROM android_garbage_collection_events
              WHERE gc_ts > first_user_unlocked()
            ),
            'num_of_processes_with_gc', (SELECT COUNT(process_name) FROM android_garbage_collection_events
              WHERE gc_ts > first_user_unlocked()
            ),
            'num_of_threads_with_gc', (SELECT SUM(cnt) FROM (SELECT COUNT(*) AS cnt
              FROM android_garbage_collection_events
              WHERE gc_ts > first_user_unlocked()
              GROUP by thread_name, process_name)
            ),
            'avg_gc_duration', (SELECT AVG(gc_dur) FROM android_garbage_collection_events
              WHERE gc_ts > first_user_unlocked()
)_d3l1m1t3r_"
R"_d3l1m1t3r_(            ),
            'avg_running_gc_duration', (SELECT AVG(gc_running_dur) FROM android_garbage_collection_events
              WHERE gc_ts > first_user_unlocked()
            ),
            'full_gc_count', (SELECT COUNT(*) FROM android_garbage_collection_events
              WHERE gc_type = "full" AND gc_ts > first_user_unlocked()
            ),
            'collector_transition_gc_count', (SELECT COUNT(*) FROM android_garbage_collection_events
              WHERE gc_type = "collector_transition" AND gc_ts > (
                SELECT COALESCE(MIN(ts), 0)
                FROM thread_slice
                WHERE name GLOB "*android.intent.action.USER_UNLOCKED*"
                ORDER BY ts ASC LIMIT 1
              )
            ),
            'young_gc_count', (
              SELECT COUNT(*)
              FROM android_garbage_collection_events
              WHERE gc_type = "young" AND gc_ts > (
                SELECT COALESCE(MIN(ts), 0)
                FROM thread_slice
                WHERE name GLOB "*android.intent.action.USER_UNLOCKED*"
)_d3l1m1t3r_"
R"_d3l1m1t3r_(                ORDER BY ts ASC LIMIT 1
              )
            ),
            'native_alloc_gc_count', (
              SELECT COUNT(*)
              FROM android_garbage_collection_events
              WHERE gc_type = "native_alloc" AND gc_ts > first_user_unlocked()
            ),
            'explicit_gc_count', (
              SELECT COUNT(*) FROM android_garbage_collection_events
              WHERE gc_type = "explicit_gc" AND gc_ts > (
                SELECT COALESCE(MIN(ts), 0)
                FROM thread_slice
                WHERE name GLOB "*android.intent.action.USER_UNLOCKED*"
                ORDER BY ts ASC LIMIT 1
              )
            ),
            'alloc_gc_count', (
              SELECT COUNT(*) FROM android_garbage_collection_events
              WHERE gc_type = "alloc_gc" AND gc_ts > first_user_unlocked()
            ),
            'mb_per_ms_of_gc', (
              SELECT
                SUM(reclaimed_mb)/SUM(gc_running_dur/1e6) AS mb_per_ms_dur
              FROM android_garbage_collection_events
)_d3l1m1t3r_"
R"_d3l1m1t3r_(              WHERE gc_ts > first_user_unlocked()
            )
        ))
    ),
    'post_boot_oom_adjuster_transition_counts_by_process', (
      SELECT RepeatedField(
        AndroidBootMetric_OomAdjusterTransitionCounts(
          'name', process_name,
          'src_bucket', src_bucket,
          'dest_bucket', bucket,
          'count', count
        )
      ) FROM oom_adj_events_by_process_name
    ),
    'post_boot_oom_adjuster_transition_counts_global', (
      SELECT RepeatedField(
        AndroidBootMetric_OomAdjusterTransitionCounts(
          'name', name,
          'src_bucket', src_bucket,
          'dest_bucket', bucket,
          'count', count
        )
      )
      FROM oom_adj_events_global_by_bucket
    ),
    'post_boot_oom_adjuster_transition_counts_by_oom_adj_reason',(
      SELECT RepeatedField(
        AndroidBootMetric_OomAdjusterTransitionCounts(
          'name', name,
          'src_bucket', src_bucket,
          'dest_bucket', bucket,
          'count', count
)_d3l1m1t3r_"
R"_d3l1m1t3r_(        )
      )
      FROM oom_adj_events_by_oom_adj_reason
    ),
    'post_boot_oom_adj_bucket_duration_agg_global',(SELECT RepeatedField(
      AndroidBootMetric_OomAdjBucketDurationAggregation(
            'name', name,
            'bucket', bucket,
            'total_dur', total_dur
      ))
      FROM (
        SELECT
          NULL as name,
          bucket,
          SUM(dur) as total_dur
        FROM android_oom_adj_intervals_with_detailed_bucket_name
          WHERE ts > first_user_unlocked()
        GROUP BY bucket)
    ),
    'post_boot_oom_adj_bucket_duration_agg_by_process',(SELECT RepeatedField(
        AndroidBootMetric_OomAdjBucketDurationAggregation(
            'name', name,
            'bucket', bucket,
            'total_dur', total_dur
        )
    )
    FROM (
      SELECT
        process_name as name,
        bucket,
        SUM(dur) as total_dur
      FROM android_oom_adj_intervals_with_detailed_bucket_name
      WHERE ts > first_user_unlocked()
      AND process_name IS NOT NULL
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      GROUP BY process_name, bucket)
    ),
    'post_boot_oom_adj_duration_agg',
    (SELECT RepeatedField(
        AndroidBootMetric_OomAdjDurationAggregation(
            'min_oom_adj_dur', min_oom_adj_dur,
            'max_oom_adj_dur', max_oom_adj_dur,
            'avg_oom_adj_dur', avg_oom_adj_dur,
            'oom_adj_event_count', oom_adj_event_count,
            'oom_adj_reason', oom_adj_reason
        )
    )
    FROM (
      SELECT
        MIN(oom_adj_dur) as min_oom_adj_dur,
        MAX(oom_adj_dur) as max_oom_adj_dur,
        AVG(oom_adj_dur) as avg_oom_adj_dur,
        COUNT(DISTINCT(oom_adj_id)) oom_adj_event_count,
        oom_adj_reason
      FROM android_oom_adj_intervals_with_detailed_bucket_name
      WHERE ts > first_user_unlocked()
      GROUP BY oom_adj_reason
      )
    ),
  'post_boot_broadcast_process_count_by_intent', (
    SELECT RepeatedField(
      AndroidBootMetric_BroadcastCountAggregation(
        'name', intent_action,
        'count', process_name_counts
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      )
    )
    FROM (
      SELECT
        intent_action,
        COUNT(process_name) as process_name_counts
      FROM _android_broadcasts_minsdk_u
      WHERE ts > first_user_unlocked()
      GROUP BY intent_action
    )
  ),
  'post_boot_broadcast_count_by_process', (
    SELECT RepeatedField(
      AndroidBootMetric_BroadcastCountAggregation(
        'name', process_name,
        'count', broadcast_counts
      )
    )
    FROM (
      SELECT
        process_name,
        COUNT(id) as broadcast_counts
      FROM _android_broadcasts_minsdk_u
      WHERE ts > first_user_unlocked()
      GROUP BY process_name
    )
  ),
  'post_boot_brodcast_duration_agg_by_intent', (
    SELECT RepeatedField(
      AndroidBootMetric_BroadcastDurationAggregation(
        'name', intent_action,
        'avg_duration', avg_duration,
        'max_duration', max_duration,
        'sum_duration', sum_duration
      )
    )
    FROM (
      SELECT
        intent_action,
        AVG(dur) as avg_duration,
        SUM(dur) as sum_duration,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(        MAX(dur) as max_duration
      FROM _android_broadcasts_minsdk_u
      WHERE ts > first_user_unlocked()
      GROUP BY intent_action
    )
  ),  'post_boot_brodcast_duration_agg_by_process', (
    SELECT RepeatedField(
      AndroidBootMetric_BroadcastDurationAggregation(
        'name', process_name,
        'avg_duration', avg_duration,
        'max_duration', max_duration,
        'sum_duration', sum_duration
      )
    )
    FROM (
      SELECT
        process_name,
        AVG(dur) as avg_duration,
        SUM(dur) as sum_duration,
        MAX(dur) as max_duration
      FROM _android_broadcasts_minsdk_u
      WHERE ts > first_user_unlocked()
      GROUP BY process_name
    )
  )
);

)_d3l1m1t3r_"
;

const char kAndroidAndroidBootUnagg[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE android.app_process_starts;
INCLUDE PERFETTO MODULE android.garbage_collection;
INCLUDE PERFETTO MODULE android.suspend;

DROP VIEW IF EXISTS android_boot_unagg_output;
CREATE PERFETTO VIEW android_boot_unagg_output AS
SELECT AndroidBootUnagg(
  'android_app_process_start_metric', (
    SELECT AndroidAppProcessStartsMetric(
        'all_apps', (
            SELECT RepeatedField(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(                AndroidAppProcessStartsMetric_ProcessStart(
                    'process_name', process_name,
                    'intent', intent,
                    'reason', reason,
                    'proc_start_dur', proc_start_dur,
                    'bind_app_dur', bind_app_dur,
                    'intent_dur', intent_dur,
                    'total_dur', total_dur
                )
            )
            FROM android_app_process_starts WHERE proc_start_ts > (SELECT COALESCE(MIN(ts), 0)
            FROM thread_slice WHERE name GLOB "*android.intent.action.USER_UNLOCKED*" ORDER BY ts
            ASC LIMIT 1)
        ),
        'started_by_broadcast', (
            SELECT RepeatedField(
                AndroidAppProcessStartsMetric_ProcessStart(
                    'process_name', process_name,
                    'intent', intent,
                    'reason', reason,
                    'proc_start_dur', proc_start_dur,
                    'bind_app_dur', bind_app_dur,
                    'intent_dur', intent_dur,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(                    'total_dur', total_dur
                )
            )
            FROM android_app_process_starts WHERE proc_start_ts > (SELECT COALESCE(MIN(ts), 0)
            FROM thread_slice WHERE name GLOB "*android.intent.action.USER_UNLOCKED*" ORDER BY ts
            ASC LIMIT 1)
            AND reason = "broadcast"
        ),
        'started_by_service', (
            SELECT RepeatedField(
                AndroidAppProcessStartsMetric_ProcessStart(
                    'process_name', process_name,
                    'intent', intent,
                    'reason', reason,
                    'proc_start_dur', proc_start_dur,
                    'bind_app_dur', bind_app_dur,
                    'intent_dur', intent_dur,
                    'total_dur', total_dur
                )
            )
            FROM android_app_process_starts WHERE proc_start_ts > (SELECT COALESCE(MIN(ts), 0)
            FROM thread_slice WHERE name GLOB "*android.intent.action.USER_UNLOCKED*" ORDER BY ts
)_d3l1m1t3r_"
R"_d3l1m1t3r_(            ASC LIMIT 1 )
            AND reason = "service"
        )
    )),
    'android_post_boot_gc_metric', (SELECT AndroidGarbageCollectionUnaggMetric(
        'gc_events', (
            SELECT RepeatedField(
                AndroidGarbageCollectionUnaggMetric_GarbageCollectionEvent(
                    'thread_name', thread_name,
                    'process_name', process_name,
                    'gc_type', gc_type,
                    'is_mark_compact', is_mark_compact,
                    'reclaimed_mb', reclaimed_mb,
                    'min_heap_mb', min_heap_mb,
                    'max_heap_mb', max_heap_mb,
                    'mb_per_ms_of_running_gc', reclaimed_mb/(gc_running_dur/1e6),
                    'mb_per_ms_of_wall_gc', reclaimed_mb/(gc_dur/1e6),
                    'gc_dur', gc_dur,
                    'gc_running_dur', gc_running_dur,
                    'gc_runnable_dur', gc_runnable_dur,
                    'gc_unint_io_dur', gc_unint_io_dur,
                    'gc_unint_non_io_dur', gc_unint_non_io_dur,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(                    'gc_int_dur', gc_int_dur,
                    'gc_ts', gc_ts,
                    'tid', tid,
                    'pid', pid,
                    'gc_monotonic_dur', _extract_duration_without_suspend(gc_ts, gc_dur)
                )
            ) FROM android_garbage_collection_events WHERE gc_ts > (SELECT COALESCE(MIN(ts), 0)
                FROM thread_slice WHERE name GLOB "*android.intent.action.USER_UNLOCKED*" ORDER BY ts
                ASC LIMIT 1
            )
        )
    ))
);

)_d3l1m1t3r_"
;

const char kAndroidAndroidBroadcasts[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
INCLUDE PERFETTO MODULE android.broadcasts;

DROP VIEW IF EXISTS android_broadcasts_output;
CREATE PERFETTO VIEW android_broadcasts_output AS
SELECT AndroidBroadcastsMetric(
  'process_count_by_intent', (
    SELECT RepeatedField(
      AndroidBroadcastsMetric_BroadcastCountAggregation(
        'name', intent_action,
        'count', process_name_counts
      )
    )
    FROM (
      SELECT
)_d3l1m1t3r_"
R"_d3l1m1t3r_(        intent_action,
        COUNT(process_name) as process_name_counts
      FROM _android_broadcasts_minsdk_u
      GROUP BY intent_action
    )
  ),
  'broadcast_count_by_process', (
    SELECT RepeatedField(
      AndroidBroadcastsMetric_BroadcastCountAggregation(
        'name', process_name,
        'count', broadcast_counts
      )
    )
    FROM (
      SELECT
        process_name,
        COUNT(id) as broadcast_counts
      FROM _android_broadcasts_minsdk_u
      GROUP BY process_name
    )
  ),
  'brodcast_duration_agg_by_intent', (
    SELECT RepeatedField(
      AndroidBroadcastsMetric_BroadcastDurationAggregation(
        'name', intent_action,
        'avg_duration', avg_duration,
        'max_duration', max_duration,
        'sum_duration', sum_duration
      )
    )
    FROM (
      SELECT
        intent_action,
        AVG(dur) as avg_duration,
        SUM(dur) as sum_duration,
        MAX(dur) as max_duration
      FROM _android_broadcasts_minsdk_u
      GROUP BY intent_action
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    )
  ),  'brodcast_duration_agg_by_process', (
    SELECT RepeatedField(
      AndroidBroadcastsMetric_BroadcastDurationAggregation(
        'name', process_name,
        'avg_duration', avg_duration,
        'max_duration', max_duration,
        'sum_duration', sum_duration
      )
    )
    FROM (
      SELECT
        process_name,
        AVG(dur) as avg_duration,
        SUM(dur) as sum_duration,
        MAX(dur) as max_duration
      FROM _android_broadcasts_minsdk_u
      GROUP BY process_name
    )
  )
)
)_d3l1m1t3r_"
;

const char kAndroidAndroidCamera[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- This gives us access to the RSS breakdowns.
SELECT RUN_METRIC('android/process_mem.sql');

-- Compute DMA spans.
SELECT RUN_METRIC('android/global_counter_span_view.sql',
  'table_name', 'dma',
  'counter_name', 'mem.dma_heap');

-- RSS of GCA.
DROP VIEW IF EXISTS rss_gca;
CREATE PERFETTO VIEW rss_gca AS
SELECT ts, dur, rss_val AS gca_rss_val
FROM rss_and_swap_span
JOIN (
  SELECT max(start_ts), upid
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  FROM process
  WHERE name GLOB '*GoogleCamera'
    OR name GLOB '*googlecamera.fishfood'
    OR name GLOB '*GoogleCameraEng'
  LIMIT 1
) AS gca USING (upid);

-- RSS of camera HAL.
DROP VIEW IF EXISTS rss_camera_hal;
CREATE PERFETTO VIEW rss_camera_hal AS
SELECT ts, dur, rss_val AS hal_rss_val
FROM rss_and_swap_span
JOIN (
  SELECT max(start_ts), upid
  FROM process
  WHERE name GLOB '*camera.provider*'
  LIMIT 1
) AS hal USING (upid);

-- RSS of cameraserver.
DROP VIEW IF EXISTS rss_cameraserver;
CREATE PERFETTO VIEW rss_cameraserver AS
SELECT ts, dur, rss_val AS cameraserver_rss_val
FROM rss_and_swap_span
JOIN (
  SELECT max(start_ts), upid
  FROM process
  WHERE name GLOB '*cameraserver'
  LIMIT 1
) AS cameraserver USING (upid);

-- RSS of GCA + HAL.
DROP TABLE IF EXISTS rss_gca_hal;
CREATE VIRTUAL TABLE rss_gca_hal
USING SPAN_OUTER_JOIN(rss_gca, rss_camera_hal);

-- RSS of GCA + HAL + cameraserver.
DROP TABLE IF EXISTS rss_all_camera;
CREATE VIRTUAL TABLE rss_all_camera
USING SPAN_OUTER_JOIN(rss_gca_hal, rss_cameraserver);
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- RSS of GCA + HAL + cameraserver + DMA.
DROP TABLE IF EXISTS rss_and_dma_all_camera_join;
CREATE VIRTUAL TABLE rss_and_dma_all_camera_join
USING SPAN_OUTER_JOIN(dma_span, rss_all_camera);

DROP VIEW IF EXISTS rss_and_dma_all_camera_span;
CREATE PERFETTO VIEW rss_and_dma_all_camera_span AS
SELECT
  ts,
  dur,
  IFNULL(gca_rss_val, 0) as gca_rss_val,
  IFNULL(hal_rss_val, 0) as hal_rss_val,
  IFNULL(cameraserver_rss_val, 0) as cameraserver_rss_val,
  IFNULL(dma_val, 0) as dma_val,
  CAST(
    IFNULL(gca_rss_val, 0)
    + IFNULL(hal_rss_val, 0)
    + IFNULL(cameraserver_rss_val, 0)
    + IFNULL(dma_val, 0) AS int) AS rss_and_dma_val
FROM rss_and_dma_all_camera_join;

-- we are dividing and casting to real when calculating avg_value
-- to avoid issues such as the one in b/203613535
DROP VIEW IF EXISTS rss_and_dma_all_camera_stats;
CREATE PERFETTO VIEW rss_and_dma_all_camera_stats AS
SELECT
  MIN(rss_and_dma_val) AS min_value,
  MAX(rss_and_dma_val) AS max_value,
  SUM(rss_and_dma_val * dur / 1e3) / SUM(dur / 1e3) AS avg_value
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM rss_and_dma_all_camera_span;

DROP VIEW IF EXISTS android_camera_event;
CREATE PERFETTO VIEW android_camera_event AS
SELECT
  'counter' AS track_type,
  'Camera Memory' AS track_name,
  ts,
  rss_and_dma_val AS value
FROM rss_and_dma_all_camera_span;

DROP VIEW IF EXISTS android_camera_output;
CREATE PERFETTO VIEW android_camera_output AS
SELECT
  AndroidCameraMetric(
    'gc_rss_and_dma', AndroidCameraMetric_Counter(
      'min', CAST(min_value AS real),
      'max', CAST(max_value AS real),
      'avg', CAST(avg_value AS real)
    )
  )
FROM rss_and_dma_all_camera_stats;

)_d3l1m1t3r_"
;

const char kAndroidAndroidCameraUnagg[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- This gives us access to the raw spans.
SELECT RUN_METRIC('android/android_camera.sql');

DROP VIEW IF EXISTS android_camera_unagg_output;
CREATE PERFETTO VIEW android_camera_unagg_output AS
SELECT
  AndroidCameraUnaggregatedMetric(
    'gc_rss_and_dma', (
      SELECT RepeatedField(
          AndroidCameraUnaggregatedMetric_Value(
            'ts', ts,
            'gca_rss_val', CAST(gca_rss_val AS real),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(            'hal_rss_val', CAST(hal_rss_val AS real),
            'cameraserver_rss_val', CAST(cameraserver_rss_val AS real),
            'dma_val', CAST(dma_val AS real),
            'value', CAST(rss_and_dma_val AS real)
          )
      )
      FROM rss_and_dma_all_camera_span
    )
  );

)_d3l1m1t3r_"
;

const char kAndroidAndroidCpu[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- Create all the views used to generate the Android Cpu metrics proto.
SELECT RUN_METRIC('android/android_cpu_agg.sql');
SELECT RUN_METRIC('android/android_cpu_raw_metrics_per_core.sql',
  'input_table', 'cpu_freq_sched_per_thread',
  'output_table', 'raw_metrics_per_core');
SELECT RUN_METRIC('android/process_metadata.sql');

DROP VIEW IF EXISTS metrics_per_core_type;
CREATE PERFETTO VIEW metrics_per_core_type AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  utid,
  core_type,
  AndroidCpuMetric_Metrics(
    'mcycles', SUM(mcycles),
    'runtime_ns', SUM(runtime_ns),
    'min_freq_khz', MIN(min_freq_khz),
    'max_freq_khz', MAX(max_freq_khz),
    -- In total here, we need to divide the denominator by 1e9 (to convert
    -- ns to s) and divide the numerator by 1e6 (to convert millicycles to
    -- kcycles). In total, this means we need to multiply the expression as
    -- a whole by 1e3.
    'avg_freq_khz', CAST((SUM(millicycles) / SUM(runtime_ns)) * 1000 AS INT)
  ) AS proto
FROM raw_metrics_per_core
GROUP BY utid, core_type;

-- Aggregate everything per thread.
DROP VIEW IF EXISTS core_proto_per_thread;
CREATE PERFETTO VIEW core_proto_per_thread AS
SELECT
  utid,
  RepeatedField(
    AndroidCpuMetric_CoreData(
      'id', cpu,
      'metrics', AndroidCpuMetric_Metrics(
        'mcycles', mcycles,
        'runtime_ns', runtime_ns,
        'min_freq_khz', min_freq_khz,
        'max_freq_khz', max_freq_khz,
        'avg_freq_khz', avg_freq_khz
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      )
    )
  ) AS proto
FROM raw_metrics_per_core
GROUP BY utid;

DROP VIEW IF EXISTS core_type_proto_per_thread;
CREATE PERFETTO VIEW core_type_proto_per_thread AS
SELECT
  utid,
  RepeatedField(
    AndroidCpuMetric_CoreTypeData(
      'type', core_type,
      'metrics', metrics_per_core_type.proto
    )
  ) AS proto
FROM metrics_per_core_type
GROUP BY utid;

DROP VIEW IF EXISTS metrics_proto_per_thread;
CREATE PERFETTO VIEW metrics_proto_per_thread AS
SELECT
  utid,
  AndroidCpuMetric_Metrics(
    'mcycles', SUM(mcycles),
    'runtime_ns', SUM(runtime_ns),
    'min_freq_khz', MIN(min_freq_khz),
    'max_freq_khz', MAX(max_freq_khz),
    -- See above for a breakdown of the maths used to compute the
    -- multiplicative factor.
    'avg_freq_khz', CAST((SUM(millicycles) / SUM(runtime_ns)) * 1000 AS INT)
  ) AS proto
FROM raw_metrics_per_core
GROUP BY utid;

-- Aggregate everything per perocess
DROP VIEW IF EXISTS thread_proto_per_process;
CREATE PERFETTO VIEW thread_proto_per_process AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  upid,
  RepeatedField(
    AndroidCpuMetric_Thread(
      'name', thread.name,
      'metrics', metrics_proto_per_thread.proto,
      'core', core_proto_per_thread.proto,
      'core_type', core_type_proto_per_thread.proto
    )
  ) AS proto
FROM thread
LEFT JOIN core_proto_per_thread USING (utid)
LEFT JOIN core_type_proto_per_thread USING (utid)
LEFT JOIN metrics_proto_per_thread USING(utid)
GROUP BY upid;

DROP VIEW IF EXISTS core_metrics_per_process;
CREATE PERFETTO VIEW core_metrics_per_process AS
SELECT
  upid,
  cpu,
  AndroidCpuMetric_Metrics(
    'mcycles', SUM(mcycles),
    'runtime_ns', SUM(runtime_ns),
    'min_freq_khz', MIN(min_freq_khz),
    'max_freq_khz', MAX(max_freq_khz),
    -- In total here, we need to divide the denominator by 1e9 (to convert
    -- ns to s) and divide the numerator by 1e6 (to convert millicycles to
    -- kcycles). In total, this means we need to multiply the expression as
    -- a whole by 1e3.
    'avg_freq_khz', CAST((SUM(millicycles) / SUM(runtime_ns)) * 1000 AS INT)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ) AS proto
FROM raw_metrics_per_core
JOIN thread USING (utid)
GROUP BY upid, cpu;

DROP VIEW IF EXISTS core_proto_per_process;
CREATE PERFETTO VIEW core_proto_per_process AS
SELECT
  upid,
  RepeatedField(
    AndroidCpuMetric_CoreData(
      'id', cpu,
      'metrics', core_metrics_per_process.proto
    )
  ) AS proto
FROM core_metrics_per_process
GROUP BY upid;

DROP VIEW IF EXISTS core_type_metrics_per_process;
CREATE PERFETTO VIEW core_type_metrics_per_process AS
SELECT
  upid,
  core_type,
  AndroidCpuMetric_Metrics(
    'mcycles', SUM(mcycles),
    'runtime_ns', SUM(runtime_ns),
    'min_freq_khz', MIN(min_freq_khz),
    'max_freq_khz', MAX(max_freq_khz),
    -- In total here, we need to divide the denominator by 1e9 (to convert
    -- ns to s) and divide the numerator by 1e6 (to convert millicycles to
    -- kcycles). In total, this means we need to multiply the expression as
    -- a whole by 1e3.
    'avg_freq_khz', CAST((SUM(millicycles) / SUM(runtime_ns)) * 1000 AS INT)
  ) AS proto
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM raw_metrics_per_core
JOIN thread USING (utid)
GROUP BY upid, core_type;

DROP VIEW IF EXISTS core_type_proto_per_process;
CREATE PERFETTO VIEW core_type_proto_per_process AS
SELECT
  upid,
  RepeatedField(
    AndroidCpuMetric_CoreTypeData(
      'type', core_type,
      'metrics', core_type_metrics_per_process.proto
    )
  ) AS proto
FROM core_type_metrics_per_process
GROUP BY upid;

DROP VIEW IF EXISTS metrics_proto_per_process;
CREATE PERFETTO VIEW metrics_proto_per_process AS
SELECT
  upid,
  AndroidCpuMetric_Metrics(
    'mcycles', SUM(mcycles),
    'runtime_ns', SUM(runtime_ns),
    'min_freq_khz', MIN(min_freq_khz),
    'max_freq_khz', MAX(max_freq_khz),
    -- See above for a breakdown of the maths used to compute the
    -- multiplicative factor.
    'avg_freq_khz', CAST((SUM(millicycles) / SUM(runtime_ns)) * 1000 AS INT)
  ) AS proto
FROM raw_metrics_per_core
JOIN thread USING (utid)
GROUP BY upid;

DROP VIEW IF EXISTS android_cpu_output;
CREATE PERFETTO VIEW android_cpu_output AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT AndroidCpuMetric(
  'process_info', (
    SELECT RepeatedField(
      AndroidCpuMetric_Process(
        'name', process.name,
        'process', process_metadata.metadata,
        'metrics', metrics_proto_per_process.proto,
        'threads', thread_proto_per_process.proto,
        'core', core_proto_per_process.proto,
        'core_type', core_type_proto_per_process.proto
      )
    )
    FROM process
    JOIN metrics_proto_per_process USING(upid)
    JOIN thread_proto_per_process USING (upid)
    JOIN core_proto_per_process USING (upid)
    JOIN core_type_proto_per_process USING (upid)
    JOIN process_metadata USING (upid)
  )
);

)_d3l1m1t3r_"
;

const char kAndroidAndroidCpuAgg[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- Create all the views used to aggregate CPU data.
-- View with start and end ts for each cpu frequency, per cpu.
DROP VIEW IF EXISTS cpu_freq_view;
CREATE PERFETTO VIEW cpu_freq_view AS
SELECT
  cpu,
  ts,
  LEAD(ts, 1, trace_end())
  OVER (PARTITION BY cpu ORDER BY ts) - ts AS dur,
  CAST(value AS INT) AS freq_khz
FROM counter
JOIN cpu_counter_track ON counter.track_id = cpu_counter_track.id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(WHERE name = 'cpufreq';

-- View that joins the cpufreq table with the slice table.
DROP TABLE IF EXISTS cpu_freq_sched_per_thread;
CREATE VIRTUAL TABLE cpu_freq_sched_per_thread
USING SPAN_LEFT_JOIN(sched PARTITIONED cpu, cpu_freq_view PARTITIONED cpu);

)_d3l1m1t3r_"
;

const char kAndroidAndroidCpuRawMetricsPerCore[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

SELECT RUN_METRIC('android/cpu_info.sql');

DROP TABLE IF EXISTS {{output_table}};
CREATE PERFETTO TABLE {{output_table}} AS
SELECT
  utid,
  cpu,
  IFNULL(core_type_per_cpu.core_type, 'unknown') AS core_type,
  -- We divide by 1e3 here as dur is in ns and freq_khz in khz. In total
  -- this means we need to divide the duration by 1e9 and multiply the
  -- frequency by 1e3 then multiply again by 1e3 to get millicycles
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- i.e. divide by 1e3 in total.
  -- We use millicycles as we want to preserve this level of precision
  -- for future calculations.
  CAST(SUM(dur * freq_khz / 1000) AS INT) AS millicycles,
  CAST(SUM(dur * freq_khz / 1000) / 1e9 AS INT) AS mcycles,
  SUM(dur) AS runtime_ns,
  MIN(freq_khz) AS min_freq_khz,
  MAX(freq_khz) AS max_freq_khz,
  -- We choose to work in micros space in both the numerator and
  -- denominator as this gives us good enough precision without risking
  -- overflows.
  CAST(SUM(dur * freq_khz / 1000) / SUM(dur / 1000) AS INT) AS avg_freq_khz
FROM {{input_table}}
LEFT JOIN core_type_per_cpu USING (cpu)
WHERE utid != 0 AND dur != -1
GROUP BY utid, cpu;

)_d3l1m1t3r_"
;

const char kAndroidAndroidDmaHeap[] = R"_d3l1m1t3r_(--
-- Copyright 2021 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

DROP VIEW IF EXISTS dma_heap_timeline;
CREATE PERFETTO VIEW dma_heap_timeline AS
SELECT
  ts,
  LEAD(ts, 1, trace_end())
  OVER(PARTITION BY track_id ORDER BY ts) - ts AS dur,
  track_id,
  value
FROM counter JOIN counter_track
  ON counter.track_id = counter_track.id
WHERE (name = 'mem.dma_heap');

DROP VIEW IF EXISTS dma_heap_stats;
CREATE PERFETTO VIEW dma_heap_stats AS
SELECT
  SUM(value * dur) / SUM(dur) AS avg_size,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  MIN(value) AS min_size,
  MAX(value) AS max_size
FROM dma_heap_timeline;

DROP VIEW IF EXISTS dma_heap_raw_allocs;
CREATE PERFETTO VIEW dma_heap_raw_allocs AS
SELECT
  ts,
  value AS instant_value,
  SUM(value) OVER win AS value
FROM counter c JOIN thread_counter_track t ON c.track_id = t.id
WHERE (name = 'mem.dma_heap_change') AND value > 0
WINDOW win AS (
  PARTITION BY name ORDER BY ts
  ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
);

DROP VIEW IF EXISTS dma_heap_total_stats;
CREATE PERFETTO VIEW dma_heap_total_stats AS
SELECT
  SUM(instant_value) AS total_alloc_size_bytes
FROM dma_heap_raw_allocs;

-- We need to group by ts here as we can have two ion events from
-- different processes occurring at the same timestamp. We take the
-- max as this will take both allocations into account at that
-- timestamp.
DROP VIEW IF EXISTS android_dma_heap_event;
CREATE PERFETTO VIEW android_dma_heap_event AS
SELECT
  'counter' AS track_type,
  printf('Buffers created from DMA-BUF heaps: ') AS track_name,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ts,
  MAX(value) AS value
FROM dma_heap_raw_allocs
GROUP BY 1, 2, 3;

DROP VIEW IF EXISTS android_dma_heap_output;
CREATE PERFETTO VIEW android_dma_heap_output AS
SELECT AndroidDmaHeapMetric(
  'avg_size_bytes', avg_size,
  'min_size_bytes', min_size,
  'max_size_bytes', max_size,
  'total_alloc_size_bytes', total_alloc_size_bytes
  )
FROM dma_heap_stats JOIN dma_heap_total_stats;

)_d3l1m1t3r_"
;

const char kAndroidAndroidDvfs[] = R"_d3l1m1t3r_(--
-- Copyright 2021 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

DROP VIEW IF EXISTS freq_slice;

CREATE PERFETTO VIEW freq_slice AS
SELECT
  counter.track_id AS track_id,
  track.name AS freq_name,
  ts,
  value AS freq_value,
  LEAD(ts, 1, trace_end()) OVER (PARTITION BY track.id ORDER BY ts) - ts AS duration
FROM counter
LEFT JOIN track ON counter.track_id = track.id
WHERE track.name GLOB "* Frequency"
ORDER BY ts;

DROP VIEW IF EXISTS freq_total_duration;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
CREATE PERFETTO VIEW freq_total_duration AS
SELECT
  track_id,
  freq_name,
  SUM(duration) AS total_duration
FROM freq_slice
WHERE duration > 0
GROUP BY track_id, freq_name;

DROP VIEW IF EXISTS dvfs_per_band_view;

CREATE PERFETTO VIEW dvfs_per_band_view AS
WITH
freq_duration AS (
  SELECT
    track_id,
    freq_name,
    CAST(freq_value AS int) AS freq_value,
    SUM(duration) AS duration_ns
  FROM freq_slice
  WHERE duration > 0
  GROUP BY track_id, freq_name, freq_value
)
SELECT
  freq_duration.track_id,
  freq_duration.freq_name,
  AndroidDvfsMetric_BandStat(
    'freq_value', freq_value,
    'percentage', duration_ns / (total_duration / 1e2),
    'duration_ns', duration_ns
  ) AS proto
FROM freq_duration
LEFT JOIN freq_total_duration
  USING(track_id)
ORDER BY freq_duration.freq_name, freq_duration.freq_value;

DROP VIEW IF EXISTS dvfs_per_freq_view;
CREATE PERFETTO VIEW dvfs_per_freq_view AS
SELECT
  AndroidDvfsMetric_FrequencyResidency(
    'freq_name', freq_total_duration.freq_name,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'band_stat', (
      SELECT
        RepeatedField(proto)
      FROM dvfs_per_band_view
      WHERE dvfs_per_band_view.track_id = freq_total_duration.track_id
    )
  ) AS proto
FROM freq_total_duration
GROUP BY track_id, freq_name
ORDER BY freq_name;

DROP VIEW IF EXISTS android_dvfs_output;
CREATE PERFETTO VIEW android_dvfs_output AS
SELECT AndroidDVFSMetric(
    'freq_residencies', (
      SELECT
        RepeatedField(proto)
      FROM dvfs_per_freq_view
    )
  );

)_d3l1m1t3r_"
;

const char kAndroidAndroidFastrpc[] = R"_d3l1m1t3r_(DROP VIEW IF EXISTS fastrpc_timeline;
CREATE PERFETTO VIEW fastrpc_timeline AS
SELECT
  ts,
  LEAD(ts, 1, trace_end())
  OVER(PARTITION BY track_id ORDER BY ts) - ts AS dur,
  RTRIM(SUBSTR(name, 13), ']') AS subsystem_name,
  track_id,
  value
FROM counter JOIN counter_track
  ON counter.track_id = counter_track.id
WHERE (name GLOB 'mem.fastrpc[[]*');

DROP VIEW IF EXISTS fastrpc_subsystem_stats;
CREATE PERFETTO VIEW fastrpc_subsystem_stats AS
SELECT
  subsystem_name,
  SUM(value * dur) / SUM(dur) AS avg_size,
  MIN(value) AS min_size,
  MAX(value) AS max_size
FROM fastrpc_timeline
GROUP BY 1;

DROP VIEW IF EXISTS fastrpc_raw_allocs;
CREATE PERFETTO VIEW fastrpc_raw_allocs AS
SELECT
  RTRIM(SUBSTR(name, 20), ']') AS subsystem_name,
  ts,
  value AS instant_value,
  SUM(value) OVER win AS value
FROM counter c JOIN thread_counter_track t ON c.track_id = t.id
WHERE name GLOB 'mem.fastrpc_change*' AND value > 0
WINDOW win AS (
  PARTITION BY name ORDER BY ts
  ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
)_d3l1m1t3r_"
R"_d3l1m1t3r_();

DROP VIEW IF EXISTS fastrpc_alloc_stats;
CREATE PERFETTO VIEW fastrpc_alloc_stats AS
SELECT
  subsystem_name,
  SUM(instant_value) AS total_alloc_size_bytes
FROM fastrpc_raw_allocs
GROUP BY 1;

-- We need to group by ts here as we can have two events from
-- different processes occurring at the same timestamp. We take the
-- max as this will take both allocations into account at that
-- timestamp.
DROP VIEW IF EXISTS android_fastrpc_event;
CREATE PERFETTO VIEW android_fastrpc_event AS
SELECT
  'counter' AS track_type,
  printf('fastrpc allocations (subsystem: %s)', subsystem_name) AS track_name,
  ts,
  MAX(value) AS value
FROM fastrpc_raw_allocs
GROUP BY 1, 2, 3;

DROP VIEW IF EXISTS android_fastrpc_output;
CREATE PERFETTO VIEW android_fastrpc_output AS
SELECT AndroidFastrpcMetric(
  'subsystem', RepeatedField(
    AndroidFastrpcMetric_Subsystem(
      'name', subsystem_name,
      'avg_size_bytes', avg_size,
      'min_size_bytes', min_size,
      'max_size_bytes', max_size,
      'total_alloc_size_bytes', total_alloc_size_bytes
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    )
  ))
FROM fastrpc_subsystem_stats JOIN fastrpc_alloc_stats USING (subsystem_name);

)_d3l1m1t3r_"
;

const char kAndroidAndroidFrameTimelineMetric[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

SELECT RUN_METRIC('android/process_metadata.sql');

DROP VIEW IF EXISTS splitted_jank_type_timeline;
CREATE PERFETTO VIEW splitted_jank_type_timeline AS
WITH RECURSIVE split_jank_type AS (
  SELECT
    upid,
    name,
    present_type,
    '' AS jank_type,
    jank_type || ', ' AS unparsed
  FROM actual_frame_timeline_slice
  UNION ALL
  SELECT
    upid,
    name,
    present_type,
    substr(unparsed, 1, instr(unparsed, ',')-1) AS jank_type,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    substr(unparsed, instr(unparsed, ',')+2) AS unparsed
  FROM split_jank_type
  WHERE unparsed != ''
)
SELECT
  upid,
  name AS vsync,
  present_type,
  jank_type
FROM split_jank_type
WHERE jank_type != '';

DROP VIEW IF EXISTS android_frame_timeline_metric_per_process;
CREATE PERFETTO VIEW android_frame_timeline_metric_per_process AS
WITH frames AS (
  SELECT
    process.upid,
    process.name AS process_name,
    timeline.name AS vsync,
    jank_type GLOB '*App Deadline Missed*' AS missed_app_frame,
    jank_type GLOB '*SurfaceFlinger CPU Deadline Missed*'
      OR jank_type GLOB '*SurfaceFlinger GPU Deadline Missed*'
      OR jank_type GLOB '*SurfaceFlinger Scheduling*'
      OR jank_type GLOB '*Prediction Error*'
      OR jank_type GLOB '*Display HAL*' AS missed_sf_frame,
    jank_type GLOB '*App Deadline Missed*'
      OR jank_type GLOB '*SurfaceFlinger CPU Deadline Missed*'
      OR jank_type GLOB '*SurfaceFlinger GPU Deadline Missed*'
      OR jank_type GLOB '*SurfaceFlinger Scheduling*'
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      OR jank_type GLOB '*Prediction Error*'
      OR jank_type GLOB '*Display HAL*'
      OR jank_type GLOB '*Dropped Frame*' AS missed_frame,
    jank_type GLOB '*Dropped Frame*' AS dropped_frame,
    -- discard dropped frame duration as it is not a meaningful value
    IIF(jank_type GLOB '*Dropped Frame*', NULL, dur) AS dur,
    IIF(jank_type GLOB '*Dropped Frame*', NULL, dur / 1e6) AS dur_ms
  FROM actual_frame_timeline_slice timeline
  JOIN process USING (upid))
SELECT
  upid,
  process_name,
  process_metadata.metadata AS process_metadata,
  COUNT(DISTINCT(vsync)) AS total_frames,
  COUNT(DISTINCT(IIF(missed_app_frame, vsync, NULL))) AS missed_app_frames,
  COUNT(DISTINCT(IIF(missed_sf_frame, vsync, NULL))) AS missed_sf_frames,
  COUNT(DISTINCT(IIF(missed_frame, vsync, NULL))) AS missed_frames,
  COUNT(DISTINCT(IIF(dropped_frame, vsync, NULL))) AS dropped_frames,
  CAST(PERCENTILE(dur, 50) AS INTEGER) AS frame_dur_p50,
  CAST(PERCENTILE(dur, 90) AS INTEGER) AS frame_dur_p90,
  CAST(PERCENTILE(dur, 95) AS INTEGER) AS frame_dur_p95,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  CAST(PERCENTILE(dur, 99) AS INTEGER) AS frame_dur_p99,
  PERCENTILE(dur_ms, 50) AS frame_dur_ms_p50,
  PERCENTILE(dur_ms, 90) AS frame_dur_ms_p90,
  PERCENTILE(dur_ms, 95) AS frame_dur_ms_p95,
  PERCENTILE(dur_ms, 99) AS frame_dur_ms_p99,
  CAST(AVG(dur) AS INTEGER) AS frame_dur_avg,
  MAX(dur) AS frame_dur_max
FROM frames
JOIN process_metadata USING (upid)
GROUP BY upid, process_name;

DROP VIEW IF EXISTS android_frame_timeline_metric_output;
CREATE PERFETTO VIEW android_frame_timeline_metric_output AS
WITH per_jank_type_metric AS (
  SELECT
    jank_type,
    COUNT(DISTINCT(vsync)) AS total_count,
    COUNT(DISTINCT(IIF(present_type = 'Unspecified Present', vsync, NULL))) AS present_unspecified_count,
    COUNT(DISTINCT(IIF(present_type = 'On-time Present', vsync, NULL))) AS present_on_time_count,
    COUNT(DISTINCT(IIF(present_type = 'Late Present', vsync, NULL))) AS present_late_count,
    COUNT(DISTINCT(IIF(present_type = 'Early Present', vsync, NULL))) AS present_early_count,
    COUNT(DISTINCT(IIF(present_type = 'Dropped Frame', vsync, NULL))) AS present_dropped_count,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    COUNT(DISTINCT(IIF(present_type = 'Unknown Present', vsync, NULL))) AS present_unknown_count
  FROM splitted_jank_type_timeline
  GROUP BY jank_type
),
per_process_jank_type_metric AS (
  SELECT
    upid,
    jank_type,
    COUNT(DISTINCT(vsync)) AS total_count,
    COUNT(DISTINCT(IIF(present_type = 'Unspecified Present', vsync, NULL))) AS present_unspecified_count,
    COUNT(DISTINCT(IIF(present_type = 'On-time Present', vsync, NULL))) AS present_on_time_count,
    COUNT(DISTINCT(IIF(present_type = 'Late Present', vsync, NULL))) AS present_late_count,
    COUNT(DISTINCT(IIF(present_type = 'Early Present', vsync, NULL))) AS present_early_count,
    COUNT(DISTINCT(IIF(present_type = 'Dropped Frame', vsync, NULL))) AS present_dropped_count,
    COUNT(DISTINCT(IIF(present_type = 'Unknown Present', vsync, NULL))) AS present_unknown_count
  FROM splitted_jank_type_timeline
  GROUP BY upid, jank_type
)
SELECT
  AndroidFrameTimelineMetric(
    'total_frames', SUM(total_frames),
    'missed_app_frames', SUM(missed_app_frames),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'dropped_frames', SUM(dropped_frames),
    'process', (
      SELECT
        RepeatedField(
          AndroidFrameTimelineMetric_ProcessBreakdown(
            'process', process_metadata,
            'total_frames', total_frames,
            'missed_frames', missed_frames,
            'missed_app_frames', missed_app_frames,
            'missed_sf_frames', missed_sf_frames,
            'frame_dur_max', frame_dur_max,
            'frame_dur_avg', frame_dur_avg,
            'frame_dur_p50', frame_dur_p50,
            'frame_dur_p90', frame_dur_p90,
            'frame_dur_p95', frame_dur_p95,
            'frame_dur_p99', frame_dur_p99,
            'frame_dur_ms_p50', frame_dur_ms_p50,
            'frame_dur_ms_p90', frame_dur_ms_p90,
            'frame_dur_ms_p95', frame_dur_ms_p95,
            'frame_dur_ms_p99', frame_dur_ms_p99,
            'dropped_frames', dropped_frames,
            'jank_types', (
              SELECT
                RepeatedField(
                  AndroidFrameTimelineMetric_JankTypeMetric(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(                    'type', jank_type,
                    'total_count', total_count,
                    'present_unspecified_count', present_unspecified_count,
                    'present_on_time_count', present_on_time_count,
                    'present_late_count', present_late_count,
                    'present_early_count', present_early_count,
                    'present_dropped_count', present_dropped_count,
                    'present_unknown_count', present_unknown_count
                  )
                )
              FROM per_process_jank_type_metric
              WHERE upid = process.upid
            )
          )
        )
      FROM android_frame_timeline_metric_per_process process
    ),
    'jank_types', (
      SELECT
        RepeatedField(
          AndroidFrameTimelineMetric_JankTypeMetric(
            'type', jank_type,
            'total_count', total_count,
            'present_unspecified_count', present_unspecified_count,
            'present_on_time_count', present_on_time_count,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(            'present_late_count', present_late_count,
            'present_early_count', present_early_count,
            'present_dropped_count', present_dropped_count,
            'present_unknown_count', present_unknown_count
          )
        )
      FROM per_jank_type_metric
    )
  )
FROM android_frame_timeline_metric_per_process;

)_d3l1m1t3r_"
;

const char kAndroidAndroidGarbageCollectionUnagg[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE android.garbage_collection;
INCLUDE PERFETTO MODULE android.suspend;

DROP VIEW IF EXISTS android_garbage_collection_unagg_output;
CREATE PERFETTO VIEW android_garbage_collection_unagg_output AS
SELECT AndroidGarbageCollectionUnaggMetric(
  'gc_events', (
    SELECT RepeatedField(
      AndroidGarbageCollectionUnaggMetric_GarbageCollectionEvent(
        'thread_name', thread_name,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(        'process_name', process_name,
        'gc_type', gc_type,
        'is_mark_compact', is_mark_compact,
        'reclaimed_mb', reclaimed_mb,
        'min_heap_mb', min_heap_mb,
        'max_heap_mb', max_heap_mb,
        'mb_per_ms_of_running_gc', reclaimed_mb/(gc_running_dur/1e6),
        'mb_per_ms_of_wall_gc', reclaimed_mb/(gc_dur/1e6),
        'gc_dur', gc_dur,
        'gc_running_dur', gc_running_dur,
        'gc_runnable_dur', gc_runnable_dur,
        'gc_unint_io_dur', gc_unint_io_dur,
        'gc_unint_non_io_dur', gc_unint_non_io_dur,
        'gc_int_dur', gc_int_dur,
        'gc_ts', gc_ts,
        'tid', tid,
        'pid', pid,
        'gc_monotonic_dur', _extract_duration_without_suspend(gc_ts, gc_dur)
      )) FROM android_garbage_collection_events
  )
);

)_d3l1m1t3r_"
;

const char kAndroidAndroidGpu[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

SELECT RUN_METRIC('android/global_counter_span_view.sql',
  'table_name', 'global_gpu_memory',
  'counter_name', 'GPU Memory');

SELECT RUN_METRIC('android/process_counter_span_view.sql',
  'table_name', 'proc_gpu_memory',
  'counter_name', 'GPU Memory');

DROP VIEW IF EXISTS proc_gpu_memory_view;
CREATE PERFETTO VIEW proc_gpu_memory_view AS
SELECT
  upid,
  MAX(proc_gpu_memory_val) AS mem_max,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  MIN(proc_gpu_memory_val) AS mem_min,
  SUM(proc_gpu_memory_val * dur) AS mem_valxdur,
  SUM(dur) AS mem_dur
FROM proc_gpu_memory_span
GROUP BY upid;

DROP VIEW IF EXISTS agg_proc_gpu_view;
CREATE PERFETTO VIEW agg_proc_gpu_view AS
SELECT
  name,
  MAX(mem_max) AS mem_max,
  MIN(mem_min) AS mem_min,
  SUM(mem_valxdur) / SUM(mem_dur) AS mem_avg
FROM process
JOIN proc_gpu_memory_view
  USING(upid)
GROUP BY name;

DROP VIEW IF EXISTS proc_gpu_view;
CREATE PERFETTO VIEW proc_gpu_view AS
SELECT
  AndroidGpuMetric_Process(
    'name', name,
    'mem_max', CAST(mem_max AS INT64),
    'mem_min', CAST(mem_min AS INT64),
    'mem_avg', CAST(mem_avg AS INT64)
  ) AS proto
FROM agg_proc_gpu_view;

SELECT RUN_METRIC('android/gpu_counter_span_view.sql',
  'table_name', 'gpu_freq',
  'counter_name', 'gpufreq');

DROP VIEW IF EXISTS metrics_per_freq_view;
CREATE PERFETTO VIEW metrics_per_freq_view AS
WITH
total_dur_per_freq AS (
  SELECT
    gpu_id,
    gpu_freq_val AS freq,
    SUM(dur) AS dur_ns
  FROM gpu_freq_span
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  GROUP BY gpu_id, gpu_freq_val
),
total_dur_per_gpu AS (
  SELECT
    gpu_id,
    SUM(dur) AS dur_ns
  FROM gpu_freq_span
  GROUP BY gpu_id
)
SELECT
  gpu_id,
  AndroidGpuMetric_FrequencyMetric_MetricsPerFrequency(
    'freq', CAST(freq AS INT64),
    'dur_ms', f.dur_ns / 1e6,
    'percentage', f.dur_ns * 100.0 / g.dur_ns
  ) AS proto
FROM total_dur_per_freq f LEFT JOIN total_dur_per_gpu g USING (gpu_id);

DROP VIEW IF EXISTS gpu_freq_metrics_view;
CREATE PERFETTO VIEW gpu_freq_metrics_view AS
SELECT
  AndroidGpuMetric_FrequencyMetric(
    'gpu_id', gpu_id,
    'freq_max', CAST(MAX(gpu_freq_val) AS INT64),
    'freq_min', CAST(MIN(gpu_freq_val) AS INT64),
    'freq_avg', SUM(gpu_freq_val * dur) / SUM(dur),
    'used_freqs', (SELECT RepeatedField(proto) FROM metrics_per_freq_view
      WHERE metrics_per_freq_view.gpu_id = gpu_freq_span.gpu_id)
  ) AS proto
FROM gpu_freq_span
GROUP BY gpu_id;

DROP VIEW IF EXISTS android_gpu_output;
CREATE PERFETTO VIEW android_gpu_output AS
SELECT AndroidGpuMetric(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  'processes', (SELECT RepeatedField(proto) FROM proc_gpu_view),
  'mem_max', CAST(MAX(global_gpu_memory_val) AS INT64),
  'mem_min', CAST(MIN(global_gpu_memory_val) AS INT64),
  'mem_avg', CAST(SUM(global_gpu_memory_val * dur) / SUM(dur) AS INT64),
  'freq_metrics', (SELECT RepeatedField(proto) FROM gpu_freq_metrics_view)
)
FROM global_gpu_memory_span;

)_d3l1m1t3r_"
;

const char kAndroidAndroidHwcomposer[] = R"_d3l1m1t3r_(--
-- Copyright 2021 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

SELECT RUN_METRIC(
  'android/composition_layers.sql',
  'track_name', 'HWComposer: Total Layer',
  'output', 'total_layers'
);

SELECT RUN_METRIC(
  'android/composition_layers.sql',
  'track_name', 'HWComposer: DPU Layer',
  'output', 'dpu_layers'
);

SELECT RUN_METRIC(
  'android/composition_layers.sql',
  'track_name', 'HWComposer: GPU Layer',
  'output', 'gpu_layers'
);

SELECT RUN_METRIC(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  'android/composition_layers.sql',
  'track_name', 'HWComposer: DPU Cached Layer',
  'output', 'dpu_cached_layers'
);

SELECT RUN_METRIC(
  'android/composition_layers.sql',
  'track_name', 'HWComposer: SF Cached Layer',
  'output', 'sf_cached_layers'
);

SELECT RUN_METRIC(
  'android/composition_layers.sql',
  'track_name', 'HWComposer: RCD Layer',
  'output', 'rcd_layers'
);

SELECT RUN_METRIC(
  'android/composer_execution.sql',
  'output', 'hwc_execution_spans'
);


DROP VIEW IF EXISTS display_ids;
CREATE PERFETTO VIEW display_ids AS
SELECT DISTINCT display_id
FROM (
  SELECT display_id FROM total_layers
  UNION
  SELECT display_id FROM dpu_layers
  UNION
  SELECT display_id FROM gpu_layers
  UNION
  SELECT display_id FROM dpu_cached_layers
  UNION
  SELECT display_id FROM sf_cached_layers
  UNION
  SELECT display_id FROM rcd_layers
  UNION
  SELECT display_id FROM hwc_execution_spans
);

DROP VIEW IF EXISTS metrics_per_display;
CREATE PERFETTO VIEW metrics_per_display AS
SELECT AndroidHwcomposerMetrics_MetricsPerDisplay(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  'display_id', display_id,
  'composition_total_layers',
  (SELECT AVG(value) FROM total_layers WHERE display_id = d.display_id),
  'composition_dpu_layers',
  (SELECT AVG(value) FROM dpu_layers WHERE display_id = d.display_id),
  'composition_gpu_layers',
  (SELECT AVG(value) FROM gpu_layers WHERE display_id = d.display_id),
  'composition_dpu_cached_layers',
  (SELECT AVG(value) FROM dpu_cached_layers WHERE display_id = d.display_id),
  'composition_sf_cached_layers',
  (SELECT AVG(value) FROM sf_cached_layers WHERE display_id = d.display_id),
  'composition_rcd_layers',
  (SELECT AVG(value) FROM rcd_layers WHERE display_id = d.display_id),
  'skipped_validation_count',
  (SELECT COUNT(*) FROM hwc_execution_spans
    WHERE display_id = d.display_id AND validation_type = 'skipped_validation'),
  'unskipped_validation_count',
  (SELECT COUNT(*) FROM hwc_execution_spans
    WHERE display_id = d.display_id AND validation_type = 'unskipped_validation'),
  'separated_validation_count',
  (SELECT COUNT(*) FROM hwc_execution_spans
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    WHERE display_id = d.display_id AND validation_type = 'separated_validation'),
  'unknown_validation_count',
  (SELECT COUNT(*) FROM hwc_execution_spans
    WHERE display_id = d.display_id AND validation_type = 'unknown'),
  'avg_all_execution_time_ms',
  (SELECT AVG(execution_time_ns) / 1e6 FROM hwc_execution_spans
    WHERE display_id = d.display_id AND validation_type != 'unknown'),
  'avg_skipped_execution_time_ms',
  (SELECT AVG(execution_time_ns) / 1e6 FROM hwc_execution_spans
    WHERE display_id = d.display_id AND validation_type = 'skipped_validation'),
  'avg_unskipped_execution_time_ms',
  (SELECT AVG(execution_time_ns) / 1e6 FROM hwc_execution_spans
    WHERE display_id = d.display_id AND validation_type = 'unskipped_validation'),
  'avg_separated_execution_time_ms',
  (SELECT AVG(execution_time_ns) / 1e6 FROM hwc_execution_spans
    WHERE display_id = d.display_id AND validation_type = 'separated_validation')
) AS proto
FROM display_ids d;

SELECT RUN_METRIC('android/process_counter_span_view.sql',
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  'table_name', 'dpu_vote_clock',
  'counter_name', 'dpu_vote_clock'
);

SELECT RUN_METRIC('android/process_counter_span_view.sql',
  'table_name', 'dpu_vote_avg_bw',
  'counter_name', 'dpu_vote_avg_bw'
);

SELECT RUN_METRIC('android/process_counter_span_view.sql',
  'table_name', 'dpu_vote_peak_bw',
  'counter_name', 'dpu_vote_peak_bw'
);

SELECT RUN_METRIC('android/process_counter_span_view.sql',
  'table_name', 'dpu_vote_rt_bw',
  'counter_name', 'dpu_vote_rt_bw'
);

DROP VIEW IF EXISTS dpu_vote_process;
CREATE PERFETTO VIEW dpu_vote_process AS
SELECT DISTINCT p.upid, p.pid
FROM (
  SELECT upid FROM dpu_vote_clock_span
  UNION
  SELECT upid FROM dpu_vote_avg_bw_span
  UNION
  SELECT upid FROM dpu_vote_peak_bw_span
) s JOIN process p USING (upid);

-- These systrace counters are coming from dedicated kernel threads, so we can
-- assume pid = tid.
DROP VIEW IF EXISTS dpu_vote_metrics;
CREATE PERFETTO VIEW dpu_vote_metrics AS
SELECT AndroidHwcomposerMetrics_DpuVoteMetrics(
  'tid', pid,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  'avg_dpu_vote_clock',
  (SELECT SUM(dpu_vote_clock_val * dur) / SUM(dur)
    FROM dpu_vote_clock_span s WHERE s.upid = p.upid),
  'avg_dpu_vote_avg_bw',
  (SELECT SUM(dpu_vote_avg_bw_val * dur) / SUM(dur)
    FROM dpu_vote_avg_bw_span s WHERE s.upid = p.upid),
  'avg_dpu_vote_peak_bw',
  (SELECT SUM(dpu_vote_peak_bw_val * dur) / SUM(dur)
    FROM dpu_vote_peak_bw_span s WHERE s.upid = p.upid),
  'avg_dpu_vote_rt_bw',
  (SELECT SUM(dpu_vote_rt_bw_val * dur) / SUM(dur)
    FROM dpu_vote_rt_bw_span s WHERE s.upid = p.upid)
) AS proto
FROM dpu_vote_process p
ORDER BY pid;

DROP VIEW IF EXISTS android_hwcomposer_output;
CREATE PERFETTO VIEW android_hwcomposer_output AS
SELECT AndroidHwcomposerMetrics(
  'composition_total_layers', (SELECT AVG(value) FROM total_layers),
  'composition_dpu_layers', (SELECT AVG(value) FROM dpu_layers),
  'composition_gpu_layers', (SELECT AVG(value) FROM gpu_layers),
  'composition_dpu_cached_layers', (SELECT AVG(value) FROM dpu_cached_layers),
  'composition_sf_cached_layers', (SELECT AVG(value) FROM sf_cached_layers),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  'composition_rcd_layers', (SELECT AVG(value) FROM rcd_layers),
  'skipped_validation_count',
  (SELECT COUNT(*) FROM hwc_execution_spans
    WHERE validation_type = 'skipped_validation'),
  'unskipped_validation_count',
  (SELECT COUNT(*) FROM hwc_execution_spans
    WHERE validation_type = 'unskipped_validation'),
  'separated_validation_count',
  (SELECT COUNT(*) FROM hwc_execution_spans
    WHERE validation_type = 'separated_validation'),
  'unknown_validation_count',
  (SELECT COUNT(*) FROM hwc_execution_spans
    WHERE validation_type = 'unknown'),
  'avg_all_execution_time_ms',
  (SELECT AVG(execution_time_ns) / 1e6 FROM hwc_execution_spans
    WHERE validation_type != 'unknown'),
  'avg_skipped_execution_time_ms',
  (SELECT AVG(execution_time_ns) / 1e6 FROM hwc_execution_spans
    WHERE validation_type = 'skipped_validation'),
  'avg_unskipped_execution_time_ms',
  (SELECT AVG(execution_time_ns) / 1e6 FROM hwc_execution_spans
    WHERE validation_type = 'unskipped_validation'),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  'avg_separated_execution_time_ms',
  (SELECT AVG(execution_time_ns) / 1e6 FROM hwc_execution_spans
    WHERE validation_type = 'separated_validation'),
  'dpu_vote_metrics', (SELECT RepeatedField(proto) FROM dpu_vote_metrics),
  'metrics_per_display', (SELECT RepeatedField(proto) FROM metrics_per_display)
);

)_d3l1m1t3r_"
;

const char kAndroidAndroidHwuiMetric[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--


-- TOP processes that have a RenderThread, sorted by CPU time on RT
DROP VIEW IF EXISTS hwui_processes;
CREATE PERFETTO VIEW hwui_processes AS
SELECT
  process.name AS process_name,
  process.upid AS process_upid,
  CAST(SUM(sched.dur) / 1e6 AS INT64) AS rt_cpu_time_ms,
  thread.utid AS render_thread_id
FROM sched
JOIN thread ON (thread.utid = sched.utid AND thread.name = 'RenderThread')
)_d3l1m1t3r_"
R"_d3l1m1t3r_(JOIN process ON (process.upid = thread.upid)
GROUP BY process.name
ORDER BY rt_cpu_time_ms DESC;

DROP VIEW IF EXISTS hwui_draw_frame;
CREATE PERFETTO VIEW hwui_draw_frame AS
SELECT
  count(*) AS draw_frame_count,
  max(dur) AS draw_frame_max,
  min(dur) AS draw_frame_min,
  avg(dur) AS draw_frame_avg,
  thread_track.utid AS render_thread_id
FROM slice
JOIN thread_track ON (thread_track.id = slice.track_id)
WHERE slice.name GLOB 'DrawFrame*' AND slice.dur >= 0
GROUP BY thread_track.utid;

DROP VIEW IF EXISTS hwui_flush_commands;
CREATE PERFETTO VIEW hwui_flush_commands AS
SELECT
  count(*) AS flush_count,
  max(dur) AS flush_max,
  min(dur) AS flush_min,
  avg(dur) AS flush_avg,
  thread_track.utid AS render_thread_id
FROM slice
JOIN thread_track ON (thread_track.id = slice.track_id)
WHERE slice.name = 'flush commands' AND slice.dur >= 0
GROUP BY thread_track.utid;

DROP VIEW IF EXISTS hwui_prepare_tree;
CREATE PERFETTO VIEW hwui_prepare_tree AS
SELECT
  count(*) AS prepare_tree_count,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  max(dur) AS prepare_tree_max,
  min(dur) AS prepare_tree_min,
  avg(dur) AS prepare_tree_avg,
  thread_track.utid AS render_thread_id
FROM slice
JOIN thread_track ON (thread_track.id = slice.track_id)
WHERE slice.name = 'prepareTree' AND slice.dur >= 0
GROUP BY thread_track.utid;

DROP VIEW IF EXISTS hwui_gpu_completion;
CREATE PERFETTO VIEW hwui_gpu_completion AS
SELECT
  count(*) AS gpu_completion_count,
  max(dur) AS gpu_completion_max,
  min(dur) AS gpu_completion_min,
  avg(dur) AS gpu_completion_avg,
  thread.upid AS process_upid
FROM slice
JOIN thread_track ON (thread_track.id = slice.track_id)
JOIN thread ON (thread.name = 'GPU completion' AND thread.utid = thread_track.utid)
WHERE slice.name GLOB 'waiting for GPU completion*' AND slice.dur >= 0
GROUP BY thread_track.utid;

DROP VIEW IF EXISTS hwui_ui_record;
CREATE PERFETTO VIEW hwui_ui_record AS
SELECT
  count(*) AS ui_record_count,
  max(dur) AS ui_record_max,
  min(dur) AS ui_record_min,
  avg(dur) AS ui_record_avg,
  thread.upid AS process_upid
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM slice
JOIN thread_track ON (thread_track.id = slice.track_id)
JOIN thread ON (thread.name = substr(process.name, -15) AND thread.utid = thread_track.utid)
JOIN process ON (process.upid = thread.upid)
WHERE slice.name = 'Record View#draw()' AND slice.dur >= 0
GROUP BY thread_track.utid;

DROP VIEW IF EXISTS hwui_shader_compile;
CREATE PERFETTO VIEW hwui_shader_compile AS
SELECT
  count(*) AS shader_compile_count,
  sum(dur) AS shader_compile_time,
  avg(dur) AS shader_compile_avg,
  thread_track.utid AS render_thread_id
FROM slice
JOIN thread_track ON (thread_track.id = slice.track_id)
WHERE slice.name = 'shader_compile' AND slice.dur >= 0
GROUP BY thread_track.utid;

DROP VIEW IF EXISTS hwui_cache_hit;
CREATE PERFETTO VIEW hwui_cache_hit AS
SELECT
  count(*) AS cache_hit_count,
  sum(dur) AS cache_hit_time,
  avg(dur) AS cache_hit_avg,
  thread_track.utid AS render_thread_id
FROM slice
JOIN thread_track ON (thread_track.id = slice.track_id)
WHERE slice.name = 'cache_hit' AND slice.dur >= 0
)_d3l1m1t3r_"
R"_d3l1m1t3r_(GROUP BY thread_track.utid;

DROP VIEW IF EXISTS hwui_cache_miss;
CREATE PERFETTO VIEW hwui_cache_miss AS
SELECT
  count(*) AS cache_miss_count,
  sum(dur) AS cache_miss_time,
  avg(dur) AS cache_miss_avg,
  thread_track.utid AS render_thread_id
FROM slice
JOIN thread_track ON (thread_track.id = slice.track_id)
WHERE slice.name = 'cache_miss' AND slice.dur >= 0
GROUP BY thread_track.utid;

DROP VIEW IF EXISTS hwui_graphics_cpu_mem;
CREATE PERFETTO VIEW hwui_graphics_cpu_mem AS
SELECT
  max(value) AS graphics_cpu_mem_max,
  min(value) AS graphics_cpu_mem_min,
  avg(value) AS graphics_cpu_mem_avg,
  process_counter_track.upid AS process_upid
FROM counter
JOIN process_counter_track ON (counter.track_id = process_counter_track.id)
WHERE name = 'HWUI CPU Memory' AND counter.value >= 0
GROUP BY process_counter_track.upid;

DROP VIEW IF EXISTS hwui_graphics_gpu_mem;
CREATE PERFETTO VIEW hwui_graphics_gpu_mem AS
SELECT
  max(value) AS graphics_gpu_mem_max,
  min(value) AS graphics_gpu_mem_min,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  avg(value) AS graphics_gpu_mem_avg,
  process_counter_track.upid AS process_upid
FROM counter
JOIN process_counter_track ON (counter.track_id = process_counter_track.id)
WHERE name = 'HWUI Misc Memory' AND counter.value >= 0
GROUP BY process_counter_track.upid;

DROP VIEW IF EXISTS hwui_texture_mem;
CREATE PERFETTO VIEW hwui_texture_mem AS
SELECT
  max(value) AS texture_mem_max,
  min(value) AS texture_mem_min,
  avg(value) AS texture_mem_avg,
  process_counter_track.upid AS process_upid
FROM counter
JOIN process_counter_track ON (counter.track_id = process_counter_track.id)
WHERE name = 'HWUI Texture Memory' AND counter.value >= 0
GROUP BY process_counter_track.upid;

DROP VIEW IF EXISTS hwui_all_mem;
CREATE PERFETTO VIEW hwui_all_mem AS
SELECT
  max(value) AS all_mem_max,
  min(value) AS all_mem_min,
  avg(value) AS all_mem_avg,
  process_counter_track.upid AS process_upid
FROM counter
JOIN process_counter_track ON (counter.track_id = process_counter_track.id)
WHERE name = 'HWUI All Memory' AND counter.value >= 0
)_d3l1m1t3r_"
R"_d3l1m1t3r_(GROUP BY process_counter_track.upid;

DROP VIEW IF EXISTS android_hwui_metric_output;
CREATE PERFETTO VIEW android_hwui_metric_output AS
SELECT AndroidHwuiMetric(
  'process_info', (
    SELECT RepeatedField(
      ProcessRenderInfo(
        'process_name', process_name,
        'rt_cpu_time_ms', rt_cpu_time_ms,

        'draw_frame_count', hwui_draw_frame.draw_frame_count,
        'draw_frame_max', hwui_draw_frame.draw_frame_max,
        'draw_frame_min', hwui_draw_frame.draw_frame_min,
        'draw_frame_avg', hwui_draw_frame.draw_frame_avg,

        'flush_count', hwui_flush_commands.flush_count,
        'flush_max', hwui_flush_commands.flush_max,
        'flush_min', hwui_flush_commands.flush_min,
        'flush_avg', hwui_flush_commands.flush_avg,

        'prepare_tree_count', hwui_prepare_tree.prepare_tree_count,
        'prepare_tree_max', hwui_prepare_tree.prepare_tree_max,
        'prepare_tree_min', hwui_prepare_tree.prepare_tree_min,
        'prepare_tree_avg', hwui_prepare_tree.prepare_tree_avg,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
        'gpu_completion_count', hwui_gpu_completion.gpu_completion_count,
        'gpu_completion_max', hwui_gpu_completion.gpu_completion_max,
        'gpu_completion_min', hwui_gpu_completion.gpu_completion_min,
        'gpu_completion_avg', hwui_gpu_completion.gpu_completion_avg,

        'ui_record_count', hwui_ui_record.ui_record_count,
        'ui_record_max', hwui_ui_record.ui_record_max,
        'ui_record_min', hwui_ui_record.ui_record_min,
        'ui_record_avg', hwui_ui_record.ui_record_avg,

        'shader_compile_count', hwui_shader_compile.shader_compile_count,
        'shader_compile_time', hwui_shader_compile.shader_compile_time,
        'shader_compile_avg', hwui_shader_compile.shader_compile_avg,

        'cache_hit_count', hwui_cache_hit.cache_hit_count,
        'cache_hit_time', hwui_cache_hit.cache_hit_time,
        'cache_hit_avg', hwui_cache_hit.cache_hit_avg,

        'cache_miss_count', hwui_cache_miss.cache_miss_count,
        'cache_miss_time', hwui_cache_miss.cache_miss_time,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(        'cache_miss_avg', hwui_cache_miss.cache_miss_avg,

        'graphics_cpu_mem_max', CAST(hwui_graphics_cpu_mem.graphics_cpu_mem_max AS INT64),
        'graphics_cpu_mem_min', CAST(hwui_graphics_cpu_mem.graphics_cpu_mem_min AS INT64),
        'graphics_cpu_mem_avg', hwui_graphics_cpu_mem.graphics_cpu_mem_avg,

        'graphics_gpu_mem_max', CAST(hwui_graphics_gpu_mem.graphics_gpu_mem_max AS INT64),
        'graphics_gpu_mem_min', CAST(hwui_graphics_gpu_mem.graphics_gpu_mem_min AS INT64),
        'graphics_gpu_mem_avg', hwui_graphics_gpu_mem.graphics_gpu_mem_avg,

        'texture_mem_max', CAST(hwui_texture_mem.texture_mem_max AS INT64),
        'texture_mem_min', CAST(hwui_texture_mem.texture_mem_min AS INT64),
        'texture_mem_avg', hwui_texture_mem.texture_mem_avg,

        'all_mem_max', CAST(hwui_all_mem.all_mem_max AS INT64),
        'all_mem_min', CAST(hwui_all_mem.all_mem_min AS INT64),
        'all_mem_avg', hwui_all_mem.all_mem_avg
      )
    )
    FROM hwui_processes
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    LEFT JOIN hwui_draw_frame ON (hwui_draw_frame.render_thread_id = hwui_processes.render_thread_id)
    LEFT JOIN hwui_flush_commands ON (hwui_flush_commands.render_thread_id = hwui_processes.render_thread_id)
    LEFT JOIN hwui_prepare_tree ON (hwui_prepare_tree.render_thread_id = hwui_processes.render_thread_id)
    LEFT JOIN hwui_gpu_completion ON (hwui_gpu_completion.process_upid = hwui_processes.process_upid)
    LEFT JOIN hwui_ui_record ON (hwui_ui_record.process_upid = hwui_processes.process_upid)
    LEFT JOIN hwui_shader_compile ON (hwui_shader_compile.render_thread_id = hwui_processes.render_thread_id)
    LEFT JOIN hwui_cache_hit ON (hwui_cache_hit.render_thread_id = hwui_processes.render_thread_id)
    LEFT JOIN hwui_cache_miss ON (hwui_cache_miss.render_thread_id = hwui_processes.render_thread_id)
    LEFT JOIN hwui_graphics_cpu_mem ON (hwui_graphics_cpu_mem.process_upid = hwui_processes.process_upid)
    LEFT JOIN hwui_graphics_gpu_mem ON (hwui_graphics_gpu_mem.process_upid = hwui_processes.process_upid)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    LEFT JOIN hwui_texture_mem ON (hwui_texture_mem.process_upid = hwui_processes.process_upid)
    LEFT JOIN hwui_all_mem ON (hwui_all_mem.process_upid = hwui_processes.process_upid)
  )
);

)_d3l1m1t3r_"
;

const char kAndroidAndroidHwuiThreads[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--


DROP VIEW IF EXISTS {{table_name_prefix}}_main_thread;
CREATE PERFETTO VIEW {{table_name_prefix}}_main_thread AS
SELECT
  process.name AS process_name,
  thread.utid
FROM thread
JOIN {{process_allowlist_table}} process_allowlist USING (upid)
JOIN process USING (upid)
WHERE thread.is_main_thread;

DROP VIEW IF EXISTS {{table_name_prefix}}_render_thread;
CREATE PERFETTO VIEW {{table_name_prefix}}_render_thread AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  process.name AS process_name,
  thread.utid
FROM thread
JOIN {{process_allowlist_table}} process_allowlist USING (upid)
JOIN process USING (upid)
WHERE thread.name = 'RenderThread';

DROP VIEW IF EXISTS {{table_name_prefix}}_gpu_completion_thread;
CREATE PERFETTO VIEW {{table_name_prefix}}_gpu_completion_thread AS
SELECT
  process.name AS process_name,
  thread.utid
FROM thread
JOIN {{process_allowlist_table}} process_allowlist USING (upid)
JOIN process USING (upid)
WHERE thread.name = 'GPU completion';

DROP VIEW IF EXISTS {{table_name_prefix}}_hwc_release_thread;
CREATE PERFETTO VIEW {{table_name_prefix}}_hwc_release_thread AS
SELECT
  process.name AS process_name,
  thread.utid
FROM thread
JOIN {{process_allowlist_table}} process_allowlist USING (upid)
JOIN process USING (upid)
WHERE thread.name = 'HWC release';

DROP TABLE IF EXISTS {{table_name_prefix}}_main_thread_slices;
CREATE PERFETTO TABLE {{table_name_prefix}}_main_thread_slices AS
SELECT
  process_name,
  thread.utid,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  slice.*,
  ts + dur AS ts_end
FROM slice
JOIN thread_track ON slice.track_id = thread_track.id
JOIN {{table_name_prefix}}_main_thread thread USING (utid)
WHERE dur > 0;

DROP VIEW IF EXISTS {{table_name_prefix}}_do_frame_slices;
CREATE PERFETTO VIEW {{table_name_prefix}}_do_frame_slices AS
SELECT
  *,
  CAST(STR_SPLIT(name, ' ', 1) AS INTEGER) AS vsync
FROM {{table_name_prefix}}_main_thread_slices
WHERE name GLOB 'Choreographer#doFrame*';

DROP TABLE IF EXISTS {{table_name_prefix}}_render_thread_slices;
CREATE PERFETTO TABLE {{table_name_prefix}}_render_thread_slices AS
SELECT
  process_name,
  thread.utid,
  slice.*,
  ts + dur AS ts_end
FROM slice
JOIN thread_track ON slice.track_id = thread_track.id
JOIN {{table_name_prefix}}_render_thread thread USING (utid)
WHERE dur > 0;

DROP VIEW IF EXISTS {{table_name_prefix}}_draw_frame_slices;
CREATE PERFETTO VIEW {{table_name_prefix}}_draw_frame_slices AS
SELECT
  *,
  CAST(STR_SPLIT(name, ' ', 1) AS INTEGER) AS vsync
FROM {{table_name_prefix}}_render_thread_slices
)_d3l1m1t3r_"
R"_d3l1m1t3r_(WHERE name GLOB 'DrawFrame*';

DROP VIEW IF EXISTS {{table_name_prefix}}_gpu_completion_slices;
CREATE PERFETTO VIEW {{table_name_prefix}}_gpu_completion_slices AS
SELECT
  process_name,
  thread.utid,
  slice.*,
  ts + dur AS ts_end,
  -- Extracts 1234 from 'waiting for GPU completion 1234'
  CAST(STR_SPLIT(slice.name, ' ', 4) AS INTEGER) AS idx
FROM slice
JOIN thread_track ON slice.track_id = thread_track.id
JOIN {{table_name_prefix}}_gpu_completion_thread thread USING (utid)
WHERE slice.name GLOB 'waiting for GPU completion *'
  AND dur > 0;

DROP VIEW IF EXISTS {{table_name_prefix}}_hwc_release_slices;
CREATE PERFETTO VIEW {{table_name_prefix}}_hwc_release_slices AS
SELECT
  process_name,
  thread.utid,
  slice.*,
  ts + dur AS ts_end,
  -- Extracts 1234 from 'waiting for HWC release 1234'
  CAST(STR_SPLIT(slice.name, ' ', 4) AS INTEGER) AS idx
FROM slice
JOIN thread_track ON slice.track_id = thread_track.id
JOIN {{table_name_prefix}}_hwc_release_thread thread USING (utid)
WHERE slice.name GLOB 'waiting for HWC release *'
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  AND dur > 0;

)_d3l1m1t3r_"
;

const char kAndroidAndroidIo[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE android.io;

DROP VIEW IF EXISTS android_io_output;
CREATE PERFETTO VIEW android_io_output AS
SELECT AndroidIo(
    'f2fs_counter_stats', (
        SELECT RepeatedField(
            AndroidIo_F2fsCounterStats(
                'name', name,
                'sum', sum,
                'max', max,
                'min', min,
                'dur', dur,
                'count', count,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(                'avg', avg
            )
        )
        FROM _android_io_f2fs_counter_stats
    ),
    'f2fs_write_stats', (
        SELECT RepeatedField(
            AndroidIo_F2fsWriteStats(
                'total_write_count', total_write_count,
                'distinct_processes', distinct_processes,
                'total_bytes_written', total_bytes_written,
                'distinct_device_count', distinct_device_count,
                'distinct_inode_count', distinct_inode_count,
                'distinct_thread_count', distinct_thread_count
            )
        )
        FROM _android_io_f2fs_aggregate_write_stats
    )
);
)_d3l1m1t3r_"
;

const char kAndroidAndroidIoUnagg[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE android.io;

DROP VIEW IF EXISTS android_io_unagg_output;
CREATE PERFETTO VIEW android_io_unagg_output AS
SELECT AndroidIoUnaggregated(
    'f2fs_write_unaggregated_stats', (
        SELECT RepeatedField(
            AndroidIoUnaggregated_F2fsWriteUnaggreagatedStat(
                'tid', tid,
                'thread_name', thread_name,
                'pid', pid,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(                'process_name', process_name,
                'ino', ino,
                'dev', dev
            )
        )
        FROM _android_io_f2fs_write_stats
    )
);
)_d3l1m1t3r_"
;

const char kAndroidAndroidIon[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

DROP VIEW IF EXISTS ion_timeline;
CREATE PERFETTO VIEW ion_timeline AS
SELECT
  ts,
  LEAD(ts, 1, trace_end())
  OVER(PARTITION BY track_id ORDER BY ts) - ts AS dur,
  CASE name
    WHEN 'mem.ion' THEN 'all'
    ELSE SUBSTR(name, 9)
  END AS heap_name,
  track_id,
  value
FROM counter JOIN counter_track
  ON counter.track_id = counter_track.id
WHERE (name GLOB 'mem.ion.*' OR name = 'mem.ion');
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
DROP VIEW IF EXISTS ion_heap_stats;
CREATE PERFETTO VIEW ion_heap_stats AS
SELECT
  heap_name,
  SUM(value * dur) / SUM(dur) AS avg_size,
  MIN(value) AS min_size,
  MAX(value) AS max_size
FROM ion_timeline
GROUP BY 1;

DROP VIEW IF EXISTS ion_raw_allocs;
CREATE PERFETTO VIEW ion_raw_allocs AS
SELECT
  CASE name
    WHEN 'mem.ion_change' THEN 'all'
    ELSE SUBSTR(name, 16)
  END AS heap_name,
  ts,
  value AS instant_value,
  SUM(value) OVER win AS value
FROM counter c JOIN thread_counter_track t ON c.track_id = t.id
WHERE (name GLOB 'mem.ion_change.*' OR name = 'mem.ion_change') AND value > 0
WINDOW win AS (
  PARTITION BY name ORDER BY ts
  ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
);

DROP VIEW IF EXISTS ion_alloc_stats;
CREATE PERFETTO VIEW ion_alloc_stats AS
SELECT
  heap_name,
  SUM(instant_value) AS total_alloc_size_bytes
FROM ion_raw_allocs
GROUP BY 1;

-- We need to group by ts here as we can have two ion events from
-- different processes occurring at the same timestamp. We take the
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- max as this will take both allocations into account at that
-- timestamp.
DROP VIEW IF EXISTS android_ion_event;
CREATE PERFETTO VIEW android_ion_event AS
SELECT
  'counter' AS track_type,
  printf('ION allocations (heap: %s)', heap_name) AS track_name,
  ts,
  MAX(value) AS value
FROM ion_raw_allocs
GROUP BY 1, 2, 3;

DROP VIEW IF EXISTS android_ion_output;
CREATE PERFETTO VIEW android_ion_output AS
SELECT AndroidIonMetric(
  'buffer', RepeatedField(
    AndroidIonMetric_Buffer(
      'name', heap_name,
      'avg_size_bytes', avg_size,
      'min_size_bytes', min_size,
      'max_size_bytes', max_size,
      'total_alloc_size_bytes', total_alloc_size_bytes
    )
  ))
FROM ion_heap_stats JOIN ion_alloc_stats USING (heap_name);

)_d3l1m1t3r_"
;

const char kAndroidAndroidIrqRuntime[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

DROP VIEW IF EXISTS irq_runtime_all;

CREATE PERFETTO VIEW irq_runtime_all
AS
SELECT ts, dur, name
FROM slice
WHERE category = 'irq';

DROP VIEW IF EXISTS hw_irq_runtime;

CREATE PERFETTO VIEW hw_irq_runtime
AS
SELECT ts, dur, name
FROM irq_runtime_all
WHERE name GLOB 'IRQ (*)'
ORDER BY dur DESC;

DROP VIEW IF EXISTS hw_irq_runtime_statistics;

CREATE PERFETTO VIEW hw_irq_runtime_statistics
)_d3l1m1t3r_"
R"_d3l1m1t3r_(AS
SELECT
  MAX(dur) AS max_runtime,
  COUNT(IIF(dur > 1e6, 1, NULL)) AS over_threshold_count,
  COUNT(*) AS total_count
FROM hw_irq_runtime;

DROP VIEW IF EXISTS sw_irq_runtime;
CREATE PERFETTO VIEW sw_irq_runtime
AS
SELECT ts, dur, name
FROM irq_runtime_all
WHERE name NOT GLOB 'IRQ (*)'
ORDER BY dur DESC;

DROP VIEW IF EXISTS sw_irq_runtime_statistics;
CREATE PERFETTO VIEW sw_irq_runtime_statistics
AS
SELECT
  MAX(dur) AS max_runtime,
  COUNT(IIF(dur > 5e6, 1, NULL)) AS over_threshold_count,
  COUNT(*) AS total_count
FROM sw_irq_runtime;

DROP VIEW IF EXISTS android_irq_runtime_output;

CREATE PERFETTO VIEW android_irq_runtime_output
AS
SELECT
  AndroidIrqRuntimeMetric(
    'hw_irq',
    (
      SELECT
        AndroidIrqRuntimeMetric_IrqRuntimeMetric(
          'max_runtime',
          max_runtime,
          'total_count',
          total_count,
          'threshold_metric',
          AndroidIrqRuntimeMetric_ThresholdMetric(
            'threshold',
            '1ms',
            'over_threshold_count',
)_d3l1m1t3r_"
R"_d3l1m1t3r_(            over_threshold_count,
            'anomaly_ratio',
            CAST(
              over_threshold_count AS DOUBLE)
            / CAST(
              total_count AS DOUBLE)),
          'longest_irq_slices',
          (
            SELECT
              RepeatedField(
                AndroidIrqRuntimeMetric_IrqSlice(
                  'irq_name', name, 'ts', ts, 'dur', dur))
            FROM (SELECT ts, dur, name FROM hw_irq_runtime LIMIT 10)
          ))
      FROM hw_irq_runtime_statistics
    ),
    'sw_irq',
    (
      SELECT
        AndroidIrqRuntimeMetric_IrqRuntimeMetric(
          'max_runtime',
          max_runtime,
          'total_count',
          total_count,
          'threshold_metric',
          AndroidIrqRuntimeMetric_ThresholdMetric(
            'threshold',
            '5ms',
            'over_threshold_count',
            over_threshold_count,
            'anomaly_ratio',
            CAST(
              over_threshold_count AS DOUBLE)
            / CAST(
              total_count AS DOUBLE)),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(          'longest_irq_slices',
          (
            SELECT
              RepeatedField(
                AndroidIrqRuntimeMetric_IrqSlice(
                  'irq_name', name, 'ts', ts, 'dur', dur))
            FROM (SELECT ts, dur, name FROM sw_irq_runtime LIMIT 10)
          ))
      FROM sw_irq_runtime_statistics
    ));

)_d3l1m1t3r_"
;

const char kAndroidAndroidJankCuj[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Create the base table (`android_jank_cuj`) containing all completed CUJs
-- found in the trace.
SELECT RUN_METRIC('android/jank/cujs.sql');

-- Creates tables that store constant parameters for each CUJ - e.g. parameter
-- that describes whether Choreographer callbacks run on a dedicated thread.
SELECT RUN_METRIC('android/jank/params.sql');

-- Create tables to store each CUJs main, render, HWC release,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- and GPU completion threads.
-- Also stores the (not CUJ-specific) threads of SF: main, render engine,
-- and GPU completion threads.
SELECT RUN_METRIC('android/jank/relevant_threads.sql');

-- Create tables to store the main slices on each of the relevant threads
-- * `Choreographer#doFrame` on the main thread
-- * `DrawFrames on the render` thread
-- * `waiting for HWC release` on the HWC release thread
-- * `Waiting for GPU completion` on the GPU completion thread
-- * `commit` and `composite` on SF main thread.
-- * `REThreaded::drawLayers` on SF RenderEngine thread.
-- Also extracts vsync ids and GPU completion fence ids that allow us to match
-- slices to concrete vsync IDs.
-- Slices and vsyncs are matched between the app and SF processes by looking
-- at the actual frame timeline data.
-- We only store the slices that were produced for the vsyncs within the
-- CUJ markers.
SELECT RUN_METRIC('android/jank/relevant_slices.sql');

-- Computes the boundaries of specific frames and overall CUJ boundaries
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- on specific important threads since each thread will work on a frame at a
-- slightly different time.
-- We also compute the corrected CUJ ts boundaries. This is necessary because
-- the instrumentation logs begin/end CUJ markers *during* the first frame and
-- typically *right at the start* of the last CUJ frame. The ts boundaries in
-- `android_jank_cuj` table are based on these markers so do not actually
-- contain the whole CUJ, but instead overlap with all Choreographer#doFrame
-- slices that belong to a CUJ.
SELECT RUN_METRIC('android/jank/cujs_boundaries.sql');

-- With relevant slices and corrected boundaries we can now estimate the ts
-- boundaries of each frame within the CUJ.
-- We also match with the data from the actual timeline to check which frames
-- missed the deadline and whether this was due to the app or SF.
SELECT RUN_METRIC('android/jank/frames.sql');

-- Creates tables with slices from various relevant threads that are within
-- the CUJ boundaries. Used as data sources for further processing and
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- jank cause analysis of traces.
SELECT RUN_METRIC('android/jank/slices.sql');

-- Creates tables and functions to be used for manual investigations and
-- jank cause analysis of traces.
SELECT RUN_METRIC('android/jank/internal/query_base.sql');
SELECT RUN_METRIC('android/jank/query_functions.sql');

-- Creates a table that matches CUJ counters with the correct CUJs.
-- After the CUJ ends FrameTracker emits counters with the number of total
-- frames, missed frames, longest frame duration, etc.
-- The same numbers are also reported by FrameTracker to statsd.
SELECT RUN_METRIC('android/jank/internal/counters.sql');

-- Creates derived events to visualize a few of the created tables.
-- Used only for debugging so by default not used and not displayed in the UI.
-- See https://perfetto.dev/docs/contributing/common-tasks#adding-new-derived-events
-- for instructions on how to add these events to the UI.
SELECT RUN_METRIC('android/jank/internal/derived_events.sql');


DROP VIEW IF EXISTS android_jank_cuj_output;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO VIEW android_jank_cuj_output AS
SELECT
  AndroidJankCujMetric(
    'cuj', (
      SELECT RepeatedField(
        AndroidJankCujMetric_Cuj(
          'id', cuj_id,
          'name', cuj_name,
          'process', process_metadata,
          'layer_name', layer_name,
          'ts', COALESCE(boundary.ts, cuj.ts),
          'dur', COALESCE(boundary.dur, cuj.dur),
          'counter_metrics', (
            SELECT AndroidJankCujMetric_Metrics(
              'total_frames', total_frames,
              'missed_frames', missed_frames,
              'missed_app_frames', missed_app_frames,
              'missed_sf_frames', missed_sf_frames,
              'missed_frames_max_successive', missed_frames_max_successive,
              'sf_callback_missed_frames', sf_callback_missed_frames,
              'hwui_callback_missed_frames', hwui_callback_missed_frames,
              'frame_dur_max', frame_dur_max)
            FROM android_jank_cuj_counter_metrics cm
            WHERE cm.cuj_id = cuj.cuj_id),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(          'trace_metrics', (
            SELECT AndroidJankCujMetric_Metrics(
              'total_frames', COUNT(*),
              'missed_frames', SUM(app_missed OR sf_missed),
              'missed_app_frames', SUM(app_missed),
              'missed_sf_frames', SUM(sf_missed),
              'sf_callback_missed_frames', SUM(sf_callback_missed),
              'hwui_callback_missed_frames', SUM(hwui_callback_missed),
              'frame_dur_max', MAX(f.dur),
              'frame_dur_avg', CAST(AVG(f.dur) AS INTEGER),
              'frame_dur_p50', CAST(PERCENTILE(f.dur, 50) AS INTEGER),
              'frame_dur_p90', CAST(PERCENTILE(f.dur, 90) AS INTEGER),
              'frame_dur_p95', CAST(PERCENTILE(f.dur, 95) AS INTEGER),
              'frame_dur_p99', CAST(PERCENTILE(f.dur, 99) AS INTEGER),
              'frame_dur_ms_p50', PERCENTILE(f.dur / 1e6, 50),
              'frame_dur_ms_p90', PERCENTILE(f.dur / 1e6, 90),
              'frame_dur_ms_p95', PERCENTILE(f.dur / 1e6, 95),
              'frame_dur_ms_p99', PERCENTILE(f.dur / 1e6, 99))
)_d3l1m1t3r_"
R"_d3l1m1t3r_(            FROM android_jank_cuj_frame f
            WHERE f.cuj_id = cuj.cuj_id),
          'timeline_metrics', (
            SELECT AndroidJankCujMetric_Metrics(
              'total_frames', COUNT(*),
              'missed_frames', SUM(app_missed OR sf_missed),
              'missed_app_frames', SUM(app_missed),
              'missed_sf_frames', SUM(sf_missed),
              'sf_callback_missed_frames', SUM(sf_callback_missed),
              'hwui_callback_missed_frames', SUM(hwui_callback_missed),
              'frame_dur_max', MAX(f.dur),
              'frame_dur_avg', CAST(AVG(f.dur) AS INTEGER),
              'frame_dur_p50', CAST(PERCENTILE(f.dur, 50) AS INTEGER),
              'frame_dur_p90', CAST(PERCENTILE(f.dur, 90) AS INTEGER),
              'frame_dur_p95', CAST(PERCENTILE(f.dur, 95) AS INTEGER),
              'frame_dur_p99', CAST(PERCENTILE(f.dur, 99) AS INTEGER),
              'frame_dur_ms_p50', PERCENTILE(f.dur / 1e6, 50),
              'frame_dur_ms_p90', PERCENTILE(f.dur / 1e6, 90),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(              'frame_dur_ms_p95', PERCENTILE(f.dur / 1e6, 95),
              'frame_dur_ms_p99', PERCENTILE(f.dur / 1e6, 99))
            FROM android_jank_cuj_frame_timeline f
            WHERE f.cuj_id = cuj.cuj_id),
          'frame', (
            SELECT RepeatedField(
              AndroidJankCujMetric_Frame(
                'frame_number', f.frame_number,
                'vsync', f.vsync,
                'ts', f.ts,
                'dur', f.dur,
                'dur_expected', f.dur_expected,
                'app_missed', f.app_missed,
                'sf_missed', f.sf_missed,
                'sf_callback_missed', f.sf_callback_missed,
                'hwui_callback_missed', f.hwui_callback_missed))
            FROM android_jank_cuj_frame f
            WHERE f.cuj_id = cuj.cuj_id
            ORDER BY frame_number ASC),
          'sf_frame', (
            SELECT RepeatedField(
              AndroidJankCujMetric_Frame(
                'frame_number', f.frame_number,
                'vsync', f.vsync,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(                'ts', f.ts,
                'dur', f.dur,
                'dur_expected', f.dur_expected,
                'sf_missed', f.sf_missed))
            FROM android_jank_cuj_sf_frame f
            WHERE f.cuj_id = cuj.cuj_id
            ORDER BY frame_number ASC)
        ))
      FROM android_jank_cuj cuj
      LEFT JOIN android_jank_cuj_boundary boundary USING (cuj_id)
      LEFT JOIN android_jank_cuj_layer_name cuj_layer USING (cuj_id)
      ORDER BY cuj.cuj_id ASC));

)_d3l1m1t3r_"
;

const char kAndroidAndroidLmk[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

SELECT RUN_METRIC('android/process_oom_score.sql');

-- All LMK events ordered by timestamp
DROP TABLE IF EXISTS lmk_events;
CREATE PERFETTO TABLE lmk_events AS
WITH raw_events AS (
  SELECT upid, MAX(ts) AS ts
  FROM instant
  JOIN process_track ON instant.track_id = process_track.id
  WHERE instant.name = 'mem.lmk'
  GROUP BY 1
)
SELECT
  raw_events.ts,
  raw_events.upid,
  oom_scores.oom_score_val AS score
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM raw_events
LEFT JOIN oom_score_span oom_scores
  ON (raw_events.upid = oom_scores.upid
      AND raw_events.ts >= oom_scores.ts
      AND raw_events.ts < oom_scores.ts + oom_scores.dur)
ORDER BY 1;

DROP VIEW IF EXISTS android_lmk_event;
CREATE PERFETTO VIEW android_lmk_event AS
WITH raw_events AS (
  SELECT
    ts,
    LEAD(ts) OVER (ORDER BY ts) - ts AS dur,
    CAST(value AS INTEGER) AS pid
  FROM counter c
  JOIN counter_track t ON t.id = c.track_id
  WHERE t.name = 'kill_one_process'
  UNION ALL
  SELECT
    slice.ts,
    slice.dur,
    CAST(STR_SPLIT(slice.name, ",", 1) AS INTEGER) AS pid
  FROM slice
  WHERE slice.name GLOB 'lmk,*'
),
lmks_with_proc_name AS (
  SELECT
    *,
    process.name AS process_name
  FROM raw_events
  LEFT JOIN process ON
    process.pid = raw_events.pid
    AND (raw_events.ts >= process.start_ts OR process.start_ts IS NULL)
    AND (raw_events.ts < process.end_ts OR process.end_ts IS NULL)
  WHERE raw_events.pid != 0
)
SELECT
  'slice' AS track_type,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  'Low Memory Kills (LMKs)' AS track_name,
  ts,
  dur,
  CASE
    WHEN process_name IS NULL THEN printf('Process %d', lmk.pid)
    ELSE printf('%s (pid: %d)', process_name, lmk.pid)
  END AS slice_name
FROM lmks_with_proc_name AS lmk;

DROP VIEW IF EXISTS android_lmk_output;
CREATE PERFETTO VIEW android_lmk_output AS
WITH lmk_counts AS (
  SELECT score, COUNT(1) AS count
  FROM lmk_events
  GROUP BY score
)
SELECT AndroidLmkMetric(
  'total_count', (SELECT COUNT(1) FROM lmk_events),
  'by_oom_score', (
    SELECT
      RepeatedField(AndroidLmkMetric_ByOomScore(
        'oom_score_adj', score,
        'count', count
      ))
    FROM lmk_counts
    WHERE score IS NOT NULL
  ),
  'oom_victim_count', (
    SELECT COUNT(1)
    FROM instant
    WHERE name = 'mem.oom_kill'
  )
);

)_d3l1m1t3r_"
;

const char kAndroidAndroidLmkReason[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

SELECT RUN_METRIC('android/android_ion.sql');
SELECT RUN_METRIC('android/android_lmk.sql');
SELECT RUN_METRIC('android/process_mem.sql');
SELECT RUN_METRIC('android/process_metadata.sql');

DROP VIEW IF EXISTS android_lmk_reason_output;
CREATE PERFETTO VIEW android_lmk_reason_output AS
WITH
total_ion_name AS (
  SELECT
    CASE
      WHEN EXISTS(SELECT TRUE FROM ion_timeline WHERE heap_name = 'all')
)_d3l1m1t3r_"
R"_d3l1m1t3r_(        THEN 'all'
      ELSE 'system'
    END AS name
),
oom_score_at_lmk_time AS (
  SELECT
    lmk_events.ts,
    oom_score_span.upid,
    oom_score_val
  FROM lmk_events
  JOIN oom_score_span ON (
    lmk_events.ts
    BETWEEN oom_score_span.ts
    AND oom_score_span.ts + MAX(oom_score_span.dur - 1, 0))
),
ion_at_lmk_time AS (
  SELECT
    lmk_events.ts,
    CAST(ion_timeline.value AS INT) AS ion_size
  FROM lmk_events
  JOIN ion_timeline ON (
    lmk_events.ts
    BETWEEN ion_timeline.ts
    AND ion_timeline.ts + MAX(ion_timeline.dur - 1, 0))
  WHERE ion_timeline.heap_name IN (SELECT name FROM total_ion_name)
),
lmk_process_sizes AS (
  SELECT
    lmk_events.ts,
    rss_and_swap_span.upid,
    file_rss_val,
    anon_rss_val,
    shmem_rss_val,
    swap_val,
    rss_and_swap_val
  FROM lmk_events
  JOIN rss_and_swap_span
  WHERE lmk_events.ts
  BETWEEN rss_and_swap_span.ts
  AND rss_and_swap_span.ts + MAX(rss_and_swap_span.dur - 1, 0)
),
lmk_process_sizes_output AS (
  SELECT ts, RepeatedField(AndroidLmkReasonMetric_Process(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'process', metadata,
    'oom_score_adj', oom_score_val,
    'size', rss_and_swap_val,
    'file_rss_bytes', file_rss_val,
    'anon_rss_bytes', anon_rss_val,
    'shmem_rss_bytes', shmem_rss_val,
    'swap_bytes', swap_val
    )) AS processes
  FROM lmk_process_sizes
  JOIN process_metadata USING (upid)
  LEFT JOIN oom_score_at_lmk_time USING (ts, upid)
  GROUP BY ts
)
SELECT AndroidLmkReasonMetric(
  'lmks', (
    SELECT RepeatedField(AndroidLmkReasonMetric_Lmk(
      'oom_score_adj', oom_score_val,
      'system_ion_heap_size', ion_size,
      'ion_heaps_bytes', ion_size,
      'processes', processes
      ))
    FROM lmk_events
    LEFT JOIN oom_score_at_lmk_time USING (ts, upid)
    LEFT JOIN ion_at_lmk_time USING (ts)
    LEFT JOIN lmk_process_sizes_output USING (ts)
    WHERE oom_score_val IS NOT NULL
    ORDER BY ts
  )
);

)_d3l1m1t3r_"
;

const char kAndroidAndroidMem[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

SELECT RUN_METRIC('android/process_mem.sql');

SELECT RUN_METRIC('android/span_view_stats.sql', 'table_name', 'anon_rss');

SELECT RUN_METRIC('android/span_view_stats.sql', 'table_name', 'file_rss');

SELECT RUN_METRIC('android/span_view_stats.sql', 'table_name', 'swap');

SELECT RUN_METRIC('android/span_view_stats.sql', 'table_name', 'anon_and_swap');

SELECT RUN_METRIC('android/span_view_stats.sql', 'table_name', 'java_heap');
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
SELECT RUN_METRIC('android/mem_stats_priority_breakdown.sql', 'table_name', 'anon_rss');

SELECT RUN_METRIC('android/mem_stats_priority_breakdown.sql', 'table_name', 'file_rss');

SELECT RUN_METRIC('android/mem_stats_priority_breakdown.sql', 'table_name', 'swap');

SELECT RUN_METRIC('android/mem_stats_priority_breakdown.sql', 'table_name', 'anon_and_swap');

SELECT RUN_METRIC('android/mem_stats_priority_breakdown.sql', 'table_name', 'java_heap');

-- Find out all process + priority pairs with data to drive the joins (no outer join in sqlite).
DROP VIEW IF EXISTS mem_all_processes;
CREATE PERFETTO VIEW mem_all_processes AS
SELECT DISTINCT process_name
FROM
  (
    SELECT process_name FROM anon_rss_stats_proto
    UNION
    SELECT process_name FROM file_rss_stats_proto
    UNION
    SELECT process_name FROM swap_stats_proto
    UNION
    SELECT process_name FROM anon_and_swap_stats_proto
    UNION
    SELECT process_name FROM java_heap_stats_proto
  );

DROP VIEW IF EXISTS mem_all_process_priorities;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO VIEW mem_all_process_priorities AS
SELECT DISTINCT process_name, priority
FROM
  (
    SELECT process_name, priority FROM anon_rss_by_priority_stats_proto
    UNION
    SELECT process_name, priority FROM file_rss_by_priority_stats_proto
    UNION
    SELECT process_name, priority FROM swap_by_priority_stats_proto
    UNION
    SELECT process_name, priority FROM anon_and_swap_by_priority_stats_proto
    UNION
    SELECT process_name, priority FROM java_heap_by_priority_stats_proto
  );

DROP VIEW IF EXISTS process_priority_view;
CREATE PERFETTO VIEW process_priority_view AS
SELECT
  process_name,
  AndroidMemoryMetric_PriorityBreakdown(
    'priority', priority,
    'counters', AndroidMemoryMetric_ProcessMemoryCounters(
      'anon_rss', anon_rss_by_priority_stats_proto.proto,
      'file_rss', file_rss_by_priority_stats_proto.proto,
      'swap', swap_by_priority_stats_proto.proto,
      'anon_and_swap', anon_and_swap_by_priority_stats_proto.proto,
      'java_heap', java_heap_by_priority_stats_proto.proto
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    )
  ) AS priority_breakdown_proto
FROM mem_all_process_priorities
LEFT JOIN anon_rss_by_priority_stats_proto USING (process_name, priority)
LEFT JOIN file_rss_by_priority_stats_proto USING (process_name, priority)
LEFT JOIN swap_by_priority_stats_proto USING (process_name, priority)
LEFT JOIN anon_and_swap_by_priority_stats_proto USING (process_name, priority)
LEFT JOIN java_heap_by_priority_stats_proto USING (process_name, priority);

DROP VIEW IF EXISTS process_metrics_view;
CREATE PERFETTO VIEW process_metrics_view AS
SELECT
  AndroidMemoryMetric_ProcessMetrics(
    'process_name', process_name,
    'total_counters', AndroidMemoryMetric_ProcessMemoryCounters(
      'anon_rss', anon_rss_stats_proto.proto,
      'file_rss', file_rss_stats_proto.proto,
      'swap', swap_stats_proto.proto,
      'anon_and_swap', anon_and_swap_stats_proto.proto,
      'java_heap', java_heap_stats_proto.proto
    ),
    'priority_breakdown', (
      SELECT RepeatedField(priority_breakdown_proto)
      FROM process_priority_view AS ppv
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      WHERE mem_all_processes.process_name = ppv.process_name
    )
  ) AS metric
FROM
  mem_all_processes
LEFT JOIN anon_rss_stats_proto USING (process_name)
LEFT JOIN file_rss_stats_proto USING (process_name)
LEFT JOIN swap_stats_proto USING (process_name)
LEFT JOIN anon_and_swap_stats_proto USING (process_name)
LEFT JOIN java_heap_stats_proto USING (process_name);

DROP VIEW IF EXISTS android_mem_output;
CREATE PERFETTO VIEW android_mem_output AS
SELECT
  AndroidMemoryMetric(
    'process_metrics',
    (SELECT RepeatedField(metric) FROM process_metrics_view)
  );

)_d3l1m1t3r_"
;

const char kAndroidAndroidMemUnagg[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

SELECT RUN_METRIC('android/process_mem.sql');

SELECT RUN_METRIC('android/process_unagg_mem_view.sql',
  'table_name', 'anon_rss');

SELECT RUN_METRIC('android/process_unagg_mem_view.sql',
  'table_name', 'swap');

SELECT RUN_METRIC('android/process_unagg_mem_view.sql',
  'table_name', 'file_rss');

SELECT RUN_METRIC('android/process_unagg_mem_view.sql',
  'table_name', 'anon_and_swap');
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
DROP VIEW IF EXISTS process_unagg_metrics_view;
CREATE PERFETTO VIEW process_unagg_metrics_view AS
SELECT
  AndroidMemoryUnaggregatedMetric_ProcessValues(
    'process_name', process.name,
    'mem_values', AndroidMemoryUnaggregatedMetric_ProcessMemoryValues(
      'anon_rss', anon_rss_unagg_values.metric,
      'swap', swap_unagg_values.metric,
      'file_rss', file_rss_unagg_values.metric,
      'anon_and_swap', anon_and_swap_unagg_values.metric
    )
  ) AS metric
FROM
  process
LEFT JOIN
  anon_rss_unagg_values USING(upid)
LEFT JOIN
  swap_unagg_values USING(upid)
LEFT JOIN
  file_rss_unagg_values USING(upid)
LEFT JOIN
  anon_and_swap_unagg_values USING(upid)
WHERE
  process.name IS NOT NULL;

DROP VIEW IF EXISTS android_mem_unagg_output;
CREATE PERFETTO VIEW android_mem_unagg_output AS
SELECT
  AndroidMemoryUnaggregatedMetric(
    'process_values',
    (SELECT RepeatedField(metric) FROM process_unagg_metrics_view)
  );

)_d3l1m1t3r_"
;

const char kAndroidAndroidMonitorContention[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE android.monitor_contention;

DROP VIEW IF EXISTS android_monitor_contention_output;
CREATE PERFETTO VIEW android_monitor_contention_output AS
SELECT AndroidMonitorContentionMetric(
  'node', (
    SELECT RepeatedField(
      AndroidMonitorContentionMetric_Node(
        'node_parent_id', parent_id,
        'node_child_id', child_id,
        'node_id', id,
        'ts', ts,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(        'dur', dur,
        'monotonic_dur', monotonic_dur,
        'blocking_method', blocking_method,
        'blocked_method', blocked_method,
        'short_blocking_method', short_blocking_method,
        'short_blocked_method', short_blocked_method,
        'blocking_src', blocking_src,
        'blocked_src', blocked_src,
        'waiter_count', waiter_count,
        'blocking_thread_name', blocking_thread_name,
        'blocked_thread_name', blocked_thread_name,
        'blocked_thread_tid', blocked_thread_tid,
        'blocking_thread_tid', blocking_thread_tid,
        'process_name', process_name,
        'pid', pid,
        'is_blocked_thread_main', is_blocked_thread_main,
        'is_blocking_thread_main', is_blocking_thread_main,
        'binder_reply_ts', binder_reply_ts,
        'binder_reply_tid', binder_reply_tid,
        'thread_states', (
          SELECT RepeatedField(
            AndroidMonitorContentionMetric_ThreadStateBreakdown(
              'thread_state', thread_state,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(              'thread_state_dur', thread_state_dur,
              'thread_state_count', thread_state_count
            )
          ) FROM android_monitor_contention_chain_thread_state_by_txn t WHERE t.id = android_monitor_contention_chain.id
        ),
        'blocked_functions', (
          SELECT RepeatedField(
            AndroidMonitorContentionMetric_BlockedFunctionBreakdown(
              'blocked_function', blocked_function,
              'blocked_function_dur', blocked_function_dur,
              'blocked_function_count', blocked_function_count
            )
          ) FROM android_monitor_contention_chain_blocked_functions_by_txn b WHERE b.id = android_monitor_contention_chain.id
        )
      )
    )
    FROM android_monitor_contention_chain
  )
);

)_d3l1m1t3r_"
;

const char kAndroidAndroidMonitorContentionAgg[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE android.monitor_contention;

DROP VIEW IF EXISTS amc_process_agg;
CREATE PERFETTO VIEW amc_process_agg AS
WITH full_contention AS (
  Select process_name, COUNT(*) as total_contention_count, SUM(dur)
  as total_contention_dur from android_monitor_contention group by process_name
),
main_thread_contention AS
(
  Select process_name, COUNT(*) as main_thread_contention_count, SUM(dur)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  as main_thread_contention_dur from android_monitor_contention
  where is_blocked_thread_main=1 group by process_name
)
SELECT f.process_name, total_contention_count, total_contention_dur,
 main_thread_contention_count, main_thread_contention_dur
 from full_contention as f left join main_thread_contention as m on f.process_name = m.process_name;

DROP VIEW IF EXISTS android_monitor_contention_agg_output;
CREATE PERFETTO VIEW android_monitor_contention_agg_output AS
SELECT AndroidMonitorContentionAggMetric(
  'process_aggregation', (
    SELECT RepeatedField(
        AndroidMonitorContentionAggMetric_ProcessAggregation(
            'name', process_name,
            'total_contention_count', total_contention_count,
            'total_contention_dur', total_contention_dur,
            'main_thread_contention_count', main_thread_contention_count,
            'main_thread_contention_dur', main_thread_contention_dur
        )
    )
    FROM amc_process_agg
  )
);
)_d3l1m1t3r_"
;

const char kAndroidAndroidMultiuser[] = R"_d3l1m1t3r_(--
-- Copyright 2021 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

SELECT RUN_METRIC('android/android_multiuser_populator.sql',
    'output_table_name', 'event_user_switch',
    'start_event', 'user_start',
    'end_event', 'launcher_end');

DROP VIEW IF EXISTS android_multiuser_output;
CREATE PERFETTO VIEW android_multiuser_output AS
SELECT AndroidMultiuserMetric(
  'user_switch', (SELECT * FROM event_user_switch)
);

)_d3l1m1t3r_"
;

const char kAndroidAndroidMultiuserPopulator[] = R"_d3l1m1t3r_(--
-- Copyright 2021 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- Create the base tables and views containing the launch spans.
INCLUDE PERFETTO MODULE android.startup.startups;

-- Collect the important timestamps for Multiuser events.
DROP VIEW IF EXISTS multiuser_events;
CREATE PERFETTO VIEW multiuser_events AS
SELECT
  {{start_event}}_time_ns AS event_start_time_ns,
  {{end_event}}_time_ns AS event_end_time_ns
FROM
  (
    SELECT MIN(slice.ts) AS user_start_time_ns
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    FROM slice
    WHERE (
        slice.name = "UserDetailView.Adapter#onClick" -- QuickSettings
        OR slice.name = "UserDetailSettings.switchUser" -- Settings
        OR slice.name = "shell_runSwitchUser" -- adb shell
    )
  ),
  (
    SELECT ts_end AS launcher_end_time_ns
    FROM android_startups
    WHERE (package = 'com.android.launcher3' OR package = 'com.google.android.apps.nexuslauncher')
  ),
  (
    SELECT MIN(slice.ts) AS user_create_time_ns
    FROM slice
    WHERE (
        slice.name = "UserDetailView.Adapter#onClick" -- QuickSettings
        OR slice.name = "UserSettings.addUserNow" -- Settings
        OR slice.name = "UserSettings.addGuest" -- Settings
        OR slice.name = "shell_runCreateUser" -- adb shell
    )
  );

-- Calculation of the duration of the Multiuser event of interest.
DROP VIEW IF EXISTS multiuser_timing;
CREATE PERFETTO VIEW multiuser_timing AS
SELECT
  CAST((event_end_time_ns - event_start_time_ns) / 1e6 + 0.5 AS INT) AS duration_ms
FROM
  multiuser_events;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(

-- Calculate CPU usage during the Multiuser event of interest.

-- Get all the scheduling slices.
DROP VIEW IF EXISTS sp_sched;
CREATE PERFETTO VIEW sp_sched AS
SELECT ts, dur, cpu, utid
FROM sched;
-- Get all the cpu frequency slices.
DROP VIEW IF EXISTS sp_frequency;
CREATE PERFETTO VIEW sp_frequency AS
SELECT
  ts,
  lead(ts) OVER (PARTITION BY track_id ORDER BY ts) - ts AS dur,
  cpu,
  value AS freq_khz
FROM counter
JOIN cpu_counter_track ON counter.track_id = cpu_counter_track.id;
-- Create the span joined table which combines cpu frequency with scheduling slices.
DROP TABLE IF EXISTS sched_with_frequency;
CREATE VIRTUAL TABLE sched_with_frequency
USING SPAN_JOIN(sp_sched PARTITIONED cpu, sp_frequency PARTITIONED cpu);

-- Calculate the CPU cycles spent per process during the duration.
DROP VIEW IF EXISTS cpu_usage_all;
CREATE PERFETTO VIEW cpu_usage_all AS
SELECT
  process.uid / 100000 AS user_id,
  process.name AS process_name,
  SUM(dur * freq_khz) / 1e9 AS cpu_kcycles
FROM
  sched_with_frequency
)_d3l1m1t3r_"
R"_d3l1m1t3r_(JOIN thread USING (utid)
JOIN process USING (upid)
WHERE
  ts >= (SELECT event_start_time_ns FROM multiuser_events)
  AND
  ts <= (SELECT event_end_time_ns FROM multiuser_events)
GROUP BY upid, process.name
ORDER BY cpu_kcycles DESC;

-- Get the data from cpu_usage_all, but also with the percentage.
DROP VIEW IF EXISTS cpu_usage;
CREATE PERFETTO VIEW cpu_usage AS
SELECT
  user_id,
  process_name,
  process_name || ":" || (CASE WHEN user_id = 0 THEN "system" ELSE "secondary" END) AS identifier,
  CAST(cpu_kcycles / 1e3 AS INT) AS cpu_mcycles,
  cpu_kcycles / (SELECT SUM(cpu_kcycles) FROM cpu_usage_all) * 100 AS cpu_percentage
FROM
  cpu_usage_all
ORDER BY cpu_mcycles DESC LIMIT 25;


-- Record the output for populating the proto.
DROP VIEW IF EXISTS {{output_table_name}};
CREATE PERFETTO VIEW {{output_table_name}} AS
SELECT AndroidMultiuserMetric_EventData(
  'duration_ms', (
    SELECT duration_ms
    FROM multiuser_timing
  ),
  'cpu_usage', (
    SELECT RepeatedField(
      AndroidMultiuserMetric_EventData_CpuUsage(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(        'identifier', identifier,
        'user_id', user_id,
        'process_name', process_name,
        'cpu_mcycles', cpu_mcycles,
        'cpu_percentage', cpu_percentage
      )
    )
    FROM cpu_usage
  )
);

)_d3l1m1t3r_"
;

const char kAndroidAndroidNetperf[] = R"_d3l1m1t3r_(--
-- Copyright 2021 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

DROP VIEW IF EXISTS rx_packets;
CREATE PERFETTO VIEW rx_packets AS
SELECT
  ts,
  REPLACE(name, " Received KB", "") AS dev,
  EXTRACT_ARG(arg_set_id, 'cpu') AS cpu,
  EXTRACT_ARG(arg_set_id, 'len') AS len
FROM counter c
LEFT JOIN counter_track t
  ON c.track_id = t.id
WHERE name GLOB "* Received KB"
ORDER BY ts DESC;

DROP VIEW IF EXISTS gro_rx_packet_count;
CREATE PERFETTO VIEW gro_rx_packet_count AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  s.name AS dev,
  COUNT(1) AS cnt
FROM slice s
LEFT JOIN track t
  ON s.track_id = t.id
WHERE t.name GLOB "Napi Gro Cpu *"
GROUP BY s.name;

DROP VIEW IF EXISTS tx_packets;
CREATE PERFETTO VIEW tx_packets AS
SELECT
  ts,
  REPLACE(name, " Transmitted KB", "") AS dev,
  EXTRACT_ARG(arg_set_id, 'cpu') AS cpu,
  EXTRACT_ARG(arg_set_id, 'len') AS len
FROM counter c
LEFT JOIN counter_track t
  ON c.track_id = t.id
WHERE name GLOB "* Transmitted KB"
ORDER BY ts DESC;

DROP VIEW IF EXISTS net_devices;
CREATE PERFETTO VIEW net_devices AS
SELECT DISTINCT dev
FROM tx_packets
UNION
SELECT DISTINCT dev
FROM rx_packets;

DROP VIEW IF EXISTS tcp_retransmitted_count;
CREATE PERFETTO VIEW tcp_retransmitted_count AS
SELECT
  COUNT(1) AS cnt
FROM slice s
LEFT JOIN track t
  ON s.track_id = t.id
WHERE
  t.name = "TCP Retransmit Skb";

DROP VIEW IF EXISTS kfree_skb_count;
CREATE PERFETTO VIEW kfree_skb_count AS
SELECT
  MAX(value) AS cnt
FROM counter c
LEFT JOIN track t
  ON c.track_id = t.id
WHERE
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  t.name = "Kfree Skb IP Prot";

DROP VIEW IF EXISTS device_per_core_ingress_traffic;
CREATE PERFETTO VIEW device_per_core_ingress_traffic AS
SELECT
  dev,
  AndroidNetworkMetric_CorePacketStatistic(
    'id', cpu,
    'packet_statistic', AndroidNetworkMetric_PacketStatistic(
      'packets', COUNT(1),
      'bytes', SUM(len),
      'first_packet_timestamp_ns', MIN(ts),
      'last_packet_timestamp_ns', MAX(ts),
      'interval_ns', IIF((MAX(ts) - MIN(ts)) > 10000000, MAX(ts) - MIN(ts), 10000000),
      'data_rate_kbps', (SUM(len) * 8) / (IIF((MAX(ts) - MIN(ts)) > 10000000, MAX(ts) - MIN(ts), 10000000) / 1e9) / 1024
    )
  ) AS proto
FROM rx_packets
GROUP BY dev, cpu;

DROP VIEW IF EXISTS device_per_core_egress_traffic;
CREATE PERFETTO VIEW device_per_core_egress_traffic AS
SELECT
  dev,
  AndroidNetworkMetric_CorePacketStatistic(
    'id', cpu,
    'packet_statistic', AndroidNetworkMetric_PacketStatistic(
      'packets', COUNT(1),
      'bytes', SUM(len),
      'first_packet_timestamp_ns', MIN(ts),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      'last_packet_timestamp_ns', MAX(ts),
      'interval_ns', IIF((MAX(ts) - MIN(ts)) > 10000000, MAX(ts) - MIN(ts), 10000000),
      'data_rate_kbps', (SUM(len) * 8) / (IIF((MAX(ts) - MIN(ts)) > 10000000, MAX(ts) - MIN(ts), 10000000) / 1e9) / 1024
    )
  ) AS proto
FROM tx_packets
GROUP BY dev, cpu;

DROP VIEW IF EXISTS device_total_ingress_traffic;
CREATE PERFETTO VIEW device_total_ingress_traffic AS
SELECT
  dev,
  MIN(ts) AS start_ts,
  MAX(ts) AS end_ts,
  IIF((MAX(ts) - MIN(ts)) > 10000000, MAX(ts) - MIN(ts), 10000000) AS interval,
  COUNT(1) AS packets,
  SUM(len) AS bytes
FROM rx_packets
GROUP BY dev;

DROP VIEW IF EXISTS device_total_egress_traffic;
CREATE PERFETTO VIEW device_total_egress_traffic AS
SELECT
  dev,
  MIN(ts) AS start_ts,
  MAX(ts) AS end_ts,
  IIF((MAX(ts) - MIN(ts)) > 10000000, MAX(ts) - MIN(ts), 10000000) AS interval,
  COUNT(1) AS packets,
  SUM(len) AS bytes
FROM tx_packets
GROUP BY dev;

DROP VIEW IF EXISTS device_traffic_statistic;
CREATE PERFETTO VIEW device_traffic_statistic AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  AndroidNetworkMetric_NetDevice(
    'name', net_devices.dev,
    'rx', (
      SELECT
        AndroidNetworkMetric_Rx(
          'total', AndroidNetworkMetric_PacketStatistic(
            'packets', packets,
            'bytes', bytes,
            'first_packet_timestamp_ns', start_ts,
            'last_packet_timestamp_ns', end_ts,
            'interval_ns', interval,
            'data_rate_kbps', (bytes * 8) / (interval / 1e9) / 1024
          ),
          'core', (
            SELECT
              RepeatedField(proto)
            FROM device_per_core_ingress_traffic
            WHERE device_per_core_ingress_traffic.dev = device_total_ingress_traffic.dev
          ),
          'gro_aggregation_ratio', (
            SELECT
              CASE
                WHEN packets > 0 THEN '1:' || CAST((cnt * 1.0 / packets) AS text)
                ELSE '0:' || cnt
              END
            FROM gro_rx_packet_count
            WHERE gro_rx_packet_count.dev = net_devices.dev
          )
)_d3l1m1t3r_"
R"_d3l1m1t3r_(        )
      FROM device_total_ingress_traffic
      WHERE device_total_ingress_traffic.dev = net_devices.dev
    ),
    'tx', (
      SELECT
        AndroidNetworkMetric_Tx(
          'total', AndroidNetworkMetric_PacketStatistic(
            'packets', packets,
            'bytes', bytes,
            'first_packet_timestamp_ns', start_ts,
            'last_packet_timestamp_ns', end_ts,
            'interval_ns', interval,
            'data_rate_kbps', (bytes * 8) / (interval / 1e9) / 1024
          ),
          'core', (
            SELECT
              RepeatedField(proto)
            FROM device_per_core_egress_traffic
            WHERE device_per_core_egress_traffic.dev = device_total_egress_traffic.dev
          )
        )
      FROM device_total_egress_traffic
      WHERE device_total_egress_traffic.dev = net_devices.dev
    )
  ) AS proto
FROM net_devices
ORDER BY dev;

DROP VIEW IF EXISTS net_rx_actions;
CREATE PERFETTO VIEW net_rx_actions AS
SELECT
  s.ts,
  s.dur,
  CAST(SUBSTR(t.name, 13, 1) AS int) AS cpu
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM slice s
LEFT JOIN track t
  ON s.track_id = t.id
WHERE s.name = "NET_RX";

DROP VIEW IF EXISTS net_tx_actions;
CREATE PERFETTO VIEW net_tx_actions AS
SELECT
  s.ts,
  s.dur,
  CAST(SUBSTR(t.name, 13, 1) AS int) AS cpu
FROM slice s
LEFT JOIN track t
  ON s.track_id = t.id
WHERE s.name = "NET_TX";

DROP VIEW IF EXISTS ipi_actions;
CREATE PERFETTO VIEW ipi_actions AS
SELECT
  s.ts,
  s.dur,
  CAST(SUBSTR(t.name, 13, 1) AS int) AS cpu
FROM slice s
LEFT JOIN track t
  ON s.track_id = t.id
WHERE s.name = "IRQ (IPI)";

DROP VIEW IF EXISTS cpu_freq_view;
CREATE PERFETTO VIEW cpu_freq_view AS
SELECT
  cpu,
  ts,
  LEAD(ts, 1, trace_end())
  OVER (PARTITION BY cpu ORDER BY ts) - ts AS dur,
  CAST(value AS INT) AS freq_khz
FROM counter
JOIN cpu_counter_track ON counter.track_id = cpu_counter_track.id
WHERE name = 'cpufreq';

DROP TABLE IF EXISTS cpu_freq_net_rx_action_per_core;
CREATE VIRTUAL TABLE cpu_freq_net_rx_action_per_core
USING SPAN_LEFT_JOIN(net_rx_actions PARTITIONED cpu, cpu_freq_view PARTITIONED cpu);
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
DROP TABLE IF EXISTS cpu_freq_net_tx_action_per_core;
CREATE VIRTUAL TABLE cpu_freq_net_tx_action_per_core
USING SPAN_LEFT_JOIN(net_tx_actions PARTITIONED cpu, cpu_freq_view PARTITIONED cpu);

DROP VIEW IF EXISTS total_net_rx_action_statistic;
CREATE PERFETTO VIEW total_net_rx_action_statistic AS
SELECT
  COUNT(1) AS times,
  SUM(dur) AS runtime,
  AVG(dur) AS avg_runtime,
  (SELECT COUNT(1) FROM rx_packets) AS total_packet
FROM net_rx_actions;

DROP VIEW IF EXISTS total_net_tx_action_statistic;
CREATE PERFETTO VIEW total_net_tx_action_statistic AS
SELECT
  COUNT(1) AS times,
  SUM(dur) AS runtime,
  AVG(dur) AS avg_runtime
FROM net_tx_actions;

DROP VIEW IF EXISTS total_ipi_action_statistic;
CREATE PERFETTO VIEW total_ipi_action_statistic AS
SELECT
  COUNT(1) AS times,
  SUM(dur) AS runtime,
  AVG(dur) AS avg_runtime
FROM ipi_actions;

DROP VIEW IF EXISTS activated_cores_net_rx;
CREATE PERFETTO VIEW activated_cores_net_rx AS
SELECT DISTINCT
  cpu
FROM net_rx_actions;

DROP VIEW IF EXISTS activated_cores_net_tx;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO VIEW activated_cores_net_tx AS
SELECT DISTINCT
  cpu
FROM net_tx_actions;

DROP VIEW IF EXISTS per_core_net_rx_action_statistic;
CREATE PERFETTO VIEW per_core_net_rx_action_statistic AS
SELECT
  AndroidNetworkMetric_CoreNetRxActionStatistic(
    'id', cpu,
    'net_rx_action_statistic', AndroidNetworkMetric_NetRxActionStatistic(
      'count', (SELECT COUNT(1) FROM net_rx_actions AS na WHERE na.cpu = ac.cpu),
      'runtime_ms', (SELECT SUM(dur) / 1e6 FROM net_rx_actions AS na WHERE na.cpu = ac.cpu),
      'avg_runtime_ms', (SELECT AVG(dur) / 1e6 FROM net_rx_actions AS na WHERE na.cpu = ac.cpu),
      'avg_freq_khz', (SELECT SUM(dur * freq_khz) / SUM(dur) FROM cpu_freq_net_rx_action_per_core AS cc WHERE cc.cpu = ac.cpu),
      'mcycles', (SELECT CAST(SUM(dur * freq_khz / 1000) / 1e9 AS INT) FROM cpu_freq_net_rx_action_per_core AS cc WHERE cc.cpu = ac.cpu)
    )
  ) AS proto
FROM activated_cores_net_rx AS ac;

DROP VIEW IF EXISTS per_core_net_tx_action_statistic;
CREATE PERFETTO VIEW per_core_net_tx_action_statistic AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  AndroidNetworkMetric_CoreNetTxActionStatistic(
    'id', cpu,
    'net_tx_action_statistic', AndroidNetworkMetric_NetTxActionStatistic(
      'count', (SELECT COUNT(1) FROM net_tx_actions AS na WHERE na.cpu = ac.cpu),
      'runtime_ms', (SELECT SUM(dur) / 1e6 FROM net_tx_actions AS na WHERE na.cpu = ac.cpu),
      'avg_runtime_ms', (SELECT AVG(dur) / 1e6 FROM net_tx_actions AS na WHERE na.cpu = ac.cpu),
      'avg_freq_khz', (SELECT SUM(dur * freq_khz) / SUM(dur) FROM cpu_freq_net_tx_action_per_core AS cc WHERE cc.cpu = ac.cpu),
      'mcycles', (SELECT CAST(SUM(dur * freq_khz / 1000) / 1e9 AS INT) FROM cpu_freq_net_tx_action_per_core AS cc WHERE cc.cpu = ac.cpu)
    )
  ) AS proto
FROM activated_cores_net_tx AS ac;

DROP VIEW IF EXISTS android_netperf_output;
CREATE PERFETTO VIEW android_netperf_output AS
SELECT AndroidNetworkMetric(
    'net_devices', (
      SELECT
        RepeatedField(proto)
      FROM device_traffic_statistic
    ),
    'net_rx_action', AndroidNetworkMetric_NetRxAction(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      'total', AndroidNetworkMetric_NetRxActionStatistic(
        'count', (SELECT times FROM total_net_rx_action_statistic),
        'runtime_ms', (SELECT runtime / 1e6 FROM total_net_rx_action_statistic),
        'avg_runtime_ms', (SELECT avg_runtime / 1e6 FROM total_net_rx_action_statistic),
        'avg_freq_khz', (SELECT SUM(dur * freq_khz) / SUM(dur) FROM cpu_freq_net_rx_action_per_core),
        'mcycles', (SELECT CAST(SUM(dur * freq_khz / 1000) / 1e9 AS INT) FROM cpu_freq_net_rx_action_per_core)
      ),
      'core', (
        SELECT
          RepeatedField(proto)
        FROM per_core_net_rx_action_statistic
      ),
      'avg_interstack_latency_ms', (
        SELECT
          runtime / total_packet / 1e6
        FROM total_net_rx_action_statistic
      )
    ),
    'retransmission_rate', (
      SELECT
        (SELECT cnt FROM tcp_retransmitted_count) * 100.0 / COUNT(1)
      FROM tx_packets
    ),
    'kfree_skb_rate', (
      SELECT
        cnt * 100.0 / ((SELECT count(1) FROM rx_packets) + (SELECT count(1) FROM tx_packets))
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      FROM kfree_skb_count
    ),
    'net_tx_action', AndroidNetworkMetric_NetTxAction(
      'total', AndroidNetworkMetric_NetTxActionStatistic(
        'count', (SELECT times FROM total_net_tx_action_statistic),
        'runtime_ms', (SELECT runtime / 1e6 FROM total_net_tx_action_statistic),
        'avg_runtime_ms', (SELECT avg_runtime / 1e6 FROM total_net_tx_action_statistic),
        'avg_freq_khz', (SELECT SUM(dur * freq_khz) / SUM(dur) FROM cpu_freq_net_tx_action_per_core),
        'mcycles', (SELECT CAST(SUM(dur * freq_khz / 1000) / 1e9 AS INT) FROM cpu_freq_net_tx_action_per_core)
      ),
      'core', (
        SELECT
          RepeatedField(proto)
        FROM per_core_net_tx_action_statistic
      )
    ),
    'ipi_action', AndroidNetworkMetric_IpiAction(
      'total', AndroidNetworkMetric_IpiActionStatistic(
        'count', (SELECT times FROM total_ipi_action_statistic),
        'runtime_ms', (SELECT runtime / 1e6 FROM total_ipi_action_statistic),
        'avg_runtime_ms', (SELECT avg_runtime / 1e6 FROM total_ipi_action_statistic)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      )
    )
  );

)_d3l1m1t3r_"
;

const char kAndroidAndroidOomAdjuster[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
INCLUDE PERFETTO MODULE android.oom_adjuster;

DROP VIEW IF EXISTS android_oom_adj_intervals_with_detailed_bucket_name;
CREATE PERFETTO VIEW android_oom_adj_intervals_with_detailed_bucket_name (
  -- Timestamp the oom_adj score of the process changed
  ts INT,
  -- Duration until the next oom_adj score change of the process.
  dur INT,
  -- oom_adj score of the process.
  score INT,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- oom_adj bucket of the process.
  bucket STRING,
  -- Upid of the process having an oom_adj update.
  upid INT,
  -- Name of the process having an oom_adj update.
  process_name STRING,
  -- Slice id of the latest oom_adj update in the system_server.
  oom_adj_id INT,
  -- Timestamp of the latest oom_adj update in the system_server.
  oom_adj_ts INT,
  -- Duration of the latest oom_adj update in the system_server.
  oom_adj_dur INT,
  -- Track id of the latest oom_adj update in the system_server
  oom_adj_track_id INT,
  -- Thread name of the latest oom_adj update in the system_server.
  oom_adj_thread_name STRING,
  -- Reason for the latest oom_adj update in the system_server.
  oom_adj_reason STRING,
  -- Trigger for the latest oom_adj update in the system_server.
  oom_adj_trigger STRING
  ) AS
SELECT
  ts,
  dur,
  score,
  android_oom_adj_score_to_detailed_bucket_name(score, android_appid) AS bucket,
  upid,
  process_name,
  oom_adj_id,
  oom_adj_ts,
  oom_adj_dur,
  oom_adj_track_id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  oom_adj_thread_name,
  oom_adj_reason,
  oom_adj_trigger
FROM _oom_adjuster_intervals;

DROP TABLE IF EXISTS _oom_adj_events_with_src_bucket;
CREATE PERFETTO TABLE _oom_adj_events_with_src_bucket
AS
SELECT
  LAG(bucket) OVER (PARTITION BY upid ORDER BY ts) AS src_bucket,
  ts,
  bucket,
  process_name,
  oom_adj_reason
FROM android_oom_adj_intervals_with_detailed_bucket_name;

DROP VIEW IF EXISTS oom_adj_events_by_process_name;
CREATE PERFETTO VIEW oom_adj_events_by_process_name AS
SELECT
  src_bucket,
  bucket,
  count(ts) as count,
  process_name
FROM _oom_adj_events_with_src_bucket
GROUP BY process_name, bucket, src_bucket;

DROP VIEW IF EXISTS oom_adj_events_global_by_bucket;
CREATE PERFETTO VIEW oom_adj_events_global_by_bucket AS
SELECT
  src_bucket,
  bucket,
  count(ts) as count,
  NULL as name
FROM _oom_adj_events_with_src_bucket
GROUP BY bucket, src_bucket;

DROP VIEW IF EXISTS oom_adj_events_by_oom_adj_reason;
CREATE PERFETTO VIEW oom_adj_events_by_oom_adj_reason AS
SELECT
  src_bucket,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  bucket,
  count(ts) as count,
  oom_adj_reason as name
FROM _oom_adj_events_with_src_bucket
GROUP BY bucket, src_bucket, oom_adj_reason;

DROP VIEW IF EXISTS android_oom_adjuster_output;
CREATE PERFETTO VIEW android_oom_adjuster_output AS
SELECT AndroidOomAdjusterMetric(
  'oom_adjuster_transition_counts_by_process', (
    SELECT RepeatedField(
      AndroidOomAdjusterMetric_OomAdjusterTransitionCounts(
        'name', process_name,
        'src_bucket', src_bucket,
        'dest_bucket', bucket,
        'count', count
      )
    ) FROM oom_adj_events_by_process_name
  ),
  'oom_adjuster_transition_counts_global', (
    SELECT RepeatedField(
      AndroidOomAdjusterMetric_OomAdjusterTransitionCounts(
        'name', name,
        'src_bucket', src_bucket,
        'dest_bucket', bucket,
        'count', count
      )
    )
    FROM oom_adj_events_global_by_bucket
  ),
  'oom_adjuster_transition_counts_by_oom_adj_reason',(
    SELECT RepeatedField(
      AndroidOomAdjusterMetric_OomAdjusterTransitionCounts(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(        'name', name,
        'src_bucket', src_bucket,
        'dest_bucket', bucket,
        'count', count
      )
    )
    FROM oom_adj_events_by_oom_adj_reason
  ),
  'oom_adj_bucket_duration_agg_global',(SELECT RepeatedField(
    AndroidOomAdjusterMetric_OomAdjBucketDurationAggregation(
          'name', name,
          'bucket', bucket,
          'total_dur', total_dur
        )
    )
    FROM (
        SELECT NULL as name, bucket, SUM(dur) as total_dur
        FROM android_oom_adj_intervals_with_detailed_bucket_name GROUP BY bucket
    )
  ),
  'oom_adj_bucket_duration_agg_by_process',(SELECT RepeatedField(
      AndroidOomAdjusterMetric_OomAdjBucketDurationAggregation(
          'name', name,
          'bucket', bucket,
          'total_dur', total_dur
      )
    )
    FROM (
      SELECT process_name as name, bucket, SUM(dur) as total_dur
      FROM android_oom_adj_intervals_with_detailed_bucket_name
      WHERE process_name IS NOT NULL
      GROUP BY process_name, bucket
    )
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ),
  'oom_adj_duration_agg', (SELECT RepeatedField(
      AndroidOomAdjusterMetric_OomAdjDurationAggregation(
          'min_oom_adj_dur', min_oom_adj_dur,
          'max_oom_adj_dur', max_oom_adj_dur,
          'avg_oom_adj_dur', avg_oom_adj_dur,
          'oom_adj_event_count', oom_adj_event_count,
          'oom_adj_reason', oom_adj_reason
      )
    )
    FROM (
      SELECT
        MIN(oom_adj_dur) as min_oom_adj_dur,
        MAX(oom_adj_dur) as max_oom_adj_dur,
        AVG(oom_adj_dur) as avg_oom_adj_dur,
        COUNT(DISTINCT(oom_adj_id)) oom_adj_event_count,
        oom_adj_reason
      FROM android_oom_adj_intervals_with_detailed_bucket_name GROUP BY oom_adj_reason
    )
  )
);

)_d3l1m1t3r_"
;

const char kAndroidAndroidOtherTraces[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

DROP VIEW IF EXISTS android_other_traces_view;
CREATE PERFETTO VIEW android_other_traces_view AS
SELECT
  ts,
  dur,
  SUBSTR(slice.name, 15) AS uuid,
  'Finalize' AS event_type
FROM slice
JOIN track
  ON track.name = 'OtherTraces' AND slice.track_id = track.id
WHERE
  slice.name GLOB 'finalize-uuid-*';

DROP VIEW IF EXISTS android_other_traces_event;
CREATE PERFETTO VIEW android_other_traces_event AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  'slice' AS track_type,
  'Other Traces' AS track_name,
  ts,
  dur,
  event_type || ' ' || uuid AS slice_name
FROM android_other_traces_view;

DROP VIEW IF EXISTS android_other_traces_output;
CREATE PERFETTO VIEW android_other_traces_output AS
SELECT AndroidOtherTracesMetric(
    'finalized_traces_uuid', (
      SELECT RepeatedField(uuid)
      FROM android_other_traces_view
      WHERE event_type = 'Finalize')
  );

)_d3l1m1t3r_"
;

const char kAndroidAndroidPackageList[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

DROP VIEW IF EXISTS android_package_list_output;
CREATE PERFETTO VIEW android_package_list_output AS
SELECT AndroidPackageList(
  'packages', (
    SELECT RepeatedField(AndroidPackageList_Package(
      'package_name', package_name,
      'uid', uid,
      'version_code', version_code
      )) FROM package_list
  )
);

)_d3l1m1t3r_"
;

const char kAndroidAndroidPowrails[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE android.power_rails;

-- View of Power Rail counters with ts converted from ns to ms.
DROP VIEW IF EXISTS power_rails_counters;
CREATE PERFETTO VIEW power_rails_counters AS
SELECT value, ts / 1000000 AS ts, power_rail_name AS name
FROM android_power_rails_counters;

DROP VIEW IF EXISTS avg_used_powers;
CREATE PERFETTO VIEW avg_used_powers AS
SELECT
  name,
  avg_used_power,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  tot_used_power,
  powrail_start_ts,
  powrail_end_ts
FROM (
  SELECT
    name,
    (LEAD(value) OVER (PARTITION BY name ORDER BY ts) - value)
    / (LEAD(ts) OVER (PARTITION BY name ORDER BY ts) - ts) AS avg_used_power,
    (LEAD(value) OVER (PARTITION BY name ORDER BY ts) - value) AS tot_used_power,
    ts AS powrail_start_ts,
    (LEAD(ts) OVER (PARTITION BY name ORDER BY ts)) AS powrail_end_ts
  FROM (
    SELECT name, MIN(ts) AS ts, value
    FROM power_rails_counters
    GROUP BY name
    UNION
    SELECT name, MAX(ts) AS ts, value
    FROM power_rails_counters
    GROUP BY name
  )
  ORDER BY name, ts
) WHERE avg_used_power IS NOT NULL;

DROP VIEW IF EXISTS power_rails_view;
CREATE PERFETTO VIEW power_rails_view AS
WITH RECURSIVE name AS (SELECT DISTINCT name FROM power_rails_counters)
SELECT
  name,
  ts,
  AndroidPowerRails_PowerRails(
    'name', name,
    'energy_data', RepeatedField(
      AndroidPowerRails_EnergyData(
        'timestamp_ms', ts,
        'energy_uws', value
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      )
    ),
    'avg_used_power_mw', (SELECT avg_used_power FROM avg_used_powers
      WHERE avg_used_powers.name = power_rails_counters.name)
  ) AS power_rails_proto
FROM power_rails_counters
GROUP BY name
ORDER BY ts ASC;

DROP VIEW IF EXISTS android_powrails_output;
CREATE PERFETTO VIEW android_powrails_output AS
SELECT AndroidPowerRails(
  'power_rails', (
    SELECT RepeatedField(power_rails_proto)
    FROM power_rails_view
  ),
  'avg_total_used_power_mw', (
    SELECT SUM(tot_used_power) / (MAX(powrail_end_ts) - MIN(powrail_start_ts)) FROM avg_used_powers
  )
);

)_d3l1m1t3r_"
;

const char kAndroidAndroidProxyPower[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- This metric assigns a power drain rate in milliampers to each sched slice.
-- The power_profile table should be populated with device power profile data
-- before running the metric. It has the following scheme:
-- (device STRING, cpu INT, cluster INT, freq INT, power DOUBLE).
--
-- Metric usage examples:
-- 1) Compute the power cost of every thread in milliamper-seconds:
--     SELECT
)_d3l1m1t3r_"
R"_d3l1m1t3r_(--         utid,
--         SUM(dur * COALESCE(power_ma, 0) / 1e9) AS power_mas
--     FROM power_per_thread
--     GROUP BY utid;
-- 2) Compute the total power cost of all slices from a table 'my_slice':
--     CREATE PERFETTO VIEW my_slice_utid AS
--     SELECT ts, dur, utid
--     FROM my_slice
--     JOIN thread_track ON track_id = thread_track.id;
--
--     CREATE VIRTUAL TABLE my_slice_power
--     USING SPAN_JOIN(power_per_thread PARTITIONED utid,
--                     my_slice_utid PARTITIONED utid);
--
--     SELECT
--         SUM(dur * COALESCE(power_ma, 0) / 1e9) as power_mas
--     FROM my_slice_power;

SELECT RUN_METRIC('android/android_cpu_agg.sql');
SELECT RUN_METRIC('android/power_profile_data.sql');

DROP VIEW IF EXISTS device;
CREATE PERFETTO VIEW device AS
WITH
after_first_slash(str) AS (
  SELECT SUBSTR(str_value, INSTR(str_value, '/') + 1)
  FROM metadata
  WHERE name = 'android_build_fingerprint'
),
before_second_slash(str) AS (
  SELECT SUBSTR(str, 0, INSTR(str, '/'))
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  FROM after_first_slash
)
SELECT str AS name FROM before_second_slash;

DROP VIEW IF EXISTS power_view;
CREATE PERFETTO VIEW power_view AS
SELECT
  cpu_freq_view.cpu AS cpu,
  ts,
  dur,
  power AS power_ma
FROM cpu_freq_view
JOIN power_profile ON (
  power_profile.device = (SELECT name FROM device)
  AND power_profile.cpu = cpu_freq_view.cpu
  AND power_profile.freq = cpu_freq_view.freq_khz
  );

-- utid = 0 is a reserved value used to mark sched slices where CPU was idle.
-- It doesn't correspond to any real thread.
DROP VIEW IF EXISTS sched_real_threads;
CREATE PERFETTO VIEW sched_real_threads AS
SELECT *
FROM sched
WHERE utid != 0;

DROP TABLE IF EXISTS power_per_thread;
CREATE VIRTUAL TABLE power_per_thread
USING SPAN_LEFT_JOIN(sched_real_threads PARTITIONED cpu, power_view PARTITIONED cpu);

)_d3l1m1t3r_"
;

const char kAndroidAndroidRtRuntime[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

DROP VIEW IF EXISTS rt_runtime_all;

CREATE PERFETTO VIEW rt_runtime_all
AS
SELECT ts, dur, thread.name AS tname
FROM sched_slice
LEFT JOIN thread
  USING (utid)
LEFT JOIN process
  USING (upid)
WHERE priority < 100
ORDER BY dur DESC;

DROP VIEW IF EXISTS android_rt_runtime_output;

CREATE PERFETTO VIEW android_rt_runtime_output
AS
SELECT
  AndroidRtRuntimeMetric(
    'max_runtime',
    (SELECT dur FROM rt_runtime_all LIMIT 1),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'over_5ms_count',
    (SELECT COUNT(*) FROM rt_runtime_all WHERE dur > 5e6),
    'longest_rt_slices',
    (
      SELECT
        RepeatedField(
          AndroidRtRuntimeMetric_RtSlice(
            'tname', tname, 'ts', ts, 'dur', dur))
      FROM (SELECT ts, dur, tname FROM rt_runtime_all LIMIT 10)
    ));

)_d3l1m1t3r_"
;

const char kAndroidAndroidSimpleperf[] = R"_d3l1m1t3r_(--
-- Copyright 2021 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.


-- Find all counters from track that satisfies regex 'slc/qurg2_(wr|rd):lvl=0x(0|1|3|7)%'
DROP VIEW IF EXISTS all_qurg2;
CREATE PERFETTO VIEW all_qurg2 AS
SELECT
  ts,
  track_id,
  name,
  value
FROM counters
WHERE name GLOB 'slc/qurg2_??:lvl=0x_*';

-- Find all counters from track that satisfies regex 'slc/qurg2_(wr|rd):lvl=0x(1|3|7)%'
DROP VIEW IF EXISTS non_zero_qurg2;
CREATE PERFETTO VIEW non_zero_qurg2 AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  *
FROM all_qurg2
WHERE name NOT GLOB 'slc/qurg2_??:lvl=0x0*';

-- Find all event counters from simpleperf in the form of
-- (<event_name> + '_tid' + <tid> + '_cpu' + <cpu_id>)
DROP VIEW IF EXISTS simpleperf_event_raw;
CREATE PERFETTO VIEW simpleperf_event_raw AS
SELECT
  SUBSTR(name, 0, tid_pos) AS name,
  CAST(SUBSTR(name, tid_pos + 4, cpu_pos - tid_pos - 4) AS INT) AS tid,
  CAST(SUBSTR(name, cpu_pos + 4) AS INT) AS cpu,
  total
FROM (
  SELECT
    name,
    INSTR(name, '_tid') AS tid_pos,
    INSTR(name, '_cpu') AS cpu_pos,
    SUM(value) AS total
  FROM counters
  WHERE name GLOB '*_tid*_cpu*'
  GROUP BY name
);

DROP VIEW IF EXISTS simpleperf_event_per_process;
CREATE PERFETTO VIEW simpleperf_event_per_process AS
SELECT
  e.name,
  t.upid,
  RepeatedField(
    AndroidSimpleperfMetric_PerfEventMetric_Thread(
      'tid', e.tid,
      'name', t.name,
      'cpu', e.cpu,
      'total', e.total
    )
  ) AS threads,
  SUM(e.total) AS total
FROM simpleperf_event_raw e JOIN thread t USING (tid)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(GROUP BY e.name, t.upid;


DROP VIEW IF EXISTS simpleperf_event_metric;
CREATE PERFETTO VIEW simpleperf_event_metric AS
SELECT
  AndroidSimpleperfMetric_PerfEventMetric(
    'name', e.name,
    'processes', RepeatedField(
      AndroidSimpleperfMetric_PerfEventMetric_Process(
        'pid', p.pid,
        'name', p.name,
        'threads', e.threads,
        'total', e.total
      )
    ),
    'total', SUM(total)
  ) AS proto
FROM simpleperf_event_per_process e JOIN process p USING (upid)
GROUP BY e.name;

DROP VIEW IF EXISTS android_simpleperf_output;
CREATE PERFETTO VIEW android_simpleperf_output AS
SELECT AndroidSimpleperfMetric(
  'urgent_ratio', (SELECT sum(value) FROM non_zero_qurg2) / (SELECT sum(value) FROM all_qurg2),
  'events', (SELECT RepeatedField(proto) FROM simpleperf_event_metric)
);

)_d3l1m1t3r_"
;

const char kAndroidAndroidStartup[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

SELECT RUN_METRIC('android/cpu_info.sql');

-- Create the base tables and views containing the launch spans.
INCLUDE PERFETTO MODULE android.startup.startups;

-- TTID and TTFD
INCLUDE PERFETTO MODULE android.startup.time_to_display;

SELECT RUN_METRIC('android/process_metadata.sql');

-- Define the helper functions which will be used throught the remainder
-- of the metric.
SELECT RUN_METRIC('android/startup/slice_functions.sql');
)_d3l1m1t3r_"
R"_d3l1m1t3r_(INCLUDE PERFETTO MODULE intervals.overlap;

-- Define helper functions related to slow start reasons
SELECT RUN_METRIC('android/startup/slow_start_reasons.sql');

-- Run all the HSC metrics.
SELECT RUN_METRIC('android/startup/hsc.sql');

-- Define some helper functions related to breaking down thread state
-- for launches.
SELECT RUN_METRIC('android/startup/thread_state_breakdown.sql');

-- Define helper functions to break down slices/threads by thread
-- state.
SELECT RUN_METRIC('android/startup/mcycles_per_launch.sql');

-- Define helper functions for GC slices.
SELECT RUN_METRIC('android/startup/gc_slices.sql');

-- Define helper functions for system state.
SELECT RUN_METRIC('android/startup/system_state.sql');

CREATE OR REPLACE PERFETTO FUNCTION _is_spans_overlapping(
  ts1 LONG,
  ts_end1 LONG,
  ts2 LONG,
  ts_end2 LONG)
RETURNS BOOL AS
SELECT (IIF($ts1 < $ts2, $ts2, $ts1)
      < IIF($ts_end1 < $ts_end2, $ts_end1, $ts_end2));

-- Returns the slices for forked processes. Never present in hot starts.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- Prefer this over process start_ts, since the process might have
-- been preforked.
CREATE OR REPLACE PERFETTO FUNCTION zygote_fork_for_launch(startup_id INT)
RETURNS TABLE(ts INT, dur INT) AS
SELECT slice.ts, slice.dur
FROM android_startups l
JOIN slice ON (
  l.ts < slice.ts AND
  slice.ts + slice.dur < l.ts_end AND
  STR_SPLIT(slice.name, ': ', 1) = l.package
)
WHERE l.startup_id = $startup_id AND slice.name GLOB 'Start proc: *';

-- Returns the fully drawn slice proto given a launch id.
CREATE OR REPLACE PERFETTO FUNCTION report_fully_drawn_for_launch(startup_id INT)
RETURNS PROTO AS
SELECT
  startup_slice_proto(report_fully_drawn_ts - launch_ts)
FROM (
  SELECT
    launches.ts AS launch_ts,
    min(slice.ts) AS report_fully_drawn_ts
  FROM android_startups launches
  JOIN android_startup_processes ON (launches.startup_id = android_startup_processes.startup_id)
  JOIN thread USING (upid)
  JOIN thread_track USING (utid)
  JOIN slice ON (slice.track_id = thread_track.id)
  WHERE
    slice.name GLOB "reportFullyDrawn*" AND
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    slice.ts >= launches.ts AND
    launches.startup_id = $startup_id
);

-- Given a launch id and GLOB for a slice name, returns the N longest slice name and duration.
CREATE OR REPLACE PERFETTO FUNCTION get_long_slices_for_launch(
  startup_id INT, slice_name STRING, top_n INT)
RETURNS TABLE(slice_name STRING, slice_dur INT) AS
SELECT slice_name, slice_dur
FROM android_thread_slices_for_all_startups s
WHERE s.startup_id = $startup_id AND s.slice_name GLOB $slice_name
ORDER BY slice_dur DESC
LIMIT $top_n;

-- Returns the number of CPUs.
CREATE OR REPLACE PERFETTO FUNCTION get_number_of_cpus()
RETURNS INT AS
SELECT COUNT(DISTINCT cpu)
FROM core_type_per_cpu;

-- Define the view
DROP VIEW IF EXISTS startup_view;
CREATE PERFETTO VIEW startup_view AS
SELECT
  AndroidStartupMetric_Startup(
    'startup_id',launches.startup_id,
    'startup_type', (
      SELECT lp.startup_type
      FROM android_startup_processes lp
      WHERE lp.startup_id =launches.startup_id
      LIMIT 1
    ),
    'package_name', launches.package,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'process_name', (
      SELECT p.name
      FROM android_startup_processes lp
      JOIN process p USING (upid)
      WHERE lp.startup_id =launches.startup_id
      LIMIT 1
    ),
    'process', (
      SELECT m.metadata
      FROM process_metadata m
      JOIN android_startup_processes p USING (upid)
      WHERE p.startup_id =launches.startup_id
      LIMIT 1
    ),
    'activities', (
      SELECT RepeatedField(AndroidStartupMetric_Activity(
        'name', (SELECT STR_SPLIT(s.slice_name, ':', 1)),
        'method', (SELECT STR_SPLIT(s.slice_name, ':', 0)),
        'ts_method_start', s.slice_ts
        ))
      FROM thread_slices_for_all_launches s
      WHERE
        s.startup_id =launches.startup_id
        AND (s.slice_name GLOB 'performResume:*' OR s.slice_name GLOB 'performCreate:*')
    ),
    'long_binder_transactions', (
      SELECT RepeatedField(
        AndroidStartupMetric_BinderTransaction(
          "duration", startup_slice_proto(s.slice_dur),
          "thread", s.thread_name,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(          "destination_thread", EXTRACT_ARG(s.arg_set_id, "destination name"),
          "destination_process", s.process,
          "flags", EXTRACT_ARG(s.arg_set_id, "flags"),
          "code", EXTRACT_ARG(s.arg_set_id, "code"),
          "data_size", EXTRACT_ARG(s.arg_set_id, "data_size")
        )
      )
      FROM ANDROID_BINDER_TRANSACTION_SLICES_FOR_STARTUP(launches.startup_id, 2e7) s
    ),
    'zygote_new_process', EXISTS(SELECT TRUE FROM ZYGOTE_FORK_FOR_LAUNCH(launches.startup_id)),
    'activity_hosting_process_count', (
      SELECT COUNT(1) FROM android_startup_processes p
      WHERE p.startup_id =launches.startup_id
    ),
    'time_to_initial_display', (
      SELECT time_to_initial_display
      FROM android_startup_time_to_display s
      WHERE s.startup_id = launches.startup_id
    ),
    'time_to_full_display', (
      SELECT time_to_full_display
      FROM android_startup_time_to_display s
      WHERE s.startup_id = launches.startup_id
    ),
    'event_timestamps', AndroidStartupMetric_EventTimestamps(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      'intent_received', launches.ts,
      'first_frame', launches.ts_end
    ),
    'to_first_frame', AndroidStartupMetric_ToFirstFrame(
      'dur_ns', launches.dur,
      'dur_ms', launches.dur / 1e6,
      'main_thread_by_task_state', AndroidStartupMetric_TaskStateBreakdown(
        'running_dur_ns', IFNULL(
          main_thread_time_for_launch_and_state(launches.startup_id, 'Running'), 0
        ),
        'runnable_dur_ns', IFNULL(
          main_thread_time_for_launch_in_runnable_state(launches.startup_id), 0
        ),
        'uninterruptible_sleep_dur_ns', IFNULL(
          main_thread_time_for_launch_and_state(launches.startup_id, 'D*'), 0
        ),
        'interruptible_sleep_dur_ns', IFNULL(
          main_thread_time_for_launch_and_state(launches.startup_id, 'S'), 0
        ),
        'uninterruptible_io_sleep_dur_ns', IFNULL(
          main_thread_time_for_launch_state_and_io_wait(launches.startup_id, 'D*', TRUE), 0
        ),
        'uninterruptible_non_io_sleep_dur_ns', IFNULL(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(          main_thread_time_for_launch_state_and_io_wait(launches.startup_id, 'D*', FALSE), 0
        )

      ),
      'mcycles_by_core_type', NULL_IF_EMPTY(AndroidStartupMetric_McyclesByCoreType(
        'little', mcycles_for_launch_and_core_type(launches.startup_id, 'little'),
        'big', mcycles_for_launch_and_core_type(launches.startup_id, 'big'),
        'bigger', mcycles_for_launch_and_core_type(launches.startup_id, 'bigger'),
        'unknown', mcycles_for_launch_and_core_type(launches.startup_id, 'unknown')
      )),
      'to_post_fork',
      launch_to_main_thread_slice_proto(launches.startup_id, 'PostFork'),
      'to_activity_thread_main',
      launch_to_main_thread_slice_proto(launches.startup_id, 'ActivityThreadMain'),
      'to_bind_application',
      launch_to_main_thread_slice_proto(launches.startup_id, 'bindApplication'),
      'time_activity_manager', (
        SELECT startup_slice_proto(l.ts - launches.ts)
        FROM _startup_events l
        WHERE l.ts BETWEEN launches.ts AND launches.ts + launches.dur
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      ),
      'time_post_fork',
      dur_sum_slice_proto_for_launch(launches.startup_id, 'PostFork'),
      'time_activity_thread_main',
      dur_sum_slice_proto_for_launch(launches.startup_id, 'ActivityThreadMain'),
      'time_bind_application',
      dur_sum_slice_proto_for_launch(launches.startup_id, 'bindApplication'),
      'time_activity_start',
      dur_sum_slice_proto_for_launch(launches.startup_id, 'activityStart'),
      'time_activity_resume',
      dur_sum_slice_proto_for_launch(launches.startup_id, 'activityResume'),
      'time_activity_restart',
      dur_sum_slice_proto_for_launch(launches.startup_id, 'activityRestart'),
      'time_choreographer',
      dur_sum_slice_proto_for_launch(launches.startup_id, 'Choreographer#doFrame*'),
      'time_inflate',
      dur_sum_slice_proto_for_launch(launches.startup_id, 'inflate'),
      'time_get_resources',
      dur_sum_slice_proto_for_launch(launches.startup_id, 'ResourcesManager#getResources'),
      'time_dex_open',
      dur_sum_slice_proto_for_launch(launches.startup_id, 'OpenDexFilesFromOat*'),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      'time_verify_class',
      dur_sum_slice_proto_for_launch(launches.startup_id, 'VerifyClass*'),
      'time_gc_total', (
        SELECT NULL_IF_EMPTY(startup_slice_proto(total_gc_time_by_launch(launches.startup_id)))
      ),
      'time_dex_open_thread_main',
      dur_sum_main_thread_slice_proto_for_launch(
        launches.startup_id,
        'OpenDexFilesFromOat*'),
      'time_dlopen_thread_main',
      dur_sum_main_thread_slice_proto_for_launch(
        launches.startup_id,
        'dlopen:*.so'),
      'time_lock_contention_thread_main',
      dur_sum_main_thread_slice_proto_for_launch(
        launches.startup_id,
        'Lock contention on*'
      ),
      'time_monitor_contention_thread_main',
      dur_sum_main_thread_slice_proto_for_launch(
        launches.startup_id,
        'Lock contention on a monitor*'
      ),
      'time_before_start_process', (
        SELECT startup_slice_proto(ts - launches.ts)
        FROM ZYGOTE_FORK_FOR_LAUNCH(launches.startup_id)
      ),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      'time_to_running_state',
      time_to_running_state_for_launch(launches.startup_id),
      'time_jit_thread_pool_on_cpu', NULL_IF_EMPTY(startup_slice_proto(
        thread_time_for_launch_state_and_thread(
         launches.startup_id,
          'Running',
          'Jit thread pool'
        )
      )),
      'time_gc_on_cpu', (
        SELECT startup_slice_proto(sum_dur)
        FROM running_gc_slices_materialized
        WHERE launches.startup_id = startup_id
      ),
      'time_during_start_process', (
        SELECT startup_slice_proto(dur)
        FROM ZYGOTE_FORK_FOR_LAUNCH(launches.startup_id)
      ),
      'jit_compiled_methods', (
        SELECT IIF(COUNT(1) = 0, NULL, COUNT(1))
        FROM ANDROID_SLICES_FOR_STARTUP_AND_SLICE_NAME(launches.startup_id, 'JIT compiling*')
        WHERE thread_name = 'Jit thread pool'
      ),
      'other_processes_spawned_count', (
        SELECT COUNT(1)
        FROM process
        WHERE
          process.start_ts BETWEEN launches.ts AND launches.ts + launches.dur
)_d3l1m1t3r_"
R"_d3l1m1t3r_(          AND process.upid NOT IN (
            SELECT upid FROM android_startup_processes
            WHERE android_startup_processes.startup_id =launches.startup_id
          )
      )
    ),
    'hsc', NULL_IF_EMPTY(AndroidStartupMetric_HscMetrics(
      'full_startup', (
        SELECT startup_slice_proto(h.ts_total)
        FROM hsc_based_startup_times h
        WHERE h.id =launches.startup_id
      )
    )),
    'report_fully_drawn', NULL_IF_EMPTY(report_fully_drawn_for_launch(launches.startup_id)),
    'optimization_status', (
      SELECT RepeatedField(AndroidStartupMetric_OptimizationStatus(
        'location', SUBSTR(STR_SPLIT(slice_name, ' status=', 0), LENGTH('location=') + 1),
        'odex_status', STR_SPLIT(STR_SPLIT(slice_name, ' status=', 1), ' filter=', 0),
        'compilation_filter', STR_SPLIT(STR_SPLIT(slice_name, ' filter=', 1), ' reason=', 0),
        'compilation_reason', STR_SPLIT(slice_name, ' reason=', 1),
        'summary',
        summary_for_optimization_status(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(          SUBSTR(STR_SPLIT(slice_name, ' status=', 0), LENGTH('location=') + 1),
          STR_SPLIT(STR_SPLIT(slice_name, ' status=', 1), ' filter=', 0),
          STR_SPLIT(STR_SPLIT(slice_name, ' filter=', 1), ' reason=', 0),
          STR_SPLIT(slice_name, ' reason=', 1))
        ))
      FROM (
        SELECT *
        FROM ANDROID_SLICES_FOR_STARTUP_AND_SLICE_NAME(
         launches.startup_id,
          'location=* status=* filter=* reason=*'
        )
        ORDER BY slice_name
      )
    ),
    'verify_class', (
      SELECT RepeatedField(AndroidStartupMetric_VerifyClass(
        'name', STR_SPLIT(slice_name, "VerifyClass ", 1),
        'dur_ns', slice_dur))
      FROM GET_LONG_SLICES_FOR_LAUNCH(launches.startup_id, "VerifyClass *", 5)
    ),
    'startup_concurrent_to_launch', (
      SELECT RepeatedField(package)
      FROM android_startups l
      WHERE l.startup_id != launches.startup_id
        AND _is_spans_overlapping(l.ts, l.ts_end, launches.ts, launches.ts_end)
    ),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'dlopen_file', (
      SELECT RepeatedField(STR_SPLIT(slice_name, "dlopen: ", 1))
      FROM android_thread_slices_for_all_startups s
      WHERE startup_id = launches.startup_id AND slice_name GLOB "dlopen: *.so"
    ),
    'system_state', AndroidStartupMetric_SystemState(
      'dex2oat_running',
      dur_of_process_running_concurrent_to_launch(launches.startup_id, '*dex2oat64') > 0,
      'installd_running',
      dur_of_process_running_concurrent_to_launch(launches.startup_id, '*installd') > 0,
      'broadcast_dispatched_count',
      count_slices_concurrent_to_launch(launches.startup_id, 'Broadcast dispatched*'),
      'broadcast_received_count',
      count_slices_concurrent_to_launch(launches.startup_id, 'broadcastReceiveReg*'),
      'most_active_non_launch_processes',
      n_most_active_process_names_for_launch(launches.startup_id),
      'installd_dur_ns',
      dur_of_process_running_concurrent_to_launch(launches.startup_id, '*installd'),
      'dex2oat_dur_ns',
      dur_of_process_running_concurrent_to_launch(launches.startup_id, '*dex2oat64')
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    ),
    -- Remove slow_start_reason implementation once slow_start_reason_detailed
    -- is added to slow_start dashboards. (b/308460401)
    'slow_start_reason', (SELECT RepeatedField(slow_cause)
      FROM (
        SELECT 'No baseline or cloud profiles' AS slow_cause
        WHERE missing_baseline_profile_for_launch(launches.startup_id, launches.package)

        UNION ALL
        SELECT 'Optimized artifacts missing, run from apk'
        WHERE  run_from_apk_for_launch(launches.startup_id)

        UNION ALL
        SELECT 'Unlock running during launch'
        WHERE is_unlock_running_during_launch(launches.startup_id)

        UNION ALL
        SELECT 'App in debuggable mode'
        WHERE is_process_debuggable(launches.package)

        UNION ALL
        SELECT 'GC Activity'
        WHERE total_gc_time_by_launch(launches.startup_id) > 0

        UNION ALL
        SELECT 'dex2oat running during launch' AS slow_cause
        WHERE
          dur_of_process_running_concurrent_to_launch(launches.startup_id, '*dex2oat64') > 0
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
        UNION ALL
        SELECT 'installd running during launch' AS slow_cause
        WHERE
          dur_of_process_running_concurrent_to_launch(launches.startup_id, '*installd') > 0

        UNION ALL
        SELECT 'Main Thread - Time spent in Runnable state'
          AS slow_cause
        WHERE
          get_number_of_cpus() > 2 AND
          main_thread_time_for_launch_in_runnable_state(launches.startup_id) > launches.dur * 0.15

        UNION ALL
        SELECT 'Main Thread - Time spent in interruptible sleep state'
          AS slow_cause
        WHERE main_thread_time_for_launch_and_state(launches.startup_id, 'S') > 2900e6

        UNION ALL
        SELECT 'Main Thread - Time spent in Blocking I/O'
        WHERE main_thread_time_for_launch_state_and_io_wait(launches.startup_id, 'D*', TRUE) > 450e6

        UNION ALL
        SELECT 'Main Thread - Time spent in OpenDexFilesFromOat*'
          AS slow_cause
        WHERE android_sum_dur_on_main_thread_for_startup_and_slice(
          launches.startup_id, 'OpenDexFilesFromOat*') > launches.dur * 0.2
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
        UNION ALL
        SELECT 'Time spent in bindApplication'
          AS slow_cause
        WHERE android_sum_dur_for_startup_and_slice(launches.startup_id, 'bindApplication') > 1250e6

        UNION ALL
        SELECT 'Time spent in view inflation'
          AS slow_cause
        WHERE android_sum_dur_for_startup_and_slice(launches.startup_id, 'inflate') > 450e6

        UNION ALL
        SELECT 'Time spent in ResourcesManager#getResources'
          AS slow_cause
        WHERE android_sum_dur_for_startup_and_slice(
          launches.startup_id, 'ResourcesManager#getResources') > 130e6

        UNION ALL
        SELECT 'Time spent verifying classes'
          AS slow_cause
        WHERE
          android_sum_dur_for_startup_and_slice(launches.startup_id, 'VerifyClass*')
            > launches.dur * 0.15

        UNION ALL
        SELECT 'Potential CPU contention with another process' AS slow_cause
        WHERE
          get_number_of_cpus() > 2 AND
          main_thread_time_for_launch_in_runnable_state(launches.startup_id) > 100e6 AND
)_d3l1m1t3r_"
R"_d3l1m1t3r_(          most_active_process_for_launch(launches.startup_id) IS NOT NULL

        UNION ALL
        SELECT 'JIT Activity'
          AS slow_cause
        WHERE thread_time_for_launch_state_and_thread(
          launches.startup_id,
          'Running',
          'Jit thread pool'
        ) > 100e6

        UNION ALL
        SELECT 'Main Thread - Lock contention'
          AS slow_cause
        WHERE android_sum_dur_on_main_thread_for_startup_and_slice(
          launches.startup_id,
          'Lock contention on*'
        ) > launches.dur * 0.2

        UNION ALL
        SELECT 'Main Thread - Monitor contention'
          AS slow_cause
        WHERE android_sum_dur_on_main_thread_for_startup_and_slice(
          launches.startup_id,
          'Lock contention on a monitor*'
        ) > launches.dur * 0.15

        UNION ALL
        SELECT 'JIT compiled methods'
        WHERE (
          SELECT COUNT(1)
          FROM ANDROID_SLICES_FOR_STARTUP_AND_SLICE_NAME(launches.startup_id, 'JIT compiling*')
)_d3l1m1t3r_"
R"_d3l1m1t3r_(          WHERE thread_name = 'Jit thread pool'
        ) > 65

        UNION ALL
        SELECT 'Broadcast dispatched count'
        WHERE count_slices_concurrent_to_launch(
          launches.startup_id,
          'Broadcast dispatched*'
        ) > 15

        UNION ALL
        SELECT 'Broadcast received count'
        WHERE count_slices_concurrent_to_launch(
          launches.startup_id,
          'broadcastReceiveReg*'
        ) > 50

        UNION ALL
        SELECT 'Startup running concurrent to launch'
        WHERE EXISTS(
          SELECT package
          FROM android_startups l
          WHERE l.startup_id != launches.startup_id
            AND _is_spans_overlapping(l.ts, l.ts_end, launches.ts, launches.ts_end)
        )

        UNION ALL
        SELECT 'Main Thread - Binder transactions blocked'
        WHERE (
          SELECT COUNT(1)
          FROM binder_transaction_reply_slices_for_launch(launches.startup_id, 2e7)
        ) > 0

      )
    ),
    'slow_start_reason_with_details', get_slow_start_reason_with_details(launches.startup_id)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ) AS startup
FROM android_startups launches;

DROP VIEW IF EXISTS android_startup_output;
CREATE PERFETTO VIEW android_startup_output AS
SELECT
  AndroidStartupMetric(
    'startup', (
      SELECT RepeatedField(startup) FROM startup_view
    )
  );

)_d3l1m1t3r_"
;

const char kAndroidAndroidSurfaceflinger[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

SELECT RUN_METRIC(
  'android/frame_missed.sql',
  'track_name', 'PrevFrameMissed',
  'output', 'frame_missed'
);
SELECT RUN_METRIC(
  'android/frame_missed.sql',
  'track_name', 'PrevHwcFrameMissed',
  'output', 'hwc_frame_missed'
);
SELECT RUN_METRIC(
  'android/frame_missed.sql',
  'track_name', 'PrevGpuFrameMissed',
  'output', 'gpu_frame_missed'
);

DROP VIEW IF EXISTS android_surfaceflinger_event;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO VIEW android_surfaceflinger_event AS
SELECT
  'slice' AS track_type,
  'Android Missed Frames' AS track_name,
  ts,
  dur,
  'Frame missed' AS slice_name
FROM frame_missed
WHERE value = 1 AND ts IS NOT NULL;

DROP VIEW IF EXISTS surfaceflinger_track;
CREATE PERFETTO VIEW surfaceflinger_track AS
SELECT tr.id AS track_id, t.utid, t.tid
FROM process p JOIN thread t ON p.upid = t.upid
JOIN thread_track tr ON tr.utid = t.utid
WHERE p.cmdline = '/system/bin/surfaceflinger';

DROP VIEW IF EXISTS gpu_waiting_start;
CREATE PERFETTO VIEW gpu_waiting_start AS
SELECT
  CAST(SUBSTR(s.name, 28) AS UINT32) AS fence_id,
  ts AS start_ts
FROM slices s JOIN surfaceflinger_track t ON s.track_id = t.track_id
WHERE s.name GLOB 'Trace GPU completion fence *';

DROP VIEW IF EXISTS gpu_waiting_end;
CREATE PERFETTO VIEW gpu_waiting_end AS
SELECT
  CAST(SUBSTR(s.name, 28) AS UINT32) AS fence_id,
  dur,
  ts + dur AS end_ts
FROM slices s JOIN surfaceflinger_track t ON s.track_id = t.track_id
WHERE s.name GLOB 'waiting for GPU completion *';
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
DROP VIEW IF EXISTS gpu_waiting_span;
CREATE PERFETTO VIEW gpu_waiting_span AS
SELECT
  fence_id,
  ts,
  dur
FROM (
  SELECT
    fence_id,
    ts,
    LEAD(ts) OVER (ORDER BY fence_id, event_type) - ts AS dur,
    LEAD(fence_id) OVER (ORDER BY fence_id, event_type) AS next_fence_id,
    event_type
  FROM (
    SELECT fence_id, start_ts AS ts, 0 AS event_type FROM gpu_waiting_start
    UNION
    SELECT fence_id, end_ts AS ts, 1 AS event_type FROM gpu_waiting_end
  )
  ORDER BY fence_id, event_type
)
WHERE event_type = 0 AND fence_id = next_fence_id;


DROP VIEW IF EXISTS display_ids;
CREATE PERFETTO VIEW display_ids AS
SELECT DISTINCT display_id
FROM (
  SELECT display_id FROM frame_missed
  UNION
  SELECT display_id FROM hwc_frame_missed
  UNION
  SELECT display_id FROM gpu_frame_missed
);

DROP VIEW IF EXISTS metrics_per_display;
CREATE PERFETTO VIEW metrics_per_display AS
SELECT AndroidSurfaceflingerMetric_MetricsPerDisplay(
  'display_id', d.display_id,
  'missed_frames',
  (SELECT COUNT(1) FROM frame_missed WHERE value = 1 AND display_id = d.display_id),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  'missed_hwc_frames',
  (SELECT COUNT(1) FROM hwc_frame_missed WHERE value = 1 AND display_id = d.display_id),
  'missed_gpu_frames',
  (SELECT COUNT(1) FROM gpu_frame_missed WHERE value = 1 AND display_id = d.display_id),
  'missed_frame_rate',
  (SELECT AVG(value) FROM frame_missed WHERE display_id = d.display_id),
  'missed_hwc_frame_rate',
  (SELECT AVG(value) FROM hwc_frame_missed WHERE display_id = d.display_id),
  'missed_gpu_frame_rate',
  (SELECT AVG(value) FROM gpu_frame_missed WHERE display_id = d.display_id)
) AS proto
FROM display_ids d;

DROP VIEW IF EXISTS android_surfaceflinger_output;
CREATE PERFETTO VIEW android_surfaceflinger_output AS
SELECT
  AndroidSurfaceflingerMetric(
    'missed_frames', (SELECT COUNT(1) FROM frame_missed WHERE value = 1),
    'missed_hwc_frames', (SELECT COUNT(1) FROM hwc_frame_missed WHERE value = 1),
    'missed_gpu_frames', (SELECT COUNT(1) FROM gpu_frame_missed WHERE value = 1),
    'missed_frame_rate', (SELECT AVG(value) FROM frame_missed),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'missed_hwc_frame_rate', (SELECT AVG(value) FROM hwc_frame_missed),
    'missed_gpu_frame_rate', (SELECT AVG(value) FROM gpu_frame_missed),
    'gpu_invocations', (SELECT COUNT(1) FROM gpu_waiting_end),
    'avg_gpu_waiting_dur_ms', (SELECT AVG(dur) / 1e6 FROM gpu_waiting_span),
    'total_non_empty_gpu_waiting_dur_ms',
    (SELECT SUM(dur) / 1e6 FROM gpu_waiting_end),
    'metrics_per_display', (SELECT RepeatedField(proto) FROM metrics_per_display)
  );

)_d3l1m1t3r_"
;

const char kAndroidAndroidSysuiNotificationsBlockingCallsMetric[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE android.slices;

DROP TABLE IF EXISTS android_sysui_notifications_blocking_calls;
CREATE PERFETTO TABLE android_sysui_notifications_blocking_calls AS
SELECT
    s.name name,
    COUNT(s.name) count,
    MAX(dur) AS max_dur_ns,
    MIN(dur) AS min_dur_ns,
    SUM(dur) AS total_dur_ns
FROM slice s
    JOIN thread_track ON s.track_id = thread_track.id
    JOIN thread USING (utid)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(WHERE
    thread.is_main_thread AND
    s.dur > 0 AND (
       s.name GLOB 'NotificationStackScrollLayout#onMeasure'
    OR s.name GLOB 'NotificationToplineView#onMeasure'
    OR s.name GLOB 'ExpNotRow#*'
    OR s.name GLOB 'NotificationShadeWindowView#onMeasure'
    OR s.name GLOB 'ImageFloatingTextView#onMeasure'
)
GROUP BY s.name;

DROP VIEW IF EXISTS android_sysui_notifications_blocking_calls_metric_output;
CREATE PERFETTO VIEW android_sysui_notifications_blocking_calls_metric_output AS
SELECT AndroidSysUINotificationsBlockingCallsMetric('blocking_calls', (
        SELECT RepeatedField(
            AndroidBlockingCall(
                'name', a.name,
                'cnt', a.count,
                'total_dur_ns', a.total_dur_ns,
                'max_dur_ns', a.max_dur_ns,
                'min_dur_ns', a.min_dur_ns
            )
        )
        FROM android_sysui_notifications_blocking_calls a
        ORDER BY total_dur_ns DESC
    )
);

)_d3l1m1t3r_"
;

const char kAndroidAndroidTaskNames[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

SELECT RUN_METRIC('android/process_metadata.sql');

DROP VIEW IF EXISTS android_task_names_output;
CREATE PERFETTO VIEW android_task_names_output AS
WITH
-- Process to thread name
threads_by_upid AS (
  SELECT
    upid,
    RepeatedField(name) AS thread_names
  FROM thread
  WHERE name IS NOT NULL
  GROUP BY 1
),
upid_packages AS (
  SELECT
    upid,
    RepeatedField(package_name) AS packages
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  FROM process
  JOIN android_process_metadata USING (upid)
  WHERE package_name IS NOT NULL
  GROUP BY 1
)
SELECT AndroidTaskNames(
  'process', RepeatedField(
    AndroidTaskNames_Process(
      'pid', p.pid,
      'process_name', p.name,
      'thread_name', threads_by_upid.thread_names,
      'uid', p.uid,
      'uid_package_name', upid_packages.packages
    )
  )
)
FROM process p
LEFT JOIN threads_by_upid USING (upid)
LEFT JOIN upid_packages USING (upid)
WHERE upid != 0;

)_d3l1m1t3r_"
;

const char kAndroidAndroidTraceQuality[] = R"_d3l1m1t3r_(--
-- Copyright 2021 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

DROP VIEW IF EXISTS android_trace_quality_failures;
CREATE PERFETTO VIEW android_trace_quality_failures AS
-- Check that all the sched slices are less than 1 week long.
SELECT
  'sched_slice_too_long' AS name,
  MAX(dur) > 1 * 7 * 24 * 60 * 60 * 1000 * 1000 * 1000 AS failed
FROM sched;

DROP VIEW IF EXISTS android_trace_quality_output;
CREATE PERFETTO VIEW android_trace_quality_output AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT AndroidTraceQualityMetric(
  'failures', (
    SELECT RepeatedField(AndroidTraceQualityMetric_Failure(
      'name', name
      ))
    FROM android_trace_quality_failures
    WHERE failed
  )
);

)_d3l1m1t3r_"
;

const char kAndroidAndroidTrustyWorkqueues[] = R"_d3l1m1t3r_(-- Gather the `nop_work_func` slices and the CPU they each ran on and use that
-- information to generate a metric that displays just the Trusty workqueue
-- events grouped by CPU.
DROP VIEW IF EXISTS android_trusty_workqueues_event;
CREATE PERFETTO VIEW android_trusty_workqueues_event AS
SELECT
  'slice' AS track_type,
  name AS slice_name,
  ts,
  dur,
  'Cpu ' || EXTRACT_ARG(arg_set_id, 'cpu') AS track_name,
  'Trusty Workqueues' AS group_name
FROM slice
WHERE slice.name GLOB 'nop_work_func*';

-- Generate the final metric output. This is empty because we're only using the
-- metric to generate custom tracks, and so don't have any aggregate data to
-- generate.
DROP VIEW IF EXISTS android_trusty_workqueues_output;
CREATE PERFETTO VIEW android_trusty_workqueues_output AS
SELECT AndroidTrustyWorkqueues();

)_d3l1m1t3r_"
;

const char kAndroidCodecMetrics[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

SELECT RUN_METRIC('android/android_cpu.sql');

-- Attaching thread proto with media thread name
DROP VIEW IF EXISTS core_type_proto_per_thread_name;
CREATE PERFETTO VIEW core_type_proto_per_thread_name AS
SELECT
thread.name as thread_name,
core_type_proto_per_thread.proto AS proto
FROM core_type_proto_per_thread
JOIN thread using(utid)
WHERE thread.name = 'MediaCodec_loop' OR
      thread.name = 'CodecLooper'
)_d3l1m1t3r_"
R"_d3l1m1t3r_(GROUP BY thread.name;

-- aggregate all cpu the codec threads
DROP VIEW IF EXISTS codec_per_thread_cpu_use;
CREATE PERFETTO VIEW codec_per_thread_cpu_use AS
SELECT
  upid,
  process.name AS process_name,
  thread.name AS thread_name,
  CAST(SUM(sched.dur) as INT64) AS cpu_time_ns,
  COUNT(DISTINCT utid) AS num_threads
FROM sched
JOIN thread USING(utid)
JOIN process USING(upid)
WHERE thread.name = 'MediaCodec_loop' OR
      thread.name = 'CodecLooper'
GROUP BY process.name, thread.name;

-- All process that has codec thread
DROP VIEW IF EXISTS android_codec_process;
CREATE PERFETTO VIEW android_codec_process AS
SELECT
  upid,
  process.name as process_name
FROM sched
JOIN thread using(utid)
JOIN process using(upid)
WHERE thread.name = 'MediaCodec_loop' OR
      thread.name = 'CodecLooper'
GROUP BY process_name;

-- Total cpu for a process
DROP VIEW IF EXISTS codec_total_per_process_cpu_use;
CREATE PERFETTO VIEW codec_total_per_process_cpu_use AS
SELECT
  upid,
  process_name,
  CAST(SUM(sched.dur) as INT64) AS media_process_cpu_time_ns
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM sched
JOIN thread using(utid)
JOIN android_codec_process using(upid)
GROUP BY process_name;

-- Joining total process with media thread table
DROP VIEW IF EXISTS codec_per_process_thread_cpu_use;
CREATE PERFETTO VIEW codec_per_process_thread_cpu_use AS
SELECT
  *
FROM codec_total_per_process_cpu_use
JOIN codec_per_thread_cpu_use using(process_name);

-- Traces are collected using specific traits in codec framework. These traits
-- are mapped to actual names of slices and then combined with other tables to
-- give out the total_cpu and cpu_running time.

-- Utility function to trim codec trace string: extract the string demilited
-- by the limiter.
CREATE OR REPLACE PERFETTO FUNCTION extract_codec_string(slice_name STRING, limiter STRING)
RETURNS STRING AS
SELECT CASE
  -- Delimit with the first occurrence
  WHEN instr($slice_name, $limiter) > 0
  THEN substr($slice_name, 1, instr($slice_name, $limiter) - 1)
  ELSE $slice_name
END;

-- traits strings from codec framework
DROP TABLE IF EXISTS trace_trait_table;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE TABLE trace_trait_table(
  trace_trait  varchar(100));
insert into trace_trait_table (trace_trait) values
  ('MediaCodec'),
  ('CCodec'),
  ('C2PooledBlockPool'),
  ('C2BufferQueueBlockPool'),
  ('Codec2'),
  ('ACodec'),
  ('FrameDecoder');

-- Maps traits to slice strings. Any string with '@' is considered to indicate
-- the same trace with different information.Hence those strings are delimited
-- using '@' and considered as part of single trace.
DROP VIEW IF EXISTS codec_slices;
CREATE PERFETTO VIEW codec_slices AS
SELECT
  DISTINCT extract_codec_string(slice.name, '@') as codec_slice_string
FROM slice
JOIN trace_trait_table ON slice.name glob  '*' || trace_trait || '*';

-- combine slice and thread info
DROP VIEW IF EXISTS slice_with_utid;
CREATE PERFETTO VIEW slice_with_utid AS
SELECT
  extract_codec_string(slice.name, '@') as codec_string,
  ts,
  dur,
  upid,
  slice.name as slice_name,
  slice.id as slice_id, utid,
  thread.name as thread_name
FROM slice
JOIN thread_track ON thread_track.id = slice.track_id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(JOIN thread USING (utid);

-- Combine with thread_state info
DROP TABLE IF EXISTS slice_thread_state_breakdown;
CREATE VIRTUAL TABLE slice_thread_state_breakdown
USING SPAN_LEFT_JOIN(
  slice_with_utid PARTITIONED utid,
  thread_state PARTITIONED utid
);

-- Get cpu_running_time for all the slices of interest
DROP VIEW IF EXISTS slice_cpu_running;
CREATE PERFETTO VIEW slice_cpu_running AS
SELECT
  codec_string,
  sum(dur) as cpu_time,
  sum(case when state = 'Running' then dur else 0 end) as cpu_run_ns,
  thread_name,
  process.name as process_name,
  slice_id,
  slice_name
FROM slice_thread_state_breakdown
LEFT JOIN process using(upid)
where codec_string in (select codec_slice_string from codec_slices)
GROUP BY codec_string, thread_name, process_name;


-- Generate proto for the trace
DROP VIEW IF EXISTS metrics_per_slice_type;
CREATE PERFETTO VIEW metrics_per_slice_type AS
SELECT
  process_name,
  codec_string,
  AndroidCodecMetrics_Detail(
    'thread_name', thread_name,
    'total_cpu_ns', CAST(cpu_time as INT64),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'running_cpu_ns', CAST(cpu_run_ns as INT64)
  ) AS proto
FROM slice_cpu_running;

-- Generating codec framework cpu metric
DROP VIEW IF EXISTS codec_metrics_output;
CREATE PERFETTO VIEW codec_metrics_output AS
SELECT AndroidCodecMetrics(
  'cpu_usage', (
    SELECT RepeatedField(
      AndroidCodecMetrics_CpuUsage(
        'process_name', process_name,
        'thread_name', thread_name,
        'thread_cpu_ns', CAST((cpu_time_ns) as INT64),
        'num_threads', num_threads,
        'core_data', core_type_proto_per_thread_name.proto
      )
    ) FROM codec_per_process_thread_cpu_use
      JOIN core_type_proto_per_thread_name using(thread_name)
  ),
  'codec_function', (
    SELECT RepeatedField (
      AndroidCodecMetrics_CodecFunction(
        'codec_string', codec_string,
        'process_name', process_name,
        'detail', metrics_per_slice_type.proto
      )
    ) FROM metrics_per_slice_type
  )
);

)_d3l1m1t3r_"
;

const char kAndroidComposerExecution[] = R"_d3l1m1t3r_(--
-- Copyright 2021 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.


-- The HWC execution time will be calculated based on the runtime of
-- HwcPresentOrValidateDisplay, HwcValidateDisplay, and/or HwcPresentDisplay
-- which are happened in one frame.
-- There are 3 possible combinations how those functions will be called, i.e.:
-- 1. HwcPresentOrValidateDisplay and then HwcPresentDisplay
-- 2. HwcPresentOrValidateDisplay
-- 3. HwcValidateDisplay and then HwcPresentDisplay
)_d3l1m1t3r_"
R"_d3l1m1t3r_(DROP VIEW IF EXISTS raw_hwc_function_spans;
CREATE PERFETTO VIEW raw_hwc_function_spans AS
SELECT
  id,
  display_id,
  name,
  dur,
  LEAD(name, 1, '') OVER (PARTITION BY display_id ORDER BY ts) AS next_name,
  LEAD(dur, 1, 0) OVER (PARTITION BY display_id ORDER BY ts) AS next_dur
FROM(
  SELECT
    id,
    ts,
    dur,
    track_id,
    CASE
      WHEN INSTR(name, ' ') = 0 THEN name
      ELSE SUBSTR(name, 1, INSTR(name, ' ')-1)
    END AS name,
    CASE
      WHEN INSTR(name, ' ') = 0 THEN 'unspecified'
      ELSE SUBSTR(name, INSTR(name, ' ')+1)
    END AS display_id
  FROM slice
  WHERE name GLOB 'HwcPresentOrValidateDisplay*' OR name GLOB 'HwcValidateDisplay*'
    OR name GLOB 'HwcPresentDisplay*'
)
ORDER BY ts;

DROP VIEW IF EXISTS {{output}};
CREATE PERFETTO VIEW {{output}} AS
SELECT
  id,
  display_id,
  CASE
    WHEN name = 'HwcValidateDisplay' AND next_name = 'HwcPresentDisplay' THEN dur + next_dur
    WHEN name = 'HwcPresentOrValidateDisplay' AND next_name = 'HwcPresentDisplay' THEN dur + next_dur
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    WHEN name = 'HwcPresentOrValidateDisplay' AND next_name != 'HwcPresentDisplay' THEN dur
    ELSE 0
  END AS execution_time_ns,
  CASE
    WHEN name = 'HwcValidateDisplay' AND next_name = 'HwcPresentDisplay' THEN 'separated_validation'
    WHEN name = 'HwcPresentOrValidateDisplay' AND next_name = 'HwcPresentDisplay' THEN 'unskipped_validation'
    WHEN name = 'HwcPresentOrValidateDisplay' AND next_name != 'HwcPresentDisplay' THEN 'skipped_validation'
    ELSE 'unknown'
  END AS validation_type
FROM raw_hwc_function_spans
WHERE (name = 'HwcValidateDisplay' OR name = 'HwcPresentOrValidateDisplay');

)_d3l1m1t3r_"
;

const char kAndroidCompositionLayers[] = R"_d3l1m1t3r_(--
-- Copyright 2021 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

DROP VIEW IF EXISTS {{output}};
CREATE PERFETTO VIEW {{output}} AS
WITH composition_layer_counts AS (
  SELECT
    LAG(ts) OVER (ORDER BY ts) AS ts,
    name,
    INSTR(name, '(') AS separator_pos,
    value
  FROM counter c
  JOIN process_counter_track t ON c.track_id = t.id
  WHERE t.name GLOB '{{track_name}}*'
)
SELECT
  ts,
  CASE
    WHEN separator_pos = 0 THEN 'unspecified'
    ELSE SUBSTR(name, separator_pos + 1, INSTR(name, ')') - separator_pos - 1)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  END AS display_id,
  value
FROM composition_layer_counts
WHERE value >= 0 AND ts IS NOT NULL;

)_d3l1m1t3r_"
;

const char kAndroidCounterSpanViewMerged[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- Creates a span view for counters that may be global or associated with a
-- process, assuming that in the latter case we don't actually care about the
-- process (probably because it's always system_server). We may want to erase
-- this distinction for example when merging system properties and atrace
-- counters.
--
-- It also does another type of merging: it merges together temporally adjacent
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- identical values.

--TODO(simonmacm) remove when not referenced internally
DROP VIEW IF EXISTS {{table_name}}_span;
CREATE PERFETTO VIEW {{table_name}}_span AS
SELECT
  ts,
  LEAD(ts, 1, trace_end()) OVER(ORDER BY ts) - ts AS dur,
  CAST(value AS INT) AS {{table_name}}_val
FROM (
    SELECT ts, value, LAG(value) OVER (ORDER BY ts) AS lag_value
    FROM counter c JOIN counter_track t
      ON t.id = c.track_id
    WHERE name = '{{counter_name}}'
)
WHERE value != lag_value OR lag_value IS NULL;

)_d3l1m1t3r_"
;

const char kAndroidCpuInfo[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

SELECT RUN_METRIC('android/power_profile_data.sql');

DROP TABLE IF EXISTS cluster_core_type;
CREATE PERFETTO TABLE cluster_core_type AS
SELECT 0 AS cluster, 'little' AS core_type
UNION ALL
SELECT 1, 'big'
UNION ALL
SELECT 2, 'bigger';

DROP VIEW IF EXISTS device_power_profile;
CREATE PERFETTO VIEW device_power_profile AS
SELECT cpu, cluster, freq, power
FROM power_profile pp
WHERE EXISTS (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  SELECT 1 FROM metadata
  WHERE name = 'android_build_fingerprint' AND str_value GLOB '*' || pp.device || '*');

DROP VIEW IF EXISTS core_cluster_per_cpu;
CREATE PERFETTO VIEW core_cluster_per_cpu AS
SELECT DISTINCT cpu, cluster
FROM device_power_profile;

DROP VIEW IF EXISTS core_type_per_cpu;
CREATE PERFETTO VIEW core_type_per_cpu AS
SELECT
  cpu,
  core_type
FROM core_cluster_per_cpu JOIN cluster_core_type USING(cluster);

DROP VIEW IF EXISTS cpu_cluster_power;
CREATE PERFETTO VIEW cpu_cluster_power AS
SELECT DISTINCT core_type, freq, power
FROM device_power_profile pp JOIN cluster_core_type USING(cluster);

)_d3l1m1t3r_"
;

const char kAndroidDisplayMetrics[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
DROP VIEW IF EXISTS same_frame;
CREATE PERFETTO VIEW same_frame AS
SELECT COUNT(name) AS total_duplicate_frames
FROM counters
WHERE name = 'SAME_FRAME'
  AND value = 1;

DROP VIEW IF EXISTS duplicate_frames_logged;
CREATE PERFETTO VIEW duplicate_frames_logged AS
SELECT CASE WHEN COUNT(name) > 0 THEN 1 ELSE 0 END AS logs_found
FROM counters
WHERE name = 'SAME_FRAME' AND value = 0;

DROP VIEW IF EXISTS dpu_underrun;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO VIEW dpu_underrun AS
SELECT COUNT(name) AS total_dpu_underrun_count
FROM counters
WHERE name = 'DPU_UNDERRUN'
  AND value = 1;

DROP VIEW IF EXISTS non_repeated_panel_fps;
CREATE PERFETTO VIEW non_repeated_panel_fps AS
SELECT *
FROM (
  SELECT
    ts,
    value,
    track_id,
    LAG(value, 1, 0) OVER (PARTITION BY track_id ORDER BY ts) AS prev_value
  FROM counter c JOIN track t ON c.track_id = t.id
  WHERE t.name = 'panel_fps'
  ORDER BY ts
)
WHERE prev_value != value;

DROP VIEW IF EXISTS panel_fps_spans;
CREATE PERFETTO VIEW panel_fps_spans AS
SELECT *
FROM (
  SELECT
    ts,
    value,
    LEAD(ts) OVER (PARTITION BY track_id ORDER BY ts) - ts AS dur
  FROM non_repeated_panel_fps
  ORDER BY ts
)
WHERE dur > 0;

DROP VIEW IF EXISTS update_power_state_stats;
CREATE PERFETTO VIEW update_power_state_stats AS
SELECT
  CAST(AVG(dur) / 1e3 AS INT64) AS avg_runtime_micro_secs
FROM slice
WHERE slice.name = 'DisplayPowerController#updatePowerState' AND slice.dur >= 0;

DROP VIEW IF EXISTS display_metrics_output;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO VIEW display_metrics_output AS
SELECT AndroidDisplayMetrics(
  'total_duplicate_frames', (SELECT total_duplicate_frames
    FROM same_frame),
  'duplicate_frames_logged', (SELECT logs_found
    FROM duplicate_frames_logged),
  'total_dpu_underrun_count', (SELECT total_dpu_underrun_count
    FROM dpu_underrun),
  'refresh_rate_switches', (SELECT COUNT(*) FROM panel_fps_spans),
  'refresh_rate_stats', (
    SELECT RepeatedField(metric)
    FROM (
      SELECT AndroidDisplayMetrics_RefreshRateStat(
        'refresh_rate_fps', CAST(value AS UINT32),
        'count', COUNT(*),
        'total_dur_ms', SUM(dur) / 1e6,
        'avg_dur_ms', AVG(dur) / 1e6
      ) AS metric
      FROM panel_fps_spans
      GROUP BY value
      ORDER BY value
    )
  ),
  'update_power_state', (
    SELECT AndroidDisplayMetrics_UpdatePowerState(
      'avg_runtime_micro_secs', avg_runtime_micro_secs
    )
    FROM update_power_state_stats
  )
);

)_d3l1m1t3r_"
;

const char kAndroidFrameMissed[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

DROP VIEW IF EXISTS {{output}};
CREATE PERFETTO VIEW {{output}} AS
WITH frame_missed_counters AS (
  SELECT
    LAG(ts) OVER (ORDER BY ts) AS ts,
    -- We intentionally don't partition by track id here as only one
    -- track should ever exist with this name (the track from
    -- surfaceflinger).
    ts - LAG(ts) OVER (ORDER BY ts) AS dur,
    name,
    INSTR(name, ' ') AS separator_pos,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    value
  FROM counter c
  JOIN process_counter_track t ON c.track_id = t.id
  WHERE t.name GLOB '{{track_name}}*'
)
SELECT
  CASE
    WHEN separator_pos = 0 THEN 'unspecified'
    ELSE SUBSTR(name, separator_pos + 1)
  END AS display_id,
  ts,
  dur,
  value
FROM frame_missed_counters;

)_d3l1m1t3r_"
;

const char kAndroidG2d[] = R"_d3l1m1t3r_(--
-- Copyright 2021 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.


SELECT RUN_METRIC(
  'android/g2d_duration.sql',
  'g2d_type', 'sw',
  'output_table', 'g2d_sw_duration_metric'
);

SELECT RUN_METRIC(
  'android/g2d_duration.sql',
  'g2d_type', 'hw',
  'output_table', 'g2d_hw_duration_metric'
);

DROP VIEW IF EXISTS g2d_output;
CREATE PERFETTO VIEW g2d_output AS
SELECT G2dMetrics(
  'g2d_hw', (SELECT metric FROM g2d_hw_duration_metric),
  'g2d_sw', (SELECT metric FROM g2d_sw_duration_metric)
)_d3l1m1t3r_"
R"_d3l1m1t3r_();

)_d3l1m1t3r_"
;

const char kAndroidG2dDuration[] = R"_d3l1m1t3r_(--
-- Copyright 2021 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

DROP VIEW IF EXISTS raw_g2d_{{g2d_type}}_spans;
CREATE PERFETTO VIEW raw_g2d_{{g2d_type}}_spans AS
SELECT
  ts,
  pct.name AS track_name,
  LEAD(ts, 1, 0) OVER (PARTITION BY name ORDER BY ts) - ts AS dur,
  LAG(value, 1, -1) OVER (PARTITION BY name ORDER BY ts) AS prev_g2d_value,
  value AS g2d_value,
  LEAD(value, 1, -1) OVER (PARTITION BY name ORDER BY ts) AS next_g2d_value
FROM counter c JOIN process_counter_track pct ON pct.id = c.track_id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(WHERE pct.name GLOB 'g2d_frame_{{g2d_type}}*';


DROP VIEW IF EXISTS g2d_{{g2d_type}}_spans;
CREATE PERFETTO VIEW g2d_{{g2d_type}}_spans AS
SELECT ts, track_name, dur
FROM raw_g2d_{{g2d_type}}_spans
WHERE g2d_value = 1 AND next_g2d_value = 0;


DROP VIEW IF EXISTS g2d_{{g2d_type}}_errors;
CREATE PERFETTO VIEW g2d_{{g2d_type}}_errors AS
SELECT ts, track_name, g2d_value
FROM raw_g2d_{{g2d_type}}_spans
WHERE (g2d_value = 1 AND next_g2d_value = 1) OR (prev_g2d_value = 0 AND g2d_value = 0);


DROP VIEW IF EXISTS g2d_{{g2d_type}}_instances;
CREATE PERFETTO VIEW g2d_{{g2d_type}}_instances AS
SELECT
  G2dMetrics_G2dInstance(
    'name', g.track_name,
    'max_dur_ms', MAX(dur) / 1e6,
    'min_dur_ms', MIN(dur) / 1e6,
    'avg_dur_ms', AVG(dur) / 1e6,
    'frame_count', COUNT(*),
    'error_count', (SELECT COUNT(*) FROM g2d_{{g2d_type}}_errors e WHERE e.track_name = g.track_name)
  ) AS instance
FROM g2d_{{g2d_type}}_spans g GROUP BY g.track_name;


DROP VIEW IF EXISTS {{output_table}};
CREATE PERFETTO VIEW {{output_table}} AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  G2dMetrics_G2dMetric(
    'instances', (SELECT RepeatedField(instance) FROM g2d_{{g2d_type}}_instances),
    'max_dur_ms', MAX(dur) / 1e6,
    'min_dur_ms', MIN(dur) / 1e6,
    'avg_dur_ms', AVG(dur) / 1e6,
    'frame_count', COUNT(*),
    'error_count', (SELECT COUNT(*) FROM g2d_{{g2d_type}}_errors)
  ) AS metric
FROM g2d_{{g2d_type}}_spans;

)_d3l1m1t3r_"
;

const char kAndroidGlobalCounterSpanView[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

DROP VIEW IF EXISTS {{table_name}}_span;
CREATE PERFETTO VIEW {{table_name}}_span AS
SELECT
  ts,
  LEAD(ts, 1, trace_end()) OVER(PARTITION BY track_id ORDER BY ts) - ts AS dur,
  value AS {{table_name}}_val
FROM counter c JOIN counter_track t
  ON t.id = c.track_id
WHERE t.type = 'counter_track'
  AND name = '{{counter_name}}';

)_d3l1m1t3r_"
;

const char kAndroidGpuCounterSpanView[] = R"_d3l1m1t3r_(--
-- Copyright 2021 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

DROP VIEW IF EXISTS {{table_name}}_span;
CREATE PERFETTO VIEW {{table_name}}_span AS
SELECT
  ts,
  LEAD(ts, 1, trace_end()) OVER (PARTITION BY track_id ORDER BY ts) - ts AS dur,
  gpu_id,
  value AS {{table_name}}_val
FROM counter c JOIN gpu_counter_track t
  ON t.id = c.track_id
WHERE name = '{{counter_name}}' AND gpu_id IS NOT NULL;

)_d3l1m1t3r_"
;

const char kAndroidJankCujs[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

SELECT RUN_METRIC('android/process_metadata.sql');

-- Stores information about the CUJs (important UI transitions) in the trace.
DROP TABLE IF EXISTS android_jank_cuj;
CREATE TABLE android_jank_cuj AS
-- Finds slices like J<SHADE_EXPAND_COLLAPSE> which mark which frames were
-- rendered during a specific CUJ.
WITH cujs AS (
  SELECT
    ROW_NUMBER() OVER (ORDER BY ts) AS cuj_id,
    process.upid AS upid,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    process.name AS process_name,
    process_metadata.metadata AS process_metadata,
    slice.name AS cuj_slice_name,
    -- Extracts "CUJ_NAME" from "J<CUJ_NAME>"
    SUBSTR(slice.name, 3, LENGTH(slice.name) - 3) AS cuj_name,
    ts,
    dur,
    ts + dur AS ts_end
  FROM slice
  JOIN process_track
    ON slice.track_id = process_track.id
  JOIN process USING (upid)
  JOIN process_metadata USING (upid)
  WHERE
    slice.name GLOB 'J<*>'
    AND (
      process.name GLOB 'com.google.android*'
      OR process.name GLOB 'com.android.*')
    AND dur > 0
),
-- Slices logged from FrameTracker#markEvent that describe when
-- the instrumentation was started and the reason the CUJ ended.
cuj_state_markers AS (
  SELECT
    cujs.cuj_id,
    CASE
      WHEN cuj_state_marker.name GLOB '*FT#begin*' THEN 'begin'
      WHEN cuj_state_marker.name GLOB '*FT#deferMonitoring*' THEN 'deferMonitoring'
      WHEN cuj_state_marker.name GLOB '*FT#end*' THEN 'end'
      WHEN cuj_state_marker.name GLOB '*FT#cancel*' THEN 'cancel'
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      WHEN cuj_state_marker.name GLOB '*FT#layerId*' THEN 'layerId'
    ELSE 'other'
    END AS marker_type,
    cuj_state_marker.name as marker_name
  FROM cujs
  LEFT JOIN slice cuj_state_marker
    ON cuj_state_marker.ts >= cujs.ts
      AND cuj_state_marker.ts < cujs.ts_end
  LEFT JOIN track marker_track on marker_track.id = cuj_state_marker.track_id
  WHERE
    -- e.g. J<CUJ_NAME>#FT#end#0 this for backward compatibility
    cuj_state_marker.name GLOB (cujs.cuj_slice_name || "#FT#*")
    OR (marker_track.name = cuj_slice_name and cuj_state_marker.name GLOB 'FT#*')
)
SELECT
  cujs.*,
  CASE
    WHEN EXISTS (
      SELECT 1
      FROM cuj_state_markers csm
      WHERE csm.cuj_id = cujs.cuj_id
        AND csm.marker_type = 'cancel')
      THEN 'canceled'
    WHEN EXISTS (
      SELECT 1
      FROM cuj_state_markers csm
      WHERE csm.cuj_id = cujs.cuj_id
        AND csm.marker_type = 'end')
      THEN 'completed'
    ELSE NULL
  END AS state,
  (
    SELECT CAST(STR_SPLIT(csm.marker_name, 'layerId#', 1) AS INTEGER)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    FROM cuj_state_markers csm
    WHERE csm.cuj_id = cujs.cuj_id AND csm.marker_name GLOB '*layerId#*'
    LIMIT 1
  ) AS layer_id,
  (
    SELECT CAST(STR_SPLIT(csm.marker_name, 'beginVsync#', 1) AS INTEGER)
    FROM cuj_state_markers csm
    WHERE csm.cuj_id = cujs.cuj_id AND csm.marker_name GLOB '*beginVsync#*'
    LIMIT 1
  ) AS begin_vsync,
  (
    SELECT CAST(STR_SPLIT(csm.marker_name, 'endVsync#', 1) AS INTEGER)
    FROM cuj_state_markers csm
    WHERE csm.cuj_id = cujs.cuj_id AND csm.marker_name GLOB '*endVsync#*'
    LIMIT 1
  ) AS end_vsync
FROM cujs
WHERE
  state != 'canceled'
  -- Older builds don't have the state markers so we allow NULL but filter out
  -- CUJs that are <4ms long - assuming CUJ was canceled in that case.
  OR (state IS NULL AND cujs.dur > 4e6)
ORDER BY ts ASC;
)_d3l1m1t3r_"
;

const char kAndroidJankCujsBoundaries[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Stores the min and max vsync IDs for each of the CUJs which are extracted
-- from the CUJ markers. For backward compatibility (In case the markers don't
-- exist), We calculate that by extracting the vsync ID from the
-- `Choreographer#doFrame` slices that are within the CUJ markers.
DROP TABLE IF EXISTS android_jank_cuj_vsync_boundary;
CREATE PERFETTO TABLE android_jank_cuj_vsync_boundary AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  cuj.cuj_id,
  cuj.upid, -- also store upid to simplify further queries
  cuj.layer_id,  -- also store layer_id to simplify further queries
  IFNULL(cuj.begin_vsync, MIN(vsync)) AS vsync_min,
  IFNULL(cuj.end_vsync, MAX(vsync)) AS vsync_max
FROM android_jank_cuj cuj
JOIN android_jank_cuj_do_frame_slice USING (cuj_id)
GROUP BY cuj.cuj_id, cuj.upid, cuj.layer_id;

-- Similarly, extract the min/max vsync for the SF from
-- commit/compose/onMessageInvalidate slices on its main thread.
DROP TABLE IF EXISTS android_jank_cuj_sf_vsync_boundary;
CREATE PERFETTO TABLE android_jank_cuj_sf_vsync_boundary AS
SELECT
  cuj_id,
  MIN(vsync) AS vsync_min,
  MAX(vsync) AS vsync_max
FROM android_jank_cuj_sf_root_slice
GROUP BY cuj_id;

-- Calculates the frame boundaries based on when we *expected* the work on
-- a given frame to start and when the previous frame finished - not when
-- Choreographer#doFrame actually started.
-- We use MAX(expected time, previous frame ended) as the expected start time.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- Shifting the start time based on the previous frame is done to avoid having
-- overlapping frame boundaries which would make further analysis more
-- complicated.
-- We also separately store the previous frame ts_end.
-- This will allow us to look into cases where frame start was delayed due to
-- some other work occupying the main thread (e.g. non-drawing callbacks or
-- the previous frame taking much longer than expected).
DROP TABLE IF EXISTS android_jank_cuj_main_thread_frame_boundary;
CREATE PERFETTO TABLE android_jank_cuj_main_thread_frame_boundary AS
-- intermediate table that discards unfinished slices and parses vsync as int.
WITH expected_timeline AS (
  SELECT *, CAST(name AS INTEGER) AS vsync
  FROM expected_frame_timeline_slice
  WHERE dur > 0
),
-- Matches vsyncs in CUJ to expected frame timeline data.
-- We also store the actual timeline data to handle a few edge cases where due to clock drift the frame timeline is shifted
cuj_frame_timeline AS (
  SELECT
    cuj_id,
    vsync,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    e.ts AS ts_expected,
    -- In cases where we are drawing multiple layers, there will be  one
    -- expected frame timeline slice, but multiple actual frame timeline slices.
    -- As a simplification we just take here the min(ts) and max(ts_end) of
    -- the actual frame timeline slices.
    MIN(a.ts) AS ts_actual_min,
    MAX(a.ts + a.dur) AS ts_end_actual_max
  FROM android_jank_cuj_vsync_boundary vsync_boundary
  JOIN expected_timeline e
    ON e.upid = vsync_boundary.upid
      AND e.vsync >= vsync_min
      AND e.vsync <= vsync_max
  JOIN actual_frame_timeline_slice a
    ON e.upid = a.upid
      AND e.name = a.name
  GROUP BY cuj_id, e.vsync, e.ts
),
-- Orders do_frame slices by vsync to calculate the ts_end of the previous frame
-- android_jank_cuj_do_frame_slice only contains frames within the CUJ so
-- the ts_prev_do_frame_end is always missing for the very first frame
-- For now this is acceptable as it keeps the query simpler.
do_frame_ordered AS (
  SELECT
    *,
    -- ts_end of the previous do_frame, or -1 if no previous do_frame found
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    COALESCE(LAG(ts_end) OVER (PARTITION BY cuj_id ORDER BY vsync ASC), -1) AS ts_prev_do_frame_end
  FROM android_jank_cuj_do_frame_slice
),
-- introducing an intermediate table since we want to calculate dur = ts_end - ts
frame_boundary_base AS (
  SELECT
    do_frame.cuj_id,
    do_frame.utid,
    do_frame.vsync,
    do_frame.ts AS ts_do_frame_start,
    do_frame.ts_end,
    do_frame.ts_prev_do_frame_end,
    timeline.ts_expected,
    CASE
      WHEN timeline.ts_expected IS NULL
        THEN do_frame.ts
      ELSE MAX(do_frame.ts_prev_do_frame_end, timeline.ts_expected)
    END AS ts
  FROM do_frame_ordered do_frame
  LEFT JOIN cuj_frame_timeline timeline
    ON timeline.cuj_id = do_frame.cuj_id
      AND do_frame.vsync = timeline.vsync
      -- There are a few special cases we have to handle:
      -- *) In rare cases there is a clock drift after device suspends
      -- This may cause the actual/expected timeline to be misaligned with the rest
      -- of the trace for a short period.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      -- Do not use the timelines if it seems that this happened.
      -- *) Actual timeline start time might also be reported slightly after doFrame
      -- starts. We allow it to start up to 1ms later.
      -- *) If the frame is significantly (~100s of ms) over the deadline,
      -- expected timeline data will be dropped in SF and never recorded. In that case
      -- the actual timeline will only report the end ts correctly. If this happens
      -- fall back to calculating the boundaries based on doFrame slices. Ideally we
      -- would prefer to infer the intended start time of the frame instead.
      AND do_frame.ts >= timeline.ts_actual_min - 1e6 AND do_frame.ts <= timeline.ts_end_actual_max
)
SELECT
  *,
  ts_end - ts AS dur
FROM frame_boundary_base;


-- Compute the CUJ boundary on the main thread from the frame boundaries.
DROP TABLE IF EXISTS android_jank_cuj_main_thread_cuj_boundary;
CREATE PERFETTO TABLE android_jank_cuj_main_thread_cuj_boundary AS
SELECT
  cuj_id,
  utid,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  MIN(ts) AS ts,
  MAX(ts_end) AS ts_end,
  MAX(ts_end) - MIN(ts) AS dur
FROM android_jank_cuj_main_thread_frame_boundary
GROUP BY cuj_id, utid;

-- Similar to `android_jank_cuj_main_thread_frame_boundary` but for the render
-- thread the expected start time is the time of the first `postAndWait` slice
-- on the main thread.
-- The query is slightly simpler because we don't have to handle the clock drift
-- and data loss like with the frame timeline.
-- One difference vs main thread is that there might be multiple DrawFrames
-- slices for a single vsync - this happens when we are drawing multiple layers
-- (e.g. status bar & notifications).
DROP TABLE IF EXISTS android_jank_cuj_render_thread_frame_boundary;
CREATE PERFETTO TABLE android_jank_cuj_render_thread_frame_boundary AS
-- see do_frame_ordered above
-- we also order by `ts` to handle multiple DrawFrames for a single vsync
WITH draw_frame_ordered AS (
  SELECT
    *,
    -- ts_end of the previous draw frame, or -1 if no previous draw frame found
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    COALESCE(LAG(ts_end) OVER (PARTITION BY cuj_id ORDER BY vsync ASC, ts ASC), -1) AS ts_prev_draw_frame_end
  FROM android_jank_cuj_draw_frame_slice
),
-- introducing an intermediate table since we want to calculate dur = ts_end - ts
frame_boundary_base AS (
  SELECT
    draw_frame.cuj_id,
    draw_frame.utid,
    draw_frame.vsync,
    MIN(post_and_wait.ts) AS ts_expected,
    MIN(draw_frame.ts) AS ts_draw_frame_start,
    MIN(draw_frame.ts_prev_draw_frame_end) AS ts_prev_draw_frame_end,
    MIN(
      MAX(
        MIN(post_and_wait.ts),
        MIN(draw_frame.ts_prev_draw_frame_end)),
      MIN(draw_frame.ts)) AS ts,
    MAX(draw_frame.ts_end) AS ts_end
  FROM draw_frame_ordered draw_frame
  JOIN android_jank_cuj_do_frame_slice do_frame USING (cuj_id, vsync)
  JOIN descendant_slice(do_frame.id) post_and_wait
  WHERE post_and_wait.name = 'postAndWait'
  GROUP BY draw_frame.cuj_id, draw_frame.utid, draw_frame.vsync
)
SELECT
  *,
  ts_end - ts AS dur
FROM frame_boundary_base;

-- Compute the CUJ boundary on the render thread from the frame boundaries.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(DROP TABLE IF EXISTS android_jank_cuj_render_thread_cuj_boundary;
CREATE PERFETTO TABLE android_jank_cuj_render_thread_cuj_boundary AS
SELECT
  cuj_id,
  utid,
  MIN(ts) AS ts,
  MAX(ts_end) AS ts_end,
  MAX(ts_end) - MIN(ts) AS dur
FROM android_jank_cuj_render_thread_frame_boundary
GROUP BY cuj_id, utid;

-- Compute the overall CUJ boundary (in the app process) based on the main
-- thread CUJ boundaries and the actual timeline.
DROP TABLE IF EXISTS android_jank_cuj_boundary;
CREATE PERFETTO TABLE android_jank_cuj_boundary AS
-- introducing an intermediate table since we want to calculate dur = ts_end - ts
WITH boundary_base AS (
  SELECT
    cuj_id,
    cuj.upid,
    main_thread_boundary.ts,
    CASE
      WHEN timeline_slice.ts IS NOT NULL
        THEN MAX(timeline_slice.ts + timeline_slice.dur)
      ELSE (
        SELECT MAX(MAX(ts_end), cuj.ts_end)
        FROM android_jank_cuj_do_frame_slice do_frame
        WHERE do_frame.cuj_id = cuj.cuj_id)
    END AS ts_end
  FROM android_jank_cuj_main_thread_cuj_boundary main_thread_boundary
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  JOIN android_jank_cuj cuj USING (cuj_id)
  JOIN android_jank_cuj_vsync_boundary USING (cuj_id)
  LEFT JOIN actual_frame_timeline_slice timeline_slice
    ON cuj.upid = timeline_slice.upid
      -- Timeline slices for this exact VSYNC might be missing (e.g. if the last
      -- doFrame did not actually produce anything to draw).
      -- In that case we compute the boundary based on the last doFrame and the
      -- CUJ markers.
      AND vsync_max = CAST(timeline_slice.name AS INTEGER)
  GROUP BY cuj_id, cuj.upid, main_thread_boundary.ts
)
SELECT
  *,
  ts_end - ts AS dur
FROM boundary_base;

-- Similar to `android_jank_cuj_main_thread_frame_boundary`, calculates the frame boundaries
-- based on when we *expected* the work to start and we use the end of the `composite` slice
-- as the end of the work on the frame.
DROP TABLE IF EXISTS android_jank_cuj_sf_main_thread_frame_boundary;
CREATE PERFETTO TABLE android_jank_cuj_sf_main_thread_frame_boundary AS
-- Join `commit` and `composite` slices using vsync IDs.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- We treat the two slices as a single "fake slice" that starts when `commit` starts, and ends
-- when `composite` ends.
WITH fake_commit_composite_slice AS (
  SELECT
    cuj_id,
    commit_slice.utid,
    vsync,
    commit_slice.ts,
    composite_slice.ts_end,
    composite_slice.ts_end - commit_slice.ts AS dur
  FROM android_jank_cuj_sf_commit_slice commit_slice
  JOIN android_jank_cuj_sf_composite_slice composite_slice USING(cuj_id, vsync)
),
-- As older builds will not have separate commit/composite slices for each frame, but instead
-- a single `onMessageInvalidate`, we UNION ALL the two tables. Exactly one of them should
-- have data.
main_thread_slice AS (
  SELECT utid, cuj_id, vsync, ts, dur, ts_end FROM fake_commit_composite_slice
  UNION ALL
  SELECT utid, cuj_id, vsync, ts, dur, ts_end FROM android_jank_cuj_sf_on_message_invalidate_slice
)
SELECT
  cuj_id,
  utid,
  vsync,
  expected_timeline.ts,
  main_thread_slice.ts AS ts_main_thread_start,
  main_thread_slice.ts_end,
  main_thread_slice.ts_end - expected_timeline.ts AS dur
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM expected_frame_timeline_slice expected_timeline
JOIN android_jank_cuj_sf_process USING (upid)
JOIN main_thread_slice
  ON main_thread_slice.vsync = CAST(expected_timeline.name AS INTEGER);

-- Compute the CUJ boundary on the main thread from the frame boundaries.
DROP TABLE IF EXISTS android_jank_cuj_sf_main_thread_cuj_boundary;
CREATE PERFETTO TABLE android_jank_cuj_sf_main_thread_cuj_boundary AS
SELECT
  cuj_id,
  utid,
  MIN(ts) AS ts,
  MAX(ts_end) AS ts_end,
  MAX(ts_end) - MIN(ts) AS dur
FROM android_jank_cuj_sf_main_thread_frame_boundary
GROUP BY cuj_id, utid;

-- RenderEngine will only work on a frame if SF falls back to client composition.
-- Because of that we do not calculate overall CUJ boundaries so there is no
-- `android_jank_cuj_sf_render_engine_cuj_boundary` table created.
-- RenderEngine frame boundaries are calculated based on `composeSurfaces` slice start
-- on the main thread (this calls into RenderEngine), and when `REThreaded::drawLayers`
-- ends.
DROP TABLE IF EXISTS android_jank_cuj_sf_render_engine_frame_boundary;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO TABLE android_jank_cuj_sf_render_engine_frame_boundary AS
SELECT
  cuj_id,
  utid,
  vsync,
  draw_layers.ts_compose_surfaces AS ts,
  draw_layers.ts AS ts_draw_layers_start,
  draw_layers.ts_end,
  draw_layers.ts_end - draw_layers.ts_compose_surfaces AS dur
FROM android_jank_cuj_sf_draw_layers_slice draw_layers;

DROP TABLE IF EXISTS android_jank_cuj_sf_boundary;
CREATE PERFETTO TABLE android_jank_cuj_sf_boundary AS
SELECT cuj_id, ts, ts_end, dur
FROM android_jank_cuj_sf_main_thread_cuj_boundary;

)_d3l1m1t3r_"
;

const char kAndroidJankFrames[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE android.frames.jank_type;

DROP TABLE IF EXISTS vsync_missed_callback;
CREATE PERFETTO TABLE vsync_missed_callback AS
SELECT CAST(STR_SPLIT(name, 'Callback#', 1) AS INTEGER) AS vsync,
       MAX(name GLOB '*SF*') as sf_callback_missed,
       MAX(name GLOB '*HWUI*') as hwui_callback_missed
FROM slice
WHERE name GLOB '*FT#Missed*Callback*'
GROUP BY vsync;

DROP TABLE IF EXISTS android_jank_cuj_frame_timeline;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO TABLE android_jank_cuj_frame_timeline AS
WITH actual_timeline_with_vsync AS (
  SELECT
    *,
    CAST(name AS INTEGER) AS vsync
  FROM actual_frame_timeline_slice
  WHERE dur > 0
)
SELECT
  cuj_id,
  vsync,
  -- We use MAX to check if at least one of the layers jank_type matches the pattern
  MAX(android_is_app_jank_type(jank_type)) AS app_missed,
  -- We use MAX to check if at least one of the layers jank_type matches the pattern
  MAX(android_is_sf_jank_type(jank_type)) AS sf_missed,
  IFNULL(MAX(sf_callback_missed), 0) AS sf_callback_missed,
  IFNULL(MAX(hwui_callback_missed), 0) AS hwui_callback_missed,
  -- We use MIN to check if ALL layers finished on time
  MIN(on_time_finish) AS on_time_finish,
  MAX(timeline.ts + timeline.dur) AS ts_end_actual,
  MAX(timeline.dur) AS dur,
  -- At the moment of writing we expect to see at most one expected_frame_timeline_slice
  -- for a given vsync but using MAX here in case this changes in the future.
  -- In case expected timeline is missing, as a fallback we use the typical frame deadline
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- for 60Hz.
  COALESCE(MAX(expected.dur), 16600000) AS dur_expected,
  COUNT(DISTINCT timeline.layer_name) as number_of_layers_for_frame,
  -- we use MAX to get at least one of the frame's layer names
  MAX(timeline.layer_name) as frame_layer_name
FROM android_jank_cuj_vsync_boundary boundary
JOIN actual_timeline_with_vsync timeline
  ON boundary.upid = timeline.upid
    AND vsync >= vsync_min
    AND vsync <= vsync_max
LEFT JOIN expected_frame_timeline_slice expected
  ON expected.upid = timeline.upid AND expected.name = timeline.name
LEFT JOIN vsync_missed_callback missed_callback USING(vsync)
WHERE
  boundary.layer_id IS NULL
  OR (
    timeline.layer_name GLOB '*#*'
    AND boundary.layer_id
      = CAST(STR_SPLIT(timeline.layer_name, '#', 1) AS INTEGER))
GROUP BY cuj_id, vsync;

DROP TABLE IF EXISTS android_jank_cuj_layer_name;
CREATE PERFETTO TABLE android_jank_cuj_layer_name AS
SELECT
    cuj_id,
    MAX(frame_layer_name) as layer_name
FROM android_jank_cuj_frame_timeline timeline
)_d3l1m1t3r_"
R"_d3l1m1t3r_(GROUP BY cuj_id
-- Return only cujs where the max number of layers for all frames in the whole cuj equals 1,
-- this is to infer the layer name if the cuj marker for layer id is not present
HAVING MAX(number_of_layers_for_frame) = 1;

-- Matches slices and boundaries to compute estimated frame boundaries across
-- all threads. Joins with the actual timeline to figure out which frames missed
-- the deadline and whether the app process or SF are at fault.
DROP TABLE IF EXISTS android_jank_cuj_frame;
CREATE PERFETTO TABLE android_jank_cuj_frame AS
WITH frame_base AS (
  SELECT
    cuj_id,
    ROW_NUMBER() OVER (PARTITION BY cuj_id ORDER BY do_frame.vsync ASC) AS frame_number,
    vsync,
    boundary.ts,
    boundary.ts_expected,
    boundary.ts_do_frame_start,
    COUNT(fence_idx) AS gpu_fence_count,
    COUNT(fence_idx) > 0 AS drew_anything
  FROM android_jank_cuj_do_frame_slice do_frame
  JOIN android_jank_cuj_main_thread_frame_boundary boundary USING (cuj_id, vsync)
  JOIN android_jank_cuj_draw_frame_slice draw_frame USING (cuj_id, vsync)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  LEFT JOIN android_jank_cuj_gpu_completion_fence fence USING (cuj_id, vsync)
  WHERE draw_frame.id = fence.draw_frame_slice_id
  GROUP BY cuj_id, vsync, boundary.ts, boundary.ts_do_frame_start
)
SELECT
  frame_base.*,
  app_missed,
  sf_missed,
  sf_callback_missed,
  hwui_callback_missed,
  on_time_finish,
  ts_end_actual - ts AS dur,
  ts_end_actual - ts_do_frame_start AS dur_unadjusted,
  dur_expected,
  ts_end_actual AS ts_end
FROM frame_base
JOIN android_jank_cuj_frame_timeline USING (cuj_id, vsync);

-- Similar to `android_jank_cuj_frame` computes overall SF frame boundaries.
-- The computation is somewhat simpler as most of SF work happens within the duration of
-- the commit/composite slices on the main thread.
DROP TABLE IF EXISTS android_jank_cuj_sf_frame;
CREATE PERFETTO TABLE android_jank_cuj_sf_frame AS
SELECT
  cuj_id,
  ROW_NUMBER() OVER (PARTITION BY cuj_id ORDER BY vsync ASC) AS frame_number,
  vsync,
  boundary.ts,
  boundary.ts_main_thread_start,
  boundary.ts_end,
  boundary.dur,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  actual_timeline.jank_tag = 'Self Jank' AS sf_missed,
  NULL AS app_missed, -- for simplicity align schema with android_jank_cuj_frame
  jank_tag,
  jank_type,
  prediction_type,
  present_type,
  gpu_composition,
  -- In case expected timeline is missing, as a fallback we use the typical frame deadline
  -- for 60Hz.
  -- See similar expression in android_jank_cuj_frame_timeline.
  COALESCE(expected_timeline.dur, 16600000) AS dur_expected
FROM android_jank_cuj_sf_main_thread_frame_boundary boundary
JOIN android_jank_cuj_sf_process sf_process
JOIN actual_frame_timeline_slice actual_timeline
  ON actual_timeline.upid = sf_process.upid
    AND boundary.vsync = CAST(actual_timeline.name AS INTEGER)
LEFT JOIN expected_frame_timeline_slice expected_timeline
  ON expected_timeline.upid = actual_timeline.upid
    AND expected_timeline.name = actual_timeline.name;

)_d3l1m1t3r_"
;

const char kAndroidJankInternalCounters[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

DROP TABLE IF EXISTS android_jank_cuj_counter;
CREATE PERFETTO TABLE android_jank_cuj_counter AS
WITH cuj_counter_track AS (
  SELECT DISTINCT
    upid,
    track.id AS track_id,
    -- extract the CUJ name inside <>
    STR_SPLIT(STR_SPLIT(track.name, '>#', 0), '<', 1) AS cuj_name,
    -- take the name of the counter after #
    STR_SPLIT(track.name, '#', 1) AS counter_name
  FROM process_counter_track track
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  JOIN android_jank_cuj USING (upid)
  WHERE track.name GLOB 'J<*>#*'
)
SELECT
  ts,
  upid,
  cuj_name,
  counter_name,
  CAST(value AS INTEGER) AS value
FROM counter
JOIN cuj_counter_track ON counter.track_id = cuj_counter_track.track_id;

CREATE OR REPLACE PERFETTO FUNCTION android_jank_cuj_counter_value(cuj_name STRING,
                                                        counter_name STRING,
                                                        ts_min INT,
                                                        ts_max INT)
RETURNS INT AS
SELECT value
FROM android_jank_cuj_counter
WHERE
  cuj_name = $cuj_name
  AND counter_name = $counter_name
  AND ts >= $ts_min
  AND ($ts_max IS NULL OR ts <= $ts_max)
ORDER BY ts ASC LIMIT 1;

DROP TABLE IF EXISTS cuj_marker_missed_callback;
CREATE PERFETTO TABLE cuj_marker_missed_callback AS
SELECT
  marker_track.name AS cuj_slice_name,
  marker.ts,
  marker.name AS marker_name
FROM slice marker
JOIN track marker_track on  marker_track.id = marker.track_id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(WHERE marker.name GLOB '*FT#Missed*';

CREATE OR REPLACE PERFETTO FUNCTION android_missed_vsyncs_for_callback(
  cuj_slice_name STRING,
  ts_min INT,
  ts_max INT,
  callback_missed STRING
)
RETURNS INT AS
SELECT IFNULL(SUM(marker_name GLOB $callback_missed), 0)
FROM cuj_marker_missed_callback
WHERE
  cuj_slice_name = $cuj_slice_name
  AND ts >= $ts_min
  AND ($ts_max IS NULL OR ts <= $ts_max)
ORDER BY ts ASC
LIMIT 1;

DROP TABLE IF EXISTS android_jank_cuj_counter_metrics;
CREATE PERFETTO TABLE android_jank_cuj_counter_metrics AS
-- Order CUJs to get the ts of the next CUJ with the same name.
-- This is to avoid selecting counters logged for the next CUJ in case multiple
-- CUJs happened in a short succession.
WITH cujs_ordered AS (
  SELECT
    cuj_id,
    cuj_name,
    cuj_slice_name,
    upid,
    state,
    ts_end,
    CASE
      WHEN process_name GLOB 'com.android.*' THEN ts_end
      WHEN process_name = 'com.google.android.apps.nexuslauncher' THEN ts_end
      -- Some processes publish counters just before logging the CUJ end
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      ELSE MAX(ts, ts_end - 4000000)
    END AS ts_earliest_allowed_counter,
    LEAD(ts_end) OVER (PARTITION BY cuj_name ORDER BY ts_end ASC) AS ts_end_next_cuj
  FROM android_jank_cuj
)
SELECT
  cuj_id,
  cuj_name,
  upid,
  state,
  android_jank_cuj_counter_value(cuj_name, 'totalFrames', ts_earliest_allowed_counter, ts_end_next_cuj) AS total_frames,
  android_jank_cuj_counter_value(cuj_name, 'missedFrames', ts_earliest_allowed_counter, ts_end_next_cuj) AS missed_frames,
  android_jank_cuj_counter_value(cuj_name, 'missedAppFrames', ts_earliest_allowed_counter, ts_end_next_cuj) AS missed_app_frames,
  android_jank_cuj_counter_value(cuj_name, 'missedSfFrames', ts_earliest_allowed_counter, ts_end_next_cuj) AS missed_sf_frames,
  android_jank_cuj_counter_value(cuj_name, 'maxSuccessiveMissedFrames', ts_earliest_allowed_counter, ts_end_next_cuj) AS missed_frames_max_successive,
  -- convert ms to nanos to align with the unit for `dur` in the other tables
  android_jank_cuj_counter_value(cuj_name, 'maxFrameTimeMillis', ts_earliest_allowed_counter, ts_end_next_cuj) * 1000000 AS frame_dur_max,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  android_missed_vsyncs_for_callback(cuj_slice_name, ts_earliest_allowed_counter, ts_end_next_cuj, '*SF*') AS sf_callback_missed_frames,
  android_missed_vsyncs_for_callback(cuj_slice_name, ts_earliest_allowed_counter, ts_end_next_cuj, '*HWUI*') AS hwui_callback_missed_frames
FROM cujs_ordered cuj;

)_d3l1m1t3r_"
;

const char kAndroidJankInternalDerivedEvents[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.


DROP VIEW IF EXISTS android_jank_cuj_event;
CREATE PERFETTO VIEW android_jank_cuj_event AS
-- Computed CUJ boundaries.
SELECT
  'slice' AS track_type,
  cuj.cuj_name AS track_name,
  boundary.ts,
  boundary.dur,
  cuj.cuj_name || ' (adjusted, id=' || cuj_id || ') ' AS slice_name,
  'CUJ Boundaries' AS group_name
FROM android_jank_cuj cuj
JOIN android_jank_cuj_boundary boundary USING (cuj_id)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(UNION ALL
-- Computed frame boundaries on the Main Thread.
SELECT
  'slice' AS track_type,
  cuj.cuj_name || ' MT ' || vsync AS track_name,
  boundary.ts,
  boundary.dur,
  vsync || '' AS slice_name,
  cuj.cuj_name || ' - MT frame boundaries' AS group_name
FROM android_jank_cuj cuj
JOIN android_jank_cuj_main_thread_frame_boundary boundary USING (cuj_id)
UNION ALL
-- Computed frame boundaries on the Render Thread.
SELECT
  'slice' AS track_type,
  cuj.cuj_name || ' RT ' || vsync AS track_name,
  boundary.ts,
  boundary.dur,
  vsync || '' AS slice_name,
  cuj.cuj_name || ' - RT frame boundaries' AS group_name
FROM android_jank_cuj cuj
JOIN android_jank_cuj_render_thread_frame_boundary boundary USING (cuj_id)
UNION ALL
-- Computed overall frame boundaries not specific to any thread.
SELECT
  'slice' AS track_type,
  cuj.cuj_name || ' ' || vsync AS track_name,
  f.ts,
  f.dur,
  vsync || ' [app_missed=' || f.app_missed || ']' AS slice_name,
  cuj.cuj_name || ' - frames' AS group_name
FROM android_jank_cuj cuj
)_d3l1m1t3r_"
R"_d3l1m1t3r_(JOIN android_jank_cuj_frame f USING (cuj_id)
UNION ALL
-- Computed frame boundaries on the SF Main Thread
SELECT
  'slice' AS track_type,
  cuj.cuj_name || ' SF MT ' || vsync AS track_name,
  boundary.ts,
  boundary.dur,
  vsync || '' AS slice_name,
  cuj.cuj_name || ' - SF MT frame boundaries' AS group_name
FROM android_jank_cuj cuj
JOIN android_jank_cuj_sf_main_thread_frame_boundary boundary USING (cuj_id)
UNION ALL
-- Computed frame boundaries on the SF RenderEngine Thread.
SELECT
  'slice' AS track_type,
  cuj.cuj_name || ' SF RE ' || vsync AS track_name,
  boundary.ts,
  boundary.dur,
  vsync || '' AS slice_name,
  cuj.cuj_name || ' - SF RE frame boundaries' AS group_name
FROM android_jank_cuj cuj
JOIN android_jank_cuj_sf_render_engine_frame_boundary boundary USING (cuj_id);

)_d3l1m1t3r_"
;

const char kAndroidJankInternalQueryBase[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Stores sets of tables that make sense together (e.g. slices on the main thread
-- and frame boundaries on the main thread).
-- Used to simplify passing arguments to other functions / metrics.
DROP TABLE IF EXISTS android_jank_cuj_table_set;
CREATE TABLE android_jank_cuj_table_set(
  name TEXT,
  slice_table_name TEXT,
  frame_boundary_table_name TEXT,
  cuj_boundary_table_name TEXT,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  frame_table_name TEXT);

INSERT INTO android_jank_cuj_table_set(
  name,
  slice_table_name,
  frame_boundary_table_name,
  cuj_boundary_table_name,
  frame_table_name)
VALUES
('App threads',
  'android_jank_cuj_slice',
  'android_jank_cuj_frame',
  'android_jank_cuj_boundary',
  'android_jank_cuj_frame'),
('MainThread',
  'android_jank_cuj_main_thread_slice',
  'android_jank_cuj_main_thread_frame_boundary',
  'android_jank_cuj_main_thread_cuj_boundary',
  'android_jank_cuj_frame'),
('RenderThread',
  'android_jank_cuj_render_thread_slice',
  'android_jank_cuj_render_thread_frame_boundary',
  'android_jank_cuj_render_thread_cuj_boundary',
  'android_jank_cuj_frame'),
('SF threads',
  'android_jank_cuj_sf_slice',
  'android_jank_cuj_sf_frame',
  'android_jank_cuj_sf_boundary',
  'android_jank_cuj_sf_frame'),
('SF MainThread',
  'android_jank_cuj_sf_main_thread_slice',
  'android_jank_cuj_sf_main_thread_frame_boundary',
  'android_jank_cuj_sf_main_thread_cuj_boundary',
  'android_jank_cuj_sf_frame'),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(('SF RenderEngine',
  'android_jank_cuj_sf_render_engine_slice',
  'android_jank_cuj_sf_render_engine_frame_boundary',
  'android_jank_cuj_sf_boundary',
  'android_jank_cuj_sf_frame');

-- Functions below retrieve specific columns for a given table set.

CREATE OR REPLACE PERFETTO FUNCTION android_jank_cuj_table_set_slice(table_set STRING)
RETURNS STRING AS
SELECT slice_table_name
FROM android_jank_cuj_table_set ts
WHERE ts.name = $table_set;

CREATE OR REPLACE PERFETTO FUNCTION android_jank_cuj_table_set_frame_boundary(
  table_set STRING
)
RETURNS STRING AS
SELECT frame_boundary_table_name
FROM android_jank_cuj_table_set ts
WHERE ts.name = $table_set;

CREATE OR REPLACE PERFETTO FUNCTION android_jank_cuj_table_set_cuj_boundary(
  table_set STRING
)
RETURNS STRING AS
SELECT cuj_boundary_table_name
FROM android_jank_cuj_table_set ts
WHERE ts.name = $table_set;

CREATE OR REPLACE PERFETTO FUNCTION android_jank_cuj_table_set_frame(table_set STRING)
RETURNS STRING AS
SELECT frame_table_name
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM android_jank_cuj_table_set ts
WHERE ts.name = $table_set;

-- Checks if two slices, described by ts and dur, ts_second and dur_second, overlap.
-- Does not handle cases where slices are unfinished (dur = -1).
CREATE OR REPLACE PERFETTO FUNCTION android_jank_cuj_slice_overlaps(ts LONG,
                                                        dur LONG,
                                                        ts_second LONG,
                                                        dur_second LONG)
RETURNS BOOL AS
SELECT
  -- A starts before B ends and A ends after B starts
  ($ts < $ts_second + $dur_second AND $ts + $dur > $ts_second)
  -- or A starts after B starts and A ends before B ends
  OR ($ts > $ts_second AND $ts < $ts_second + $ts_dur);

)_d3l1m1t3r_"
;

const char kAndroidJankInternalQueryFrameSlice[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Matches slices with frames within CUJs and aggregates slices durations within each frame.
-- This allows comparing the cumulative durations of a set of slices vs what was the expected
-- duration of each frame. It can be a useful heuristic to figure out what contributed to
-- frames missing their expected deadlines.
--
-- EXAMPLE:
--
--
-- CUJ Frames:
--
--      |==== FRAME 1 ====|
)_d3l1m1t3r_"
R"_d3l1m1t3r_(--                  |====== FRAME 2 ======|
--                                             |== FRAME 3 ==|
--                                                          |== FRAME 4 ==|
--
-- Main thread frame boundaries:
--
--      |= FRAME 1 =|==== FRAME 2 ====|        |= FRAME 3 =||= FRAME 4 =|
--
-- `relevant_slice_table_name` slices:
--
--  |== binder ==|      |== binder ==|   |=b=|   |=b=||=b=|
--
--
-- OUTPUT:
--
-- Data in `*_slice_in_frame` - slices from `relevant_slice_table_name` matched
-- to frames and trimmed to their boundaries:
--
-- * FRAME 1:
--      | binder |
-- * FRAME 2:
--                      |== binder ==|
-- * FRAME 3:
--                                               |=b=||=b=|
-- * FRAME 4 - not present in the output
--
--
-- Data in `*_slice_in_frame_agg` is just an aggregation of durations in  *_slice_in_frame.


-- For simplicity we allow `relevant_slice_table_name` to be based on any
-- of the slice tables. This table filters it down to only include slices within
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- the (broadly bounded) CUJ and on the specific process / thread.
-- Using TABLE and not VIEW as this gives better, localized error messages in cases
-- `relevant_slice_table_name` is not correct (e.g. missing cuj_id).
DROP TABLE IF EXISTS {{table_name_prefix}}_query_slice;
CREATE PERFETTO TABLE {{table_name_prefix}}_query_slice AS
SELECT DISTINCT
  slice.cuj_id,
  slice.utid,
  slice.id,
  slice.name,
  slice.ts,
  slice.dur,
  slice.ts_end
FROM {{relevant_slice_table_name}} slice
JOIN {{slice_table_name}} android_jank_cuj_slice_table
  USING (cuj_id, id);

-- Flat view of frames and slices matched and "trimmed" to each frame boundaries.
DROP VIEW IF EXISTS {{table_name_prefix}}_slice_in_frame;
CREATE PERFETTO VIEW {{table_name_prefix}}_slice_in_frame AS
SELECT
  frame.*,
  query_slice.id AS slice_id,
  query_slice.utid AS slice_utid,
  query_slice.name AS slice_name,
  MAX(query_slice.ts, frame_boundary.ts) AS slice_ts,
  MIN(query_slice.ts_end, frame_boundary.ts_end) AS slice_ts_end,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  MIN(query_slice.ts_end, frame_boundary.ts_end) - MAX(query_slice.ts, frame_boundary.ts) AS slice_dur,
  query_slice.ts_end AS ts_end_original
FROM {{frame_table_name}} frame
-- We want to use different boundaries depending on which thread's slices the query is targetting.
JOIN {{frame_boundary_table_name}} frame_boundary USING (cuj_id, vsync)
JOIN {{table_name_prefix}}_query_slice query_slice
  ON frame_boundary.cuj_id = query_slice.cuj_id
    AND android_jank_cuj_slice_overlaps(frame_boundary.ts, frame_boundary.dur, query_slice.ts, query_slice.dur);

-- Aggregated view of frames and slices overall durations within each frame boundaries.
DROP VIEW IF EXISTS {{table_name_prefix}}_slice_in_frame_agg;
CREATE PERFETTO VIEW {{table_name_prefix}}_slice_in_frame_agg AS
SELECT
  cuj_id,
  frame_number,
  vsync,
  dur_expected,
  app_missed,
  sf_missed,
  1.0 * SUM(slice_dur) / dur_expected AS slice_dur_div_frame_dur_expected,
  SUM(slice_dur) AS slice_dur_sum,
  MAX(slice_dur) AS slice_dur_max
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM {{table_name_prefix}}_slice_in_frame
GROUP BY cuj_id, frame_number, vsync, dur_expected, app_missed, sf_missed;

)_d3l1m1t3r_"
;

const char kAndroidJankParams[] = R"_d3l1m1t3r_(-- Table to store parameters that will be matched with CUJs using the CUJ name.
DROP TABLE IF EXISTS android_jank_cuj_param_set;
CREATE TABLE android_jank_cuj_param_set (cuj_name_glob STRING, main_thread_override STRING);
INSERT INTO android_jank_cuj_param_set (cuj_name_glob, main_thread_override)
VALUES
('SPLASHSCREEN_EXIT_ANIM', 'll.splashscreen'),
('SPLASHSCREEN_AVD', 'll.splashscreen'),
('ONE_HANDED_ENTER_TRANSITION::*', 'wmshell.main'),
('ONE_HANDED_EXIT_TRANSITION::*', 'wmshell.main'),
('PIP_TRANSITION::*', 'wmshell.main');


-- Matches each CUJ with the right set of parameters.
DROP TABLE IF EXISTS android_jank_cuj_param;
CREATE PERFETTO TABLE android_jank_cuj_param AS
SELECT cuj_id, main_thread_override
FROM android_jank_cuj
LEFT JOIN android_jank_cuj_param_set ON cuj_name GLOB cuj_name_glob;

)_d3l1m1t3r_"
;

const char kAndroidJankQueryFunctions[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Consider calling android_jank_correlate_frame_slice which passes a default value for
-- `table_name_prefix`.
--
-- Matches slices with frames within CUJs and aggregates slices durations within each frame.
-- This allows comparing the cumulative durations of a set of slices vs what was the expected
-- duration of each frame. It can be a useful heuristic to figure out what contributed to
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- frames missing their expected deadlines.
--
-- For more details see the documentation in query_frame_slice.sql.
--
-- Example usage:
--
-- CREATE PERFETTO VIEW example_table AS
-- SELECT * FROM android_jank_cuj_slice WHERE name = 'binder transaction';
-- SELECT android_jank_correlate_frame_slice_impl('MainThread',
--                                                'example_table',
--                                                'jank_query');
-- SELECT * FROM jank_query_slice_in_frame_agg;
--
-- Function arguments:
--
-- table_set - Name of a set of tables from `android_jank_cuj_table_set`.
--             Groups releated tables to simplify passing them as arguments to
--             functions.
--
-- relevant_slice_table_name - Table or View which selects slices for analysis
--                             from the `android_jank_cuj_slice` table.
--
-- table_name_prefix - Running the function will create multiple tables. This
--                     value will be used as a prefx for their names to avoid
)_d3l1m1t3r_"
R"_d3l1m1t3r_(--                     name collisions with other tables.
CREATE OR REPLACE PERFETTO FUNCTION android_jank_correlate_frame_slice_impl(
  table_set STRING,
  relevant_slice_table_name STRING,
  table_name_prefix STRING
)
RETURNS STRING AS
-- COALESCE to return the text with table names to the caller instead of NULL
SELECT COALESCE(
  RUN_METRIC(
    "android/jank/internal/query_frame_slice.sql",
    "table_name_prefix", $table_name_prefix,
    "relevant_slice_table_name", $relevant_slice_table_name,
    "slice_table_name", (SELECT android_jank_cuj_table_set_slice($table_set)),
    "frame_boundary_table_name", (SELECT android_jank_cuj_table_set_frame_boundary($table_set)),
    "frame_table_name", (SELECT android_jank_cuj_table_set_frame($table_set))
  ),
  "Query results in `" || $table_name_prefix || "_slice_in_frame_agg` and `" || $table_name_prefix || "_slice_in_frame`."
);

-- Provides a default value for table_name_prefix in
-- android_jank_correlate_frame_slice_impl.
-- See documentation for android_jank_correlate_frame_slice_impl.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE OR REPLACE PERFETTO FUNCTION android_jank_correlate_frame_slice(
  table_set STRING,
  relevant_slice_table_name STRING
)
RETURNS STRING AS
SELECT android_jank_correlate_frame_slice_impl(
  $table_set,
  $relevant_slice_table_name,
  "jank_query"
);

)_d3l1m1t3r_"
;

const char kAndroidJankRelevantSlices[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

CREATE OR REPLACE PERFETTO FUNCTION vsync_from_name(slice_name STRING)
RETURNS STRING AS
SELECT CAST(STR_SPLIT($slice_name, " ", 1) AS INTEGER);

CREATE OR REPLACE PERFETTO FUNCTION gpu_completion_fence_id_from_name(slice_name STRING)
RETURNS STRING AS
SELECT
  CASE
    WHEN
      $slice_name GLOB "GPU completion fence *"
    THEN
      CAST(STR_SPLIT($slice_name, " ", 3) AS INTEGER)
    WHEN
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      $slice_name GLOB "Trace GPU completion fence *"
    THEN
      CAST(STR_SPLIT($slice_name, " ", 4) AS INTEGER)
    WHEN
      $slice_name GLOB "waiting for GPU completion *"
    THEN
      CAST(STR_SPLIT($slice_name, " ", 4) AS INTEGER)
    WHEN
      $slice_name GLOB "Trace HWC release fence *"
    THEN
      CAST(STR_SPLIT($slice_name, " ", 4) AS INTEGER)
    WHEN
      $slice_name GLOB "waiting for HWC release *"
    THEN
      CAST(STR_SPLIT($slice_name, " ", 4) AS INTEGER)
    ELSE NULL
  END;

-- Find Choreographer#doFrame slices that are between the CUJ markers.
-- We extract vsync IDs from doFrame slice names and use these as the source
-- of truth that allow us to get correct slices on the other threads.
DROP TABLE IF EXISTS android_jank_cuj_do_frame_slice;
CREATE PERFETTO TABLE android_jank_cuj_do_frame_slice AS
SELECT
  cuj.cuj_id,
  main_thread.upid,
  main_thread.utid,
  slice.*,
  slice.ts + slice.dur AS ts_end,
  vsync_from_name(slice.name) AS vsync
FROM android_jank_cuj cuj
)_d3l1m1t3r_"
R"_d3l1m1t3r_(JOIN slice
  ON slice.ts + slice.dur >= cuj.ts AND slice.ts <= cuj.ts_end
JOIN android_jank_cuj_main_thread main_thread
  ON cuj.cuj_id = main_thread.cuj_id
    AND main_thread.track_id = slice.track_id
WHERE
  slice.name GLOB 'Choreographer#doFrame*'
-- Ignore child slice e.g. "Choreographer#doFrame - resynced to 1234 in 20.0ms"
  AND slice.name not GLOB '*resynced*'
  AND slice.dur > 0
  AND (vsync >= begin_vsync OR begin_vsync is NULL)
  AND (vsync <= end_vsync OR end_vsync is NULL)
  -- In some malformed traces we see nested doFrame slices.
  -- If that is the case, we ignore all parent doFrames and only keep the one
  -- the lowest in the hierarchy.
  AND NOT EXISTS (
    SELECT 1 FROM descendant_slice(slice.id) child
    WHERE child.name GLOB 'Choreographer#doFrame*'
    AND child.name NOT GLOB '*resynced*'
  );


-- Store render thread DrawFrames by matching in the vsync IDs extracted from
-- doFrame slices. In case of multiple layers being drawn, there might be
-- multiple DrawFrames for a single vsync.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(DROP TABLE IF EXISTS android_jank_cuj_draw_frame_slice;
CREATE PERFETTO TABLE android_jank_cuj_draw_frame_slice AS
SELECT
  cuj_id,
  render_thread.upid,
  render_thread.utid,
  slice.*,
  slice.ts + slice.dur AS ts_end,
  vsync_from_name(slice.name) AS vsync
FROM android_jank_cuj_do_frame_slice do_frame
JOIN android_jank_cuj_render_thread render_thread USING (cuj_id)
JOIN slice
  ON slice.track_id = render_thread.track_id
WHERE slice.name GLOB 'DrawFrame*'
  AND vsync_from_name(slice.name) = do_frame.vsync
  AND slice.dur > 0;

-- Find descendants of DrawFrames which contain the GPU completion fence ID that
-- is used for signaling that the GPU finished drawing.
DROP TABLE IF EXISTS android_jank_cuj_gpu_completion_fence;
CREATE PERFETTO TABLE android_jank_cuj_gpu_completion_fence AS
SELECT
  cuj_id,
  vsync,
  draw_frame.id AS draw_frame_slice_id,
  gpu_completion_fence_id_from_name(fence.name) AS fence_idx
FROM android_jank_cuj_draw_frame_slice draw_frame
JOIN descendant_slice(draw_frame.id) fence
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ON fence.name GLOB '*GPU completion fence*';

-- Similarly find descendants of DrawFrames which have the HWC release fence ID
DROP TABLE IF EXISTS android_jank_cuj_hwc_release_fence;
CREATE PERFETTO TABLE android_jank_cuj_hwc_release_fence AS
SELECT
  cuj_id,
  vsync,
  draw_frame.id AS draw_frame_slice_id,
  gpu_completion_fence_id_from_name(fence.name) AS fence_idx
FROM android_jank_cuj_draw_frame_slice draw_frame
JOIN descendant_slice(draw_frame.id) fence
  ON fence.name GLOB '*HWC release fence *';

-- Find HWC release slices which indicate when the HWC released the buffer.
DROP TABLE IF EXISTS android_jank_cuj_hwc_release_slice;
CREATE PERFETTO TABLE android_jank_cuj_hwc_release_slice AS
SELECT
  fence.cuj_id,
  vsync,
  slice.*,
  slice.ts + slice.dur AS ts_end,
  fence.fence_idx,
  draw_frame_slice_id
FROM android_jank_cuj_hwc_release_thread hwc_release_thread
JOIN slice USING (track_id)
JOIN android_jank_cuj_hwc_release_fence fence
  ON fence.cuj_id = hwc_release_thread.cuj_id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    AND fence.fence_idx = gpu_completion_fence_id_from_name(slice.name)
WHERE
  slice.name GLOB 'waiting for HWC release *'
  AND slice.dur > 0;

-- Find GPU completion slices which indicate when the GPU finished drawing.
DROP TABLE IF EXISTS android_jank_cuj_gpu_completion_slice;
CREATE PERFETTO TABLE android_jank_cuj_gpu_completion_slice AS
SELECT
  fence.cuj_id,
  vsync,
  slice.*,
  slice.ts + slice.dur AS ts_end,
  hwc_release.ts_end AS hwc_release_ts_end,
  fence.fence_idx
FROM android_jank_cuj_gpu_completion_thread gpu_completion_thread
JOIN slice USING (track_id)
JOIN android_jank_cuj_gpu_completion_fence fence
  ON fence.cuj_id = gpu_completion_thread.cuj_id
  AND fence.fence_idx = gpu_completion_fence_id_from_name(slice.name)
LEFT JOIN android_jank_cuj_hwc_release_slice hwc_release
  USING (cuj_id, vsync, draw_frame_slice_id)
WHERE
  slice.name GLOB 'waiting for GPU completion *'
  AND slice.dur > 0;

-- Match the frame timeline on the app side with the frame timeline on the SF side.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- This way we get the vsyncs IDs of SF frames within the CUJ.
-- Note that there might be multiple SF vsync IDs that match a single App vsync ID, e.g.
-- if one App layer produced a frame later and it was picked up by the next SF frame.
DROP TABLE IF EXISTS android_jank_cuj_app_to_sf_match;
CREATE PERFETTO TABLE android_jank_cuj_app_to_sf_match AS
SELECT
  cuj_id,
  do_frame.upid AS app_upid,
  do_frame.vsync AS app_vsync,
  sf_process.upid AS sf_upid,
  CAST(sf_timeline.name AS INTEGER) AS sf_vsync
FROM android_jank_cuj_do_frame_slice do_frame
JOIN actual_frame_timeline_slice app_timeline
  ON do_frame.upid = app_timeline.upid
    AND do_frame.vsync = CAST(app_timeline.name AS INTEGER)
JOIN directly_connected_flow(app_timeline.id) flow
  ON flow.slice_out = app_timeline.id
JOIN actual_frame_timeline_slice sf_timeline
  ON flow.slice_in = sf_timeline.id
JOIN android_jank_cuj_sf_process sf_process
  ON sf_timeline.upid = sf_process.upid
-- In cases where there are multiple layers drawn we would have separate frame timeline
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- slice for each of the layers. GROUP BY to deduplicate these rows.
GROUP BY cuj_id, app_upid, app_vsync, sf_upid, sf_vsync;

CREATE OR REPLACE PERFETTO FUNCTION find_android_jank_cuj_sf_main_thread_slice(
  slice_name_glob STRING)
RETURNS TABLE(
  cuj_id INT, utid INT, vsync INT, id INT,
  name STRING, ts LONG, dur LONG, ts_end LONG)
AS
WITH sf_vsync AS (
  SELECT DISTINCT cuj_id, sf_vsync AS vsync
  FROM android_jank_cuj_app_to_sf_match)
SELECT
  cuj_id,
  utid,
  sf_vsync.vsync,
  slice.id,
  slice.name,
  slice.ts,
  slice.dur,
  slice.ts + slice.dur AS ts_end
FROM slice
JOIN android_jank_cuj_sf_main_thread main_thread USING (track_id)
JOIN sf_vsync
  ON vsync_from_name(slice.name) = sf_vsync.vsync
WHERE slice.name GLOB $slice_name_glob AND slice.dur > 0
ORDER BY cuj_id, vsync;

DROP TABLE IF EXISTS android_jank_cuj_sf_commit_slice;
CREATE PERFETTO TABLE android_jank_cuj_sf_commit_slice AS
SELECT * FROM FIND_ANDROID_JANK_CUJ_SF_MAIN_THREAD_SLICE('commit *');

DROP TABLE IF EXISTS android_jank_cuj_sf_composite_slice;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO TABLE android_jank_cuj_sf_composite_slice AS
SELECT * FROM FIND_ANDROID_JANK_CUJ_SF_MAIN_THREAD_SLICE('composite *');

-- Older builds do not have the commit/composite but onMessageInvalidate instead
DROP TABLE IF EXISTS android_jank_cuj_sf_on_message_invalidate_slice;
CREATE PERFETTO TABLE android_jank_cuj_sf_on_message_invalidate_slice AS
SELECT * FROM FIND_ANDROID_JANK_CUJ_SF_MAIN_THREAD_SLICE('onMessageInvalidate *');

DROP VIEW IF EXISTS android_jank_cuj_sf_root_slice;
CREATE PERFETTO VIEW android_jank_cuj_sf_root_slice AS
SELECT * FROM android_jank_cuj_sf_commit_slice
UNION ALL
SELECT * FROM android_jank_cuj_sf_composite_slice
UNION ALL
SELECT * FROM android_jank_cuj_sf_on_message_invalidate_slice;

-- Find descendants of SF main thread slices which contain the GPU completion fence ID that
-- is used for signaling that the GPU finished drawing.
DROP TABLE IF EXISTS android_jank_cuj_sf_gpu_completion_fence;
CREATE PERFETTO TABLE android_jank_cuj_sf_gpu_completion_fence AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  cuj_id,
  vsync,
  sf_root_slice.id AS sf_root_slice_id,
  gpu_completion_fence_id_from_name(fence.name) AS fence_idx
FROM android_jank_cuj_sf_root_slice sf_root_slice
JOIN descendant_slice(sf_root_slice.id) fence
  ON fence.name GLOB '*GPU completion fence*';

-- Find GPU completion slices which indicate when the GPU finished drawing.
DROP TABLE IF EXISTS android_jank_cuj_sf_gpu_completion_slice;
CREATE PERFETTO TABLE android_jank_cuj_sf_gpu_completion_slice AS
SELECT
  fence.cuj_id,
  vsync,
  slice.*,
  slice.ts + slice.dur AS ts_end,
  fence.fence_idx
FROM android_jank_cuj_sf_gpu_completion_fence fence
JOIN android_jank_cuj_sf_gpu_completion_thread gpu_completion_thread
JOIN slice
  ON slice.track_id = gpu_completion_thread.track_id
    AND fence.fence_idx = gpu_completion_fence_id_from_name(slice.name)
WHERE
  slice.name GLOB 'waiting for GPU completion *'
  AND slice.dur > 0;


-- Find REThreaded::drawLayers on RenderEngine thread.
-- These will be only relevant if SF is doing client composition so we check if
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- the drawLayers slice is completely within the bounds of composeSurfaces on SF
-- main thread.
DROP TABLE IF EXISTS android_jank_cuj_sf_draw_layers_slice;
CREATE PERFETTO TABLE android_jank_cuj_sf_draw_layers_slice AS
WITH compose_surfaces AS (
  SELECT
    cuj_id,
    vsync,
    sf_root_slice.id AS sf_root_slice_id,
    compose_surfaces.ts,
    compose_surfaces.ts + compose_surfaces.dur AS ts_end
  FROM android_jank_cuj_sf_root_slice sf_root_slice
  JOIN descendant_slice(sf_root_slice.id) compose_surfaces
    ON compose_surfaces.name = 'composeSurfaces'
)
SELECT
  cuj_id,
  re_thread.utid,
  vsync,
  draw_layers.*,
  draw_layers.ts + draw_layers.dur AS ts_end,
  -- Store composeSurfaces ts as this will simplify calculating frame boundaries
  compose_surfaces.ts AS ts_compose_surfaces
FROM compose_surfaces
JOIN android_jank_cuj_sf_render_engine_thread re_thread
JOIN slice draw_layers
  ON draw_layers.track_id = re_thread.track_id
    AND draw_layers.ts >= compose_surfaces.ts
    AND draw_layers.ts + draw_layers.dur <= compose_surfaces.ts_end
)_d3l1m1t3r_"
R"_d3l1m1t3r_(WHERE
  draw_layers.name = 'REThreaded::drawLayers'
  AND draw_layers.dur > 0;

)_d3l1m1t3r_"
;

const char kAndroidJankRelevantThreads[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

DROP TABLE IF EXISTS android_jank_cuj_main_thread;
CREATE PERFETTO TABLE android_jank_cuj_main_thread AS
SELECT cuj_id, cuj.upid, utid, thread.name, thread_track.id AS track_id
FROM thread
JOIN android_jank_cuj cuj USING (upid)
JOIN thread_track USING (utid)
JOIN android_jank_cuj_param p USING (cuj_id)
WHERE
  (p.main_thread_override IS NULL AND thread.is_main_thread)
  -- Some CUJs use a dedicated thread for Choreographer callbacks
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  OR (p.main_thread_override = thread.name);

CREATE OR REPLACE PERFETTO FUNCTION android_jank_cuj_app_thread(thread_name STRING)
RETURNS TABLE(cuj_id INT, upid INT, utid INT, name STRING, track_id INT) AS
SELECT
  cuj_id,
  cuj.upid,
  utid,
  thread.name,
  thread_track.id AS track_id
FROM thread
JOIN android_jank_cuj cuj USING (upid)
JOIN thread_track USING (utid)
WHERE thread.name = $thread_name;

DROP TABLE IF EXISTS android_jank_cuj_render_thread;
CREATE PERFETTO TABLE android_jank_cuj_render_thread AS
SELECT * FROM ANDROID_JANK_CUJ_APP_THREAD('RenderThread');

DROP TABLE IF EXISTS android_jank_cuj_gpu_completion_thread;
CREATE PERFETTO TABLE android_jank_cuj_gpu_completion_thread AS
SELECT * FROM ANDROID_JANK_CUJ_APP_THREAD('GPU completion');

DROP TABLE IF EXISTS android_jank_cuj_hwc_release_thread;
CREATE PERFETTO TABLE android_jank_cuj_hwc_release_thread AS
SELECT * FROM ANDROID_JANK_CUJ_APP_THREAD('HWC release');

DROP TABLE IF EXISTS android_jank_cuj_sf_process;
CREATE PERFETTO TABLE android_jank_cuj_sf_process AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT * FROM process
WHERE process.name = '/system/bin/surfaceflinger'
LIMIT 1;

DROP TABLE IF EXISTS android_jank_cuj_sf_main_thread;
CREATE PERFETTO TABLE android_jank_cuj_sf_main_thread AS
SELECT upid, utid, thread.name, thread_track.id AS track_id
FROM thread
JOIN android_jank_cuj_sf_process sf_process USING (upid)
JOIN thread_track USING (utid)
WHERE thread.is_main_thread;

CREATE OR REPLACE PERFETTO FUNCTION android_jank_cuj_sf_thread(thread_name STRING)
RETURNS TABLE(upid INT, utid INT, name STRING, track_id INT) AS
SELECT upid, utid, thread.name, thread_track.id AS track_id
FROM thread
JOIN android_jank_cuj_sf_process sf_process USING (upid)
JOIN thread_track USING (utid)
WHERE thread.name = $thread_name;

DROP TABLE IF EXISTS android_jank_cuj_sf_gpu_completion_thread;
CREATE PERFETTO TABLE android_jank_cuj_sf_gpu_completion_thread AS
SELECT * FROM ANDROID_JANK_CUJ_SF_THREAD('GPU completion');

DROP TABLE IF EXISTS android_jank_cuj_sf_render_engine_thread;
CREATE PERFETTO TABLE android_jank_cuj_sf_render_engine_thread AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT * FROM ANDROID_JANK_CUJ_SF_THREAD('RenderEngine');

)_d3l1m1t3r_"
;

const char kAndroidJankSlices[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

DROP VIEW IF EXISTS android_jank_cuj_slice;
CREATE PERFETTO VIEW android_jank_cuj_slice AS
SELECT
  cuj_id,
  process.upid,
  process.name AS process_name,
  thread.utid,
  thread.name AS thread_name,
  slice.*,
  slice.ts + slice.dur AS ts_end
FROM android_jank_cuj_boundary boundary
JOIN process USING (upid)
JOIN thread USING (upid)
JOIN thread_track USING (utid)
JOIN slice
  ON slice.track_id = thread_track.id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    -- Take slices which overlap even they started before the boundaries
    -- This is to be able to query slices that delayed start of a frame
    AND slice.ts + slice.dur >= boundary.ts AND slice.ts <= boundary.ts_end
WHERE slice.dur > 0;

DROP TABLE IF EXISTS android_jank_cuj_main_thread_slice;
CREATE PERFETTO TABLE android_jank_cuj_main_thread_slice AS
SELECT
  cuj_id,
  upid,
  utid,
  slice.*,
  slice.ts + slice.dur AS ts_end
FROM android_jank_cuj_main_thread_cuj_boundary boundary
JOIN thread_track USING (utid)
JOIN thread USING (utid)
JOIN slice
  ON slice.track_id = thread_track.id
    -- Take slices which overlap even they started before the boundaries
    -- This is to be able to query slices that delayed start of a frame
    AND slice.ts + slice.dur >= boundary.ts
    AND slice.ts <= boundary.ts_end
WHERE slice.dur > 0;

DROP TABLE IF EXISTS android_jank_cuj_render_thread_slice;
CREATE PERFETTO TABLE android_jank_cuj_render_thread_slice AS
SELECT
  cuj_id,
  upid,
  utid,
  slice.*,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  slice.ts + slice.dur AS ts_end
FROM android_jank_cuj_render_thread_cuj_boundary boundary
JOIN thread_track USING (utid)
JOIN thread USING (utid)
JOIN slice
  ON slice.track_id = thread_track.id
    -- Take slices which overlap even they started before the boundaries
    -- This is to be able to query slices that delayed start of a frame
    AND slice.ts + slice.dur >= boundary.ts
    AND slice.ts <= boundary.ts_end
WHERE slice.dur > 0;

DROP VIEW IF EXISTS android_jank_cuj_sf_slice;
CREATE PERFETTO VIEW android_jank_cuj_sf_slice AS
SELECT
  cuj_id,
  upid,
  sf_process.name AS process_name,
  thread.utid,
  thread.name AS thread_name,
  slice.*,
  slice.ts + slice.dur AS ts_end
FROM android_jank_cuj_sf_boundary sf_boundary
JOIN android_jank_cuj_sf_process sf_process
JOIN thread USING (upid)
JOIN thread_track USING (utid)
JOIN slice
  ON slice.track_id = thread_track.id
    -- Take slices which overlap even they started before the boundaries
    -- This is to be able to query slices that delayed start of a frame
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    AND slice.ts + slice.dur >= sf_boundary.ts AND slice.ts <= sf_boundary.ts_end
WHERE slice.dur > 0;

DROP TABLE IF EXISTS android_jank_cuj_sf_main_thread_slice;
CREATE PERFETTO TABLE android_jank_cuj_sf_main_thread_slice AS
SELECT
  cuj_id,
  upid,
  utid,
  slice.*,
  slice.ts + slice.dur AS ts_end
FROM android_jank_cuj_sf_main_thread_cuj_boundary boundary
JOIN thread_track USING (utid)
JOIN thread USING (utid)
JOIN slice
  ON slice.track_id = thread_track.id
    -- Take slices which overlap even they started before the boundaries
    -- This is to be able to query slices that delayed start of a frame
    AND slice.ts + slice.dur >= boundary.ts
    AND slice.ts <= boundary.ts_end
WHERE slice.dur > 0;

-- For RenderEngine thread we use a different approach as it's only used when SF falls back to
-- client composition. Instead of taking all slices during CUJ, we look at each frame explicitly
-- and only take slices that are within RenderEngine frame boundaries.
DROP TABLE IF EXISTS android_jank_cuj_sf_render_engine_slice;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO TABLE android_jank_cuj_sf_render_engine_slice AS
SELECT
  cuj_id,
  upid,
  utid,
  slice.*,
  slice.ts + slice.dur AS ts_end
FROM android_jank_cuj_sf_render_engine_frame_boundary boundary
JOIN thread_track USING (utid)
JOIN thread USING (utid)
JOIN slice
  ON slice.track_id = thread_track.id
    -- Take slices which overlap even they started before the boundaries
    -- This is to be able to query slices that delayed start of a frame
    AND slice.ts + slice.dur >= boundary.ts
    AND slice.ts <= boundary.ts_end
WHERE slice.dur > 0;

)_d3l1m1t3r_"
;

const char kAndroidJavaHeapClassStats[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

SELECT RUN_METRIC('android/process_metadata.sql');

INCLUDE PERFETTO MODULE android.memory.heap_graph.dominator_tree;
INCLUDE PERFETTO MODULE graphs.partition;

CREATE OR REPLACE PERFETTO FUNCTION _partition_tree_super_root_fn()
-- The assigned id of the "super root".
RETURNS INT AS
SELECT id + 1
FROM heap_graph_object
ORDER BY id DESC
LIMIT 1;

DROP TABLE IF EXISTS _heap_graph_dominator_tree_for_partition;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO TABLE _heap_graph_dominator_tree_for_partition AS
SELECT
  tree.id,
  IFNULL(tree.idom_id, _partition_tree_super_root_fn()) as parent_id,
  obj.type_id as group_key
FROM heap_graph_dominator_tree tree
JOIN heap_graph_object obj USING(id)
UNION ALL
-- provide a single root required by tree partition if heap graph exists.
SELECT
  _partition_tree_super_root_fn() AS id,
  NULL AS parent_id,
  (SELECT id + 1 FROM heap_graph_class ORDER BY id desc LIMIT 1) AS group_key
WHERE _partition_tree_super_root_fn() IS NOT NULL;

DROP TABLE IF EXISTS _heap_object_marked_for_dominated_stats;
CREATE PERFETTO TABLE _heap_object_marked_for_dominated_stats AS
SELECT
  id,
  IIF(parent_id IS NULL, 1, 0) as marked
FROM tree_structural_partition_by_group!(_heap_graph_dominator_tree_for_partition)
ORDER BY id;

DROP TABLE IF EXISTS _heap_class_stats;
CREATE PERFETTO TABLE _heap_class_stats AS
SELECT
  obj.upid,
  obj.graph_sample_ts,
  obj.type_id,
  COUNT(1) AS obj_count,
  SUM(self_size) AS size_bytes,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  SUM(native_size) AS native_size_bytes,
  SUM(IIF(obj.reachable, 1, 0)) AS reachable_obj_count,
  SUM(IIF(obj.reachable, self_size, 0)) AS reachable_size_bytes,
  SUM(IIF(obj.reachable, native_size, 0)) AS reachable_native_size_bytes,
  SUM(IIF(marked, dominated_obj_count, 0)) AS dominated_obj_count,
  SUM(IIF(marked, dominated_size_bytes, 0)) AS dominated_size_bytes,
  SUM(IIF(marked, dominated_native_size_bytes, 0)) AS dominated_native_size_bytes
FROM heap_graph_object obj
-- Left joins to preserve unreachable objects.
LEFT JOIN _heap_object_marked_for_dominated_stats USING(id)
LEFT JOIN heap_graph_dominator_tree USING(id)
GROUP BY 1, 2, 3
ORDER BY 1, 2, 3;

DROP VIEW IF EXISTS java_heap_class_stats_output;
CREATE PERFETTO VIEW java_heap_class_stats_output AS
WITH
-- Group by to build the repeated field by upid, ts
heap_class_stats_count_protos AS (
  SELECT
    upid,
    graph_sample_ts,
    RepeatedField(JavaHeapClassStats_TypeCount(
      'type_name', IFNULL(c.deobfuscated_name, c.name),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      'obj_count', obj_count,
      'size_bytes', size_bytes,
      'native_size_bytes', native_size_bytes,
      'reachable_obj_count', reachable_obj_count,
      'reachable_size_bytes', reachable_size_bytes,
      'reachable_native_size_bytes', reachable_native_size_bytes,
      'dominated_obj_count', dominated_obj_count,
      'dominated_size_bytes', dominated_size_bytes,
      'dominated_native_size_bytes', dominated_native_size_bytes
    )) AS count_protos
  FROM _heap_class_stats s
  JOIN heap_graph_class c ON s.type_id = c.id
  GROUP BY 1, 2
),
-- Group by to build the repeated field by upid
heap_class_stats_sample_protos AS (
  SELECT
    upid,
    RepeatedField(JavaHeapClassStats_Sample(
      'ts', graph_sample_ts,
      'type_count', count_protos
    )) AS sample_protos
  FROM heap_class_stats_count_protos
  GROUP BY 1
)
SELECT JavaHeapClassStats(
  'instance_stats', RepeatedField(JavaHeapClassStats_InstanceStats(
    'upid', upid,
    'process', process_metadata.metadata,
    'samples', sample_protos
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  )))
FROM heap_class_stats_sample_protos JOIN process_metadata USING (upid);

)_d3l1m1t3r_"
;

const char kAndroidJavaHeapHistogram[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

SELECT RUN_METRIC('android/process_metadata.sql');

DROP TABLE IF EXISTS android_special_classes;
CREATE PERFETTO TABLE android_special_classes AS
WITH RECURSIVE cls_visitor(cls_id, category) AS (
  SELECT id, name FROM heap_graph_class WHERE name IN (
    'android.view.View',
    'android.app.Activity',
    'android.app.Fragment',
    'android.content.ContentProviderClient',
    'android.os.Binder',
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'android.os.BinderProxy',
    'android.os.Parcel',
    'com.android.server.am.ConnectionRecord',
    'com.android.server.am.PendingIntentRecord')
  UNION ALL
  SELECT child.id, parent.category
  FROM heap_graph_class child JOIN cls_visitor parent ON parent.cls_id = child.superclass_id
)
SELECT * FROM cls_visitor;

DROP TABLE IF EXISTS heap_obj_histograms;
CREATE PERFETTO TABLE heap_obj_histograms AS
SELECT
  o.upid,
  o.graph_sample_ts,
  o.type_id AS cls_id,
  COUNT(1) AS obj_count,
  SUM(IIF(o.reachable, 1, 0)) AS reachable_obj_count,
  SUM(self_size) / 1024 AS size_kb,
  SUM(IIF(o.reachable, self_size, 0)) / 1024 AS reachable_size_kb,
  SUM(native_size) / 1024 AS native_size_kb,
  SUM(IIF(o.reachable, native_size, 0)) / 1024 AS reachable_native_size_kb
FROM heap_graph_object o
GROUP BY 1, 2, 3
ORDER BY 1, 2, 3;

DROP VIEW IF EXISTS java_heap_histogram_output;
CREATE PERFETTO VIEW java_heap_histogram_output AS
WITH
-- Group by to build the repeated field by upid, ts
heap_obj_histogram_count_protos AS (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  SELECT
    upid,
    graph_sample_ts,
    RepeatedField(JavaHeapHistogram_TypeCount(
      'type_name', IFNULL(c.deobfuscated_name, c.name),
      'category', category,
      'obj_count', obj_count,
      'reachable_obj_count', reachable_obj_count,
      'size_kb', size_kb,
      'reachable_size_kb', reachable_size_kb,
      'native_size_kb', native_size_kb,
      'reachable_native_size_kb', reachable_native_size_kb
    )) AS count_protos
  FROM heap_obj_histograms hist
  JOIN heap_graph_class c ON hist.cls_id = c.id
  LEFT JOIN android_special_classes special USING(cls_id)
  GROUP BY 1, 2
),
-- Group by to build the repeated field by upid
heap_obj_histogram_sample_protos AS (
  SELECT
    upid,
    RepeatedField(JavaHeapHistogram_Sample(
      'ts', graph_sample_ts,
      'type_count', count_protos
    )) AS sample_protos
  FROM heap_obj_histogram_count_protos
  GROUP BY 1
)
SELECT JavaHeapHistogram(
  'instance_stats', RepeatedField(JavaHeapHistogram_InstanceStats(
    'upid', upid,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'process', process_metadata.metadata,
    'samples', sample_protos
  )))
FROM heap_obj_histogram_sample_protos JOIN process_metadata USING (upid);

)_d3l1m1t3r_"
;

const char kAndroidJavaHeapStats[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

SELECT RUN_METRIC('android/process_metadata.sql');
SELECT RUN_METRIC('android/process_mem.sql');

DROP VIEW IF EXISTS java_heap_stats_output;
CREATE PERFETTO VIEW java_heap_stats_output AS
WITH
-- Base view
base_stat_counts AS (
  SELECT
    upid,
    graph_sample_ts,
    SUM(self_size) AS total_size,
    SUM(native_size) AS total_native_size,
    COUNT(1) AS total_obj_count,
    SUM(IIF(reachable, self_size, 0)) AS reachable_size,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    SUM(IIF(reachable, native_size, 0)) AS reachable_native_size,
    SUM(IIF(reachable, 1, 0)) AS reachable_obj_count
  FROM heap_graph_object
  GROUP BY 1, 2
),
heap_roots AS (
  SELECT
    upid,
    graph_sample_ts,
    root_type,
    IFNULL(t.deobfuscated_name, t.name) AS type_name,
    COUNT(1) AS obj_count
  FROM heap_graph_object o
  JOIN heap_graph_class t ON o.type_id = t.id
  -- Classes are going to be particularly spammy and uninteresting
  -- from a memory analysis perspective (compared e.g. to local jni roots)
  WHERE root_type IS NOT NULL AND root_type != 'ROOT_STICKY_CLASS'
  GROUP BY 1, 2, 3, 4
  ORDER BY obj_count DESC
),
heap_roots_proto AS (
  SELECT
    upid,
    graph_sample_ts,
    RepeatedField(JavaHeapStats_HeapRoots(
      'root_type', root_type,
      'type_name', type_name,
      'obj_count', obj_count
    )) AS roots
  FROM heap_roots
  GROUP BY 1, 2
),
base_stats AS (
  SELECT * FROM base_stat_counts JOIN heap_roots_proto USING (upid, graph_sample_ts)
),
-- Find closest value
)_d3l1m1t3r_"
R"_d3l1m1t3r_(closest_anon_swap_oom AS (
  SELECT
    upid,
    graph_sample_ts,
    (
      SELECT anon_swap_val
      FROM (
        SELECT
          ts, dur,
          CAST(anon_and_swap_val AS INTEGER) AS anon_swap_val,
          ABS(ts - base_stats.graph_sample_ts) AS diff
        FROM anon_and_swap_span
        WHERE upid = base_stats.upid)
      WHERE
        (graph_sample_ts >= ts AND graph_sample_ts < ts + dur)
        -- If the first memory sample for the UPID comes *after* the heap profile
        -- accept it if close (500ms)
        OR (graph_sample_ts < ts AND diff <= 500 * 1e6)
      ORDER BY diff LIMIT 1
    ) AS anon_swap_val,
    (
      SELECT oom_score_val
      FROM (
        SELECT
          ts, dur,
          oom_score_val,
          ABS(ts - base_stats.graph_sample_ts) AS diff
        FROM oom_score_span
        WHERE upid = base_stats.upid)
      WHERE
        (graph_sample_ts >= ts AND graph_sample_ts < ts + dur)
        -- If the first memory sample for the UPID comes *after* the heap profile
)_d3l1m1t3r_"
R"_d3l1m1t3r_(        -- accept it if close (500ms)
        OR (graph_sample_ts < ts AND diff <= 500 * 1e6)
      ORDER BY diff LIMIT 1
    ) AS oom_score_val
  FROM base_stats
),
-- Group by upid
heap_graph_sample_protos AS (
  SELECT
    base_stats.upid,
    RepeatedField(JavaHeapStats_Sample(
      'ts', graph_sample_ts,
      'process_uptime_ms',
        CASE WHEN process.start_ts IS NOT NULL
        THEN (graph_sample_ts - process.start_ts) / 1000000
        ELSE NULL
        END,
      'heap_size', total_size,
      'heap_native_size', total_native_size,
      'obj_count', total_obj_count,
      'reachable_heap_size', reachable_size,
      'reachable_heap_native_size', reachable_native_size,
      'reachable_obj_count', reachable_obj_count,
      'roots', roots,
      'anon_rss_and_swap_size', closest_anon_swap_oom.anon_swap_val,
      'oom_score_adj', closest_anon_swap_oom.oom_score_val
    )) AS sample_protos
  FROM base_stats
  JOIN process USING (upid)
  LEFT JOIN closest_anon_swap_oom USING (upid, graph_sample_ts)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  GROUP BY 1
)
SELECT JavaHeapStats(
  'instance_stats', RepeatedField(JavaHeapStats_InstanceStats(
    'upid', upid,
    'process', process_metadata.metadata,
    'samples', sample_protos
  )))
FROM heap_graph_sample_protos JOIN process_metadata USING (upid);

)_d3l1m1t3r_"
;

const char kAndroidMemStatsPriorityBreakdown[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

DROP TABLE IF EXISTS {{table_name}}_by_priority_stats;
CREATE PERFETTO TABLE {{table_name}}_by_priority_stats AS
SELECT
  process.name AS process_name,
  CASE
    WHEN oom_score_val < -900 THEN 'native'
    WHEN oom_score_val < -800 THEN 'system'
    WHEN oom_score_val < -700 THEN 'persistent'
    WHEN oom_score_val < 0 THEN 'persistent_service'
    WHEN oom_score_val < 100 THEN 'foreground'
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    WHEN oom_score_val < 200 THEN 'visible'
    WHEN oom_score_val < 300 THEN 'perceptible'
    WHEN oom_score_val < 400 THEN 'backup'
    WHEN oom_score_val < 500 THEN 'heavy_weight'
    WHEN oom_score_val < 600 THEN 'service_a'
    WHEN oom_score_val < 700 THEN 'home'
    WHEN oom_score_val < 800 THEN 'prev'
    WHEN oom_score_val < 900 THEN 'service_b'
    ELSE 'cached'
  END AS priority,
  MIN(span.{{table_name}}_val) AS min_value,
  MAX(span.{{table_name}}_val) AS max_value,
  SUM(span.{{table_name}}_val * span.dur) / SUM(span.dur) AS avg_value
FROM {{table_name}}_by_oom_span AS span JOIN process USING(upid)
WHERE process.name IS NOT NULL
GROUP BY 1, 2
ORDER BY 1, 2;

DROP VIEW IF EXISTS {{table_name}}_by_priority_stats_proto;
CREATE PERFETTO VIEW {{table_name}}_by_priority_stats_proto AS
SELECT
  process_name,
  priority,
  AndroidMemoryMetric_Counter(
    'min', min_value,
    'max', max_value,
    'avg', avg_value
  ) AS proto
FROM {{table_name}}_by_priority_stats;

)_d3l1m1t3r_"
;

const char kAndroidNetworkActivityTemplate[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE android.network_packets;

-- Creates a view of aggregated network activity. It is common among networking
-- to have the interface active for some time after network use. For example, in
-- mobile networking, it is common to have the cellular interface active for 10
-- or more seconds after the last packet was sent or received. This view takes
-- raw packet timing and aggregates it into something that approximates the
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- activity of the underlying interface.
--
-- @arg view_name        The name of the output view.
-- @arg group_by         Expression to group by (set to 'null' for no grouping).
-- @arg filter           Expression on `android_network_packets` to filter by.
-- @arg idle_ns          The amount of time before considering the network idle.
-- @arg quant_ns         Quantization value, to group rows before the heavy
--                       part of the query. This should be smaller than idle_ns.
--
-- @column group_by      The group_by columns are all present in the output.
-- @column ts            The timestamp indicating the start of the segment.
-- @column dur           The duration of the current segment.
-- @column packet_count  The total number of packets in this segment.
-- @column packet_length The total number of bytes for packets in this segment.
DROP VIEW IF EXISTS {{view_name}};
CREATE PERFETTO VIEW {{view_name}} AS
WITH quantized AS (
  SELECT
    {{group_by}},
    MIN(ts) AS ts,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    MAX(ts+dur)-MIN(ts) AS dur,
    SUM(packet_count) AS packet_count,
    SUM(packet_length) AS packet_length
  FROM android_network_packets
  WHERE {{filter}}
  GROUP BY CAST(ts / {{quant_ns}} AS INT64), {{group_by}}
),
with_last AS (
  SELECT
    *,
    MAX(ts+dur) OVER (
      PARTITION BY {{group_by}}
      ORDER BY ts
      ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING
    ) AS max_end_so_far
  FROM quantized
),
with_group AS (
  SELECT
    *,
    COUNT(IIF(ts-max_end_so_far>{{idle_ns}}, 1, null)) OVER (
      PARTITION BY {{group_by}}
      ORDER BY ts
    ) AS group_id
  FROM with_last
)
SELECT
  {{group_by}},
  MIN(ts) AS ts,
  MAX(ts+dur)-MIN(ts)+{{idle_ns}} AS dur,
  SUM(packet_count) AS packet_count,
  SUM(packet_length) AS packet_length
FROM with_group
GROUP BY group_id, {{group_by}}

)_d3l1m1t3r_"
;

const char kAndroidPState[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

SELECT RUN_METRIC("android/android_cpu_agg.sql");

DROP VIEW IF EXISTS p_state_cpu_idle_counter;
CREATE PERFETTO VIEW p_state_cpu_idle_counter AS
SELECT
  ts,
  ts - LAG(ts) OVER (
    PARTITION BY track_id
    ORDER BY
      ts
  ) AS dur,
  cpu,
  iif(value = 4294967295, -1, cast(value AS int)) AS idle_value
FROM
  counter c
JOIN cpu_counter_track t ON c.track_id = t.id
WHERE
  t.name = "cpuidle";
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
DROP TABLE IF EXISTS p_state_sched_freq_idle;
CREATE VIRTUAL TABLE p_state_sched_freq_idle USING span_join(
  cpu_freq_sched_per_thread PARTITIONED cpu,
  p_state_cpu_idle_counter PARTITIONED cpu
);

CREATE OR REPLACE PERFETTO FUNCTION p_state_over_interval(
  start_ns LONG, end_ns LONG)
RETURNS TABLE(cpu INT, freq_khz INT, idle_value INT, dur_ns INT)
AS
WITH sched_freq_idle_windowed AS (
  SELECT
    freq_khz,
    idle_value,
    cpu,
    IIF(ts + dur <= $end_ns, ts + dur, $end_ns) - IIF(ts >= $start_ns, ts, $start_ns) AS dur
  FROM
    p_state_sched_freq_idle
  WHERE
    ts + dur > $start_ns
    AND ts < $end_ns
)
SELECT
  cast(cpu AS int) AS cpu,
  cast(freq_khz AS int) AS freq_khz,
  cast(idle_value AS int) AS idle_value,
  cast(sum(dur) AS int) AS dur_ns
FROM
  sched_freq_idle_windowed
WHERE
  freq_khz > 0
GROUP BY
  cpu,
  freq_khz,
  idle_value;

)_d3l1m1t3r_"
;

const char kAndroidPowerDrainInWatts[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the 'License');
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an 'AS IS' BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- This is a mapping from counter names on different devices
-- to what subsystems they are measuring.
DROP TABLE IF EXISTS power_counters;
CREATE TABLE power_counters (name TEXT UNIQUE, subsystem TEXT);

INSERT INTO power_counters
VALUES ('power.VPH_PWR_S5C_S6C_uws', 'cpu_big'),
('power.VPH_PWR_S4C_uws', 'cpu_little'),
('power.VPH_PWR_S2C_S3C_uws', 'soc'),
('power.VPH_PWR_OLED_uws', 'display'),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(('power.PPVAR_VPH_PWR_S1A_S9A_S10A_uws', 'soc'),
('power.PPVAR_VPH_PWR_S2A_S3A_uws', 'cpu_big'),
('power.PPVAR_VPH_PWR_S1C_uws', 'cpu_little'),
('power.WCN3998_VDD13 [from PP1304_L2C]_uws', 'wifi'),
('power.PPVAR_VPH_PWR_WLAN_uws', 'wifi'),
('power.PPVAR_VPH_PWR_OLED_uws', 'display'),
('power.PPVAR_VPH_PWR_QTM525_uws', 'cellular'),
('power.PPVAR_VPH_PWR_RF_uws', 'cellular'),
('power.rails.aoc.logic', 'aoc'),
('power.rails.aoc.memory', 'aoc'),
('power.rails.cpu.big', 'cpu_big'),
('power.rails.cpu.little', 'cpu_little'),
('power.rails.cpu.mid', 'cpu_mid'),
('power.rails.ddr.a', 'mem'),
('power.rails.ddr.b', 'mem'),
('power.rails.ddr.c', 'mem'),
('power.rails.gpu', 'gpu'),
('power.rails.display', 'display'),
('power.rails.gps', 'gps'),
('power.rails.memory.interface', 'mem'),
('power.rails.modem', 'cellular'),
('power.rails.radio.frontend', 'cellular'),
('power.rails.system.fabric', 'soc'),
('power.rails.wifi.bt', 'wifi');

-- Convert power counter data into table of events, where each event has
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- start timestamp, duration and the average power drain during its duration
-- in Watts.
-- Note that power counters wrap around at different values on different
-- devices. When that happens, we ignore the value before overflow, and only
-- take into account the value after it. This underestimates the actual power
-- drain between those counters.
DROP VIEW IF EXISTS drain_in_watts;
CREATE PERFETTO VIEW drain_in_watts AS
SELECT name,
  ts,
  LEAD(ts) OVER (
    PARTITION BY track_id
    ORDER BY ts
  ) - ts AS dur,
  CASE
    WHEN LEAD(value) OVER (
      PARTITION BY track_id
      ORDER BY ts
    ) >= value THEN (
      LEAD(value) OVER (
        PARTITION BY track_id
        ORDER BY ts
      ) - value
    )
    ELSE LEAD(value) OVER (
      PARTITION BY track_id
      ORDER BY ts
    )
  END / (
    LEAD(ts) OVER (
      PARTITION BY track_id
      ORDER BY ts
    ) - ts
  ) * 1e3 AS drain_w
FROM counter
JOIN counter_track ON (counter.track_id = counter_track.id)
WHERE counter_track.type = 'counter_track'
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  AND name GLOB "power.*";

)_d3l1m1t3r_"
;

const char kAndroidPowerProfileData[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

SELECT RUN_METRIC('android/power_profile_data/marlin.sql');
SELECT RUN_METRIC('android/power_profile_data/walleye.sql');
SELECT RUN_METRIC('android/power_profile_data/taimen.sql');
SELECT RUN_METRIC('android/power_profile_data/blueline.sql');
SELECT RUN_METRIC('android/power_profile_data/crosshatch.sql');
SELECT RUN_METRIC('android/power_profile_data/bonito.sql');
SELECT RUN_METRIC('android/power_profile_data/sargo.sql');
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT RUN_METRIC('android/power_profile_data/flame.sql');
SELECT RUN_METRIC('android/power_profile_data/coral.sql');
SELECT RUN_METRIC('android/power_profile_data/sunfish.sql');
SELECT RUN_METRIC('android/power_profile_data/bramble.sql');
SELECT RUN_METRIC('android/power_profile_data/redfin.sql');
SELECT RUN_METRIC('android/power_profile_data/barbet.sql');
SELECT RUN_METRIC('android/power_profile_data/oriole.sql');
SELECT RUN_METRIC('android/power_profile_data/raven.sql');
SELECT RUN_METRIC('android/power_profile_data/bluejay.sql');
SELECT RUN_METRIC('android/power_profile_data/shusky.sql');


)_d3l1m1t3r_"
;

const char kAndroidPowerProfileDataBarbet[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INSERT OR REPLACE INTO power_profile VALUES
("barbet", 0, 0, 300000, 41.92),
("barbet", 0, 0, 576000, 59.59),
("barbet", 0, 0, 614400, 61.93),
("barbet", 0, 0, 864000, 79.86),
("barbet", 0, 0, 1075200, 95.92),
("barbet", 0, 0, 1363200, 121.97),
("barbet", 0, 0, 1516800, 140.72),
("barbet", 0, 0, 1651200, 159.18),
("barbet", 0, 0, 1804800, 176.19),
("barbet", 1, 0, 300000, 41.92),
("barbet", 1, 0, 576000, 59.59),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("barbet", 1, 0, 614400, 61.93),
("barbet", 1, 0, 864000, 79.86),
("barbet", 1, 0, 1075200, 95.92),
("barbet", 1, 0, 1363200, 121.97),
("barbet", 1, 0, 1516800, 140.72),
("barbet", 1, 0, 1651200, 159.18),
("barbet", 1, 0, 1804800, 176.19),
("barbet", 2, 0, 300000, 41.92),
("barbet", 2, 0, 576000, 59.59),
("barbet", 2, 0, 614400, 61.93),
("barbet", 2, 0, 864000, 79.86),
("barbet", 2, 0, 1075200, 95.92),
("barbet", 2, 0, 1363200, 121.97),
("barbet", 2, 0, 1516800, 140.72),
("barbet", 2, 0, 1651200, 159.18),
("barbet", 2, 0, 1804800, 176.19),
("barbet", 3, 0, 300000, 41.92),
("barbet", 3, 0, 576000, 59.59),
("barbet", 3, 0, 614400, 61.93),
("barbet", 3, 0, 864000, 79.86),
("barbet", 3, 0, 1075200, 95.92),
("barbet", 3, 0, 1363200, 121.97),
("barbet", 3, 0, 1516800, 140.72),
("barbet", 3, 0, 1651200, 159.18),
("barbet", 3, 0, 1804800, 176.19),
("barbet", 4, 0, 300000, 41.92),
("barbet", 4, 0, 576000, 59.59),
("barbet", 4, 0, 614400, 61.93),
("barbet", 4, 0, 864000, 79.86),
("barbet", 4, 0, 1075200, 95.92),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("barbet", 4, 0, 1363200, 121.97),
("barbet", 4, 0, 1516800, 140.72),
("barbet", 4, 0, 1651200, 159.18),
("barbet", 4, 0, 1804800, 176.19),
("barbet", 5, 0, 300000, 41.92),
("barbet", 5, 0, 576000, 59.59),
("barbet", 5, 0, 614400, 61.93),
("barbet", 5, 0, 864000, 79.86),
("barbet", 5, 0, 1075200, 95.92),
("barbet", 5, 0, 1363200, 121.97),
("barbet", 5, 0, 1516800, 140.72),
("barbet", 5, 0, 1651200, 159.18),
("barbet", 5, 0, 1804800, 176.19),
("barbet", 6, 1, 652800, 32.13),
("barbet", 6, 1, 940800, 35.98),
("barbet", 6, 1, 1152000, 40.03),
("barbet", 6, 1, 1478400, 51.02),
("barbet", 6, 1, 1728000, 77.06),
("barbet", 6, 1, 1900800, 86.25),
("barbet", 6, 1, 2092800, 97.3),
("barbet", 6, 1, 2208000, 101.61),
("barbet", 7, 2, 806400, 56.44),
("barbet", 7, 2, 1094400, 65.72),
("barbet", 7, 2, 1401600, 77.01),
("barbet", 7, 2, 1766400, 104.91),
("barbet", 7, 2, 1996800, 112.35),
("barbet", 7, 2, 2188800, 118.53),
("barbet", 7, 2, 2304000, 122.34),
("barbet", 7, 2, 2400000, 135.0);

)_d3l1m1t3r_"
;

const char kAndroidPowerProfileDataBluejay[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INSERT OR REPLACE INTO power_profile VALUES
("bluejay", 0, 0, 300000, 1.89),
("bluejay", 0, 0, 574000, 6.15),
("bluejay", 0, 0, 738000, 9.34),
("bluejay", 0, 0, 930000, 14.22),
("bluejay", 0, 0, 1098000, 18.94),
("bluejay", 0, 0, 1197000, 21.98),
("bluejay", 0, 0, 1328000, 26.83),
("bluejay", 0, 0, 1401000, 30.17),
("bluejay", 0, 0, 1598000, 41.55),
("bluejay", 0, 0, 1704000, 48.36),
("bluejay", 0, 0, 1803000, 58.45),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("bluejay", 1, 0, 300000, 1.89),
("bluejay", 1, 0, 574000, 6.15),
("bluejay", 1, 0, 738000, 9.34),
("bluejay", 1, 0, 930000, 14.22),
("bluejay", 1, 0, 1098000, 18.94),
("bluejay", 1, 0, 1197000, 21.98),
("bluejay", 1, 0, 1328000, 26.83),
("bluejay", 1, 0, 1401000, 30.17),
("bluejay", 1, 0, 1598000, 41.55),
("bluejay", 1, 0, 1704000, 48.36),
("bluejay", 1, 0, 1803000, 58.45),
("bluejay", 2, 0, 300000, 1.89),
("bluejay", 2, 0, 574000, 6.15),
("bluejay", 2, 0, 738000, 9.34),
("bluejay", 2, 0, 930000, 14.22),
("bluejay", 2, 0, 1098000, 18.94),
("bluejay", 2, 0, 1197000, 21.98),
("bluejay", 2, 0, 1328000, 26.83),
("bluejay", 2, 0, 1401000, 30.17),
("bluejay", 2, 0, 1598000, 41.55),
("bluejay", 2, 0, 1704000, 48.36),
("bluejay", 2, 0, 1803000, 58.45),
("bluejay", 3, 0, 300000, 1.89),
("bluejay", 3, 0, 574000, 6.15),
("bluejay", 3, 0, 738000, 9.34),
("bluejay", 3, 0, 930000, 14.22),
("bluejay", 3, 0, 1098000, 18.94),
("bluejay", 3, 0, 1197000, 21.98),
("bluejay", 3, 0, 1328000, 26.83),
("bluejay", 3, 0, 1401000, 30.17),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("bluejay", 3, 0, 1598000, 41.55),
("bluejay", 3, 0, 1704000, 48.36),
("bluejay", 3, 0, 1803000, 58.45),
("bluejay", 4, 1, 400000, 3.71),
("bluejay", 4, 1, 553000, 6.16),
("bluejay", 4, 1, 696000, 8.0),
("bluejay", 4, 1, 799000, 10.94),
("bluejay", 4, 1, 910000, 12.73),
("bluejay", 4, 1, 1024000, 14.4),
("bluejay", 4, 1, 1197000, 21.39),
("bluejay", 4, 1, 1328000, 24.1),
("bluejay", 4, 1, 1491000, 30.42),
("bluejay", 4, 1, 1663000, 42.49),
("bluejay", 4, 1, 1836000, 49.37),
("bluejay", 4, 1, 1999000, 58.09),
("bluejay", 4, 1, 2130000, 67.54),
("bluejay", 4, 1, 2253000, 79.04),
("bluejay", 5, 1, 400000, 3.71),
("bluejay", 5, 1, 553000, 6.16),
("bluejay", 5, 1, 696000, 8.0),
("bluejay", 5, 1, 799000, 10.94),
("bluejay", 5, 1, 910000, 12.73),
("bluejay", 5, 1, 1024000, 14.4),
("bluejay", 5, 1, 1197000, 21.39),
("bluejay", 5, 1, 1328000, 24.1),
("bluejay", 5, 1, 1491000, 30.42),
("bluejay", 5, 1, 1663000, 42.49),
("bluejay", 5, 1, 1836000, 49.37),
("bluejay", 5, 1, 1999000, 58.09),
("bluejay", 5, 1, 2130000, 67.54),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("bluejay", 5, 1, 2253000, 79.04),
("bluejay", 6, 2, 500000, 8.36),
("bluejay", 6, 2, 851000, 16.33),
("bluejay", 6, 2, 984000, 19.44),
("bluejay", 6, 2, 1106000, 36.71),
("bluejay", 6, 2, 1277000, 41.42),
("bluejay", 6, 2, 1426000, 48.24),
("bluejay", 6, 2, 1582000, 54.77),
("bluejay", 6, 2, 1745000, 65.32),
("bluejay", 6, 2, 1826000, 69.58),
("bluejay", 6, 2, 2048000, 128.49),
("bluejay", 6, 2, 2188000, 142.15),
("bluejay", 6, 2, 2252000, 149.74),
("bluejay", 6, 2, 2401000, 164.78),
("bluejay", 6, 2, 2507000, 188.68),
("bluejay", 6, 2, 2630000, 193.15),
("bluejay", 6, 2, 2704000, 227.98),
("bluejay", 6, 2, 2802000, 254.25),
("bluejay", 7, 2, 500000, 8.36),
("bluejay", 7, 2, 851000, 16.33),
("bluejay", 7, 2, 984000, 19.44),
("bluejay", 7, 2, 1106000, 36.71),
("bluejay", 7, 2, 1277000, 41.42),
("bluejay", 7, 2, 1426000, 48.24),
("bluejay", 7, 2, 1582000, 54.77),
("bluejay", 7, 2, 1745000, 65.32),
("bluejay", 7, 2, 1826000, 69.58),
("bluejay", 7, 2, 2048000, 128.49),
("bluejay", 7, 2, 2188000, 142.15),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("bluejay", 7, 2, 2252000, 149.74),
("bluejay", 7, 2, 2401000, 164.78),
("bluejay", 7, 2, 2507000, 188.68),
("bluejay", 7, 2, 2630000, 193.15),
("bluejay", 7, 2, 2704000, 227.98),
("bluejay", 7, 2, 2802000, 254.25);

)_d3l1m1t3r_"
;

const char kAndroidPowerProfileDataBlueline[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INSERT OR REPLACE INTO power_profile VALUES
("blueline", 0, 0, 300000, 2.27),
("blueline", 0, 0, 403200, 3.63),
("blueline", 0, 0, 480000, 4.36),
("blueline", 0, 0, 576000, 5.21),
("blueline", 0, 0, 652800, 5.47),
("blueline", 0, 0, 748800, 6.74),
("blueline", 0, 0, 825600, 7.69),
("blueline", 0, 0, 902400, 8.57),
("blueline", 0, 0, 979200, 9.42),
("blueline", 0, 0, 1056000, 10.41),
("blueline", 0, 0, 1132800, 11.56),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("blueline", 0, 0, 1228800, 12.87),
("blueline", 0, 0, 1324800, 14.61),
("blueline", 0, 0, 1420800, 16.49),
("blueline", 0, 0, 1516800, 18.9),
("blueline", 0, 0, 1612800, 21.62),
("blueline", 0, 0, 1689600, 24.47),
("blueline", 0, 0, 1766400, 26.45),
("blueline", 1, 0, 300000, 2.27),
("blueline", 1, 0, 403200, 3.63),
("blueline", 1, 0, 480000, 4.36),
("blueline", 1, 0, 576000, 5.21),
("blueline", 1, 0, 652800, 5.47),
("blueline", 1, 0, 748800, 6.74),
("blueline", 1, 0, 825600, 7.69),
("blueline", 1, 0, 902400, 8.57),
("blueline", 1, 0, 979200, 9.42),
("blueline", 1, 0, 1056000, 10.41),
("blueline", 1, 0, 1132800, 11.56),
("blueline", 1, 0, 1228800, 12.87),
("blueline", 1, 0, 1324800, 14.61),
("blueline", 1, 0, 1420800, 16.49),
("blueline", 1, 0, 1516800, 18.9),
("blueline", 1, 0, 1612800, 21.62),
("blueline", 1, 0, 1689600, 24.47),
("blueline", 1, 0, 1766400, 26.45),
("blueline", 2, 0, 300000, 2.27),
("blueline", 2, 0, 403200, 3.63),
("blueline", 2, 0, 480000, 4.36),
("blueline", 2, 0, 576000, 5.21),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("blueline", 2, 0, 652800, 5.47),
("blueline", 2, 0, 748800, 6.74),
("blueline", 2, 0, 825600, 7.69),
("blueline", 2, 0, 902400, 8.57),
("blueline", 2, 0, 979200, 9.42),
("blueline", 2, 0, 1056000, 10.41),
("blueline", 2, 0, 1132800, 11.56),
("blueline", 2, 0, 1228800, 12.87),
("blueline", 2, 0, 1324800, 14.61),
("blueline", 2, 0, 1420800, 16.49),
("blueline", 2, 0, 1516800, 18.9),
("blueline", 2, 0, 1612800, 21.62),
("blueline", 2, 0, 1689600, 24.47),
("blueline", 2, 0, 1766400, 26.45),
("blueline", 3, 0, 300000, 2.27),
("blueline", 3, 0, 403200, 3.63),
("blueline", 3, 0, 480000, 4.36),
("blueline", 3, 0, 576000, 5.21),
("blueline", 3, 0, 652800, 5.47),
("blueline", 3, 0, 748800, 6.74),
("blueline", 3, 0, 825600, 7.69),
("blueline", 3, 0, 902400, 8.57),
("blueline", 3, 0, 979200, 9.42),
("blueline", 3, 0, 1056000, 10.41),
("blueline", 3, 0, 1132800, 11.56),
("blueline", 3, 0, 1228800, 12.87),
("blueline", 3, 0, 1324800, 14.61),
("blueline", 3, 0, 1420800, 16.49),
("blueline", 3, 0, 1516800, 18.9),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("blueline", 3, 0, 1612800, 21.62),
("blueline", 3, 0, 1689600, 24.47),
("blueline", 3, 0, 1766400, 26.45),
("blueline", 4, 1, 825600, 28.88),
("blueline", 4, 1, 902400, 32.4),
("blueline", 4, 1, 979200, 36.46),
("blueline", 4, 1, 1056000, 39.99),
("blueline", 4, 1, 1209600, 47.23),
("blueline", 4, 1, 1286400, 51.39),
("blueline", 4, 1, 1363200, 56.9),
("blueline", 4, 1, 1459200, 64.26),
("blueline", 4, 1, 1536000, 69.65),
("blueline", 4, 1, 1612800, 75.14),
("blueline", 4, 1, 1689600, 83.16),
("blueline", 4, 1, 1766400, 91.75),
("blueline", 4, 1, 1843200, 100.66),
("blueline", 4, 1, 1920000, 111.45),
("blueline", 4, 1, 1996800, 122.23),
("blueline", 4, 1, 2092800, 143.54),
("blueline", 4, 1, 2169600, 147.54),
("blueline", 4, 1, 2246400, 153.09),
("blueline", 4, 1, 2323200, 166.44),
("blueline", 4, 1, 2400000, 184.69),
("blueline", 4, 1, 2476800, 204.14),
("blueline", 4, 1, 2553600, 223.37),
("blueline", 4, 1, 2649600, 253.77),
("blueline", 5, 1, 825600, 28.88),
("blueline", 5, 1, 902400, 32.4),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("blueline", 5, 1, 979200, 36.46),
("blueline", 5, 1, 1056000, 39.99),
("blueline", 5, 1, 1209600, 47.23),
("blueline", 5, 1, 1286400, 51.39),
("blueline", 5, 1, 1363200, 56.9),
("blueline", 5, 1, 1459200, 64.26),
("blueline", 5, 1, 1536000, 69.65),
("blueline", 5, 1, 1612800, 75.14),
("blueline", 5, 1, 1689600, 83.16),
("blueline", 5, 1, 1766400, 91.75),
("blueline", 5, 1, 1843200, 100.66),
("blueline", 5, 1, 1920000, 111.45),
("blueline", 5, 1, 1996800, 122.23),
("blueline", 5, 1, 2092800, 143.54),
("blueline", 5, 1, 2169600, 147.54),
("blueline", 5, 1, 2246400, 153.09),
("blueline", 5, 1, 2323200, 166.44),
("blueline", 5, 1, 2400000, 184.69),
("blueline", 5, 1, 2476800, 204.14),
("blueline", 5, 1, 2553600, 223.37),
("blueline", 5, 1, 2649600, 253.77),
("blueline", 6, 1, 825600, 28.88),
("blueline", 6, 1, 902400, 32.4),
("blueline", 6, 1, 979200, 36.46),
("blueline", 6, 1, 1056000, 39.99),
("blueline", 6, 1, 1209600, 47.23),
("blueline", 6, 1, 1286400, 51.39),
("blueline", 6, 1, 1363200, 56.9),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("blueline", 6, 1, 1459200, 64.26),
("blueline", 6, 1, 1536000, 69.65),
("blueline", 6, 1, 1612800, 75.14),
("blueline", 6, 1, 1689600, 83.16),
("blueline", 6, 1, 1766400, 91.75),
("blueline", 6, 1, 1843200, 100.66),
("blueline", 6, 1, 1920000, 111.45),
("blueline", 6, 1, 1996800, 122.23),
("blueline", 6, 1, 2092800, 143.54),
("blueline", 6, 1, 2169600, 147.54),
("blueline", 6, 1, 2246400, 153.09),
("blueline", 6, 1, 2323200, 166.44),
("blueline", 6, 1, 2400000, 184.69),
("blueline", 6, 1, 2476800, 204.14),
("blueline", 6, 1, 2553600, 223.37),
("blueline", 6, 1, 2649600, 253.77),
("blueline", 7, 1, 825600, 28.88),
("blueline", 7, 1, 902400, 32.4),
("blueline", 7, 1, 979200, 36.46),
("blueline", 7, 1, 1056000, 39.99),
("blueline", 7, 1, 1209600, 47.23),
("blueline", 7, 1, 1286400, 51.39),
("blueline", 7, 1, 1363200, 56.9),
("blueline", 7, 1, 1459200, 64.26),
("blueline", 7, 1, 1536000, 69.65),
("blueline", 7, 1, 1612800, 75.14),
("blueline", 7, 1, 1689600, 83.16),
("blueline", 7, 1, 1766400, 91.75),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("blueline", 7, 1, 1843200, 100.66),
("blueline", 7, 1, 1920000, 111.45),
("blueline", 7, 1, 1996800, 122.23),
("blueline", 7, 1, 2092800, 143.54),
("blueline", 7, 1, 2169600, 147.54),
("blueline", 7, 1, 2246400, 153.09),
("blueline", 7, 1, 2323200, 166.44),
("blueline", 7, 1, 2400000, 184.69),
("blueline", 7, 1, 2476800, 204.14),
("blueline", 7, 1, 2553600, 223.37),
("blueline", 7, 1, 2649600, 253.77);

)_d3l1m1t3r_"
;

const char kAndroidPowerProfileDataBonito[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INSERT OR REPLACE INTO power_profile VALUES
("bonito", 0, 0, 300000, 15.2466666667),
("bonito", 0, 0, 576000, 18.2166666667),
("bonito", 0, 0, 748800, 20.1866666667),
("bonito", 0, 0, 998400, 23.29),
("bonito", 0, 0, 1209600, 25.0116666667),
("bonito", 0, 0, 1324800, 28.485),
("bonito", 0, 0, 1516800, 31.6866666667),
("bonito", 0, 0, 1708800, 35.79),
("bonito", 1, 0, 300000, 15.2466666667),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("bonito", 1, 0, 576000, 18.2166666667),
("bonito", 1, 0, 748800, 20.1866666667),
("bonito", 1, 0, 998400, 23.29),
("bonito", 1, 0, 1209600, 25.0116666667),
("bonito", 1, 0, 1324800, 28.485),
("bonito", 1, 0, 1516800, 31.6866666667),
("bonito", 1, 0, 1708800, 35.79),
("bonito", 2, 0, 300000, 15.2466666667),
("bonito", 2, 0, 576000, 18.2166666667),
("bonito", 2, 0, 748800, 20.1866666667),
("bonito", 2, 0, 998400, 23.29),
("bonito", 2, 0, 1209600, 25.0116666667),
("bonito", 2, 0, 1324800, 28.485),
("bonito", 2, 0, 1516800, 31.6866666667),
("bonito", 2, 0, 1708800, 35.79),
("bonito", 3, 0, 300000, 15.2466666667),
("bonito", 3, 0, 576000, 18.2166666667),
("bonito", 3, 0, 748800, 20.1866666667),
("bonito", 3, 0, 998400, 23.29),
("bonito", 3, 0, 1209600, 25.0116666667),
("bonito", 3, 0, 1324800, 28.485),
("bonito", 3, 0, 1516800, 31.6866666667),
("bonito", 3, 0, 1708800, 35.79),
("bonito", 4, 0, 300000, 15.2466666667),
("bonito", 4, 0, 576000, 18.2166666667),
("bonito", 4, 0, 748800, 20.1866666667),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("bonito", 4, 0, 998400, 23.29),
("bonito", 4, 0, 1209600, 25.0116666667),
("bonito", 4, 0, 1324800, 28.485),
("bonito", 4, 0, 1516800, 31.6866666667),
("bonito", 4, 0, 1708800, 35.79),
("bonito", 5, 0, 300000, 15.2466666667),
("bonito", 5, 0, 576000, 18.2166666667),
("bonito", 5, 0, 748800, 20.1866666667),
("bonito", 5, 0, 998400, 23.29),
("bonito", 5, 0, 1209600, 25.0116666667),
("bonito", 5, 0, 1324800, 28.485),
("bonito", 5, 0, 1516800, 31.6866666667),
("bonito", 5, 0, 1708800, 35.79),
("bonito", 6, 1, 300000, 24.06),
("bonito", 6, 1, 652800, 27.56),
("bonito", 6, 1, 825600, 29.0),
("bonito", 6, 1, 979200, 31.675),
("bonito", 6, 1, 1132800, 34.53),
("bonito", 6, 1, 1363200, 38.885),
("bonito", 6, 1, 1536000, 43.075),
("bonito", 6, 1, 1747200, 48.705),
("bonito", 6, 1, 1843200, 64.57),
("bonito", 6, 1, 1996800, 69.805),
("bonito", 6, 1, 2016000, 76.545),
("bonito", 7, 1, 300000, 24.06),
("bonito", 7, 1, 652800, 27.56),
("bonito", 7, 1, 825600, 29.0),
("bonito", 7, 1, 979200, 31.675),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("bonito", 7, 1, 1132800, 34.53),
("bonito", 7, 1, 1363200, 38.885),
("bonito", 7, 1, 1536000, 43.075),
("bonito", 7, 1, 1747200, 48.705),
("bonito", 7, 1, 1843200, 64.57),
("bonito", 7, 1, 1996800, 69.805),
("bonito", 7, 1, 2016000, 76.545);

)_d3l1m1t3r_"
;

const char kAndroidPowerProfileDataBramble[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INSERT OR REPLACE INTO power_profile VALUES
("bramble", 0, 0, 300000, 6.98666666667),
("bramble", 0, 0, 576000, 9.93166666667),
("bramble", 0, 0, 614400, 10.3216666667),
("bramble", 0, 0, 864000, 13.31),
("bramble", 0, 0, 1075200, 15.9866666667),
("bramble", 0, 0, 1363200, 20.3283333333),
("bramble", 0, 0, 1516800, 23.4533333333),
("bramble", 0, 0, 1651200, 26.53),
("bramble", 0, 0, 1804800, 29.365),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("bramble", 1, 0, 300000, 6.98666666667),
("bramble", 1, 0, 576000, 9.93166666667),
("bramble", 1, 0, 614400, 10.3216666667),
("bramble", 1, 0, 864000, 13.31),
("bramble", 1, 0, 1075200, 15.9866666667),
("bramble", 1, 0, 1363200, 20.3283333333),
("bramble", 1, 0, 1516800, 23.4533333333),
("bramble", 1, 0, 1651200, 26.53),
("bramble", 1, 0, 1804800, 29.365),
("bramble", 2, 0, 300000, 6.98666666667),
("bramble", 2, 0, 576000, 9.93166666667),
("bramble", 2, 0, 614400, 10.3216666667),
("bramble", 2, 0, 864000, 13.31),
("bramble", 2, 0, 1075200, 15.9866666667),
("bramble", 2, 0, 1363200, 20.3283333333),
("bramble", 2, 0, 1516800, 23.4533333333),
("bramble", 2, 0, 1651200, 26.53),
("bramble", 2, 0, 1804800, 29.365),
("bramble", 3, 0, 300000, 6.98666666667),
("bramble", 3, 0, 576000, 9.93166666667),
("bramble", 3, 0, 614400, 10.3216666667),
("bramble", 3, 0, 864000, 13.31),
("bramble", 3, 0, 1075200, 15.9866666667),
("bramble", 3, 0, 1363200, 20.3283333333),
("bramble", 3, 0, 1516800, 23.4533333333),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("bramble", 3, 0, 1651200, 26.53),
("bramble", 3, 0, 1804800, 29.365),
("bramble", 4, 0, 300000, 6.98666666667),
("bramble", 4, 0, 576000, 9.93166666667),
("bramble", 4, 0, 614400, 10.3216666667),
("bramble", 4, 0, 864000, 13.31),
("bramble", 4, 0, 1075200, 15.9866666667),
("bramble", 4, 0, 1363200, 20.3283333333),
("bramble", 4, 0, 1516800, 23.4533333333),
("bramble", 4, 0, 1651200, 26.53),
("bramble", 4, 0, 1804800, 29.365),
("bramble", 5, 0, 300000, 6.98666666667),
("bramble", 5, 0, 576000, 9.93166666667),
("bramble", 5, 0, 614400, 10.3216666667),
("bramble", 5, 0, 864000, 13.31),
("bramble", 5, 0, 1075200, 15.9866666667),
("bramble", 5, 0, 1363200, 20.3283333333),
("bramble", 5, 0, 1516800, 23.4533333333),
("bramble", 5, 0, 1651200, 26.53),
("bramble", 5, 0, 1804800, 29.365),
("bramble", 6, 1, 652800, 32.13),
("bramble", 6, 1, 940800, 35.98),
("bramble", 6, 1, 1152000, 40.03),
("bramble", 6, 1, 1478400, 51.02),
("bramble", 6, 1, 1728000, 77.06),
("bramble", 6, 1, 1900800, 86.25),
("bramble", 6, 1, 2092800, 97.3),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("bramble", 6, 1, 2208000, 101.61),
("bramble", 7, 2, 806400, 56.44),
("bramble", 7, 2, 1094400, 65.72),
("bramble", 7, 2, 1401600, 77.01),
("bramble", 7, 2, 1766400, 104.91),
("bramble", 7, 2, 1996800, 112.35),
("bramble", 7, 2, 2188800, 118.53),
("bramble", 7, 2, 2304000, 122.34),
("bramble", 7, 2, 2400000, 135.0);

)_d3l1m1t3r_"
;

const char kAndroidPowerProfileDataCoral[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INSERT OR REPLACE INTO power_profile VALUES
("coral", 0, 0, 300000, 9.86),
("coral", 0, 0, 403200, 10.335),
("coral", 0, 0, 499200, 10.8925),
("coral", 0, 0, 576000, 11.37),
("coral", 0, 0, 672000, 11.8),
("coral", 0, 0, 768000, 12.41),
("coral", 0, 0, 844800, 12.97),
("coral", 0, 0, 940800, 13.335),
("coral", 0, 0, 1036800, 14.1725),
("coral", 0, 0, 1113600, 14.695),
("coral", 0, 0, 1209600, 15.3525),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("coral", 0, 0, 1305600, 16.2775),
("coral", 0, 0, 1382400, 16.8725),
("coral", 0, 0, 1478400, 17.6525),
("coral", 0, 0, 1555200, 18.0975),
("coral", 0, 0, 1632000, 18.8575),
("coral", 0, 0, 1708800, 20.0525),
("coral", 0, 0, 1785600, 21.2625),
("coral", 1, 0, 300000, 9.86),
("coral", 1, 0, 403200, 10.335),
("coral", 1, 0, 499200, 10.8925),
("coral", 1, 0, 576000, 11.37),
("coral", 1, 0, 672000, 11.8),
("coral", 1, 0, 768000, 12.41),
("coral", 1, 0, 844800, 12.97),
("coral", 1, 0, 940800, 13.335),
("coral", 1, 0, 1036800, 14.1725),
("coral", 1, 0, 1113600, 14.695),
("coral", 1, 0, 1209600, 15.3525),
("coral", 1, 0, 1305600, 16.2775),
("coral", 1, 0, 1382400, 16.8725),
("coral", 1, 0, 1478400, 17.6525),
("coral", 1, 0, 1555200, 18.0975),
("coral", 1, 0, 1632000, 18.8575),
("coral", 1, 0, 1708800, 20.0525),
("coral", 1, 0, 1785600, 21.2625),
("coral", 2, 0, 300000, 9.86),
("coral", 2, 0, 403200, 10.335),
("coral", 2, 0, 499200, 10.8925),
("coral", 2, 0, 576000, 11.37),
("coral", 2, 0, 672000, 11.8),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("coral", 2, 0, 768000, 12.41),
("coral", 2, 0, 844800, 12.97),
("coral", 2, 0, 940800, 13.335),
("coral", 2, 0, 1036800, 14.1725),
("coral", 2, 0, 1113600, 14.695),
("coral", 2, 0, 1209600, 15.3525),
("coral", 2, 0, 1305600, 16.2775),
("coral", 2, 0, 1382400, 16.8725),
("coral", 2, 0, 1478400, 17.6525),
("coral", 2, 0, 1555200, 18.0975),
("coral", 2, 0, 1632000, 18.8575),
("coral", 2, 0, 1708800, 20.0525),
("coral", 2, 0, 1785600, 21.2625),
("coral", 3, 0, 300000, 9.86),
("coral", 3, 0, 403200, 10.335),
("coral", 3, 0, 499200, 10.8925),
("coral", 3, 0, 576000, 11.37),
("coral", 3, 0, 672000, 11.8),
("coral", 3, 0, 768000, 12.41),
("coral", 3, 0, 844800, 12.97),
("coral", 3, 0, 940800, 13.335),
("coral", 3, 0, 1036800, 14.1725),
("coral", 3, 0, 1113600, 14.695),
("coral", 3, 0, 1209600, 15.3525),
("coral", 3, 0, 1305600, 16.2775),
("coral", 3, 0, 1382400, 16.8725),
("coral", 3, 0, 1478400, 17.6525),
("coral", 3, 0, 1555200, 18.0975),
("coral", 3, 0, 1632000, 18.8575),
("coral", 3, 0, 1708800, 20.0525),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("coral", 3, 0, 1785600, 21.2625),
("coral", 4, 1, 710400, 16.7833333333),
("coral", 4, 1, 825600, 18.3733333333),
("coral", 4, 1, 940800, 20.4833333333),
("coral", 4, 1, 1056000, 23.3066666667),
("coral", 4, 1, 1171200, 25.8266666667),
("coral", 4, 1, 1286400, 28.45),
("coral", 4, 1, 1401600, 31.7233333333),
("coral", 4, 1, 1497600, 34.42),
("coral", 4, 1, 1612800, 39.3966666667),
("coral", 4, 1, 1708800, 44.24),
("coral", 4, 1, 1804800, 47.9433333333),
("coral", 4, 1, 1920000, 51.97),
("coral", 4, 1, 2016000, 63.3866666667),
("coral", 4, 1, 2131200, 71.0366666667),
("coral", 4, 1, 2227200, 79.32),
("coral", 4, 1, 2323200, 88.99),
("coral", 4, 1, 2419200, 100.68),
("coral", 5, 1, 710400, 16.7833333333),
("coral", 5, 1, 825600, 18.3733333333),
("coral", 5, 1, 940800, 20.4833333333),
("coral", 5, 1, 1056000, 23.3066666667),
("coral", 5, 1, 1171200, 25.8266666667),
("coral", 5, 1, 1286400, 28.45),
("coral", 5, 1, 1401600, 31.7233333333),
("coral", 5, 1, 1497600, 34.42),
("coral", 5, 1, 1612800, 39.3966666667),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("coral", 5, 1, 1708800, 44.24),
("coral", 5, 1, 1804800, 47.9433333333),
("coral", 5, 1, 1920000, 51.97),
("coral", 5, 1, 2016000, 63.3866666667),
("coral", 5, 1, 2131200, 71.0366666667),
("coral", 5, 1, 2227200, 79.32),
("coral", 5, 1, 2323200, 88.99),
("coral", 5, 1, 2419200, 100.68),
("coral", 6, 1, 710400, 16.7833333333),
("coral", 6, 1, 825600, 18.3733333333),
("coral", 6, 1, 940800, 20.4833333333),
("coral", 6, 1, 1056000, 23.3066666667),
("coral", 6, 1, 1171200, 25.8266666667),
("coral", 6, 1, 1286400, 28.45),
("coral", 6, 1, 1401600, 31.7233333333),
("coral", 6, 1, 1497600, 34.42),
("coral", 6, 1, 1612800, 39.3966666667),
("coral", 6, 1, 1708800, 44.24),
("coral", 6, 1, 1804800, 47.9433333333),
("coral", 6, 1, 1920000, 51.97),
("coral", 6, 1, 2016000, 63.3866666667),
("coral", 6, 1, 2131200, 71.0366666667),
("coral", 6, 1, 2227200, 79.32),
("coral", 6, 1, 2323200, 88.99),
("coral", 6, 1, 2419200, 100.68),
("coral", 7, 2, 825600, 52.7),
("coral", 7, 2, 940800, 55.9),
("coral", 7, 2, 1056000, 59.73),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("coral", 7, 2, 1171200, 63.66),
("coral", 7, 2, 1286400, 67.28),
("coral", 7, 2, 1401600, 71.66),
("coral", 7, 2, 1497600, 76.47),
("coral", 7, 2, 1612800, 80.92),
("coral", 7, 2, 1708800, 85.81),
("coral", 7, 2, 1804800, 93.19),
("coral", 7, 2, 1920000, 98.06),
("coral", 7, 2, 2016000, 119.08),
("coral", 7, 2, 2131200, 127.88),
("coral", 7, 2, 2227200, 129.85),
("coral", 7, 2, 2323200, 140.37),
("coral", 7, 2, 2419200, 151.22),
("coral", 7, 2, 2534400, 160.73),
("coral", 7, 2, 2649600, 175.5),
("coral", 7, 2, 2745600, 186.29),
("coral", 7, 2, 2841600, 223.89);

)_d3l1m1t3r_"
;

const char kAndroidPowerProfileDataCrosshatch[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INSERT OR REPLACE INTO power_profile VALUES
("crosshatch", 0, 0, 300000, 2.27),
("crosshatch", 0, 0, 403200, 3.63),
("crosshatch", 0, 0, 480000, 4.36),
("crosshatch", 0, 0, 576000, 5.21),
("crosshatch", 0, 0, 652800, 5.47),
("crosshatch", 0, 0, 748800, 6.74),
("crosshatch", 0, 0, 825600, 7.69),
("crosshatch", 0, 0, 902400, 8.57),
("crosshatch", 0, 0, 979200, 9.42),
("crosshatch", 0, 0, 1056000, 10.41),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("crosshatch", 0, 0, 1132800, 11.56),
("crosshatch", 0, 0, 1228800, 12.87),
("crosshatch", 0, 0, 1324800, 14.61),
("crosshatch", 0, 0, 1420800, 16.49),
("crosshatch", 0, 0, 1516800, 18.9),
("crosshatch", 0, 0, 1612800, 21.62),
("crosshatch", 0, 0, 1689600, 24.47),
("crosshatch", 0, 0, 1766400, 26.45),
("crosshatch", 1, 0, 300000, 2.27),
("crosshatch", 1, 0, 403200, 3.63),
("crosshatch", 1, 0, 480000, 4.36),
("crosshatch", 1, 0, 576000, 5.21),
("crosshatch", 1, 0, 652800, 5.47),
("crosshatch", 1, 0, 748800, 6.74),
("crosshatch", 1, 0, 825600, 7.69),
("crosshatch", 1, 0, 902400, 8.57),
("crosshatch", 1, 0, 979200, 9.42),
("crosshatch", 1, 0, 1056000, 10.41),
("crosshatch", 1, 0, 1132800, 11.56),
("crosshatch", 1, 0, 1228800, 12.87),
("crosshatch", 1, 0, 1324800, 14.61),
("crosshatch", 1, 0, 1420800, 16.49),
("crosshatch", 1, 0, 1516800, 18.9),
("crosshatch", 1, 0, 1612800, 21.62),
("crosshatch", 1, 0, 1689600, 24.47),
("crosshatch", 1, 0, 1766400, 26.45),
("crosshatch", 2, 0, 300000, 2.27),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("crosshatch", 2, 0, 403200, 3.63),
("crosshatch", 2, 0, 480000, 4.36),
("crosshatch", 2, 0, 576000, 5.21),
("crosshatch", 2, 0, 652800, 5.47),
("crosshatch", 2, 0, 748800, 6.74),
("crosshatch", 2, 0, 825600, 7.69),
("crosshatch", 2, 0, 902400, 8.57),
("crosshatch", 2, 0, 979200, 9.42),
("crosshatch", 2, 0, 1056000, 10.41),
("crosshatch", 2, 0, 1132800, 11.56),
("crosshatch", 2, 0, 1228800, 12.87),
("crosshatch", 2, 0, 1324800, 14.61),
("crosshatch", 2, 0, 1420800, 16.49),
("crosshatch", 2, 0, 1516800, 18.9),
("crosshatch", 2, 0, 1612800, 21.62),
("crosshatch", 2, 0, 1689600, 24.47),
("crosshatch", 2, 0, 1766400, 26.45),
("crosshatch", 3, 0, 300000, 2.27),
("crosshatch", 3, 0, 403200, 3.63),
("crosshatch", 3, 0, 480000, 4.36),
("crosshatch", 3, 0, 576000, 5.21),
("crosshatch", 3, 0, 652800, 5.47),
("crosshatch", 3, 0, 748800, 6.74),
("crosshatch", 3, 0, 825600, 7.69),
("crosshatch", 3, 0, 902400, 8.57),
("crosshatch", 3, 0, 979200, 9.42),
("crosshatch", 3, 0, 1056000, 10.41),
("crosshatch", 3, 0, 1132800, 11.56),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("crosshatch", 3, 0, 1228800, 12.87),
("crosshatch", 3, 0, 1324800, 14.61),
("crosshatch", 3, 0, 1420800, 16.49),
("crosshatch", 3, 0, 1516800, 18.9),
("crosshatch", 3, 0, 1612800, 21.62),
("crosshatch", 3, 0, 1689600, 24.47),
("crosshatch", 3, 0, 1766400, 26.45),
("crosshatch", 4, 1, 825600, 28.88),
("crosshatch", 4, 1, 902400, 32.4),
("crosshatch", 4, 1, 979200, 36.46),
("crosshatch", 4, 1, 1056000, 39.99),
("crosshatch", 4, 1, 1209600, 47.23),
("crosshatch", 4, 1, 1286400, 51.39),
("crosshatch", 4, 1, 1363200, 56.9),
("crosshatch", 4, 1, 1459200, 64.26),
("crosshatch", 4, 1, 1536000, 69.65),
("crosshatch", 4, 1, 1612800, 75.14),
("crosshatch", 4, 1, 1689600, 83.16),
("crosshatch", 4, 1, 1766400, 91.75),
("crosshatch", 4, 1, 1843200, 100.66),
("crosshatch", 4, 1, 1920000, 111.45),
("crosshatch", 4, 1, 1996800, 122.23),
("crosshatch", 4, 1, 2092800, 143.54),
("crosshatch", 4, 1, 2169600, 147.54),
("crosshatch", 4, 1, 2246400, 153.09),
("crosshatch", 4, 1, 2323200, 166.44),
("crosshatch", 4, 1, 2400000, 184.69),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("crosshatch", 4, 1, 2476800, 204.14),
("crosshatch", 4, 1, 2553600, 223.37),
("crosshatch", 4, 1, 2649600, 253.77),
("crosshatch", 5, 1, 825600, 28.88),
("crosshatch", 5, 1, 902400, 32.4),
("crosshatch", 5, 1, 979200, 36.46),
("crosshatch", 5, 1, 1056000, 39.99),
("crosshatch", 5, 1, 1209600, 47.23),
("crosshatch", 5, 1, 1286400, 51.39),
("crosshatch", 5, 1, 1363200, 56.9),
("crosshatch", 5, 1, 1459200, 64.26),
("crosshatch", 5, 1, 1536000, 69.65),
("crosshatch", 5, 1, 1612800, 75.14),
("crosshatch", 5, 1, 1689600, 83.16),
("crosshatch", 5, 1, 1766400, 91.75),
("crosshatch", 5, 1, 1843200, 100.66),
("crosshatch", 5, 1, 1920000, 111.45),
("crosshatch", 5, 1, 1996800, 122.23),
("crosshatch", 5, 1, 2092800, 143.54),
("crosshatch", 5, 1, 2169600, 147.54),
("crosshatch", 5, 1, 2246400, 153.09),
("crosshatch", 5, 1, 2323200, 166.44),
("crosshatch", 5, 1, 2400000, 184.69),
("crosshatch", 5, 1, 2476800, 204.14),
("crosshatch", 5, 1, 2553600, 223.37),
("crosshatch", 5, 1, 2649600, 253.77),
("crosshatch", 6, 1, 825600, 28.88),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("crosshatch", 6, 1, 902400, 32.4),
("crosshatch", 6, 1, 979200, 36.46),
("crosshatch", 6, 1, 1056000, 39.99),
("crosshatch", 6, 1, 1209600, 47.23),
("crosshatch", 6, 1, 1286400, 51.39),
("crosshatch", 6, 1, 1363200, 56.9),
("crosshatch", 6, 1, 1459200, 64.26),
("crosshatch", 6, 1, 1536000, 69.65),
("crosshatch", 6, 1, 1612800, 75.14),
("crosshatch", 6, 1, 1689600, 83.16),
("crosshatch", 6, 1, 1766400, 91.75),
("crosshatch", 6, 1, 1843200, 100.66),
("crosshatch", 6, 1, 1920000, 111.45),
("crosshatch", 6, 1, 1996800, 122.23),
("crosshatch", 6, 1, 2092800, 143.54),
("crosshatch", 6, 1, 2169600, 147.54),
("crosshatch", 6, 1, 2246400, 153.09),
("crosshatch", 6, 1, 2323200, 166.44),
("crosshatch", 6, 1, 2400000, 184.69),
("crosshatch", 6, 1, 2476800, 204.14),
("crosshatch", 6, 1, 2553600, 223.37),
("crosshatch", 6, 1, 2649600, 253.77),
("crosshatch", 7, 1, 825600, 28.88),
("crosshatch", 7, 1, 902400, 32.4),
("crosshatch", 7, 1, 979200, 36.46),
("crosshatch", 7, 1, 1056000, 39.99),
("crosshatch", 7, 1, 1209600, 47.23),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("crosshatch", 7, 1, 1286400, 51.39),
("crosshatch", 7, 1, 1363200, 56.9),
("crosshatch", 7, 1, 1459200, 64.26),
("crosshatch", 7, 1, 1536000, 69.65),
("crosshatch", 7, 1, 1612800, 75.14),
("crosshatch", 7, 1, 1689600, 83.16),
("crosshatch", 7, 1, 1766400, 91.75),
("crosshatch", 7, 1, 1843200, 100.66),
("crosshatch", 7, 1, 1920000, 111.45),
("crosshatch", 7, 1, 1996800, 122.23),
("crosshatch", 7, 1, 2092800, 143.54),
("crosshatch", 7, 1, 2169600, 147.54),
("crosshatch", 7, 1, 2246400, 153.09),
("crosshatch", 7, 1, 2323200, 166.44),
("crosshatch", 7, 1, 2400000, 184.69),
("crosshatch", 7, 1, 2476800, 204.14),
("crosshatch", 7, 1, 2553600, 223.37),
("crosshatch", 7, 1, 2649600, 253.77);

)_d3l1m1t3r_"
;

const char kAndroidPowerProfileDataFlame[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INSERT OR REPLACE INTO power_profile VALUES
("flame", 0, 0, 300000, 9.86),
("flame", 0, 0, 403200, 10.335),
("flame", 0, 0, 499200, 10.8925),
("flame", 0, 0, 576000, 11.37),
("flame", 0, 0, 672000, 11.8),
("flame", 0, 0, 768000, 12.41),
("flame", 0, 0, 844800, 12.97),
("flame", 0, 0, 940800, 13.335),
("flame", 0, 0, 1036800, 14.1725),
("flame", 0, 0, 1113600, 14.695),
("flame", 0, 0, 1209600, 15.3525),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("flame", 0, 0, 1305600, 16.2775),
("flame", 0, 0, 1382400, 16.8725),
("flame", 0, 0, 1478400, 17.6525),
("flame", 0, 0, 1555200, 18.0975),
("flame", 0, 0, 1632000, 18.8575),
("flame", 0, 0, 1708800, 20.0525),
("flame", 0, 0, 1785600, 21.2625),
("flame", 1, 0, 300000, 9.86),
("flame", 1, 0, 403200, 10.335),
("flame", 1, 0, 499200, 10.8925),
("flame", 1, 0, 576000, 11.37),
("flame", 1, 0, 672000, 11.8),
("flame", 1, 0, 768000, 12.41),
("flame", 1, 0, 844800, 12.97),
("flame", 1, 0, 940800, 13.335),
("flame", 1, 0, 1036800, 14.1725),
("flame", 1, 0, 1113600, 14.695),
("flame", 1, 0, 1209600, 15.3525),
("flame", 1, 0, 1305600, 16.2775),
("flame", 1, 0, 1382400, 16.8725),
("flame", 1, 0, 1478400, 17.6525),
("flame", 1, 0, 1555200, 18.0975),
("flame", 1, 0, 1632000, 18.8575),
("flame", 1, 0, 1708800, 20.0525),
("flame", 1, 0, 1785600, 21.2625),
("flame", 2, 0, 300000, 9.86),
("flame", 2, 0, 403200, 10.335),
("flame", 2, 0, 499200, 10.8925),
("flame", 2, 0, 576000, 11.37),
("flame", 2, 0, 672000, 11.8),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("flame", 2, 0, 768000, 12.41),
("flame", 2, 0, 844800, 12.97),
("flame", 2, 0, 940800, 13.335),
("flame", 2, 0, 1036800, 14.1725),
("flame", 2, 0, 1113600, 14.695),
("flame", 2, 0, 1209600, 15.3525),
("flame", 2, 0, 1305600, 16.2775),
("flame", 2, 0, 1382400, 16.8725),
("flame", 2, 0, 1478400, 17.6525),
("flame", 2, 0, 1555200, 18.0975),
("flame", 2, 0, 1632000, 18.8575),
("flame", 2, 0, 1708800, 20.0525),
("flame", 2, 0, 1785600, 21.2625),
("flame", 3, 0, 300000, 9.86),
("flame", 3, 0, 403200, 10.335),
("flame", 3, 0, 499200, 10.8925),
("flame", 3, 0, 576000, 11.37),
("flame", 3, 0, 672000, 11.8),
("flame", 3, 0, 768000, 12.41),
("flame", 3, 0, 844800, 12.97),
("flame", 3, 0, 940800, 13.335),
("flame", 3, 0, 1036800, 14.1725),
("flame", 3, 0, 1113600, 14.695),
("flame", 3, 0, 1209600, 15.3525),
("flame", 3, 0, 1305600, 16.2775),
("flame", 3, 0, 1382400, 16.8725),
("flame", 3, 0, 1478400, 17.6525),
("flame", 3, 0, 1555200, 18.0975),
("flame", 3, 0, 1632000, 18.8575),
("flame", 3, 0, 1708800, 20.0525),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("flame", 3, 0, 1785600, 21.2625),
("flame", 4, 1, 710400, 16.7833333333),
("flame", 4, 1, 825600, 18.3733333333),
("flame", 4, 1, 940800, 20.4833333333),
("flame", 4, 1, 1056000, 23.3066666667),
("flame", 4, 1, 1171200, 25.8266666667),
("flame", 4, 1, 1286400, 28.45),
("flame", 4, 1, 1401600, 31.7233333333),
("flame", 4, 1, 1497600, 34.42),
("flame", 4, 1, 1612800, 39.3966666667),
("flame", 4, 1, 1708800, 44.24),
("flame", 4, 1, 1804800, 47.9433333333),
("flame", 4, 1, 1920000, 51.97),
("flame", 4, 1, 2016000, 63.3866666667),
("flame", 4, 1, 2131200, 71.0366666667),
("flame", 4, 1, 2227200, 79.32),
("flame", 4, 1, 2323200, 88.99),
("flame", 4, 1, 2419200, 100.68),
("flame", 5, 1, 710400, 16.7833333333),
("flame", 5, 1, 825600, 18.3733333333),
("flame", 5, 1, 940800, 20.4833333333),
("flame", 5, 1, 1056000, 23.3066666667),
("flame", 5, 1, 1171200, 25.8266666667),
("flame", 5, 1, 1286400, 28.45),
("flame", 5, 1, 1401600, 31.7233333333),
("flame", 5, 1, 1497600, 34.42),
("flame", 5, 1, 1612800, 39.3966666667),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("flame", 5, 1, 1708800, 44.24),
("flame", 5, 1, 1804800, 47.9433333333),
("flame", 5, 1, 1920000, 51.97),
("flame", 5, 1, 2016000, 63.3866666667),
("flame", 5, 1, 2131200, 71.0366666667),
("flame", 5, 1, 2227200, 79.32),
("flame", 5, 1, 2323200, 88.99),
("flame", 5, 1, 2419200, 100.68),
("flame", 6, 1, 710400, 16.7833333333),
("flame", 6, 1, 825600, 18.3733333333),
("flame", 6, 1, 940800, 20.4833333333),
("flame", 6, 1, 1056000, 23.3066666667),
("flame", 6, 1, 1171200, 25.8266666667),
("flame", 6, 1, 1286400, 28.45),
("flame", 6, 1, 1401600, 31.7233333333),
("flame", 6, 1, 1497600, 34.42),
("flame", 6, 1, 1612800, 39.3966666667),
("flame", 6, 1, 1708800, 44.24),
("flame", 6, 1, 1804800, 47.9433333333),
("flame", 6, 1, 1920000, 51.97),
("flame", 6, 1, 2016000, 63.3866666667),
("flame", 6, 1, 2131200, 71.0366666667),
("flame", 6, 1, 2227200, 79.32),
("flame", 6, 1, 2323200, 88.99),
("flame", 6, 1, 2419200, 100.68),
("flame", 7, 2, 825600, 52.7),
("flame", 7, 2, 940800, 55.9),
("flame", 7, 2, 1056000, 59.73),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("flame", 7, 2, 1171200, 63.66),
("flame", 7, 2, 1286400, 67.28),
("flame", 7, 2, 1401600, 71.66),
("flame", 7, 2, 1497600, 76.47),
("flame", 7, 2, 1612800, 80.92),
("flame", 7, 2, 1708800, 85.81),
("flame", 7, 2, 1804800, 93.19),
("flame", 7, 2, 1920000, 98.06),
("flame", 7, 2, 2016000, 119.08),
("flame", 7, 2, 2131200, 127.88),
("flame", 7, 2, 2227200, 129.85),
("flame", 7, 2, 2323200, 140.37),
("flame", 7, 2, 2419200, 151.22),
("flame", 7, 2, 2534400, 160.73),
("flame", 7, 2, 2649600, 175.5),
("flame", 7, 2, 2745600, 186.29),
("flame", 7, 2, 2841600, 223.89);

)_d3l1m1t3r_"
;

const char kAndroidPowerProfileDataMarlin[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INSERT OR REPLACE INTO power_profile VALUES
("marlin", 0, 0, 307200, 11.272),
("marlin", 0, 0, 384000, 14.842),
("marlin", 0, 0, 460800, 18.497),
("marlin", 0, 0, 537600, 22.518),
("marlin", 0, 0, 614400, 25.967),
("marlin", 0, 0, 691200, 31.694),
("marlin", 0, 0, 768000, 37.673),
("marlin", 0, 0, 844800, 42.859),
("marlin", 0, 0, 902600, 46.872),
("marlin", 0, 0, 979200, 57.92),
("marlin", 0, 0, 1056000, 67.561),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("marlin", 0, 0, 1132800, 76.303),
("marlin", 0, 0, 1209600, 87.613),
("marlin", 0, 0, 1286400, 97.045),
("marlin", 0, 0, 1363200, 109.544),
("marlin", 0, 0, 1440000, 122.054),
("marlin", 0, 0, 1516800, 136.345),
("marlin", 0, 0, 1593600, 154.435),
("marlin", 1, 0, 307200, 11.272),
("marlin", 1, 0, 384000, 14.842),
("marlin", 1, 0, 460800, 18.497),
("marlin", 1, 0, 537600, 22.518),
("marlin", 1, 0, 614400, 25.967),
("marlin", 1, 0, 691200, 31.694),
("marlin", 1, 0, 768000, 37.673),
("marlin", 1, 0, 844800, 42.859),
("marlin", 1, 0, 902600, 46.872),
("marlin", 1, 0, 979200, 57.92),
("marlin", 1, 0, 1056000, 67.561),
("marlin", 1, 0, 1132800, 76.303),
("marlin", 1, 0, 1209600, 87.613),
("marlin", 1, 0, 1286400, 97.045),
("marlin", 1, 0, 1363200, 109.544),
("marlin", 1, 0, 1440000, 122.054),
("marlin", 1, 0, 1516800, 136.345),
("marlin", 1, 0, 1593600, 154.435),
("marlin", 2, 1, 307200, 7.055),
("marlin", 2, 1, 384000, 11.483),
("marlin", 2, 1, 460800, 14.979),
("marlin", 2, 1, 537600, 19.642),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("marlin", 2, 1, 614400, 23.167),
("marlin", 2, 1, 691200, 27.479),
("marlin", 2, 1, 748800, 31.632),
("marlin", 2, 1, 825600, 39.192),
("marlin", 2, 1, 902400, 47.817),
("marlin", 2, 1, 979200, 55.659),
("marlin", 2, 1, 1056000, 64.908),
("marlin", 2, 1, 1132800, 73.824),
("marlin", 2, 1, 1209600, 85.299),
("marlin", 2, 1, 1286400, 96.036),
("marlin", 2, 1, 1363200, 109.233),
("marlin", 2, 1, 1440000, 118.56),
("marlin", 2, 1, 1516800, 132.959),
("marlin", 2, 1, 1593600, 143.692),
("marlin", 2, 1, 1670400, 161.378),
("marlin", 2, 1, 1747200, 180.616),
("marlin", 2, 1, 1824000, 193.897),
("marlin", 2, 1, 1900800, 214.361),
("marlin", 2, 1, 1977600, 238.338),
("marlin", 2, 1, 2054400, 265.759),
("marlin", 2, 1, 2150400, 297.918),
("marlin", 3, 1, 307200, 7.055),
("marlin", 3, 1, 384000, 11.483),
("marlin", 3, 1, 460800, 14.979),
("marlin", 3, 1, 537600, 19.642),
("marlin", 3, 1, 614400, 23.167),
("marlin", 3, 1, 691200, 27.479),
("marlin", 3, 1, 748800, 31.632),
("marlin", 3, 1, 825600, 39.192),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("marlin", 3, 1, 902400, 47.817),
("marlin", 3, 1, 979200, 55.659),
("marlin", 3, 1, 1056000, 64.908),
("marlin", 3, 1, 1132800, 73.824),
("marlin", 3, 1, 1209600, 85.299),
("marlin", 3, 1, 1286400, 96.036),
("marlin", 3, 1, 1363200, 109.233),
("marlin", 3, 1, 1440000, 118.56),
("marlin", 3, 1, 1516800, 132.959),
("marlin", 3, 1, 1593600, 143.692),
("marlin", 3, 1, 1670400, 161.378),
("marlin", 3, 1, 1747200, 180.616),
("marlin", 3, 1, 1824000, 193.897),
("marlin", 3, 1, 1900800, 214.361),
("marlin", 3, 1, 1977600, 238.338),
("marlin", 3, 1, 2054400, 265.759),
("marlin", 3, 1, 2150400, 297.918);

)_d3l1m1t3r_"
;

const char kAndroidPowerProfileDataOriole[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INSERT OR REPLACE INTO power_profile VALUES
("oriole", 0, 0, 300000, 1.89),
("oriole", 0, 0, 574000, 6.15),
("oriole", 0, 0, 738000, 9.34),
("oriole", 0, 0, 930000, 14.22),
("oriole", 0, 0, 1098000, 18.94),
("oriole", 0, 0, 1197000, 21.98),
("oriole", 0, 0, 1328000, 26.83),
("oriole", 0, 0, 1401000, 30.17),
("oriole", 0, 0, 1598000, 41.55),
("oriole", 0, 0, 1704000, 48.36),
("oriole", 0, 0, 1803000, 58.45),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("oriole", 1, 0, 300000, 1.89),
("oriole", 1, 0, 574000, 6.15),
("oriole", 1, 0, 738000, 9.34),
("oriole", 1, 0, 930000, 14.22),
("oriole", 1, 0, 1098000, 18.94),
("oriole", 1, 0, 1197000, 21.98),
("oriole", 1, 0, 1328000, 26.83),
("oriole", 1, 0, 1401000, 30.17),
("oriole", 1, 0, 1598000, 41.55),
("oriole", 1, 0, 1704000, 48.36),
("oriole", 1, 0, 1803000, 58.45),
("oriole", 2, 0, 300000, 1.89),
("oriole", 2, 0, 574000, 6.15),
("oriole", 2, 0, 738000, 9.34),
("oriole", 2, 0, 930000, 14.22),
("oriole", 2, 0, 1098000, 18.94),
("oriole", 2, 0, 1197000, 21.98),
("oriole", 2, 0, 1328000, 26.83),
("oriole", 2, 0, 1401000, 30.17),
("oriole", 2, 0, 1598000, 41.55),
("oriole", 2, 0, 1704000, 48.36),
("oriole", 2, 0, 1803000, 58.45),
("oriole", 3, 0, 300000, 1.89),
("oriole", 3, 0, 574000, 6.15),
("oriole", 3, 0, 738000, 9.34),
("oriole", 3, 0, 930000, 14.22),
("oriole", 3, 0, 1098000, 18.94),
("oriole", 3, 0, 1197000, 21.98),
("oriole", 3, 0, 1328000, 26.83),
("oriole", 3, 0, 1401000, 30.17),
("oriole", 3, 0, 1598000, 41.55),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("oriole", 3, 0, 1704000, 48.36),
("oriole", 3, 0, 1803000, 58.45),
("oriole", 4, 1, 400000, 3.71),
("oriole", 4, 1, 553000, 6.16),
("oriole", 4, 1, 696000, 8.0),
("oriole", 4, 1, 799000, 10.94),
("oriole", 4, 1, 910000, 12.73),
("oriole", 4, 1, 1024000, 14.4),
("oriole", 4, 1, 1197000, 21.39),
("oriole", 4, 1, 1328000, 24.1),
("oriole", 4, 1, 1491000, 30.42),
("oriole", 4, 1, 1663000, 42.49),
("oriole", 4, 1, 1836000, 49.37),
("oriole", 4, 1, 1999000, 58.09),
("oriole", 4, 1, 2130000, 67.54),
("oriole", 4, 1, 2253000, 79.04),
("oriole", 5, 1, 400000, 3.71),
("oriole", 5, 1, 553000, 6.16),
("oriole", 5, 1, 696000, 8.0),
("oriole", 5, 1, 799000, 10.94),
("oriole", 5, 1, 910000, 12.73),
("oriole", 5, 1, 1024000, 14.4),
("oriole", 5, 1, 1197000, 21.39),
("oriole", 5, 1, 1328000, 24.1),
("oriole", 5, 1, 1491000, 30.42),
("oriole", 5, 1, 1663000, 42.49),
("oriole", 5, 1, 1836000, 49.37),
("oriole", 5, 1, 1999000, 58.09),
("oriole", 5, 1, 2130000, 67.54),
("oriole", 5, 1, 2253000, 79.04),
("oriole", 6, 2, 500000, 8.36),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("oriole", 6, 2, 851000, 16.33),
("oriole", 6, 2, 984000, 19.44),
("oriole", 6, 2, 1106000, 36.71),
("oriole", 6, 2, 1277000, 41.42),
("oriole", 6, 2, 1426000, 48.24),
("oriole", 6, 2, 1582000, 54.77),
("oriole", 6, 2, 1745000, 65.32),
("oriole", 6, 2, 1826000, 69.58),
("oriole", 6, 2, 2048000, 128.49),
("oriole", 6, 2, 2188000, 142.15),
("oriole", 6, 2, 2252000, 149.74),
("oriole", 6, 2, 2401000, 164.78),
("oriole", 6, 2, 2507000, 188.68),
("oriole", 6, 2, 2630000, 193.15),
("oriole", 6, 2, 2704000, 227.98),
("oriole", 6, 2, 2802000, 254.25),
("oriole", 7, 2, 500000, 8.36),
("oriole", 7, 2, 851000, 16.33),
("oriole", 7, 2, 984000, 19.44),
("oriole", 7, 2, 1106000, 36.71),
("oriole", 7, 2, 1277000, 41.42),
("oriole", 7, 2, 1426000, 48.24),
("oriole", 7, 2, 1582000, 54.77),
("oriole", 7, 2, 1745000, 65.32),
("oriole", 7, 2, 1826000, 69.58),
("oriole", 7, 2, 2048000, 128.49),
("oriole", 7, 2, 2188000, 142.15),
("oriole", 7, 2, 2252000, 149.74),
("oriole", 7, 2, 2401000, 164.78),
("oriole", 7, 2, 2507000, 188.68),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("oriole", 7, 2, 2630000, 193.15),
("oriole", 7, 2, 2704000, 227.98),
("oriole", 7, 2, 2802000, 254.25);

)_d3l1m1t3r_"
;

const char kAndroidPowerProfileDataRaven[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INSERT OR REPLACE INTO power_profile VALUES
("raven", 0, 0, 300000, 1.89),
("raven", 0, 0, 574000, 6.15),
("raven", 0, 0, 738000, 9.34),
("raven", 0, 0, 930000, 14.22),
("raven", 0, 0, 1098000, 18.94),
("raven", 0, 0, 1197000, 21.98),
("raven", 0, 0, 1328000, 26.83),
("raven", 0, 0, 1401000, 30.17),
("raven", 0, 0, 1598000, 41.55),
("raven", 0, 0, 1704000, 48.36),
("raven", 0, 0, 1803000, 58.45),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("raven", 1, 0, 300000, 1.89),
("raven", 1, 0, 574000, 6.15),
("raven", 1, 0, 738000, 9.34),
("raven", 1, 0, 930000, 14.22),
("raven", 1, 0, 1098000, 18.94),
("raven", 1, 0, 1197000, 21.98),
("raven", 1, 0, 1328000, 26.83),
("raven", 1, 0, 1401000, 30.17),
("raven", 1, 0, 1598000, 41.55),
("raven", 1, 0, 1704000, 48.36),
("raven", 1, 0, 1803000, 58.45),
("raven", 2, 0, 300000, 1.89),
("raven", 2, 0, 574000, 6.15),
("raven", 2, 0, 738000, 9.34),
("raven", 2, 0, 930000, 14.22),
("raven", 2, 0, 1098000, 18.94),
("raven", 2, 0, 1197000, 21.98),
("raven", 2, 0, 1328000, 26.83),
("raven", 2, 0, 1401000, 30.17),
("raven", 2, 0, 1598000, 41.55),
("raven", 2, 0, 1704000, 48.36),
("raven", 2, 0, 1803000, 58.45),
("raven", 3, 0, 300000, 1.89),
("raven", 3, 0, 574000, 6.15),
("raven", 3, 0, 738000, 9.34),
("raven", 3, 0, 930000, 14.22),
("raven", 3, 0, 1098000, 18.94),
("raven", 3, 0, 1197000, 21.98),
("raven", 3, 0, 1328000, 26.83),
("raven", 3, 0, 1401000, 30.17),
("raven", 3, 0, 1598000, 41.55),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("raven", 3, 0, 1704000, 48.36),
("raven", 3, 0, 1803000, 58.45),
("raven", 4, 1, 400000, 3.71),
("raven", 4, 1, 553000, 6.16),
("raven", 4, 1, 696000, 8.0),
("raven", 4, 1, 799000, 10.94),
("raven", 4, 1, 910000, 12.73),
("raven", 4, 1, 1024000, 14.4),
("raven", 4, 1, 1197000, 21.39),
("raven", 4, 1, 1328000, 24.1),
("raven", 4, 1, 1491000, 30.42),
("raven", 4, 1, 1663000, 42.49),
("raven", 4, 1, 1836000, 49.37),
("raven", 4, 1, 1999000, 58.09),
("raven", 4, 1, 2130000, 67.54),
("raven", 4, 1, 2253000, 79.04),
("raven", 5, 1, 400000, 3.71),
("raven", 5, 1, 553000, 6.16),
("raven", 5, 1, 696000, 8.0),
("raven", 5, 1, 799000, 10.94),
("raven", 5, 1, 910000, 12.73),
("raven", 5, 1, 1024000, 14.4),
("raven", 5, 1, 1197000, 21.39),
("raven", 5, 1, 1328000, 24.1),
("raven", 5, 1, 1491000, 30.42),
("raven", 5, 1, 1663000, 42.49),
("raven", 5, 1, 1836000, 49.37),
("raven", 5, 1, 1999000, 58.09),
("raven", 5, 1, 2130000, 67.54),
("raven", 5, 1, 2253000, 79.04),
("raven", 6, 2, 500000, 8.36),
("raven", 6, 2, 851000, 16.33),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("raven", 6, 2, 984000, 19.44),
("raven", 6, 2, 1106000, 36.71),
("raven", 6, 2, 1277000, 41.42),
("raven", 6, 2, 1426000, 48.24),
("raven", 6, 2, 1582000, 54.77),
("raven", 6, 2, 1745000, 65.32),
("raven", 6, 2, 1826000, 69.58),
("raven", 6, 2, 2048000, 128.49),
("raven", 6, 2, 2188000, 142.15),
("raven", 6, 2, 2252000, 149.74),
("raven", 6, 2, 2401000, 164.78),
("raven", 6, 2, 2507000, 188.68),
("raven", 6, 2, 2630000, 193.15),
("raven", 6, 2, 2704000, 227.98),
("raven", 6, 2, 2802000, 254.25),
("raven", 7, 2, 500000, 8.36),
("raven", 7, 2, 851000, 16.33),
("raven", 7, 2, 984000, 19.44),
("raven", 7, 2, 1106000, 36.71),
("raven", 7, 2, 1277000, 41.42),
("raven", 7, 2, 1426000, 48.24),
("raven", 7, 2, 1582000, 54.77),
("raven", 7, 2, 1745000, 65.32),
("raven", 7, 2, 1826000, 69.58),
("raven", 7, 2, 2048000, 128.49),
("raven", 7, 2, 2188000, 142.15),
("raven", 7, 2, 2252000, 149.74),
("raven", 7, 2, 2401000, 164.78),
("raven", 7, 2, 2507000, 188.68),
("raven", 7, 2, 2630000, 193.15),
("raven", 7, 2, 2704000, 227.98),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("raven", 7, 2, 2802000, 254.25);

)_d3l1m1t3r_"
;

const char kAndroidPowerProfileDataRedfin[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INSERT OR REPLACE INTO power_profile VALUES
("redfin", 0, 0, 300000, 41.92),
("redfin", 0, 0, 576000, 59.59),
("redfin", 0, 0, 614400, 61.93),
("redfin", 0, 0, 864000, 79.86),
("redfin", 0, 0, 1075200, 95.92),
("redfin", 0, 0, 1363200, 121.97),
("redfin", 0, 0, 1516800, 140.72),
("redfin", 0, 0, 1651200, 159.18),
("redfin", 0, 0, 1804800, 176.19),
("redfin", 1, 0, 300000, 41.92),
("redfin", 1, 0, 576000, 59.59),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("redfin", 1, 0, 614400, 61.93),
("redfin", 1, 0, 864000, 79.86),
("redfin", 1, 0, 1075200, 95.92),
("redfin", 1, 0, 1363200, 121.97),
("redfin", 1, 0, 1516800, 140.72),
("redfin", 1, 0, 1651200, 159.18),
("redfin", 1, 0, 1804800, 176.19),
("redfin", 2, 0, 300000, 41.92),
("redfin", 2, 0, 576000, 59.59),
("redfin", 2, 0, 614400, 61.93),
("redfin", 2, 0, 864000, 79.86),
("redfin", 2, 0, 1075200, 95.92),
("redfin", 2, 0, 1363200, 121.97),
("redfin", 2, 0, 1516800, 140.72),
("redfin", 2, 0, 1651200, 159.18),
("redfin", 2, 0, 1804800, 176.19),
("redfin", 3, 0, 300000, 41.92),
("redfin", 3, 0, 576000, 59.59),
("redfin", 3, 0, 614400, 61.93),
("redfin", 3, 0, 864000, 79.86),
("redfin", 3, 0, 1075200, 95.92),
("redfin", 3, 0, 1363200, 121.97),
("redfin", 3, 0, 1516800, 140.72),
("redfin", 3, 0, 1651200, 159.18),
("redfin", 3, 0, 1804800, 176.19),
("redfin", 4, 0, 300000, 41.92),
("redfin", 4, 0, 576000, 59.59),
("redfin", 4, 0, 614400, 61.93),
("redfin", 4, 0, 864000, 79.86),
("redfin", 4, 0, 1075200, 95.92),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("redfin", 4, 0, 1363200, 121.97),
("redfin", 4, 0, 1516800, 140.72),
("redfin", 4, 0, 1651200, 159.18),
("redfin", 4, 0, 1804800, 176.19),
("redfin", 5, 0, 300000, 41.92),
("redfin", 5, 0, 576000, 59.59),
("redfin", 5, 0, 614400, 61.93),
("redfin", 5, 0, 864000, 79.86),
("redfin", 5, 0, 1075200, 95.92),
("redfin", 5, 0, 1363200, 121.97),
("redfin", 5, 0, 1516800, 140.72),
("redfin", 5, 0, 1651200, 159.18),
("redfin", 5, 0, 1804800, 176.19),
("redfin", 6, 1, 652800, 32.13),
("redfin", 6, 1, 940800, 35.98),
("redfin", 6, 1, 1152000, 40.03),
("redfin", 6, 1, 1478400, 51.02),
("redfin", 6, 1, 1728000, 77.06),
("redfin", 6, 1, 1900800, 86.25),
("redfin", 6, 1, 2092800, 97.3),
("redfin", 6, 1, 2208000, 101.61),
("redfin", 7, 2, 806400, 56.44),
("redfin", 7, 2, 1094400, 65.72),
("redfin", 7, 2, 1401600, 77.01),
("redfin", 7, 2, 1766400, 104.91),
("redfin", 7, 2, 1996800, 112.35),
("redfin", 7, 2, 2188800, 118.53),
("redfin", 7, 2, 2304000, 122.34),
("redfin", 7, 2, 2400000, 135.0);

)_d3l1m1t3r_"
;

const char kAndroidPowerProfileDataSargo[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INSERT OR REPLACE INTO power_profile VALUES
("sargo", 0, 0, 300000, 15.2466666667),
("sargo", 0, 0, 576000, 18.2166666667),
("sargo", 0, 0, 748800, 20.1866666667),
("sargo", 0, 0, 998400, 23.29),
("sargo", 0, 0, 1209600, 25.0116666667),
("sargo", 0, 0, 1324800, 28.485),
("sargo", 0, 0, 1516800, 31.6866666667),
("sargo", 0, 0, 1708800, 35.79),
("sargo", 1, 0, 300000, 15.2466666667),
("sargo", 1, 0, 576000, 18.2166666667),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("sargo", 1, 0, 748800, 20.1866666667),
("sargo", 1, 0, 998400, 23.29),
("sargo", 1, 0, 1209600, 25.0116666667),
("sargo", 1, 0, 1324800, 28.485),
("sargo", 1, 0, 1516800, 31.6866666667),
("sargo", 1, 0, 1708800, 35.79),
("sargo", 2, 0, 300000, 15.2466666667),
("sargo", 2, 0, 576000, 18.2166666667),
("sargo", 2, 0, 748800, 20.1866666667),
("sargo", 2, 0, 998400, 23.29),
("sargo", 2, 0, 1209600, 25.0116666667),
("sargo", 2, 0, 1324800, 28.485),
("sargo", 2, 0, 1516800, 31.6866666667),
("sargo", 2, 0, 1708800, 35.79),
("sargo", 3, 0, 300000, 15.2466666667),
("sargo", 3, 0, 576000, 18.2166666667),
("sargo", 3, 0, 748800, 20.1866666667),
("sargo", 3, 0, 998400, 23.29),
("sargo", 3, 0, 1209600, 25.0116666667),
("sargo", 3, 0, 1324800, 28.485),
("sargo", 3, 0, 1516800, 31.6866666667),
("sargo", 3, 0, 1708800, 35.79),
("sargo", 4, 0, 300000, 15.2466666667),
("sargo", 4, 0, 576000, 18.2166666667),
("sargo", 4, 0, 748800, 20.1866666667),
("sargo", 4, 0, 998400, 23.29),
("sargo", 4, 0, 1209600, 25.0116666667),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("sargo", 4, 0, 1324800, 28.485),
("sargo", 4, 0, 1516800, 31.6866666667),
("sargo", 4, 0, 1708800, 35.79),
("sargo", 5, 0, 300000, 15.2466666667),
("sargo", 5, 0, 576000, 18.2166666667),
("sargo", 5, 0, 748800, 20.1866666667),
("sargo", 5, 0, 998400, 23.29),
("sargo", 5, 0, 1209600, 25.0116666667),
("sargo", 5, 0, 1324800, 28.485),
("sargo", 5, 0, 1516800, 31.6866666667),
("sargo", 5, 0, 1708800, 35.79),
("sargo", 6, 1, 300000, 24.06),
("sargo", 6, 1, 652800, 27.56),
("sargo", 6, 1, 825600, 29.0),
("sargo", 6, 1, 979200, 31.675),
("sargo", 6, 1, 1132800, 34.53),
("sargo", 6, 1, 1363200, 38.885),
("sargo", 6, 1, 1536000, 43.075),
("sargo", 6, 1, 1747200, 48.705),
("sargo", 6, 1, 1843200, 64.57),
("sargo", 6, 1, 1996800, 69.805),
("sargo", 6, 1, 2016000, 76.545),
("sargo", 7, 1, 300000, 24.06),
("sargo", 7, 1, 652800, 27.56),
("sargo", 7, 1, 825600, 29.0),
("sargo", 7, 1, 979200, 31.675),
("sargo", 7, 1, 1132800, 34.53),
("sargo", 7, 1, 1363200, 38.885),
("sargo", 7, 1, 1536000, 43.075),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("sargo", 7, 1, 1747200, 48.705),
("sargo", 7, 1, 1843200, 64.57),
("sargo", 7, 1, 1996800, 69.805),
("sargo", 7, 1, 2016000, 76.545);

)_d3l1m1t3r_"
;

const char kAndroidPowerProfileDataShusky[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INSERT OR REPLACE INTO power_profile VALUES
("shiba", 0, 0, 324000, 1.89),
("shiba", 0, 0, 615000, 6.15),
("shiba", 0, 0, 820000, 9.34),
("shiba", 0, 0, 975000, 14.22),
("shiba", 0, 0, 1098000, 18.94),
("shiba", 0, 0, 1197000, 21.98),
("shiba", 0, 0, 1328000, 26.83),
("shiba", 0, 0, 1475000, 30.17),
("shiba", 0, 0, 1548000, 41.55),
("shiba", 0, 0, 1704000, 48.36),
("shiba", 0, 0, 1844000, 58.45),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("shiba", 0, 0, 1950000, 68.0),
("shiba", 0, 0, 2024000, 78.0),
("shiba", 0, 0, 2098000, 88.0),
("shiba", 0, 0, 2147000, 98.0),
("shiba", 1, 0, 324000, 1.89),
("shiba", 1, 0, 615000, 6.15),
("shiba", 1, 0, 820000, 9.34),
("shiba", 1, 0, 975000, 14.22),
("shiba", 1, 0, 1098000, 18.94),
("shiba", 1, 0, 1197000, 21.98),
("shiba", 1, 0, 1328000, 26.83),
("shiba", 1, 0, 1475000, 30.17),
("shiba", 1, 0, 1548000, 41.55),
("shiba", 1, 0, 1704000, 48.36),
("shiba", 1, 0, 1844000, 58.45),
("shiba", 1, 0, 1950000, 68.0),
("shiba", 1, 0, 2024000, 78.0),
("shiba", 1, 0, 2098000, 88.0),
("shiba", 1, 0, 2147000, 98.0),
("shiba", 2, 0, 324000, 1.89),
("shiba", 2, 0, 615000, 6.15),
("shiba", 2, 0, 820000, 9.34),
("shiba", 2, 0, 975000, 14.22),
("shiba", 2, 0, 1098000, 18.94),
("shiba", 2, 0, 1197000, 21.98),
("shiba", 2, 0, 1328000, 26.83),
("shiba", 2, 0, 1475000, 30.17),
("shiba", 2, 0, 1548000, 41.55),
("shiba", 2, 0, 1704000, 48.36),
("shiba", 2, 0, 1844000, 58.45),
("shiba", 2, 0, 1950000, 68.0),
("shiba", 2, 0, 2024000, 78.0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("shiba", 2, 0, 2098000, 88.0),
("shiba", 2, 0, 2147000, 98.0),
("shiba", 3, 0, 324000, 1.89),
("shiba", 3, 0, 615000, 6.15),
("shiba", 3, 0, 820000, 9.34),
("shiba", 3, 0, 975000, 14.22),
("shiba", 3, 0, 1098000, 18.94),
("shiba", 3, 0, 1197000, 21.98),
("shiba", 3, 0, 1328000, 26.83),
("shiba", 3, 0, 1475000, 30.17),
("shiba", 3, 0, 1548000, 41.55),
("shiba", 3, 0, 1704000, 48.36),
("shiba", 3, 0, 1844000, 58.45),
("shiba", 3, 0, 1950000, 68.0),
("shiba", 3, 0, 2024000, 78.0),
("shiba", 3, 0, 2098000, 88.0),
("shiba", 3, 0, 2147000, 98.0),
("shiba", 4, 1, 402000, 3.71),
("shiba", 4, 1, 578000, 6.16),
("shiba", 4, 1, 697000, 8.0),
("shiba", 4, 1, 721000, 10.94),
("shiba", 4, 1, 910000, 12.73),
("shiba", 4, 1, 1082000, 14.4),
("shiba", 4, 1, 1221000, 21.39),
("shiba", 4, 1, 1328000, 24.1),
("shiba", 4, 1, 1418000, 30.42),
("shiba", 4, 1, 1549000, 42.49),
("shiba", 4, 1, 1622000, 49.37),
("shiba", 4, 1, 1836000, 58.09),
("shiba", 4, 1, 1999000, 67.54),
("shiba", 4, 1, 2130000, 79.04),
("shiba", 4, 1, 2245000, 92.0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("shiba", 4, 1, 2352000, 104.0),
("shiba", 4, 1, 2450000, 116.0),
("shiba", 5, 1, 402000, 3.71),
("shiba", 5, 1, 578000, 6.16),
("shiba", 5, 1, 697000, 8.0),
("shiba", 5, 1, 721000, 10.94),
("shiba", 5, 1, 910000, 12.73),
("shiba", 5, 1, 1082000, 14.4),
("shiba", 5, 1, 1221000, 21.39),
("shiba", 5, 1, 1328000, 24.1),
("shiba", 5, 1, 1418000, 30.42),
("shiba", 5, 1, 1549000, 42.49),
("shiba", 5, 1, 1622000, 49.37),
("shiba", 5, 1, 1836000, 58.09),
("shiba", 5, 1, 1999000, 67.54),
("shiba", 5, 1, 2130000, 79.04),
("shiba", 5, 1, 2245000, 92.0),
("shiba", 5, 1, 2352000, 104.0),
("shiba", 5, 1, 2450000, 116.0),
("shiba", 6, 1, 402000, 3.71),
("shiba", 6, 1, 578000, 6.16),
("shiba", 6, 1, 697000, 8.0),
("shiba", 6, 1, 721000, 10.94),
("shiba", 6, 1, 910000, 12.73),
("shiba", 6, 1, 1082000, 14.4),
("shiba", 6, 1, 1221000, 21.39),
("shiba", 6, 1, 1328000, 24.1),
("shiba", 6, 1, 1418000, 30.42),
("shiba", 6, 1, 1549000, 42.49),
("shiba", 6, 1, 1622000, 49.37),
("shiba", 6, 1, 1836000, 58.09),
("shiba", 6, 1, 1999000, 67.54),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("shiba", 6, 1, 2130000, 79.04),
("shiba", 6, 1, 2245000, 92.0),
("shiba", 6, 1, 2352000, 104.0),
("shiba", 6, 1, 2450000, 116.0),
("shiba", 7, 1, 402000, 3.71),
("shiba", 7, 1, 578000, 6.16),
("shiba", 7, 1, 697000, 8.0),
("shiba", 7, 1, 721000, 10.94),
("shiba", 7, 1, 910000, 12.73),
("shiba", 7, 1, 1082000, 14.4),
("shiba", 7, 1, 1221000, 21.39),
("shiba", 7, 1, 1328000, 24.1),
("shiba", 7, 1, 1418000, 30.42),
("shiba", 7, 1, 1549000, 42.49),
("shiba", 7, 1, 1622000, 49.37),
("shiba", 7, 1, 1836000, 58.09),
("shiba", 7, 1, 1999000, 67.54),
("shiba", 7, 1, 2130000, 79.04),
("shiba", 7, 1, 2245000, 92.0),
("shiba", 7, 1, 2352000, 104.0),
("shiba", 7, 1, 2450000, 116.0),
("shiba", 8, 2, 500000, 8.36),
("shiba", 8, 2, 893000, 16.33),
("shiba", 8, 2, 1164000, 19.44),
("shiba", 8, 2, 1328000, 36.71),
("shiba", 8, 2, 1557000, 41.42),
("shiba", 8, 2, 1745000, 48.24),
("shiba", 8, 2, 1852000, 54.77),
("shiba", 8, 2, 1901000, 65.32),
("shiba", 8, 2, 2049000, 69.58),
("shiba", 8, 2, 2147000, 128.49),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("shiba", 8, 2, 2294000, 142.15),
("shiba", 8, 2, 2409000, 149.74),
("shiba", 8, 2, 2556000, 164.78),
("shiba", 8, 2, 2687000, 188.68),
("shiba", 8, 2, 2802000, 193.15),
("shiba", 8, 2, 2914000, 227.98),
("shiba", 8, 2, 3015000, 254.25),
("husky", 0, 0, 324000, 1.89),
("husky", 0, 0, 615000, 6.15),
("husky", 0, 0, 820000, 9.34),
("husky", 0, 0, 975000, 14.22),
("husky", 0, 0, 1098000, 18.94),
("husky", 0, 0, 1197000, 21.98),
("husky", 0, 0, 1328000, 26.83),
("husky", 0, 0, 1475000, 30.17),
("husky", 0, 0, 1548000, 41.55),
("husky", 0, 0, 1704000, 48.36),
("husky", 0, 0, 1844000, 58.45),
("husky", 0, 0, 1950000, 68.0),
("husky", 0, 0, 2024000, 78.0),
("husky", 0, 0, 2098000, 88.0),
("husky", 0, 0, 2147000, 98.0),
("husky", 1, 0, 324000, 1.89),
("husky", 1, 0, 615000, 6.15),
("husky", 1, 0, 820000, 9.34),
("husky", 1, 0, 975000, 14.22),
("husky", 1, 0, 1098000, 18.94),
("husky", 1, 0, 1197000, 21.98),
("husky", 1, 0, 1328000, 26.83),
("husky", 1, 0, 1475000, 30.17),
("husky", 1, 0, 1548000, 41.55),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("husky", 1, 0, 1704000, 48.36),
("husky", 1, 0, 1844000, 58.45),
("husky", 1, 0, 1950000, 68.0),
("husky", 1, 0, 2024000, 78.0),
("husky", 1, 0, 2098000, 88.0),
("husky", 1, 0, 2147000, 98.0),
("husky", 2, 0, 324000, 1.89),
("husky", 2, 0, 615000, 6.15),
("husky", 2, 0, 820000, 9.34),
("husky", 2, 0, 975000, 14.22),
("husky", 2, 0, 1098000, 18.94),
("husky", 2, 0, 1197000, 21.98),
("husky", 2, 0, 1328000, 26.83),
("husky", 2, 0, 1475000, 30.17),
("husky", 2, 0, 1548000, 41.55),
("husky", 2, 0, 1704000, 48.36),
("husky", 2, 0, 1844000, 58.45),
("husky", 2, 0, 1950000, 68.0),
("husky", 2, 0, 2024000, 78.0),
("husky", 2, 0, 2098000, 88.0),
("husky", 2, 0, 2147000, 98.0),
("husky", 3, 0, 324000, 1.89),
("husky", 3, 0, 615000, 6.15),
("husky", 3, 0, 820000, 9.34),
("husky", 3, 0, 975000, 14.22),
("husky", 3, 0, 1098000, 18.94),
("husky", 3, 0, 1197000, 21.98),
("husky", 3, 0, 1328000, 26.83),
("husky", 3, 0, 1475000, 30.17),
("husky", 3, 0, 1548000, 41.55),
("husky", 3, 0, 1704000, 48.36),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("husky", 3, 0, 1844000, 58.45),
("husky", 3, 0, 1950000, 68.0),
("husky", 3, 0, 2024000, 78.0),
("husky", 3, 0, 2098000, 88.0),
("husky", 3, 0, 2147000, 98.0),
("husky", 4, 1, 402000, 3.71),
("husky", 4, 1, 578000, 6.16),
("husky", 4, 1, 697000, 8.0),
("husky", 4, 1, 721000, 10.94),
("husky", 4, 1, 910000, 12.73),
("husky", 4, 1, 1082000, 14.4),
("husky", 4, 1, 1221000, 21.39),
("husky", 4, 1, 1328000, 24.1),
("husky", 4, 1, 1418000, 30.42),
("husky", 4, 1, 1549000, 42.49),
("husky", 4, 1, 1622000, 49.37),
("husky", 4, 1, 1836000, 58.09),
("husky", 4, 1, 1999000, 67.54),
("husky", 4, 1, 2130000, 79.04),
("husky", 4, 1, 2245000, 92.0),
("husky", 4, 1, 2352000, 104.0),
("husky", 4, 1, 2450000, 116.0),
("husky", 5, 1, 402000, 3.71),
("husky", 5, 1, 578000, 6.16),
("husky", 5, 1, 697000, 8.0),
("husky", 5, 1, 721000, 10.94),
("husky", 5, 1, 910000, 12.73),
("husky", 5, 1, 1082000, 14.4),
("husky", 5, 1, 1221000, 21.39),
("husky", 5, 1, 1328000, 24.1),
("husky", 5, 1, 1418000, 30.42),
("husky", 5, 1, 1549000, 42.49),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("husky", 5, 1, 1622000, 49.37),
("husky", 5, 1, 1836000, 58.09),
("husky", 5, 1, 1999000, 67.54),
("husky", 5, 1, 2130000, 79.04),
("husky", 5, 1, 2245000, 92.0),
("husky", 5, 1, 2352000, 104.0),
("husky", 5, 1, 2450000, 116.0),
("husky", 6, 1, 402000, 3.71),
("husky", 6, 1, 578000, 6.16),
("husky", 6, 1, 697000, 8.0),
("husky", 6, 1, 721000, 10.94),
("husky", 6, 1, 910000, 12.73),
("husky", 6, 1, 1082000, 14.4),
("husky", 6, 1, 1221000, 21.39),
("husky", 6, 1, 1328000, 24.1),
("husky", 6, 1, 1418000, 30.42),
("husky", 6, 1, 1549000, 42.49),
("husky", 6, 1, 1622000, 49.37),
("husky", 6, 1, 1836000, 58.09),
("husky", 6, 1, 1999000, 67.54),
("husky", 6, 1, 2130000, 79.04),
("husky", 6, 1, 2245000, 92.0),
("husky", 6, 1, 2352000, 104.0),
("husky", 6, 1, 2450000, 116.0),
("husky", 7, 1, 402000, 3.71),
("husky", 7, 1, 578000, 6.16),
("husky", 7, 1, 697000, 8.0),
("husky", 7, 1, 721000, 10.94),
("husky", 7, 1, 910000, 12.73),
("husky", 7, 1, 1082000, 14.4),
("husky", 7, 1, 1221000, 21.39),
("husky", 7, 1, 1328000, 24.1),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("husky", 7, 1, 1418000, 30.42),
("husky", 7, 1, 1549000, 42.49),
("husky", 7, 1, 1622000, 49.37),
("husky", 7, 1, 1836000, 58.09),
("husky", 7, 1, 1999000, 67.54),
("husky", 7, 1, 2130000, 79.04),
("husky", 7, 1, 2245000, 92.0),
("husky", 7, 1, 2352000, 104.0),
("husky", 7, 1, 2450000, 116.0),
("husky", 8, 2, 500000, 8.36),
("husky", 8, 2, 893000, 16.33),
("husky", 8, 2, 1164000, 19.44),
("husky", 8, 2, 1328000, 36.71),
("husky", 8, 2, 1557000, 41.42),
("husky", 8, 2, 1745000, 48.24),
("husky", 8, 2, 1852000, 54.77),
("husky", 8, 2, 1901000, 65.32),
("husky", 8, 2, 2049000, 69.58),
("husky", 8, 2, 2147000, 128.49),
("husky", 8, 2, 2294000, 142.15),
("husky", 8, 2, 2409000, 149.74),
("husky", 8, 2, 2556000, 164.78),
("husky", 8, 2, 2687000, 188.68),
("husky", 8, 2, 2802000, 193.15),
("husky", 8, 2, 2914000, 227.98),
("husky", 8, 2, 3015000, 254.25);
)_d3l1m1t3r_"
;

const char kAndroidPowerProfileDataSunfish[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INSERT OR REPLACE INTO power_profile VALUES
("sunfish", 0, 0, 300000, 5.75833333333),
("sunfish", 0, 0, 576000, 7.76166666667),
("sunfish", 0, 0, 768000, 9.14),
("sunfish", 0, 0, 1017600, 11.36),
("sunfish", 0, 0, 1248000, 13.45),
("sunfish", 0, 0, 1324800, 14.4333333333),
("sunfish", 0, 0, 1497600, 16.5216666667),
("sunfish", 0, 0, 1612800, 18.5083333333),
("sunfish", 0, 0, 1708800, 19.9316666667),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("sunfish", 0, 0, 1804800, 21.4083333333),
("sunfish", 1, 0, 300000, 5.75833333333),
("sunfish", 1, 0, 576000, 7.76166666667),
("sunfish", 1, 0, 768000, 9.14),
("sunfish", 1, 0, 1017600, 11.36),
("sunfish", 1, 0, 1248000, 13.45),
("sunfish", 1, 0, 1324800, 14.4333333333),
("sunfish", 1, 0, 1497600, 16.5216666667),
("sunfish", 1, 0, 1612800, 18.5083333333),
("sunfish", 1, 0, 1708800, 19.9316666667),
("sunfish", 1, 0, 1804800, 21.4083333333),
("sunfish", 2, 0, 300000, 5.75833333333),
("sunfish", 2, 0, 576000, 7.76166666667),
("sunfish", 2, 0, 768000, 9.14),
("sunfish", 2, 0, 1017600, 11.36),
("sunfish", 2, 0, 1248000, 13.45),
("sunfish", 2, 0, 1324800, 14.4333333333),
("sunfish", 2, 0, 1497600, 16.5216666667),
("sunfish", 2, 0, 1612800, 18.5083333333),
("sunfish", 2, 0, 1708800, 19.9316666667),
("sunfish", 2, 0, 1804800, 21.4083333333),
("sunfish", 3, 0, 300000, 5.75833333333),
("sunfish", 3, 0, 576000, 7.76166666667),
("sunfish", 3, 0, 768000, 9.14),
("sunfish", 3, 0, 1017600, 11.36),
("sunfish", 3, 0, 1248000, 13.45),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("sunfish", 3, 0, 1324800, 14.4333333333),
("sunfish", 3, 0, 1497600, 16.5216666667),
("sunfish", 3, 0, 1612800, 18.5083333333),
("sunfish", 3, 0, 1708800, 19.9316666667),
("sunfish", 3, 0, 1804800, 21.4083333333),
("sunfish", 4, 0, 300000, 5.75833333333),
("sunfish", 4, 0, 576000, 7.76166666667),
("sunfish", 4, 0, 768000, 9.14),
("sunfish", 4, 0, 1017600, 11.36),
("sunfish", 4, 0, 1248000, 13.45),
("sunfish", 4, 0, 1324800, 14.4333333333),
("sunfish", 4, 0, 1497600, 16.5216666667),
("sunfish", 4, 0, 1612800, 18.5083333333),
("sunfish", 4, 0, 1708800, 19.9316666667),
("sunfish", 4, 0, 1804800, 21.4083333333),
("sunfish", 5, 0, 300000, 5.75833333333),
("sunfish", 5, 0, 576000, 7.76166666667),
("sunfish", 5, 0, 768000, 9.14),
("sunfish", 5, 0, 1017600, 11.36),
("sunfish", 5, 0, 1248000, 13.45),
("sunfish", 5, 0, 1324800, 14.4333333333),
("sunfish", 5, 0, 1497600, 16.5216666667),
("sunfish", 5, 0, 1612800, 18.5083333333),
("sunfish", 5, 0, 1708800, 19.9316666667),
("sunfish", 5, 0, 1804800, 21.4083333333),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("sunfish", 6, 1, 300000, 21.115),
("sunfish", 6, 1, 652800, 28.46),
("sunfish", 6, 1, 806400, 31.705),
("sunfish", 6, 1, 979200, 36.515),
("sunfish", 6, 1, 1094400, 40.19),
("sunfish", 6, 1, 1209600, 43.585),
("sunfish", 6, 1, 1324800, 48.275),
("sunfish", 6, 1, 1555200, 62.805),
("sunfish", 6, 1, 1708800, 72.755),
("sunfish", 6, 1, 1843200, 91.47),
("sunfish", 6, 1, 1939200, 99.46),
("sunfish", 6, 1, 2169600, 119.27),
("sunfish", 6, 1, 2208000, 133.105),
("sunfish", 7, 1, 300000, 21.115),
("sunfish", 7, 1, 652800, 28.46),
("sunfish", 7, 1, 806400, 31.705),
("sunfish", 7, 1, 979200, 36.515),
("sunfish", 7, 1, 1094400, 40.19),
("sunfish", 7, 1, 1209600, 43.585),
("sunfish", 7, 1, 1324800, 48.275),
("sunfish", 7, 1, 1555200, 62.805),
("sunfish", 7, 1, 1708800, 72.755),
("sunfish", 7, 1, 1843200, 91.47),
("sunfish", 7, 1, 1939200, 99.46),
("sunfish", 7, 1, 2169600, 119.27),
("sunfish", 7, 1, 2208000, 133.105);

)_d3l1m1t3r_"
;

const char kAndroidPowerProfileDataTaimen[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INSERT OR REPLACE INTO power_profile VALUES
("taimen", 0, 0, 300000, 3.685),
("taimen", 0, 0, 364800, 3.598),
("taimen", 0, 0, 441600, 3.621),
("taimen", 0, 0, 518400, 4.202),
("taimen", 0, 0, 595200, 4.935),
("taimen", 0, 0, 672000, 5.633),
("taimen", 0, 0, 748800, 6.216),
("taimen", 0, 0, 825600, 6.71),
("taimen", 0, 0, 883200, 7.557),
("taimen", 0, 0, 960000, 8.687),
("taimen", 0, 0, 1036800, 9.882),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("taimen", 0, 0, 1094400, 10.95),
("taimen", 0, 0, 1171200, 12.075),
("taimen", 0, 0, 1248000, 12.875),
("taimen", 0, 0, 1324800, 14.424),
("taimen", 0, 0, 1401600, 15.653),
("taimen", 0, 0, 1478400, 17.345),
("taimen", 0, 0, 1555200, 18.71),
("taimen", 0, 0, 1670400, 21.587),
("taimen", 0, 0, 1747200, 25.43),
("taimen", 0, 0, 1824000, 27.165),
("taimen", 0, 0, 1900800, 31.671),
("taimen", 1, 0, 300000, 3.685),
("taimen", 1, 0, 364800, 3.598),
("taimen", 1, 0, 441600, 3.621),
("taimen", 1, 0, 518400, 4.202),
("taimen", 1, 0, 595200, 4.935),
("taimen", 1, 0, 672000, 5.633),
("taimen", 1, 0, 748800, 6.216),
("taimen", 1, 0, 825600, 6.71),
("taimen", 1, 0, 883200, 7.557),
("taimen", 1, 0, 960000, 8.687),
("taimen", 1, 0, 1036800, 9.882),
("taimen", 1, 0, 1094400, 10.95),
("taimen", 1, 0, 1171200, 12.075),
("taimen", 1, 0, 1248000, 12.875),
("taimen", 1, 0, 1324800, 14.424),
("taimen", 1, 0, 1401600, 15.653),
("taimen", 1, 0, 1478400, 17.345),
("taimen", 1, 0, 1555200, 18.71),
("taimen", 1, 0, 1670400, 21.587),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("taimen", 1, 0, 1747200, 25.43),
("taimen", 1, 0, 1824000, 27.165),
("taimen", 1, 0, 1900800, 31.671),
("taimen", 2, 0, 300000, 3.685),
("taimen", 2, 0, 364800, 3.598),
("taimen", 2, 0, 441600, 3.621),
("taimen", 2, 0, 518400, 4.202),
("taimen", 2, 0, 595200, 4.935),
("taimen", 2, 0, 672000, 5.633),
("taimen", 2, 0, 748800, 6.216),
("taimen", 2, 0, 825600, 6.71),
("taimen", 2, 0, 883200, 7.557),
("taimen", 2, 0, 960000, 8.687),
("taimen", 2, 0, 1036800, 9.882),
("taimen", 2, 0, 1094400, 10.95),
("taimen", 2, 0, 1171200, 12.075),
("taimen", 2, 0, 1248000, 12.875),
("taimen", 2, 0, 1324800, 14.424),
("taimen", 2, 0, 1401600, 15.653),
("taimen", 2, 0, 1478400, 17.345),
("taimen", 2, 0, 1555200, 18.71),
("taimen", 2, 0, 1670400, 21.587),
("taimen", 2, 0, 1747200, 25.43),
("taimen", 2, 0, 1824000, 27.165),
("taimen", 2, 0, 1900800, 31.671),
("taimen", 3, 0, 300000, 3.685),
("taimen", 3, 0, 364800, 3.598),
("taimen", 3, 0, 441600, 3.621),
("taimen", 3, 0, 518400, 4.202),
("taimen", 3, 0, 595200, 4.935),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("taimen", 3, 0, 672000, 5.633),
("taimen", 3, 0, 748800, 6.216),
("taimen", 3, 0, 825600, 6.71),
("taimen", 3, 0, 883200, 7.557),
("taimen", 3, 0, 960000, 8.687),
("taimen", 3, 0, 1036800, 9.882),
("taimen", 3, 0, 1094400, 10.95),
("taimen", 3, 0, 1171200, 12.075),
("taimen", 3, 0, 1248000, 12.875),
("taimen", 3, 0, 1324800, 14.424),
("taimen", 3, 0, 1401600, 15.653),
("taimen", 3, 0, 1478400, 17.345),
("taimen", 3, 0, 1555200, 18.71),
("taimen", 3, 0, 1670400, 21.587),
("taimen", 3, 0, 1747200, 25.43),
("taimen", 3, 0, 1824000, 27.165),
("taimen", 3, 0, 1900800, 31.671),
("taimen", 4, 1, 300000, 10.722),
("taimen", 4, 1, 345600, 11.52),
("taimen", 4, 1, 422400, 14.105),
("taimen", 4, 1, 499200, 16.68),
("taimen", 4, 1, 576000, 18.946),
("taimen", 4, 1, 652800, 21.265),
("taimen", 4, 1, 729600, 23.432),
("taimen", 4, 1, 806400, 26.019),
("taimen", 4, 1, 902400, 28.856),
("taimen", 4, 1, 979200, 31.085),
("taimen", 4, 1, 1056000, 33.615),
("taimen", 4, 1, 1132800, 35.76),
("taimen", 4, 1, 1190400, 40.608),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("taimen", 4, 1, 1267200, 43.284),
("taimen", 4, 1, 1344000, 47.347),
("taimen", 4, 1, 1420800, 52.231),
("taimen", 4, 1, 1497600, 57.225),
("taimen", 4, 1, 1574400, 63.138),
("taimen", 4, 1, 1651200, 69.251),
("taimen", 4, 1, 1728000, 76.449),
("taimen", 4, 1, 1804800, 84.71),
("taimen", 4, 1, 1881600, 102.551),
("taimen", 4, 1, 1958400, 107.115),
("taimen", 4, 1, 2035200, 129.689),
("taimen", 4, 1, 2112000, 135.832),
("taimen", 4, 1, 2208000, 164.674),
("taimen", 4, 1, 2265600, 180.279),
("taimen", 4, 1, 2323200, 197.024),
("taimen", 4, 1, 2342400, 204.511),
("taimen", 4, 1, 2361600, 211.886),
("taimen", 4, 1, 2457600, 212.147),
("taimen", 5, 1, 300000, 10.722),
("taimen", 5, 1, 345600, 11.52),
("taimen", 5, 1, 422400, 14.105),
("taimen", 5, 1, 499200, 16.68),
("taimen", 5, 1, 576000, 18.946),
("taimen", 5, 1, 652800, 21.265),
("taimen", 5, 1, 729600, 23.432),
("taimen", 5, 1, 806400, 26.019),
("taimen", 5, 1, 902400, 28.856),
("taimen", 5, 1, 979200, 31.085),
("taimen", 5, 1, 1056000, 33.615),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("taimen", 5, 1, 1132800, 35.76),
("taimen", 5, 1, 1190400, 40.608),
("taimen", 5, 1, 1267200, 43.284),
("taimen", 5, 1, 1344000, 47.347),
("taimen", 5, 1, 1420800, 52.231),
("taimen", 5, 1, 1497600, 57.225),
("taimen", 5, 1, 1574400, 63.138),
("taimen", 5, 1, 1651200, 69.251),
("taimen", 5, 1, 1728000, 76.449),
("taimen", 5, 1, 1804800, 84.71),
("taimen", 5, 1, 1881600, 102.551),
("taimen", 5, 1, 1958400, 107.115),
("taimen", 5, 1, 2035200, 129.689),
("taimen", 5, 1, 2112000, 135.832),
("taimen", 5, 1, 2208000, 164.674),
("taimen", 5, 1, 2265600, 180.279),
("taimen", 5, 1, 2323200, 197.024),
("taimen", 5, 1, 2342400, 204.511),
("taimen", 5, 1, 2361600, 211.886),
("taimen", 5, 1, 2457600, 212.147),
("taimen", 6, 1, 300000, 10.722),
("taimen", 6, 1, 345600, 11.52),
("taimen", 6, 1, 422400, 14.105),
("taimen", 6, 1, 499200, 16.68),
("taimen", 6, 1, 576000, 18.946),
("taimen", 6, 1, 652800, 21.265),
("taimen", 6, 1, 729600, 23.432),
("taimen", 6, 1, 806400, 26.019),
("taimen", 6, 1, 902400, 28.856),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("taimen", 6, 1, 979200, 31.085),
("taimen", 6, 1, 1056000, 33.615),
("taimen", 6, 1, 1132800, 35.76),
("taimen", 6, 1, 1190400, 40.608),
("taimen", 6, 1, 1267200, 43.284),
("taimen", 6, 1, 1344000, 47.347),
("taimen", 6, 1, 1420800, 52.231),
("taimen", 6, 1, 1497600, 57.225),
("taimen", 6, 1, 1574400, 63.138),
("taimen", 6, 1, 1651200, 69.251),
("taimen", 6, 1, 1728000, 76.449),
("taimen", 6, 1, 1804800, 84.71),
("taimen", 6, 1, 1881600, 102.551),
("taimen", 6, 1, 1958400, 107.115),
("taimen", 6, 1, 2035200, 129.689),
("taimen", 6, 1, 2112000, 135.832),
("taimen", 6, 1, 2208000, 164.674),
("taimen", 6, 1, 2265600, 180.279),
("taimen", 6, 1, 2323200, 197.024),
("taimen", 6, 1, 2342400, 204.511),
("taimen", 6, 1, 2361600, 211.886),
("taimen", 6, 1, 2457600, 212.147),
("taimen", 7, 1, 300000, 10.722),
("taimen", 7, 1, 345600, 11.52),
("taimen", 7, 1, 422400, 14.105),
("taimen", 7, 1, 499200, 16.68),
("taimen", 7, 1, 576000, 18.946),
("taimen", 7, 1, 652800, 21.265),
("taimen", 7, 1, 729600, 23.432),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("taimen", 7, 1, 806400, 26.019),
("taimen", 7, 1, 902400, 28.856),
("taimen", 7, 1, 979200, 31.085),
("taimen", 7, 1, 1056000, 33.615),
("taimen", 7, 1, 1132800, 35.76),
("taimen", 7, 1, 1190400, 40.608),
("taimen", 7, 1, 1267200, 43.284),
("taimen", 7, 1, 1344000, 47.347),
("taimen", 7, 1, 1420800, 52.231),
("taimen", 7, 1, 1497600, 57.225),
("taimen", 7, 1, 1574400, 63.138),
("taimen", 7, 1, 1651200, 69.251),
("taimen", 7, 1, 1728000, 76.449),
("taimen", 7, 1, 1804800, 84.71),
("taimen", 7, 1, 1881600, 102.551),
("taimen", 7, 1, 1958400, 107.115),
("taimen", 7, 1, 2035200, 129.689),
("taimen", 7, 1, 2112000, 135.832),
("taimen", 7, 1, 2208000, 164.674),
("taimen", 7, 1, 2265600, 180.279),
("taimen", 7, 1, 2323200, 197.024),
("taimen", 7, 1, 2342400, 204.511),
("taimen", 7, 1, 2361600, 211.886),
("taimen", 7, 1, 2457600, 212.147);

)_d3l1m1t3r_"
;

const char kAndroidPowerProfileDataWalleye[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INSERT OR REPLACE INTO power_profile VALUES
("walleye", 0, 0, 300000, 3.685),
("walleye", 0, 0, 364800, 3.598),
("walleye", 0, 0, 441600, 3.621),
("walleye", 0, 0, 518400, 4.202),
("walleye", 0, 0, 595200, 4.935),
("walleye", 0, 0, 672000, 5.633),
("walleye", 0, 0, 748800, 6.216),
("walleye", 0, 0, 825600, 6.71),
("walleye", 0, 0, 883200, 7.557),
("walleye", 0, 0, 960000, 8.687),
("walleye", 0, 0, 1036800, 9.882),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("walleye", 0, 0, 1094400, 10.95),
("walleye", 0, 0, 1171200, 12.075),
("walleye", 0, 0, 1248000, 12.875),
("walleye", 0, 0, 1324800, 14.424),
("walleye", 0, 0, 1401600, 15.653),
("walleye", 0, 0, 1478400, 17.345),
("walleye", 0, 0, 1555200, 18.71),
("walleye", 0, 0, 1670400, 21.587),
("walleye", 0, 0, 1747200, 25.43),
("walleye", 0, 0, 1824000, 27.165),
("walleye", 0, 0, 1900800, 31.671),
("walleye", 1, 0, 300000, 3.685),
("walleye", 1, 0, 364800, 3.598),
("walleye", 1, 0, 441600, 3.621),
("walleye", 1, 0, 518400, 4.202),
("walleye", 1, 0, 595200, 4.935),
("walleye", 1, 0, 672000, 5.633),
("walleye", 1, 0, 748800, 6.216),
("walleye", 1, 0, 825600, 6.71),
("walleye", 1, 0, 883200, 7.557),
("walleye", 1, 0, 960000, 8.687),
("walleye", 1, 0, 1036800, 9.882),
("walleye", 1, 0, 1094400, 10.95),
("walleye", 1, 0, 1171200, 12.075),
("walleye", 1, 0, 1248000, 12.875),
("walleye", 1, 0, 1324800, 14.424),
("walleye", 1, 0, 1401600, 15.653),
("walleye", 1, 0, 1478400, 17.345),
("walleye", 1, 0, 1555200, 18.71),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("walleye", 1, 0, 1670400, 21.587),
("walleye", 1, 0, 1747200, 25.43),
("walleye", 1, 0, 1824000, 27.165),
("walleye", 1, 0, 1900800, 31.671),
("walleye", 2, 0, 300000, 3.685),
("walleye", 2, 0, 364800, 3.598),
("walleye", 2, 0, 441600, 3.621),
("walleye", 2, 0, 518400, 4.202),
("walleye", 2, 0, 595200, 4.935),
("walleye", 2, 0, 672000, 5.633),
("walleye", 2, 0, 748800, 6.216),
("walleye", 2, 0, 825600, 6.71),
("walleye", 2, 0, 883200, 7.557),
("walleye", 2, 0, 960000, 8.687),
("walleye", 2, 0, 1036800, 9.882),
("walleye", 2, 0, 1094400, 10.95),
("walleye", 2, 0, 1171200, 12.075),
("walleye", 2, 0, 1248000, 12.875),
("walleye", 2, 0, 1324800, 14.424),
("walleye", 2, 0, 1401600, 15.653),
("walleye", 2, 0, 1478400, 17.345),
("walleye", 2, 0, 1555200, 18.71),
("walleye", 2, 0, 1670400, 21.587),
("walleye", 2, 0, 1747200, 25.43),
("walleye", 2, 0, 1824000, 27.165),
("walleye", 2, 0, 1900800, 31.671),
("walleye", 3, 0, 300000, 3.685),
("walleye", 3, 0, 364800, 3.598),
("walleye", 3, 0, 441600, 3.621),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("walleye", 3, 0, 518400, 4.202),
("walleye", 3, 0, 595200, 4.935),
("walleye", 3, 0, 672000, 5.633),
("walleye", 3, 0, 748800, 6.216),
("walleye", 3, 0, 825600, 6.71),
("walleye", 3, 0, 883200, 7.557),
("walleye", 3, 0, 960000, 8.687),
("walleye", 3, 0, 1036800, 9.882),
("walleye", 3, 0, 1094400, 10.95),
("walleye", 3, 0, 1171200, 12.075),
("walleye", 3, 0, 1248000, 12.875),
("walleye", 3, 0, 1324800, 14.424),
("walleye", 3, 0, 1401600, 15.653),
("walleye", 3, 0, 1478400, 17.345),
("walleye", 3, 0, 1555200, 18.71),
("walleye", 3, 0, 1670400, 21.587),
("walleye", 3, 0, 1747200, 25.43),
("walleye", 3, 0, 1824000, 27.165),
("walleye", 3, 0, 1900800, 31.671),
("walleye", 4, 1, 300000, 10.722),
("walleye", 4, 1, 345600, 11.52),
("walleye", 4, 1, 422400, 14.105),
("walleye", 4, 1, 499200, 16.68),
("walleye", 4, 1, 576000, 18.946),
("walleye", 4, 1, 652800, 21.265),
("walleye", 4, 1, 729600, 23.432),
("walleye", 4, 1, 806400, 26.019),
("walleye", 4, 1, 902400, 28.856),
("walleye", 4, 1, 979200, 31.085),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("walleye", 4, 1, 1056000, 33.615),
("walleye", 4, 1, 1132800, 35.76),
("walleye", 4, 1, 1190400, 40.608),
("walleye", 4, 1, 1267200, 43.284),
("walleye", 4, 1, 1344000, 47.347),
("walleye", 4, 1, 1420800, 52.231),
("walleye", 4, 1, 1497600, 57.225),
("walleye", 4, 1, 1574400, 63.138),
("walleye", 4, 1, 1651200, 69.251),
("walleye", 4, 1, 1728000, 76.449),
("walleye", 4, 1, 1804800, 84.71),
("walleye", 4, 1, 1881600, 102.551),
("walleye", 4, 1, 1958400, 107.115),
("walleye", 4, 1, 2035200, 129.689),
("walleye", 4, 1, 2112000, 135.832),
("walleye", 4, 1, 2208000, 164.674),
("walleye", 4, 1, 2265600, 180.279),
("walleye", 4, 1, 2323200, 197.024),
("walleye", 4, 1, 2342400, 204.511),
("walleye", 4, 1, 2361600, 211.886),
("walleye", 4, 1, 2457600, 212.147),
("walleye", 5, 1, 300000, 10.722),
("walleye", 5, 1, 345600, 11.52),
("walleye", 5, 1, 422400, 14.105),
("walleye", 5, 1, 499200, 16.68),
("walleye", 5, 1, 576000, 18.946),
("walleye", 5, 1, 652800, 21.265),
("walleye", 5, 1, 729600, 23.432),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("walleye", 5, 1, 806400, 26.019),
("walleye", 5, 1, 902400, 28.856),
("walleye", 5, 1, 979200, 31.085),
("walleye", 5, 1, 1056000, 33.615),
("walleye", 5, 1, 1132800, 35.76),
("walleye", 5, 1, 1190400, 40.608),
("walleye", 5, 1, 1267200, 43.284),
("walleye", 5, 1, 1344000, 47.347),
("walleye", 5, 1, 1420800, 52.231),
("walleye", 5, 1, 1497600, 57.225),
("walleye", 5, 1, 1574400, 63.138),
("walleye", 5, 1, 1651200, 69.251),
("walleye", 5, 1, 1728000, 76.449),
("walleye", 5, 1, 1804800, 84.71),
("walleye", 5, 1, 1881600, 102.551),
("walleye", 5, 1, 1958400, 107.115),
("walleye", 5, 1, 2035200, 129.689),
("walleye", 5, 1, 2112000, 135.832),
("walleye", 5, 1, 2208000, 164.674),
("walleye", 5, 1, 2265600, 180.279),
("walleye", 5, 1, 2323200, 197.024),
("walleye", 5, 1, 2342400, 204.511),
("walleye", 5, 1, 2361600, 211.886),
("walleye", 5, 1, 2457600, 212.147),
("walleye", 6, 1, 300000, 10.722),
("walleye", 6, 1, 345600, 11.52),
("walleye", 6, 1, 422400, 14.105),
("walleye", 6, 1, 499200, 16.68),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("walleye", 6, 1, 576000, 18.946),
("walleye", 6, 1, 652800, 21.265),
("walleye", 6, 1, 729600, 23.432),
("walleye", 6, 1, 806400, 26.019),
("walleye", 6, 1, 902400, 28.856),
("walleye", 6, 1, 979200, 31.085),
("walleye", 6, 1, 1056000, 33.615),
("walleye", 6, 1, 1132800, 35.76),
("walleye", 6, 1, 1190400, 40.608),
("walleye", 6, 1, 1267200, 43.284),
("walleye", 6, 1, 1344000, 47.347),
("walleye", 6, 1, 1420800, 52.231),
("walleye", 6, 1, 1497600, 57.225),
("walleye", 6, 1, 1574400, 63.138),
("walleye", 6, 1, 1651200, 69.251),
("walleye", 6, 1, 1728000, 76.449),
("walleye", 6, 1, 1804800, 84.71),
("walleye", 6, 1, 1881600, 102.551),
("walleye", 6, 1, 1958400, 107.115),
("walleye", 6, 1, 2035200, 129.689),
("walleye", 6, 1, 2112000, 135.832),
("walleye", 6, 1, 2208000, 164.674),
("walleye", 6, 1, 2265600, 180.279),
("walleye", 6, 1, 2323200, 197.024),
("walleye", 6, 1, 2342400, 204.511),
("walleye", 6, 1, 2361600, 211.886),
("walleye", 6, 1, 2457600, 212.147),
("walleye", 7, 1, 300000, 10.722),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("walleye", 7, 1, 345600, 11.52),
("walleye", 7, 1, 422400, 14.105),
("walleye", 7, 1, 499200, 16.68),
("walleye", 7, 1, 576000, 18.946),
("walleye", 7, 1, 652800, 21.265),
("walleye", 7, 1, 729600, 23.432),
("walleye", 7, 1, 806400, 26.019),
("walleye", 7, 1, 902400, 28.856),
("walleye", 7, 1, 979200, 31.085),
("walleye", 7, 1, 1056000, 33.615),
("walleye", 7, 1, 1132800, 35.76),
("walleye", 7, 1, 1190400, 40.608),
("walleye", 7, 1, 1267200, 43.284),
("walleye", 7, 1, 1344000, 47.347),
("walleye", 7, 1, 1420800, 52.231),
("walleye", 7, 1, 1497600, 57.225),
("walleye", 7, 1, 1574400, 63.138),
("walleye", 7, 1, 1651200, 69.251),
("walleye", 7, 1, 1728000, 76.449),
("walleye", 7, 1, 1804800, 84.71),
("walleye", 7, 1, 1881600, 102.551),
("walleye", 7, 1, 1958400, 107.115),
("walleye", 7, 1, 2035200, 129.689),
("walleye", 7, 1, 2112000, 135.832),
("walleye", 7, 1, 2208000, 164.674),
("walleye", 7, 1, 2265600, 180.279),
("walleye", 7, 1, 2323200, 197.024),
("walleye", 7, 1, 2342400, 204.511),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("walleye", 7, 1, 2361600, 211.886),
("walleye", 7, 1, 2457600, 212.147);

)_d3l1m1t3r_"
;

const char kAndroidProcessCounterSpanView[] = R"_d3l1m1t3r_(--
-- Copyright 2021 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

DROP VIEW IF EXISTS {{table_name}}_span;
CREATE PERFETTO VIEW {{table_name}}_span AS
SELECT
  ts,
  LEAD(ts, 1, (
    SELECT IFNULL(
      end_ts,
      trace_end()
    )
    FROM process p WHERE p.upid = pct.upid) + 1
  ) OVER(PARTITION BY track_id ORDER BY ts) - ts AS dur,
  upid,
  value AS {{table_name}}_val
FROM counter c JOIN process_counter_track pct
  ON pct.id = c.track_id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(WHERE name = '{{counter_name}}' AND upid IS NOT NULL;

)_d3l1m1t3r_"
;

const char kAndroidProcessMem[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE android.memory.process;
INCLUDE PERFETTO MODULE linux.memory.process;

SELECT RUN_METRIC('android/process_oom_score.sql');

DROP VIEW IF EXISTS anon_rss_span;
CREATE PERFETTO VIEW anon_rss_span AS
SELECT * FROM _anon_rss;

DROP VIEW IF EXISTS file_rss_span;
CREATE PERFETTO VIEW file_rss_span AS
SELECT * FROM _file_rss;

DROP VIEW IF EXISTS shmem_rss_span;
CREATE PERFETTO VIEW shmem_rss_span AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT * FROM _shmem_rss;

DROP VIEW IF EXISTS swap_span;
CREATE PERFETTO VIEW swap_span AS
SELECT * FROM _swap;

DROP VIEW IF EXISTS anon_and_swap_span;
CREATE PERFETTO VIEW anon_and_swap_span AS
SELECT
  ts, dur, upid,
  IFNULL(anon_rss_val, 0) + IFNULL(swap_val, 0) AS anon_and_swap_val
FROM _anon_swap_sj;

DROP VIEW IF EXISTS rss_and_swap_span;
CREATE PERFETTO VIEW rss_and_swap_span AS
SELECT
  ts,
  dur,
  upid,
  file_rss AS file_rss_val,
  anon_rss AS anon_rss_val,
  shmem_rss AS shmem_rss_val,
  swap AS swap_val,
  COALESCE(file_rss, 0)
    + COALESCE(anon_rss, 0)
    + COALESCE(shmem_rss, 0) AS rss_val,
  COALESCE(file_rss, 0)
    + COALESCE(anon_rss, 0)
    + COALESCE(shmem_rss, 0)
    + COALESCE(swap, 0) AS rss_and_swap_val
FROM _memory_rss_and_swap_per_process_table;

-- If we have dalvik events enabled (for ART trace points) we can construct the java heap timeline.
SELECT RUN_METRIC('android/process_counter_span_view.sql',
  'table_name', 'java_heap_kb',
  'counter_name', 'Heap size (KB)');
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
DROP VIEW IF EXISTS java_heap_span;
CREATE PERFETTO VIEW java_heap_span AS
SELECT ts, dur, upid, java_heap_kb_val * 1024 AS java_heap_val
FROM java_heap_kb_span;

DROP TABLE IF EXISTS java_heap_by_oom_span;
CREATE VIRTUAL TABLE java_heap_by_oom_span
USING SPAN_JOIN(java_heap_span PARTITIONED upid, oom_score_span PARTITIONED upid);

DROP TABLE IF EXISTS anon_rss_by_oom_span;
CREATE VIRTUAL TABLE anon_rss_by_oom_span
USING SPAN_JOIN(_anon_rss PARTITIONED upid, oom_score_span PARTITIONED upid);

DROP TABLE IF EXISTS file_rss_by_oom_span;
CREATE VIRTUAL TABLE file_rss_by_oom_span
USING SPAN_JOIN(_file_rss PARTITIONED upid, oom_score_span PARTITIONED upid);

DROP TABLE IF EXISTS swap_by_oom_span;
CREATE VIRTUAL TABLE swap_by_oom_span
USING SPAN_JOIN(_swap PARTITIONED upid, oom_score_span PARTITIONED upid);

DROP TABLE IF EXISTS anon_and_swap_by_oom_span;
CREATE VIRTUAL TABLE anon_and_swap_by_oom_span
USING SPAN_JOIN(anon_and_swap_span PARTITIONED upid, oom_score_span PARTITIONED upid);

)_d3l1m1t3r_"
;

const char kAndroidProcessMetadata[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE android.process_metadata;

DROP VIEW IF EXISTS process_metadata_table;
CREATE PERFETTO VIEW process_metadata_table AS
SELECT android_process_metadata.*, pid FROM android_process_metadata
JOIN process USING(upid);

DROP VIEW IF EXISTS uid_package_count;
CREATE PERFETTO VIEW uid_package_count AS
SELECT * FROM _uid_package_count;

DROP VIEW IF EXISTS process_metadata;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO VIEW process_metadata AS
SELECT
  upid,
  NULL_IF_EMPTY(AndroidProcessMetadata(
    'name', process_name,
    'uid', uid,
    'pid', pid,
    'package', NULL_IF_EMPTY(AndroidProcessMetadata_Package(
      'package_name', package_name,
      'apk_version_code', version_code,
      'debuggable', debuggable
    ))
  )) AS metadata
FROM process_metadata_table;

-- Given a process name, return if it is debuggable.
CREATE OR REPLACE PERFETTO FUNCTION is_process_debuggable(process_name STRING)
RETURNS BOOL AS
SELECT p.debuggable
FROM process_metadata_table p
WHERE p.process_name = $process_name
LIMIT 1;

)_d3l1m1t3r_"
;

const char kAndroidProcessOomScore[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- Create a track for process OOM scores.
DROP VIEW IF EXISTS oom_score_span;
CREATE PERFETTO VIEW oom_score_span AS
SELECT
  ts,
  LEAD(ts, 1, trace_end() + 1)
  OVER(PARTITION BY track_id ORDER BY ts) - ts AS dur,
  upid,
  CAST(value AS INT) AS oom_score_val
FROM counter c JOIN process_counter_track t
  ON c.track_id = t.id
WHERE name = 'oom_score_adj' AND upid IS NOT NULL;

)_d3l1m1t3r_"
;

const char kAndroidProcessUnaggMemView[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

DROP TABLE IF EXISTS {{table_name}}_unagg_values;
CREATE PERFETTO TABLE {{table_name}}_unagg_values AS
SELECT
  upid,
  RepeatedField(
    AndroidMemoryUnaggregatedMetric_Value(
      'ts', ts,
      'oom_score', oom_score_val,
      'value', {{table_name}}_val
    )
  ) AS metric
FROM {{table_name}}_by_oom_span
GROUP BY upid;

)_d3l1m1t3r_"
;

const char kAndroidProfilerSmaps[] = R"_d3l1m1t3r_(--
-- Copyright 2021 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

SELECT RUN_METRIC('android/process_metadata.sql') AS unused;

DROP VIEW IF EXISTS profiler_smaps_output;
CREATE PERFETTO VIEW profiler_smaps_output AS
WITH base_stat_counts AS (
  SELECT
    ts,
    upid,
    path,
    SUM(size_kb) AS size_kb,
    SUM(private_dirty_kb) AS private_dirty_kb,
    SUM(swap_kb) AS swap_kb
  FROM profiler_smaps
  GROUP BY 1, 2, 3
  ORDER BY 4 DESC
),
mapping_protos AS (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  SELECT
    ts,
    upid,
    RepeatedField(ProfilerSmaps_Mapping(
        'path', path,
        'size_kb', size_kb,
        'private_dirty_kb', private_dirty_kb,
        'swap_kb', swap_kb
      )) AS mappings
  FROM base_stat_counts
  GROUP BY 1, 2
)
SELECT ProfilerSmaps(
    'instance', RepeatedField(
      ProfilerSmaps_Instance(
        'process', process_metadata.metadata,
        'mappings', mappings
      ))
  )
FROM mapping_protos JOIN process_metadata USING (upid);

)_d3l1m1t3r_"
;

const char kAndroidSpanViewStats[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

DROP TABLE IF EXISTS {{table_name}}_delta;
CREATE PERFETTO TABLE {{table_name}}_delta AS
WITH rolling_delta AS (
  -- emits one row per ts point
  SELECT
    upid,
    {{table_name}}_val - MIN({{table_name}}_val) OVER win AS delta
  FROM {{table_name}}_span
  WINDOW win AS (
    PARTITION BY upid
    ORDER BY ts
    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
  )
)
SELECT
  upid,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- max over all ts
  MAX(delta) AS delta
FROM rolling_delta
GROUP BY 1;

DROP TABLE IF EXISTS {{table_name}}_stats;
CREATE PERFETTO TABLE {{table_name}}_stats AS
SELECT
  process.name AS process_name,
  MIN(span.{{table_name}}_val) AS min_value,
  MAX(span.{{table_name}}_val) AS max_value,
  SUM(span.{{table_name}}_val * span.dur) / SUM(span.dur) AS avg_value,
  MAX(delta.delta) AS max_delta_value
FROM {{table_name}}_span AS span
JOIN {{table_name}}_delta AS delta USING(upid)
JOIN process USING(upid)
WHERE process.name IS NOT NULL
GROUP BY 1
ORDER BY 1;

DROP VIEW IF EXISTS {{table_name}}_stats_proto;
CREATE PERFETTO VIEW {{table_name}}_stats_proto AS
SELECT
  process_name,
  AndroidMemoryMetric_Counter(
    'min', min_value,
    'max', max_value,
    'avg', avg_value,
    'delta', max_delta_value
  ) AS proto
FROM {{table_name}}_stats;

)_d3l1m1t3r_"
;

const char kAndroidStartupAndroidAppProcessStarts[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE android.app_process_starts;

DROP VIEW IF EXISTS android_app_process_starts_output;
CREATE PERFETTO VIEW android_app_process_starts_output AS
SELECT AndroidAppProcessStartsMetric(
  'all_apps', (
    SELECT RepeatedField(
        AndroidAppProcessStartsMetric_ProcessStart(
            'process_name', process_name,
            'intent', intent,
            'reason', reason,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(            'proc_start_dur', proc_start_dur,
            'bind_app_dur', bind_app_dur,
            'intent_dur', intent_dur,
            'total_dur', total_dur
        )
    )
    FROM android_app_process_starts
  ),
  'started_by_broadcast', (
    SELECT RepeatedField(
        AndroidAppProcessStartsMetric_ProcessStart(
            'process_name', process_name,
            'intent', intent,
            'reason', reason,
            'proc_start_dur', proc_start_dur,
            'bind_app_dur', bind_app_dur,
            'intent_dur', intent_dur,
            'total_dur', total_dur
        )
    )
    FROM android_app_process_starts where reason = "broadcast"
  ),
  'started_by_service', (
    SELECT RepeatedField(
        AndroidAppProcessStartsMetric_ProcessStart(
            'process_name', process_name,
            'intent', intent,
            'reason', reason,
            'proc_start_dur', proc_start_dur,
            'bind_app_dur', bind_app_dur,
            'intent_dur', intent_dur,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(            'total_dur', total_dur
        )
    )
    FROM android_app_process_starts where reason = "service"
  )
);

)_d3l1m1t3r_"
;

const char kAndroidStartupGcSlices[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

DROP VIEW IF EXISTS gc_slices;
CREATE PERFETTO VIEW gc_slices AS
SELECT slice_ts AS ts, slice_dur AS dur, utid, startup_id AS launch_id
FROM thread_slices_for_all_launches
WHERE
  slice_name GLOB '*mark sweep GC'
  OR slice_name GLOB '*concurrent copying GC'
  OR slice_name GLOB '*semispace GC';

DROP TABLE IF EXISTS gc_slices_by_state;
CREATE VIRTUAL TABLE gc_slices_by_state
USING SPAN_JOIN(gc_slices PARTITIONED utid, thread_state_extended PARTITIONED utid);
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
DROP TABLE IF EXISTS running_gc_slices_materialized;
CREATE PERFETTO TABLE running_gc_slices_materialized AS
SELECT launch_id, SUM(dur) AS sum_dur
FROM gc_slices_by_state
WHERE state = 'Running'
GROUP BY launch_id;

)_d3l1m1t3r_"
;

const char kAndroidStartupHsc[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE android.startup.startups;

-- Must be invoked after populating launches table in android_startup.
DROP VIEW IF EXISTS functions;
CREATE PERFETTO VIEW functions AS
SELECT
  slices.ts AS ts,
  slices.dur AS dur,
  process.name AS process_name,
  thread.name AS thread_name,
  slices.name AS function_name
FROM slices
JOIN thread_track ON slices.track_id = thread_track.id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(JOIN thread USING(utid)
JOIN process USING(upid);

-- Animators don't occur on threads, so add them here.
DROP VIEW IF EXISTS animators;
CREATE PERFETTO VIEW animators AS
SELECT
  slices.ts AS ts,
  slices.dur AS dur,
  thread.name AS process_name,
  slices.name AS animator_name
FROM slices
JOIN process_track ON slices.track_id = process_track.id
JOIN thread USING(upid)
WHERE slices.name GLOB "animator*";

DROP VIEW IF EXISTS android_frame_times;
CREATE PERFETTO VIEW android_frame_times AS
SELECT
  functions.ts AS ts,
  functions.ts + functions.dur AS ts_end,
  launches.package AS name,
  launches.startup_id,
  ROW_NUMBER() OVER(PARTITION BY launches.startup_id ORDER BY functions.ts ASC) AS number
FROM functions
JOIN android_startups launches ON launches.package GLOB '*' || functions.process_name || '*'
WHERE functions.function_name GLOB "Choreographer#doFrame*" AND functions.ts > launches.ts;

DROP VIEW IF EXISTS android_render_frame_times;
CREATE PERFETTO VIEW android_render_frame_times AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  functions.ts AS ts,
  functions.ts + functions.dur AS ts_end,
  launches.package AS name,
  launches.startup_id,
  ROW_NUMBER() OVER(PARTITION BY launches.startup_id ORDER BY functions.ts ASC) AS number
FROM functions
JOIN android_startups launches ON launches.package GLOB '*' || functions.process_name || '*'
WHERE functions.function_name GLOB "DrawFrame*" AND functions.ts > launches.ts;

DROP VIEW IF EXISTS frame_times;
CREATE PERFETTO VIEW frame_times AS
SELECT startup_id AS launch_id, * FROM android_frame_times;

DROP TABLE IF EXISTS hsc_based_startup_times;
CREATE TABLE hsc_based_startup_times(package STRING, id INT, ts_total INT);

-- Calculator
INSERT INTO hsc_based_startup_times
SELECT
  launches.package AS package,
  launches.startup_id AS id,
  android_frame_times.ts_end - launches.ts AS ts_total
FROM android_frame_times
JOIN android_startups launches ON launches.package GLOB '*' || android_frame_times.name || '*'
WHERE android_frame_times.number = 2 AND android_frame_times.name GLOB "*roid.calcul*" AND android_frame_times.startup_id = launches.startup_id;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Calendar
-- Using the DrawFrame slice from the render thread due to Calendar delaying its rendering
INSERT INTO hsc_based_startup_times
SELECT
  launches.package AS package,
  launches.startup_id AS id,
  android_render_frame_times.ts_end - launches.ts AS ts_total
FROM android_render_frame_times
JOIN android_startups launches ON launches.package GLOB '*' || android_render_frame_times.name || '*'
WHERE android_render_frame_times.number = 5 AND android_render_frame_times.name GLOB "*id.calendar*" AND android_render_frame_times.startup_id = launches.startup_id;

-- Camera
INSERT INTO hsc_based_startup_times
SELECT
  launches.package AS package,
  launches.startup_id AS id,
  android_frame_times.ts_end - launches.ts AS ts_total
FROM android_frame_times
JOIN android_startups launches ON launches.package GLOB '*' || android_frame_times.name || '*'
WHERE android_frame_times.number = 2 AND android_frame_times.name GLOB "*GoogleCamera*" AND android_frame_times.startup_id = launches.startup_id;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Chrome
INSERT INTO hsc_based_startup_times
SELECT
  launches.package AS package,
  launches.startup_id AS id,
  android_frame_times.ts_end - launches.ts AS ts_total
FROM android_frame_times
JOIN android_startups launches ON launches.package GLOB '*' || android_frame_times.name || '*'
WHERE android_frame_times.number = 4 AND android_frame_times.name GLOB "*chrome*" AND android_frame_times.startup_id = launches.startup_id;

-- Clock
INSERT INTO hsc_based_startup_times
SELECT
  launches.package AS package,
  launches.startup_id AS id,
  android_frame_times.ts_end - launches.ts AS ts_total
FROM android_frame_times
JOIN android_startups launches ON launches.package GLOB '*' || android_frame_times.name || '*'
WHERE android_frame_times.ts > (SELECT ts + dur FROM animators WHERE animator_name = "animator:translationZ" AND process_name GLOB "*id.deskclock" ORDER BY (ts + dur) DESC LIMIT 1) AND android_frame_times.name GLOB "*id.deskclock" AND android_frame_times.startup_id = launches.startup_id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(ORDER BY ts_total LIMIT 1;

-- Contacts
INSERT INTO hsc_based_startup_times
SELECT
  launches.package AS package,
  launches.startup_id AS id,
  android_frame_times.ts_end - launches.ts AS ts_total
FROM android_frame_times
JOIN android_startups launches ON launches.package GLOB '*' || android_frame_times.name || '*'
WHERE android_frame_times.number = 3 AND android_frame_times.name GLOB "*id.contacts" AND android_frame_times.startup_id = launches.startup_id;

-- Dialer
-- Dialer only runs one animation at startup, use the last animation frame to indicate startup.
INSERT INTO hsc_based_startup_times
SELECT
  launches.package AS package,
  launches.startup_id AS id,
  android_frame_times.ts_end - launches.ts AS ts_total
FROM android_frame_times
JOIN android_startups launches ON launches.package GLOB '*' || android_frame_times.name || '*'
WHERE android_frame_times.ts > (SELECT ts + dur FROM animators WHERE process_name GLOB "*id.dialer" AND animator_name GLOB "*animator*" ORDER BY (ts + dur) DESC LIMIT 1) AND android_frame_times.name GLOB "*id.dialer" AND android_frame_times.startup_id = launches.startup_id LIMIT 1;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Facebook
INSERT INTO hsc_based_startup_times
SELECT
  launches.package AS package,
  launches.startup_id AS id,
  android_frame_times.ts_end - launches.ts AS ts_total
FROM android_frame_times
JOIN android_startups launches ON launches.package GLOB '*' || android_frame_times.name || '*'
WHERE android_frame_times.ts > (SELECT ts + dur FROM slices WHERE slices.name GLOB "fb_startup_complete" ORDER BY ts LIMIT 1) AND android_frame_times.name GLOB "*ok.katana" AND android_frame_times.startup_id = launches.startup_id
ORDER BY ts_total LIMIT 1;

-- Facebook Messenger
INSERT INTO hsc_based_startup_times
SELECT
  launches.package AS package,
  launches.startup_id AS id,
  android_frame_times.ts_end - launches.ts AS ts_total
FROM android_frame_times
JOIN android_startups launches ON launches.package GLOB '*' || android_frame_times.name || '*'
WHERE android_frame_times.ts > (SELECT ts + dur FROM slices WHERE slices.name GLOB "msgr_cold_start_to_cached_content" ORDER BY ts LIMIT 1) AND android_frame_times.name GLOB "*book.orca" AND android_frame_times.startup_id = launches.startup_id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(ORDER BY ts_total LIMIT 1;

-- Gmail
INSERT INTO hsc_based_startup_times
SELECT
  launches.package AS package,
  launches.startup_id AS id,
  android_frame_times.ts_end - launches.ts AS ts_total
FROM android_frame_times
JOIN android_startups launches ON launches.package GLOB '*' || android_frame_times.name || '*'
WHERE android_frame_times.ts > (SELECT ts + dur FROM animators WHERE animator_name = "animator:elevation" AND process_name GLOB "*android.gm" ORDER BY (ts + dur) DESC LIMIT 1) AND android_frame_times.name GLOB "*android.gm" AND android_frame_times.startup_id = launches.startup_id
ORDER BY ts_total LIMIT 1;

-- Instagram
INSERT INTO hsc_based_startup_times
SELECT
  launches.package AS package,
  launches.startup_id AS id,
  android_frame_times.ts_end - launches.ts AS ts_total
FROM android_frame_times
JOIN android_startups launches ON launches.package GLOB '*' || android_frame_times.name || '*'
WHERE android_frame_times.ts > (SELECT ts + dur FROM slices WHERE slices.name GLOB "ig_cold_start_to_cached_content" ORDER BY ts LIMIT 1) AND android_frame_times.name GLOB "*gram.android" AND android_frame_times.startup_id = launches.startup_id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(ORDER BY ts_total LIMIT 1;

-- Maps
-- Use the 8th choreographer frame to indicate startup.
INSERT INTO hsc_based_startup_times
SELECT
  launches.package AS package,
  launches.startup_id AS id,
  android_frame_times.ts_end - launches.ts AS ts_total
FROM android_frame_times
JOIN android_startups launches ON launches.package GLOB '*' || android_frame_times.name || '*'
WHERE android_frame_times.number = 8 AND android_frame_times.name GLOB "*maps*" AND android_frame_times.startup_id = launches.startup_id;

-- Messages
-- Use the first choreographer frame that is emitted after all animator:translationZ slices end.
INSERT INTO hsc_based_startup_times
SELECT
  launches.package AS package,
  launches.startup_id AS id,
  android_frame_times.ts_end - launches.ts AS ts_total
FROM android_frame_times
JOIN android_startups launches ON launches.package GLOB '*' || android_frame_times.name || '*'
WHERE android_frame_times.ts_end > (SELECT ts + dur FROM animators WHERE animator_name = "animator:translationZ" AND process_name GLOB "*apps.messaging*" ORDER BY (ts + dur) DESC LIMIT 1) AND android_frame_times.name GLOB "*apps.messaging*" AND android_frame_times.startup_id = launches.startup_id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(ORDER BY ts_total LIMIT 1;

-- Netflix
INSERT INTO hsc_based_startup_times
SELECT
  launches.package AS package,
  launches.startup_id AS id,
  android_frame_times.ts_end - launches.ts AS ts_total
FROM android_frame_times
JOIN android_startups launches ON launches.package GLOB '*' || android_frame_times.name || '*'
WHERE android_frame_times.ts < (SELECT ts FROM animators WHERE animator_name GLOB "animator*" AND process_name GLOB "*lix.mediaclient" ORDER BY ts LIMIT 1) AND android_frame_times.name GLOB "*lix.mediaclient*" AND android_frame_times.startup_id = launches.startup_id
ORDER BY ts_total DESC LIMIT 1;

-- Photos
-- Use the animator:translationZ slice as startup indicator.
INSERT INTO hsc_based_startup_times
SELECT
  launches.package AS package,
  launches.startup_id AS id,
  android_frame_times.ts_end - launches.ts AS ts_total
FROM android_frame_times
JOIN android_startups launches ON launches.package GLOB '*' || android_frame_times.name || '*'
WHERE android_frame_times.ts > (SELECT ts + dur FROM animators WHERE process_name GLOB "*apps.photos" AND animator_name GLOB "animator:translationZ" ORDER BY (ts + dur) DESC LIMIT 1) AND android_frame_times.name GLOB "*apps.photos*" AND android_frame_times.startup_id = launches.startup_id LIMIT 1;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Settings was deprecated in favor of reportFullyDrawn b/169694037.

-- Snapchat
INSERT INTO hsc_based_startup_times
SELECT
  launches.package AS package,
  launches.startup_id AS id,
  android_frame_times.ts_end - launches.ts AS ts_total
FROM android_frame_times
JOIN android_startups launches ON launches.package GLOB '*' || android_frame_times.name || '*'
WHERE android_frame_times.number = 1 AND android_frame_times.name GLOB "*napchat.android" AND android_frame_times.startup_id = launches.startup_id;

-- Twitter
INSERT INTO hsc_based_startup_times
SELECT
  launches.package AS package,
  launches.startup_id AS id,
  android_frame_times.ts_end - launches.ts AS ts_total
FROM android_frame_times
JOIN android_startups launches ON launches.package GLOB '*' || android_frame_times.name || '*'
WHERE android_frame_times.ts_end > (SELECT ts FROM animators WHERE animator_name = "animator" AND process_name GLOB "*tter.android" ORDER BY ts LIMIT 1) AND android_frame_times.name GLOB "*tter.android" AND android_frame_times.startup_id = launches.startup_id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(ORDER BY ts_total LIMIT 1;

-- WhatsApp
INSERT INTO hsc_based_startup_times
SELECT
  launches.package AS package,
  launches.startup_id AS id,
  android_frame_times.ts_end - launches.ts AS ts_total
FROM android_frame_times
JOIN android_startups launches ON launches.package GLOB '*' || android_frame_times.name || '*'
WHERE android_frame_times.ts > (SELECT ts + dur FROM slices WHERE slices.name GLOB "wa_startup_complete" ORDER BY ts LIMIT 1) AND android_frame_times.name GLOB "*om.whatsapp" AND android_frame_times.startup_id = launches.startup_id
ORDER BY ts_total LIMIT 1;

-- Youtube
-- Use the 10th frame that is rendered
INSERT INTO hsc_based_startup_times
SELECT
  launches.package AS package,
  launches.startup_id AS id,
  android_render_frame_times.ts_end - launches.ts AS ts_total
FROM android_render_frame_times
JOIN android_startups launches ON launches.package GLOB '*' || android_render_frame_times.name || '*'
WHERE android_render_frame_times.number = 10 AND android_render_frame_times.name GLOB "*id.youtube" AND android_render_frame_times.startup_id = launches.startup_id;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
)_d3l1m1t3r_"
;

const char kAndroidStartupLaunches[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- This metric will be deprecated soon. All of the tables have been
-- migrated to SQL standard library and can be imported from:
INCLUDE PERFETTO MODULE android.startup.startups;


DROP VIEW IF EXISTS launches;
CREATE PERFETTO VIEW launches AS
SELECT startup_id AS launch_id, *, startup_type as launch_type FROM android_startups;

DROP VIEW IF EXISTS launch_processes;
CREATE PERFETTO VIEW launch_processes AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT startup_id AS launch_id, * FROM android_startup_processes;

DROP VIEW IF EXISTS launch_threads;
CREATE PERFETTO VIEW launch_threads AS
SELECT startup_id AS launch_id, * FROM android_startup_threads;

DROP VIEW IF EXISTS launching_events;
CREATE PERFETTO VIEW launching_events AS
SELECT * FROM _startup_events;

)_d3l1m1t3r_"
;

const char kAndroidStartupLaunchesMaxsdk28[] = R"_d3l1m1t3r_(--
-- Copyright 2021 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- Cold/warm starts emitted launching slices on API level 28-.
INSERT INTO launches(id, ts, ts_end, dur, package, launch_type)
SELECT
  ROW_NUMBER() OVER(ORDER BY ts) AS id,
  launching_events.ts AS ts,
  launching_events.ts_end AS ts_end,
  launching_events.ts_end - launching_events.ts AS dur,
  package_name AS package,
  NULL AS launch_type
FROM launching_events
ORDER BY ts;

-- TODO(lalitm): add handling of hot starts using frame timings.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
)_d3l1m1t3r_"
;

const char kAndroidStartupLaunchesMinsdk29[] = R"_d3l1m1t3r_(--
-- Copyright 2021 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- Marks the beginning of the trace and is equivalent to when the statsd launch
-- logging begins.
DROP VIEW IF EXISTS activity_intent_received;
CREATE PERFETTO VIEW activity_intent_received AS
SELECT ts FROM slice
WHERE name = 'MetricsLogger:launchObserverNotifyIntentStarted';

-- We partition the trace into spans based on posted activity intents.
-- We will refine these progressively in the next steps to only encompass
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- activity starts.
DROP TABLE IF EXISTS activity_intent_recv_spans;
CREATE TABLE activity_intent_recv_spans(id INT, ts BIGINT, dur BIGINT);

INSERT INTO activity_intent_recv_spans
SELECT
  ROW_NUMBER()
  OVER(ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS id,
  ts,
  LEAD(ts, 1, trace_end()) OVER(ORDER BY ts) - ts AS dur
FROM activity_intent_received
ORDER BY ts;

-- Filter activity_intent_recv_spans, keeping only the ones that triggered
-- a launch.
DROP VIEW IF EXISTS launch_partitions;
CREATE PERFETTO VIEW launch_partitions AS
SELECT * FROM activity_intent_recv_spans AS spans
WHERE 1 = (
  SELECT COUNT(1)
  FROM launching_events
  WHERE launching_events.ts BETWEEN spans.ts AND spans.ts + spans.dur);

-- Successful activity launch. The end of the 'launching' event is not related
-- to whether it actually succeeded or not.
DROP VIEW IF EXISTS activity_intent_launch_successful;
CREATE PERFETTO VIEW activity_intent_launch_successful AS
SELECT ts FROM slice
WHERE name = 'MetricsLogger:launchObserverNotifyActivityLaunchFinished';
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Use the starting event package name. The finish event package name
-- is not reliable in the case of failed launches.
INSERT INTO launches(id, ts, ts_end, dur, package, launch_type)
SELECT
  lpart.id AS id,
  lpart.ts AS ts,
  launching_events.ts_end AS ts_end,
  launching_events.ts_end - lpart.ts AS dur,
  package_name AS package,
  NULL AS launch_type
FROM launch_partitions AS lpart
JOIN launching_events ON
  (launching_events.ts BETWEEN lpart.ts AND lpart.ts + lpart.dur)
  AND (launching_events.ts_end BETWEEN lpart.ts AND lpart.ts + lpart.dur)
WHERE (
  SELECT COUNT(1)
  FROM activity_intent_launch_successful AS successful
  WHERE successful.ts BETWEEN lpart.ts AND lpart.ts + lpart.dur
) > 0;

)_d3l1m1t3r_"
;

const char kAndroidStartupLaunchesMinsdk33[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

DROP VIEW IF EXISTS launch_async_events;
CREATE PERFETTO VIEW launch_async_events AS
SELECT
  ts,
  dur,
  SUBSTR(name, 19) AS id
FROM slice
WHERE
  name GLOB 'launchingActivity#*'
  AND dur != 0
  AND INSTR(name, ':') = 0;

DROP VIEW IF EXISTS launch_complete_events;
CREATE PERFETTO VIEW launch_complete_events AS
SELECT
  STR_SPLIT(completed, ':', 0) AS id,
  STR_SPLIT(completed, ':', 2) AS package_name,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  CASE
    WHEN STR_SPLIT(completed, ':', 1) = 'completed-hot' THEN 'hot'
    WHEN STR_SPLIT(completed, ':', 1) = 'completed-warm' THEN 'warm'
    WHEN STR_SPLIT(completed, ':', 1) = 'completed-cold' THEN 'cold'
    ELSE NULL
  END AS launch_type,
  MIN(ts)
FROM (
  SELECT ts, SUBSTR(name, 19) AS completed
  FROM slice
  WHERE
    dur = 0
    -- Originally completed was unqualified, but at some point we introduced
    -- the startup type as well
    AND name GLOB 'launchingActivity#*:completed*:*'
)
GROUP BY 1, 2, 3;

INSERT INTO launches(id, ts, ts_end, dur, package, launch_type)
SELECT
  id,
  ts,
  ts + dur AS ts_end,
  dur,
  package_name,
  launch_type
FROM launch_async_events
JOIN launch_complete_events USING (id);

)_d3l1m1t3r_"
;

const char kAndroidStartupMcyclesPerLaunch[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE android.startup.startups;

-- Create the base CPU span join table.
SELECT RUN_METRIC('android/android_cpu_agg.sql');
SELECT RUN_METRIC('android/cpu_info.sql');

-- Create a span join safe launches view; since both views
-- being span joined have an "id" column, we need to rename
-- the id column for launches to disambiguate the two.
DROP VIEW IF EXISTS android_launches_span_join_safe;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO VIEW android_launches_span_join_safe AS
SELECT ts, dur, startup_id
FROM android_startups;

DROP VIEW IF EXISTS launches_span_join_safe;
CREATE PERFETTO VIEW launches_span_join_safe AS
SELECT startup_id AS launch_id, * FROM android_launches_span_join_safe;

-- Span join the CPU table with the launches table to get the
-- breakdown per-cpu.
DROP TABLE IF EXISTS cpu_freq_sched_per_thread_per_launch;
CREATE VIRTUAL TABLE cpu_freq_sched_per_thread_per_launch
USING SPAN_JOIN(
  android_launches_span_join_safe,
  cpu_freq_sched_per_thread PARTITIONED cpu
);

-- Materialized to avoid span-joining once per core type.
DROP TABLE IF EXISTS mcycles_per_core_type_per_launch;
CREATE PERFETTO TABLE mcycles_per_core_type_per_launch AS
SELECT
  startup_id,
  IFNULL(core_type_per_cpu.core_type, 'unknown') AS core_type,
  CAST(SUM(dur * freq_khz / 1000) / 1e9 AS INT) AS mcycles
FROM cpu_freq_sched_per_thread_per_launch
LEFT JOIN core_type_per_cpu USING (cpu)
WHERE utid != 0
GROUP BY 1, 2;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Given a launch id and core type, returns the number of mcycles consumed
-- on CPUs of that core type during the launch.
CREATE OR REPLACE PERFETTO FUNCTION mcycles_for_launch_and_core_type(startup_id INT, core_type STRING)
RETURNS INT AS
SELECT mcycles
FROM mcycles_per_core_type_per_launch m
WHERE m.startup_id = $startup_id AND m.core_type = $core_type;

-- Contains the process using the most mcycles during the launch
-- *excluding the process being started*.
-- Materialized to avoid span-joining once per launch.
DROP TABLE IF EXISTS top_mcyles_process_excluding_started_per_launch;
CREATE PERFETTO TABLE top_mcyles_process_excluding_started_per_launch AS
WITH mcycles_per_launch_and_process AS MATERIALIZED (
  SELECT
    startup_id,
    upid,
    CAST(SUM(dur * freq_khz / 1000) / 1e9 AS INT) AS mcycles
  FROM cpu_freq_sched_per_thread_per_launch c
  JOIN thread USING (utid)
  JOIN process USING (upid)
  WHERE
    utid != 0
    AND upid NOT IN (
      SELECT upid
      FROM android_startup_processes l
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    )
  GROUP BY startup_id, upid
)
SELECT *
FROM (
  SELECT
    *,
    ROW_NUMBER() OVER (PARTITION BY startup_id ORDER BY mcycles DESC) AS mcycles_rank
  FROM mcycles_per_launch_and_process
)
WHERE mcycles_rank <= 5;

-- Given a launch id, returns the name of the processes consuming the most
-- mcycles during the launch excluding the process being started.
CREATE OR REPLACE PERFETTO FUNCTION n_most_active_process_names_for_launch(startup_id INT)
RETURNS STRING AS
SELECT RepeatedField(process_name)
FROM (
  SELECT IFNULL(process.name, "[NULL]") AS process_name
  FROM top_mcyles_process_excluding_started_per_launch
  JOIN process USING (upid)
  WHERE startup_id = $startup_id
  ORDER BY mcycles DESC
);

-- Given a launch id, returns the most active process name.
CREATE OR REPLACE PERFETTO FUNCTION most_active_process_for_launch(startup_id INT)
RETURNS STRING AS
SELECT process.name AS process_name
FROM top_mcyles_process_excluding_started_per_launch
JOIN process USING (upid)
WHERE startup_id = $startup_id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(ORDER BY mcycles DESC
LIMIT 1;

)_d3l1m1t3r_"
;

const char kAndroidStartupSliceFunctions[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE android.startup.startups;

-- Helper function to build a Slice proto from a duration.
CREATE OR REPLACE PERFETTO FUNCTION startup_slice_proto(dur INT)
RETURNS PROTO AS
SELECT AndroidStartupMetric_Slice(
  "dur_ns", $dur,
  "dur_ms", $dur / 1e6
);

-- View containing all the slices for all launches. Generally, this view
-- should not be used. Instead, one of the helper functions below which wrap
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- this view should be used.
DROP VIEW IF EXISTS thread_slices_for_all_launches;
CREATE PERFETTO VIEW thread_slices_for_all_launches AS
SELECT * FROM android_thread_slices_for_all_startups;

-- Given a launch id and GLOB for a slice name, returns the startup slice proto,
-- summing the slice durations across the whole startup.
CREATE OR REPLACE PERFETTO FUNCTION dur_sum_slice_proto_for_launch(startup_id LONG, slice_name STRING)
RETURNS PROTO AS
SELECT NULL_IF_EMPTY(
  startup_slice_proto(
    android_sum_dur_for_startup_and_slice($startup_id, $slice_name)
  )
);

-- Same as |dur_sum_slice_proto_for_launch| except only counting slices happening
-- on the main thread.
CREATE OR REPLACE PERFETTO FUNCTION dur_sum_main_thread_slice_proto_for_launch(startup_id LONG, slice_name STRING)
RETURNS PROTO AS
SELECT NULL_IF_EMPTY(
  startup_slice_proto(
    android_sum_dur_on_main_thread_for_startup_and_slice($startup_id, $slice_name)
  )
);

-- Given a launch id and GLOB for a slice name, returns the startup slice proto by
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- taking the duration between the start of the launch and start of the slice.
-- If multiple slices match, picks the latest one which started during the launch.
CREATE OR REPLACE PERFETTO FUNCTION launch_to_main_thread_slice_proto(startup_id INT, slice_name STRING)
RETURNS PROTO AS
SELECT NULL_IF_EMPTY(startup_slice_proto(MAX(slice_ts) - startup_ts))
FROM android_thread_slices_for_all_startups s
JOIN thread t USING (utid)
WHERE
  s.slice_name GLOB $slice_name AND
  s.startup_id = $startup_id AND
  s.is_main_thread AND
  (t.end_ts IS NULL OR t.end_ts >= s.startup_ts_end);

-- Given a lauch id, returns the total time spent in GC
CREATE OR REPLACE PERFETTO FUNCTION total_gc_time_by_launch(startup_id LONG)
RETURNS INT AS
SELECT SUM(slice_dur)
FROM android_thread_slices_for_all_startups slice
WHERE
  slice.startup_id = $startup_id AND
  (
    slice_name GLOB "*semispace GC" OR
    slice_name GLOB "*mark sweep GC" OR
    slice_name GLOB "*concurrent copying GC"
  );

-- Given a launch id and package name, returns if baseline or cloud profile is missing.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE OR REPLACE PERFETTO FUNCTION missing_baseline_profile_for_launch(startup_id LONG, pkg_name STRING)
RETURNS BOOL AS
SELECT (COUNT(slice_name) > 0)
FROM (
  SELECT *
  FROM ANDROID_SLICES_FOR_STARTUP_AND_SLICE_NAME(
    $startup_id,
    "location=* status=* filter=* reason=*"
  )
  ORDER BY slice_name
)
WHERE
  -- when location is the package odex file and the reason is "install" or "install-dm",
  -- if the compilation filter is not "speed-profile", baseline/cloud profile is missing.
  SUBSTR(STR_SPLIT(slice_name, " status=", 0), LENGTH("location=") + 1)
    GLOB ("*" || $pkg_name || "*odex")
  AND (STR_SPLIT(slice_name, " reason=", 1) = "install"
    OR STR_SPLIT(slice_name, " reason=", 1) = "install-dm")
  AND STR_SPLIT(STR_SPLIT(slice_name, " filter=", 1), " reason=", 0) != "speed-profile";

-- Given a launch id, returns if there is a main thread run-from-apk slice.
CREATE OR REPLACE PERFETTO FUNCTION run_from_apk_for_launch(launch_id LONG)
RETURNS BOOL AS
SELECT EXISTS(
  SELECT slice_name, startup_id, is_main_thread
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  FROM android_thread_slices_for_all_startups
  WHERE
    startup_id = $launch_id AND is_main_thread AND
    slice_name GLOB "location=* status=* filter=* reason=*" AND
    STR_SPLIT(STR_SPLIT(slice_name, " filter=", 1), " reason=", 0)
      GLOB ("*" || "run-from-apk" || "*")
);

CREATE OR REPLACE PERFETTO FUNCTION summary_for_optimization_status(
  loc STRING,
  status STRING,
  filter_str STRING,
  reason STRING
)
RETURNS STRING AS
SELECT
CASE
  WHEN
    $loc GLOB "*/base.odex" AND $loc GLOB "*==/*-*"
  THEN STR_SPLIT(STR_SPLIT($loc, "==/", 1), "-", 0) || "/.../"
  ELSE ""
END ||
CASE
  WHEN $loc GLOB "*/*"
    THEN REVERSE(STR_SPLIT(REVERSE($loc), "/", 0))
  ELSE $loc
END || ": " || $status || "/" || $filter_str || "/" || $reason;

CREATE OR REPLACE PERFETTO FUNCTION binder_transaction_reply_slices_for_launch(
  startup_id INT, threshold DOUBLE)
RETURNS TABLE(name STRING) AS
SELECT reply.name AS name
FROM android_binder_transaction_slices_for_startup($startup_id, $threshold) request
)_d3l1m1t3r_"
R"_d3l1m1t3r_(JOIN following_flow(request.id) arrow
JOIN slice reply ON reply.id = arrow.slice_in
WHERE reply.dur > $threshold AND request.is_main_thread;

-- Given a launch id, return if unlock is running by systemui during the launch.
CREATE OR REPLACE PERFETTO FUNCTION is_unlock_running_during_launch(startup_id LONG)
RETURNS BOOL AS
SELECT EXISTS(
  SELECT slice.name
  FROM slice, android_startups launches
  JOIN thread_track ON slice.track_id = thread_track.id
  JOIN thread USING(utid)
  JOIN process USING(upid)
  WHERE launches.startup_id = $startup_id
  AND slice.name = "KeyguardUpdateMonitor#onAuthenticationSucceeded"
  AND process.name = "com.android.systemui"
  AND slice.ts >= launches.ts
  AND (slice.ts + slice.dur) <= launches.ts_end
);

)_d3l1m1t3r_"
;

const char kAndroidStartupSlowStartReasons[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE android.startup.startups;

SELECT RUN_METRIC('android/startup/thread_state_breakdown.sql');
SELECT RUN_METRIC('android/startup/system_state.sql');
SELECT RUN_METRIC('android/startup/mcycles_per_launch.sql');

CREATE OR REPLACE PERFETTO FUNCTION _is_spans_overlapping(
  ts1 LONG,
  ts_end1 LONG,
  ts2 LONG,
  ts_end2 LONG)
RETURNS BOOL AS
SELECT (IIF($ts1 < $ts2, $ts2, $ts1)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      < IIF($ts_end1 < $ts_end2, $ts_end1, $ts_end2));

CREATE OR REPLACE PERFETTO FUNCTION get_percent(num LONG, total LONG)
RETURNS STRING AS
  SELECT SUBSTRING(CAST(($num * 100 + 0.0) / $total AS STRING), 1, 5);

CREATE OR REPLACE PERFETTO FUNCTION get_ns_to_s(ns LONG)
RETURNS STRING AS
  SELECT CAST(($ns + 0.0) / 1e9 AS STRING);

CREATE OR REPLACE PERFETTO FUNCTION get_ns_to_ms(ns LONG)
RETURNS STRING AS
  SELECT SUBSTRING(CAST(($ns + 0.0) / 1e6 AS STRING), 1, 6);

CREATE OR REPLACE PERFETTO FUNCTION get_main_thread_time_for_launch_in_runnable_state(
  startup_id LONG, num_threads INT)
RETURNS PROTO AS
  SELECT RepeatedField(AndroidStartupMetric_TraceThreadSection(
    'start_timestamp', ts, 'end_timestamp', ts + dur,
    'thread_utid', utid, 'thread_name', thread_name))
  FROM (
    SELECT ts, dur, utid, thread_name
    FROM launch_threads_by_thread_state l
    JOIN thread USING (utid)
    WHERE l.startup_id = $startup_id AND (state GLOB "R" OR state GLOB "R+") AND l.is_main_thread
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    ORDER BY dur DESC
    LIMIT $num_threads);

CREATE OR REPLACE PERFETTO FUNCTION get_main_thread_time_for_launch_and_state(
  startup_id LONG, state STRING, num_threads INT)
RETURNS PROTO AS
  SELECT RepeatedField(AndroidStartupMetric_TraceThreadSection(
    'start_timestamp', ts, 'end_timestamp', ts + dur,
    'thread_utid', utid, 'thread_name', thread_name))
  FROM (
    SELECT ts, dur, utid, thread_name
    FROM launch_threads_by_thread_state l
    JOIN thread USING (utid)
    WHERE l.startup_id = $startup_id AND state GLOB $state AND l.is_main_thread
    ORDER BY dur DESC
    LIMIT $num_threads);

CREATE OR REPLACE PERFETTO FUNCTION get_main_thread_time_for_launch_state_and_io_wait(
  startup_id INT, state STRING, io_wait BOOL, num_threads INT)
RETURNS PROTO AS
  SELECT RepeatedField(AndroidStartupMetric_TraceThreadSection(
    'start_timestamp', ts, 'end_timestamp', ts + dur,
    'thread_utid', utid, 'thread_name', thread_name))
  FROM (
    SELECT ts, dur, utid, thread_name
    FROM launch_threads_by_thread_state l
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    JOIN thread USING (utid)
    WHERE l.startup_id = $startup_id AND state GLOB $state
      AND l.is_main_thread AND l.io_wait = $io_wait
    ORDER BY dur DESC
    LIMIT $num_threads);

CREATE OR REPLACE PERFETTO FUNCTION get_thread_time_for_launch_state_and_thread(
  startup_id INT, state STRING, thread_name STRING, num_threads INT)
RETURNS PROTO AS
  SELECT RepeatedField(AndroidStartupMetric_TraceThreadSection(
    'start_timestamp', ts, 'end_timestamp', ts + dur,
    'thread_utid', utid, 'thread_name', thread_name))
  FROM (
    SELECT ts, dur, utid, thread_name
    FROM launch_threads_by_thread_state l
    JOIN thread USING (utid)
    WHERE l.startup_id = $startup_id AND state GLOB $state AND thread_name = $thread_name
    ORDER BY dur DESC
    LIMIT $num_threads);

CREATE OR REPLACE PERFETTO FUNCTION get_missing_baseline_profile_for_launch(
  startup_id LONG, pkg_name STRING)
RETURNS PROTO AS
  SELECT RepeatedField(AndroidStartupMetric_TraceSliceSection(
    'start_timestamp', slice_ts,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'end_timestamp', slice_ts + slice_dur,
    'slice_id', slice_id,
    'slice_name', slice_name))
  FROM (
    SELECT slice_ts, slice_dur, slice_id, slice_name
    FROM ANDROID_SLICES_FOR_STARTUP_AND_SLICE_NAME($startup_id,
      "location=* status=* filter=* reason=*")
    WHERE
      -- when location is the package odex file and the reason is "install" or "install-dm",
      -- if the compilation filter is not "speed-profile", baseline/cloud profile is missing.
      SUBSTR(STR_SPLIT(slice_name, " status=", 0), LENGTH("location=") + 1)
        GLOB ("*" || $pkg_name || "*odex")
      AND (STR_SPLIT(slice_name, " reason=", 1) = "install"
      OR STR_SPLIT(slice_name, " reason=", 1) = "install-dm")
    ORDER BY slice_dur DESC
    LIMIT 1);

CREATE OR REPLACE PERFETTO FUNCTION get_run_from_apk(startup_id LONG)
RETURNS PROTO AS
  SELECT RepeatedField(AndroidStartupMetric_TraceSliceSection(
    'start_timestamp', slice_ts,
    'end_timestamp', slice_ts + slice_dur,
    'slice_id', slice_id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'slice_name', slice_name))
  FROM (
    SELECT slice_ts, slice_dur, slice_id, slice_name
    FROM android_thread_slices_for_all_startups
    WHERE
      startup_id = $startup_id AND is_main_thread AND
      slice_name GLOB "location=* status=* filter=* reason=*" AND
      STR_SPLIT(STR_SPLIT(slice_name, " filter=", 1), " reason=", 0)
        GLOB ("*" || "run-from-apk" || "*")
    ORDER BY slice_dur DESC
    LIMIT 1);

CREATE OR REPLACE PERFETTO FUNCTION get_unlock_running_during_launch_slice(startup_id LONG)
RETURNS PROTO AS
  SELECT RepeatedField(AndroidStartupMetric_TraceSliceSection(
    'start_timestamp', slice_ts,
    'end_timestamp', slice_ts + slice_dur,
    'slice_id', slice_id,
    'slice_name', slice_name))
  FROM (
    SELECT slice.ts as slice_ts, slice.dur as slice_dur,
      slice.id as slice_id, slice.name as slice_name
    FROM slice, android_startups launches
    JOIN thread_track ON slice.track_id = thread_track.id
    JOIN thread USING(utid)
    JOIN process USING(upid)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    WHERE launches.startup_id = $startup_id
    AND slice.name = "KeyguardUpdateMonitor#onAuthenticationSucceeded"
    AND process.name = "com.android.systemui"
    AND slice.ts >= launches.ts
    AND (slice.ts + slice.dur) <= launches.ts_end
    LIMIT 1);

CREATE OR REPLACE PERFETTO FUNCTION get_gc_activity(startup_id LONG, num_slices INT)
RETURNS PROTO  AS
  SELECT RepeatedField(AndroidStartupMetric_TraceSliceSection(
    'start_timestamp', slice_ts,
    'end_timestamp', slice_ts + slice_dur,
    'slice_id', slice_id,
    'slice_name', slice_name))
  FROM (
    SELECT slice_ts, slice_dur, slice_id, slice_name
    FROM android_thread_slices_for_all_startups slice
    WHERE
      slice.startup_id = $startup_id AND
      (
        slice_name GLOB "*semispace GC" OR
        slice_name GLOB "*mark sweep GC" OR
        slice_name GLOB "*concurrent copying GC"
      )
    ORDER BY slice_dur DESC
    LIMIT $num_slices);

CREATE OR REPLACE PERFETTO FUNCTION get_dur_on_main_thread_for_startup_and_slice(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  startup_id LONG, slice_name STRING, num_slices INT)
RETURNS PROTO AS
  SELECT RepeatedField(AndroidStartupMetric_TraceSliceSection(
    'start_timestamp', slice_ts,
    'end_timestamp', slice_ts + slice_dur,
    'slice_id', slice_id,
    'slice_name', slice_name))
  FROM (
    SELECT slice_ts, slice_dur, slice_id, slice_name
    FROM android_thread_slices_for_all_startups l
    WHERE startup_id = $startup_id
      AND slice_name GLOB $slice_name
    ORDER BY slice_dur DESC
    LIMIT $num_slices);

CREATE OR REPLACE PERFETTO FUNCTION get_main_thread_binder_transactions_blocked(
  startup_id LONG, threshold DOUBLE, num_slices INT)
RETURNS PROTO AS
  SELECT RepeatedField(AndroidStartupMetric_TraceSliceSection(
    'start_timestamp', slice_ts, 'end_timestamp', slice_ts + slice_dur,
    'slice_id', slice_id, 'slice_name', slice_name))
  FROM (
    SELECT request.slice_ts as slice_ts, request.slice_dur as slice_dur,
      request.id as slice_id, request.slice_name as slice_name
    FROM (
      SELECT slice_id as id, slice_dur, thread_name, process.name as process,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(        s.arg_set_id, is_main_thread,
        slice_ts, s.utid, slice_name
      FROM android_thread_slices_for_all_startups s
      JOIN process ON (
        EXTRACT_ARG(s.arg_set_id, "destination process") = process.pid
      )
      WHERE startup_id = $startup_id AND slice_name GLOB "binder transaction"
        AND slice_dur > $threshold
    ) request
    JOIN following_flow(request.id) arrow
    JOIN slice reply ON reply.id = arrow.slice_in
    JOIN thread USING (utid)
    WHERE reply.dur > $threshold AND request.is_main_thread
    ORDER BY request.slice_dur DESC
    LIMIT $num_slices);

CREATE OR REPLACE PERFETTO FUNCTION get_slices_concurrent_to_launch(
  startup_id INT, slice_glob STRING, num_slices INT)
RETURNS PROTO AS
  SELECT RepeatedField(AndroidStartupMetric_TraceSliceSection(
    'start_timestamp', ts, 'end_timestamp', ts + dur,
    'slice_id', id, 'slice_name', name))
  FROM (
    SELECT s.ts as ts, dur, id, name FROM slice s
    JOIN (
      SELECT ts, ts_end
      FROM android_startups
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      WHERE startup_id = $startup_id
    ) launch
    WHERE
      s.name GLOB $slice_glob AND
      s.ts BETWEEN launch.ts AND launch.ts_end
    ORDER BY dur DESC LIMIT $num_slices);

CREATE OR REPLACE PERFETTO FUNCTION get_slices_for_startup_and_slice_name(
  startup_id INT, slice_name STRING, num_slices INT)
RETURNS PROTO AS
  SELECT RepeatedField(AndroidStartupMetric_TraceSliceSection(
    'start_timestamp', slice_ts, 'end_timestamp', slice_ts + slice_dur,
    'slice_id', slice_id, 'slice_name', slice_name))
  FROM (
    SELECT slice_ts, slice_dur, slice_id, slice_name
    FROM android_thread_slices_for_all_startups
    WHERE startup_id = $startup_id AND slice_name GLOB $slice_name
    ORDER BY slice_dur DESC
    LIMIT $num_slices);

CREATE OR REPLACE PERFETTO FUNCTION get_process_running_concurrent_to_launch(
  startup_id INT, process_glob STRING)
RETURNS STRING AS
  SELECT process.name
     FROM sched
     JOIN thread USING (utid)
     JOIN process USING (upid)
     JOIN (
       SELECT ts, ts_end
)_d3l1m1t3r_"
R"_d3l1m1t3r_(       FROM android_startups
       WHERE startup_id = $startup_id
       ) launch
     WHERE
       process.name GLOB $process_glob AND
       sched.ts BETWEEN launch.ts AND launch.ts_end
       ORDER BY (launch.ts_end - sched.ts) DESC
       LIMIT 1;

CREATE OR REPLACE PERFETTO FUNCTION get_slow_start_reason_with_details(startup_id LONG)
RETURNS PROTO AS
      SELECT RepeatedField(AndroidStartupMetric_SlowStartReason(
        'reason_id', reason_id,
        'reason', slow_cause,
        'launch_dur', launch_dur,
        'expected_value', expected_val,
        'actual_value', actual_val,
        'trace_slice_sections', trace_slices,
        'trace_thread_sections', trace_threads,
        'additional_info', extra))
      FROM (
        SELECT 'No baseline or cloud profiles' as slow_cause,
          launch.dur as launch_dur,
          'NO_BASELINE_OR_CLOUD_PROFILES' as reason_id,
          AndroidStartupMetric_ThresholdValue(
            'value', FALSE,
            'unit', 'TRUE_OR_FALSE') as expected_val,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(          AndroidStartupMetric_ActualValue(
            'value', TRUE) as actual_val,
          get_missing_baseline_profile_for_launch(launch.startup_id, launch.package)
            as trace_slices,
          NULL as trace_threads,
          NULL as extra
        FROM android_startups launch
        WHERE launch.startup_id = $startup_id
          AND missing_baseline_profile_for_launch(launch.startup_id, launch.package)

        UNION ALL
        SELECT 'Optimized artifacts missing, run from apk' as slow_cause,
          launch.dur as launch_dur,
          'RUN_FROM_APK' as reason_id,
          AndroidStartupMetric_ThresholdValue(
            'value', FALSE,
            'unit', 'TRUE_OR_FALSE') as expected_val,
          AndroidStartupMetric_ActualValue(
            'value', TRUE) as actual_val,
          get_run_from_apk(launch.startup_id) as trace_slices,
          NULL as trace_threads,
          NULL as extra
        FROM android_startups launch
        WHERE launch.startup_id = $startup_id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(          AND run_from_apk_for_launch(launch.startup_id)

        UNION ALL
        SELECT 'Unlock running during launch' as slow_cause,
          launch.dur as launch_dur,
          'UNLOCK_RUNNING' as reason_id,
          AndroidStartupMetric_ThresholdValue(
            'value', FALSE,
            'unit', 'TRUE_OR_FALSE') as expected_val,
          AndroidStartupMetric_ActualValue(
            'value', TRUE) as actual_val,
          get_unlock_running_during_launch_slice(launch.startup_id) as trace_slices,
          NULL as trace_threads,
          NULL as extra
        FROM android_startups launch
        WHERE launch.startup_id = $startup_id
         AND is_unlock_running_during_launch(launch.startup_id)

        UNION ALL
        SELECT 'App in debuggable mode' as slow_cause,
          launch.dur as launch_dur,
          'APP_IN_DEBUGGABLE_MODE' as reason_id,
          AndroidStartupMetric_ThresholdValue(
            'value', FALSE,
            'unit', 'TRUE_OR_FALSE') as expected_val,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(          AndroidStartupMetric_ActualValue(
            'value', TRUE) as actual_val,
          NULL as trace_slices,
          NULL as trace_threads,
          NULL as extra
        FROM android_startups launch
        WHERE launch.startup_id = $startup_id
          AND is_process_debuggable(launch.package)

        UNION ALL
        SELECT 'GC Activity' as slow_cause,
          launch.dur as launch_dur,
          'GC_ACTIVITY' as reason_id,
          AndroidStartupMetric_ThresholdValue(
            'value', FALSE,
            'unit', 'TRUE_OR_FALSE') as expected_val,
          AndroidStartupMetric_ActualValue(
            'value', TRUE) as actual_val,
          get_gc_activity(launch.startup_id, 1) as trace_slices,
          NULL as trace_threads,
          NULL as extra
        FROM android_startups launch
        WHERE launch.startup_id = $startup_id
          AND total_gc_time_by_launch(launch.startup_id) > 0

        UNION ALL
        SELECT 'dex2oat running during launch' AS slow_cause,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(          launch.dur as launch_dur,
          'DEX2OAT_RUNNING' as reason_id,
          AndroidStartupMetric_ThresholdValue(
            'value', FALSE,
            'unit', 'TRUE_OR_FALSE') as expected_val,
          AndroidStartupMetric_ActualValue(
            'value', TRUE) as actual_val,
          NULL as trace_slices,
          NULL as trace_threads,
          'Process: ' || get_process_running_concurrent_to_launch(launch.startup_id, '*dex2oat64')
            as extra
        FROM android_startups launch
        WHERE launch.startup_id = $startup_id AND
          dur_of_process_running_concurrent_to_launch(launch.startup_id, '*dex2oat64') > 0

        UNION ALL
        SELECT 'installd running during launch' AS slow_cause,
          launch.dur as launch_dur,
          'INSTALLD_RUNNING' as reason_id,
          AndroidStartupMetric_ThresholdValue(
            'value', FALSE,
            'unit', 'TRUE_OR_FALSE') as expected_val,
          AndroidStartupMetric_ActualValue(
            'value', TRUE) as actual_val,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(          NULL as trace_slices,
          NULL as trace_threads,
          'Process: ' || get_process_running_concurrent_to_launch(launch.startup_id, '*installd')
            as extra
        FROM android_startups launch
        WHERE launch.startup_id = $startup_id AND
          dur_of_process_running_concurrent_to_launch(launch.startup_id, '*installd') > 0

        UNION ALL
        SELECT 'Main Thread - Time spent in Runnable state' as slow_cause,
          launch.dur as launch_dur,
          'MAIN_THREAD_TIME_SPENT_IN_RUNNABLE' as reason_id,
          AndroidStartupMetric_ThresholdValue(
            'value', 15,
            'unit', 'PERCENTAGE',
            'higher_expected', FALSE) as expected_val,
          AndroidStartupMetric_ActualValue(
            'value',
              main_thread_time_for_launch_in_runnable_state(launch.startup_id) * 100 / launch.dur,
            'dur', main_thread_time_for_launch_in_runnable_state(launch.startup_id)) as actual_val,
          NULL as trace_slices,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(          get_main_thread_time_for_launch_in_runnable_state(launch.startup_id, 3) as trace_threads,
          NULL as extra
        FROM android_startups launch
        WHERE launch.startup_id = $startup_id
          AND main_thread_time_for_launch_in_runnable_state(launch.startup_id) > launch.dur * 0.15

        UNION ALL
        SELECT 'Main Thread - Time spent in interruptible sleep state' as slow_cause,
          launch.dur as launch_dur,
          'MAIN_THREAD_TIME_SPENT_IN_INTERRUPTIBLE_SLEEP' as reason_id,
          AndroidStartupMetric_ThresholdValue(
            'value', 2900000000,
            'unit', 'NS',
            'higher_expected', FALSE) as expected_val,
          AndroidStartupMetric_ActualValue(
            'value', main_thread_time_for_launch_and_state(launch.startup_id, 'S')) as actual_val,
          NULL as trace_slices,
          get_main_thread_time_for_launch_and_state(launch.startup_id, 'S', 3) as trace_threads,
          NULL as extra
        FROM android_startups launch
)_d3l1m1t3r_"
R"_d3l1m1t3r_(        WHERE launch.startup_id = $startup_id
          AND main_thread_time_for_launch_and_state(launch.startup_id, 'S') > 2900e6

        UNION ALL
        SELECT 'Main Thread - Time spent in Blocking I/O' as slow_cause,
          launch.dur as launch_dur,
          'MAIN_THREAD_TIME_SPENT_IN_BLOCKING_IO' as reason_id,
          AndroidStartupMetric_ThresholdValue(
            'value', 450000000,
            'unit', 'NS',
            'higher_expected', FALSE) as expected_val,
          AndroidStartupMetric_ActualValue(
            'value', main_thread_time_for_launch_state_and_io_wait(
              launch.startup_id, 'D*', TRUE)) as actual_val,
          NULL as trace_slices,
          get_main_thread_time_for_launch_state_and_io_wait(
            launch.startup_id, 'D*', TRUE, 3) as trace_threads,
          NULL as extra
        FROM android_startups launch
        WHERE launch.startup_id = $startup_id
          AND main_thread_time_for_launch_state_and_io_wait(launch.startup_id, 'D*', TRUE) > 450e6
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
        UNION ALL
        SELECT 'Main Thread - Time spent in OpenDexFilesFromOat*' as slow_cause,
          launch.dur as launch_dur,
          'MAIN_THREAD_TIME_SPENT_IN_OPEN_DEX_FILES_FROM_OAT' as reason_id,
          AndroidStartupMetric_ThresholdValue(
            'value', 20,
            'unit', 'PERCENTAGE',
            'higher_expected', FALSE) as expected_val,
          AndroidStartupMetric_ActualValue(
            'value', android_sum_dur_on_main_thread_for_startup_and_slice(
              launch.startup_id, 'OpenDexFilesFromOat*') * 100 / launch.dur,
            'dur', android_sum_dur_on_main_thread_for_startup_and_slice(
              launch.startup_id, 'OpenDexFilesFromOat*')) as actual_val,
          get_dur_on_main_thread_for_startup_and_slice(launch.startup_id, 'OpenDexFilesFromOat*', 3)
            as trace_slices,
          NULL as trace_threads,
          NULL as extra
        FROM android_startups launch
        WHERE launch.startup_id = $startup_id AND
          android_sum_dur_on_main_thread_for_startup_and_slice(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(          launch.startup_id, 'OpenDexFilesFromOat*') > launch.dur * 0.2

        UNION ALL
        SELECT 'Time spent in bindApplication' as slow_cause,
          launch.dur as launch_dur,
          'TIME_SPENT_IN_BIND_APPLICATION' as reason_id,
          AndroidStartupMetric_ThresholdValue(
            'value', 1250000000,
            'unit', 'NS',
            'higher_expected', FALSE) as expected_val,
          AndroidStartupMetric_ActualValue(
            'value', android_sum_dur_for_startup_and_slice(
              launch.startup_id, 'bindApplication')) as actual_val,
          get_dur_on_main_thread_for_startup_and_slice(launch.startup_id, 'bindApplication', 3)
            as trace_slices,
          NULL as trace_threads,
          NULL as extra
        FROM android_startups launch
        WHERE launch.startup_id = $startup_id
          AND android_sum_dur_for_startup_and_slice(launch.startup_id, 'bindApplication') > 1250e6

        UNION ALL
        SELECT 'Time spent in view inflation' as slow_cause,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(          launch.dur as launch_dur,
          'TIME_SPENT_IN_VIEW_INFLATION' as reason_id,
          AndroidStartupMetric_ThresholdValue(
            'value', 450000000,
            'unit', 'NS',
            'higher_expected', FALSE) as expected_val,
          AndroidStartupMetric_ActualValue(
            'value', android_sum_dur_for_startup_and_slice(
              launch.startup_id, 'inflate')) as actual_val,
          get_dur_on_main_thread_for_startup_and_slice(launch.startup_id, 'inflate', 3)
            as trace_slices,
          NULL as trace_threads,
          NULL as extra
        FROM android_startups launch
        WHERE launch.startup_id = $startup_id
          AND android_sum_dur_for_startup_and_slice(launch.startup_id, 'inflate') > 450e6

        UNION ALL
        SELECT 'Time spent in ResourcesManager#getResources' as slow_cause,
          launch.dur as launch_dur,
          'TIME_SPENT_IN_RESOURCES_MANAGER_GET_RESOURCES' as reason_id,
          AndroidStartupMetric_ThresholdValue(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(            'value', 130000000,
            'unit', 'NS',
            'higher_expected', FALSE) as expected_val,
          AndroidStartupMetric_ActualValue(
            'value', android_sum_dur_for_startup_and_slice(
              launch.startup_id, 'ResourcesManager#getResources')) as actual_val,
          get_dur_on_main_thread_for_startup_and_slice(
            launch.startup_id, 'ResourcesManager#getResources', 3) as trace_slices,
          NULL as trace_threads,
          NULL as extra
        FROM android_startups launch
        WHERE launch.startup_id = $startup_id
          AND android_sum_dur_for_startup_and_slice(
          launch.startup_id, 'ResourcesManager#getResources') > 130e6

        UNION ALL
        SELECT 'Time spent verifying classes' as slow_cause,
          launch.dur as launch_dur,
          'TIME_SPENT_VERIFYING_CLASSES' as reason_id,
          AndroidStartupMetric_ThresholdValue(
            'value', 15,
            'unit', 'PERCENTAGE',
            'higher_expected', FALSE) as expected_val,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(          AndroidStartupMetric_ActualValue(
            'value', android_sum_dur_for_startup_and_slice(
              launch.startup_id, 'VerifyClass*') * 100 / launch.dur,
            'dur', android_sum_dur_for_startup_and_slice(
              launch.startup_id, 'VerifyClass*')) as actual_val,
          get_dur_on_main_thread_for_startup_and_slice(launch.startup_id, 'VerifyClass*', 3)
            as trace_slices,
          NULL as trace_threads,
          NULL as extra
        FROM android_startups launch
        WHERE launch.startup_id = $startup_id AND
          android_sum_dur_for_startup_and_slice(launch.startup_id, 'VerifyClass*')
            > launch.dur * 0.15

        UNION ALL
        SELECT 'Potential CPU contention with another process' AS slow_cause,
          launch.dur as launch_dur,
          'POTENTIAL_CPU_CONTENTION_WITH_ANOTHER_PROCESS' as reason_id,
          AndroidStartupMetric_ThresholdValue(
            'value', 100000000,
            'unit', 'NS',
            'higher_expected', FALSE) as expected_val,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(          AndroidStartupMetric_ActualValue(
            'value',
              main_thread_time_for_launch_in_runnable_state(launch.startup_id)) as actual_val,
          NULL as trace_slices,
          get_main_thread_time_for_launch_in_runnable_state(launch.startup_id, 3) as trace_threads,
          NULL as extra
        FROM android_startups launch
        WHERE launch.startup_id = $startup_id AND
          main_thread_time_for_launch_in_runnable_state(launch.startup_id) > 100e6 AND
          most_active_process_for_launch(launch.startup_id) IS NOT NULL

        UNION ALL
        SELECT 'JIT Activity' as slow_cause,
          launch.dur as launch_dur,
          'JIT_ACTIVITY' as reason_id,
          AndroidStartupMetric_ThresholdValue(
            'value', 100000000,
            'unit', 'NS',
            'higher_expected', FALSE) as expected_val,
          AndroidStartupMetric_ActualValue(
            'value', thread_time_for_launch_state_and_thread(
              launch.startup_id, 'Running', 'Jit thread pool')) as actual_val,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(          NULL as trace_slices,
          get_thread_time_for_launch_state_and_thread(
            launch.startup_id, 'Running', 'Jit thread pool', 3) as trace_threads,
          NULL as extra
        FROM android_startups launch
        WHERE launch.startup_id = $startup_id
        AND thread_time_for_launch_state_and_thread(
          launch.startup_id,
          'Running',
          'Jit thread pool'
        ) > 100e6

        UNION ALL
        SELECT 'Main Thread - Lock contention' as slow_cause,
          launch.dur as launch_dur,
          'MAIN_THREAD_LOCK_CONTENTION' as reason_id,
          AndroidStartupMetric_ThresholdValue(
            'value', 20,
            'unit', 'PERCENTAGE',
            'higher_expected', FALSE) as expected_val,
          AndroidStartupMetric_ActualValue(
            'value', android_sum_dur_on_main_thread_for_startup_and_slice(
              launch.startup_id, 'Lock contention on*') * 100 / launch.dur,
            'dur', android_sum_dur_on_main_thread_for_startup_and_slice(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(              launch.startup_id, 'Lock contention on*')) as actual_val,
          get_dur_on_main_thread_for_startup_and_slice(launch.startup_id, 'lock contention on*', 3)
            as trace_slices,
          NULL as trace_threads,
          NULL as extra
        FROM android_startups launch
        WHERE launch.startup_id = $startup_id
          AND android_sum_dur_on_main_thread_for_startup_and_slice(
          launch.startup_id,
          'Lock contention on*'
        ) > launch.dur * 0.2

        UNION ALL
        SELECT 'Main Thread - Monitor contention' as slow_cause,
          launch.dur as launch_dur,
          'MAIN_THREAD_MONITOR_CONTENTION' as reason_id,
          AndroidStartupMetric_ThresholdValue(
            'value', 15,
            'unit', 'PERCENTAGE',
            'higher_expected', FALSE) as expected_val,
          AndroidStartupMetric_ActualValue(
            'value', android_sum_dur_on_main_thread_for_startup_and_slice(
              launch.startup_id, 'Lock contention on a monitor*') * 100 / launch.dur,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(            'dur', android_sum_dur_on_main_thread_for_startup_and_slice(
              launch.startup_id, 'Lock contention on a monitor*')) as actual_val,
          get_dur_on_main_thread_for_startup_and_slice(
            launch.startup_id, 'lock contention on a monitor*', 3) as trace_slices,
          NULL as trace_threads,
          NULL as extra
        FROM android_startups launch
        WHERE launch.startup_id = $startup_id
          AND android_sum_dur_on_main_thread_for_startup_and_slice(
            launch.startup_id,
            'Lock contention on a monitor*'
          ) > launch.dur * 0.15

        UNION ALL
        SELECT 'JIT compiled methods' as slow_cause,
          launch.dur as launch_dur,
          'JIT_COMPILED_METHODS' as reason_id,
          AndroidStartupMetric_ThresholdValue(
            'value', 65,
            'unit', 'COUNT',
            'higher_expected', FALSE) as expected_val,
          AndroidStartupMetric_ActualValue(
            'value', (SELECT COUNT(1)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(              FROM ANDROID_SLICES_FOR_STARTUP_AND_SLICE_NAME(launch.startup_id, 'JIT compiling*')
              WHERE thread_name = 'Jit thread pool')) as actual_val,
          get_slices_for_startup_and_slice_name(launch.startup_id, 'JIT compiling*', 3)
            as trace_slices,
          NULL as traced_threads,
          NULL as extra
        FROM android_startups launch
        WHERE launch.startup_id = $startup_id
          AND (
          SELECT COUNT(1)
          FROM ANDROID_SLICES_FOR_STARTUP_AND_SLICE_NAME(launch.startup_id, 'JIT compiling*')
          WHERE thread_name = 'Jit thread pool') > 65

        UNION ALL
        SELECT 'Broadcast dispatched count' as slow_cause,
          launch.dur as launch_dur,
          'BROADCAST_DISPATCHED_COUNT' as reason_id,
          AndroidStartupMetric_ThresholdValue(
            'value', 15,
            'unit', 'COUNT',
            'higher_expected', FALSE) as expected_val,
          AndroidStartupMetric_ActualValue(
            'value', count_slices_concurrent_to_launch(launch.startup_id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(              'Broadcast dispatched*')) as actual_val,
          get_slices_concurrent_to_launch(launch.startup_id, 'Broadcast dispatched*', 3)
            as trace_slices,
          NULL as trace_threads,
          NULL as extra
        FROM android_startups launch
        WHERE launch.startup_id = $startup_id
          AND count_slices_concurrent_to_launch(
          launch.startup_id,
          'Broadcast dispatched*') > 15

        UNION ALL
        SELECT 'Broadcast received count' as slow_cause,
          launch.dur as launch_dur,
          'BROADCAST_RECEIVED_COUNT' as reason_id,
          AndroidStartupMetric_ThresholdValue(
            'value', 50,
            'unit', 'COUNT',
            'higher_expected', FALSE) as expected_val,
          AndroidStartupMetric_ActualValue(
            'value', count_slices_concurrent_to_launch(launch.startup_id,
              'broadcastReceiveReg*')) as actual_val,
          get_slices_concurrent_to_launch(launch.startup_id, 'broadcastReceiveReg*', 3)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(            as trace_slices,
          NULL as trace_threads,
          NULL as extra
        FROM android_startups launch
        WHERE launch.startup_id = $startup_id
          AND count_slices_concurrent_to_launch(
            launch.startup_id,
            'broadcastReceiveReg*') > 50

        UNION ALL
        SELECT 'Startup running concurrent to launch' as slow_cause,
          launch.dur as launch_dur,
          'STARTUP_RUNNING_CONCURRENT' as reason_id,
          AndroidStartupMetric_ThresholdValue(
            'value', FALSE,
            'unit', 'TRUE_OR_FALSE') as expected_val,
          AndroidStartupMetric_ActualValue(
            'value', TRUE) as actual_val,
          NULL as trace_slices,
          NULL as trace_threads,
          'Package: ' || (
            SELECT package
            FROM android_startups l
            WHERE l.startup_id != launch.startup_id
              AND _is_spans_overlapping(l.ts, l.ts_end, launch.ts, launch.ts_end)
              LIMIT 1) as extra
)_d3l1m1t3r_"
R"_d3l1m1t3r_(        FROM android_startups launch
        WHERE launch.startup_id = $startup_id
          AND EXISTS(
          SELECT package
          FROM android_startups l
          WHERE l.startup_id != launch.startup_id
            AND _is_spans_overlapping(l.ts, l.ts_end, launch.ts, launch.ts_end))

        UNION ALL
        SELECT 'Main Thread - Binder transactions blocked' as slow_cause,
          launch.dur as launch_dur,
          'MAIN_THREAD_BINDER_TRANSCATIONS_BLOCKED' as reason_id,
          AndroidStartupMetric_ThresholdValue(
            'value', FALSE,
            'unit', 'TRUE_OR_FALSE') as expected_val,
          AndroidStartupMetric_ActualValue(
            'value', TRUE) as actual_val,
          get_main_thread_binder_transactions_blocked(launch.startup_id, 2e7, 3) as trace_slices,
          NULL as trace_threads,
          NULL as extra
        FROM android_startups launch
        WHERE launch.startup_id = $startup_id
          AND (
          SELECT COUNT(1)
          FROM BINDER_TRANSACTION_REPLY_SLICES_FOR_LAUNCH(launch.startup_id, 2e7)) > 0
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    );

)_d3l1m1t3r_"
;

const char kAndroidStartupSystemState[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- Functions useful for filling the SystemState proto which gives
-- context to what was happening on the system during a startup.

INCLUDE PERFETTO MODULE android.startup.startups;

-- Given a launch id and process name glob, returns the sched.dur if a process with
-- that name was running on a CPU concurrent to that launch.
CREATE OR REPLACE PERFETTO FUNCTION dur_of_process_running_concurrent_to_launch(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  startup_id INT,
  process_glob STRING
)
RETURNS INT AS
SELECT IFNULL(SUM(sched.dur), 0)
FROM sched
JOIN thread USING (utid)
JOIN process USING (upid)
JOIN (
  SELECT ts, ts_end
  FROM android_startups
  WHERE startup_id = $startup_id
) launch
WHERE
  process.name GLOB $process_glob AND
  sched.ts BETWEEN launch.ts AND launch.ts_end;

-- Given a launch id and slice name glob, returns the number of slices with that
-- name which start concurrent to that launch.
CREATE OR REPLACE PERFETTO FUNCTION count_slices_concurrent_to_launch(startup_id INT, slice_glob STRING)
RETURNS INT AS
SELECT COUNT(1)
FROM slice
JOIN (
  SELECT ts, ts_end
  FROM android_startups
  WHERE startup_id = $startup_id
) launch
WHERE
  slice.name GLOB $slice_glob AND
  slice.ts BETWEEN launch.ts AND launch.ts_end;

)_d3l1m1t3r_"
;

const char kAndroidStartupThreadStateBreakdown[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE android.startup.startups;

DROP VIEW IF EXISTS thread_state_extended;
CREATE PERFETTO VIEW thread_state_extended AS
SELECT
  ts,
  IIF(dur = -1, trace_end(), dur) AS dur,
  utid,
  state,
  io_wait
FROM thread_state;

DROP TABLE IF EXISTS launch_threads_by_thread_state;
CREATE VIRTUAL TABLE launch_threads_by_thread_state
USING SPAN_JOIN(
  android_startup_threads PARTITIONED utid,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  thread_state_extended PARTITIONED utid
);

-- Materialized to avoid repeatedly span joining per each thread state.
DROP TABLE IF EXISTS launch_thread_state_io_wait_dur_sum;
CREATE PERFETTO TABLE launch_thread_state_io_wait_dur_sum AS
SELECT startup_id, state, is_main_thread, thread_name, io_wait, SUM(dur) AS dur
FROM launch_threads_by_thread_state l
JOIN android_startup_processes p USING (startup_id)
WHERE
  -- If it is a main thread, only add it if it is the lauching thread.
  (is_main_thread AND p.startup_type NOT NULL)
  -- Allowlist specific threads which need this. Do not add to this list
  -- without careful consideration as every thread added here can cause
  -- memory usage to balloon.
  OR thread_name IN (
    'Jit thread pool'
  )
GROUP BY 1, 2, 3, 4, 5;

DROP VIEW IF EXISTS launch_thread_state_dur_sum;
CREATE PERFETTO VIEW launch_thread_state_dur_sum AS
SELECT startup_id, state, is_main_thread, thread_name, SUM(dur) AS dur
FROM launch_thread_state_io_wait_dur_sum
GROUP BY 1, 2, 3, 4;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Given a launch id and thread state value, returns the aggregate sum
-- of time spent in that state by the main thread of the process being started up.
CREATE OR REPLACE PERFETTO FUNCTION main_thread_time_for_launch_and_state(startup_id INT, state STRING)
RETURNS INT AS
SELECT SUM(dur)
FROM launch_thread_state_dur_sum l
WHERE l.startup_id = $startup_id AND state GLOB $state AND is_main_thread;

-- Given a launch id, returns the aggregate sum of time spent in runnable state
-- by the main thread of the process being started up.
CREATE OR REPLACE PERFETTO FUNCTION main_thread_time_for_launch_in_runnable_state(startup_id INT)
RETURNS INT AS
SELECT IFNULL(main_thread_time_for_launch_and_state($startup_id, "R"), 0)
      + IFNULL(main_thread_time_for_launch_and_state($startup_id, "R+"), 0);

-- Given a launch id, thread state  and io_wait value, returns the aggregate sum
-- of time spent in that state by the main thread of the process being started up.
CREATE OR REPLACE PERFETTO FUNCTION main_thread_time_for_launch_state_and_io_wait(startup_id INT, state STRING, io_wait BOOL)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(RETURNS INT AS
SELECT SUM(dur)
FROM launch_thread_state_io_wait_dur_sum l
WHERE l.startup_id = $startup_id AND state GLOB $state
  AND is_main_thread AND l.io_wait = $io_wait;


-- Given a launch id, thread state value and name of a thread, returns the aggregate sum
-- of time spent in that state by that thread. Note: only threads of the processes
-- being started are considered by this function - if a thread from a different name
-- happens to match the name passed, it will *not* be included.
CREATE OR REPLACE PERFETTO FUNCTION thread_time_for_launch_state_and_thread(startup_id INT, state STRING, thread_name STRING)
RETURNS INT AS
SELECT SUM(dur)
FROM launch_thread_state_dur_sum l
WHERE l.startup_id = $startup_id AND state GLOB $state AND thread_name = $thread_name;


-- Given a launch id, returns the duration between the launch and a running state thread of
-- startup process.
CREATE OR REPLACE PERFETTO FUNCTION time_to_running_state_for_launch(startup_id LONG)
RETURNS PROTO AS
  SELECT NULL_IF_EMPTY(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    STARTUP_SLICE_PROTO(
      IIF(MIN(l.ts) > launches.ts, MIN(l.ts) - launches.ts, NULL)))
  FROM launch_threads_by_thread_state l
  JOIN android_startups launches USING(startup_id)
  WHERE l.startup_id = $startup_id AND l.state = "Running";

)_d3l1m1t3r_"
;

const char kAndroidSysuiNotifShadeListBuilderMetric[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE android.slices;

SELECT RUN_METRIC('android/sysui_notif_shade_list_builder_slices.sql');

-- Get statics of all ShadeListBuilder.buildList slices
DROP TABLE IF EXISTS shade_list_builder_all;
CREATE PERFETTO TABLE shade_list_builder_all AS
SELECT
  s.name name,
  COUNT(s.name) AS count,
  cast(avg(dur) as int) average_dur_ns,
  max(dur) maximum_dur_ns,
  s.id id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM shade_list_builder_build_list_slices s
GROUP BY s.name;

-- Id of shade_list_builder slices that has a descendant of inflation
DROP VIEW IF EXISTS slices_id_with_inflation_descendants;
CREATE PERFETTO VIEW slices_id_with_inflation_descendants AS
SELECT DISTINCT id
  FROM slices_and_descendants
  WHERE
    descendant_name = 'HybridGroupManager#inflateHybridView' OR
    descendant_name = 'NotifChildCont#recreateHeader';

-- Id of shade_list_builder slices that has a descendant of ShadeNode modification
DROP VIEW IF EXISTS slices_id_with_modification_descendants;
CREATE PERFETTO VIEW slices_id_with_modification_descendants AS
SELECT DISTINCT id
  FROM slices_and_descendants
  WHERE
    descendant_name = 'ShadeNode#addChildAt' OR
    descendant_name = 'ShadeNode#removeChildAt' OR
    descendant_name = 'ShadeNode#moveChildTo';

DROP TABLE IF EXISTS shade_list_builder_slices_with_inflation;
CREATE PERFETTO TABLE shade_list_builder_slices_with_inflation AS
SELECT
  s.name || "_with_inflation" name,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  COUNT(s.name) AS count,
  cast(avg(dur) as int) average_dur_ns,
  max(dur) maximum_dur_ns
FROM shade_list_builder_build_list_slices s
WHERE s.id IN slices_id_with_inflation_descendants
GROUP BY s.name;

DROP TABLE IF EXISTS shade_list_builder_slices_with_modification;
CREATE PERFETTO TABLE shade_list_builder_slices_with_modification AS
SELECT
  s.name || "_with_node_modification" name,
  COUNT(s.name) AS count,
  cast(avg(dur) as int) average_dur_ns,
  max(dur) maximum_dur_ns
FROM shade_list_builder_build_list_slices s
WHERE s.id IN slices_id_with_modification_descendants
GROUP BY s.name;


DROP VIEW IF EXISTS sysui_notif_shade_list_builder_metric_output;
CREATE PERFETTO VIEW sysui_notif_shade_list_builder_metric_output AS
SELECT SysuiNotifShadeListBuilderMetric(
        'all_slices_performance', (
            SELECT SysUiSlicePerformanceStatisticalData(
                'name', a.name,
                'cnt', a.count,
                'avg_dur_ms', cast (a.average_dur_ns / 1000000 as int),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(                'max_dur_ms', cast (a.maximum_dur_ns / 1000000 as int),
                'avg_dur_ns', a.average_dur_ns,
                'max_dur_ns', a.maximum_dur_ns
            )
            FROM shade_list_builder_all a
        ),
        'slices_with_inflation_performance', (
            SELECT SysUiSlicePerformanceStatisticalData(
                'name', a.name,
                'cnt', a.count,
                'avg_dur_ms', cast (a.average_dur_ns / 1000000 as int),
                'max_dur_ms', cast (a.maximum_dur_ns / 1000000 as int),
                'avg_dur_ns', a.average_dur_ns,
                'max_dur_ns', a.maximum_dur_ns
            )
            FROM shade_list_builder_slices_with_inflation a
        ),
        'slices_with_modification_performance', (
            SELECT SysUiSlicePerformanceStatisticalData(
                'name', a.name,
                'cnt', a.count,
                'avg_dur_ms', cast (a.average_dur_ns / 1000000 as int),
                'max_dur_ms', cast (a.maximum_dur_ns / 1000000 as int),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(                'avg_dur_ns', a.average_dur_ns,
                'max_dur_ns', a.maximum_dur_ns
            )
            FROM shade_list_builder_slices_with_modification a
        ),
        'slice', (
            SELECT RepeatedField(
                SysuiNotifShadeListBuilderMetric_SliceDuration(
                    'name', a.name,
                    'dur_ms', cast (a.dur / 1000000 as int),
                    'dur_ns', a.dur
                )
            )
            FROM shade_list_builder_build_list_slices a
            ORDER BY dur DESC
        )
);
)_d3l1m1t3r_"
;

const char kAndroidSysuiNotifShadeListBuilderSlices[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE android.slices;

-- Table of ShadeListBuilder.buildList slices
DROP TABLE IF EXISTS shade_list_builder_build_list_slices;
CREATE PERFETTO TABLE shade_list_builder_build_list_slices AS
SELECT
  s.name name,
  dur,
  s.id id
FROM slice s
  JOIN thread_track ON thread_track.id = s.track_id
  JOIN thread USING (utid)
WHERE
  thread.is_main_thread AND
  s.dur > 0 AND (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    s.name GLOB 'ShadeListBuilder.buildList'
  );

-- Table of ShadeListBuilder.buildList slices with the descendants
DROP TABLE IF EXISTS slices_and_descendants;
CREATE PERFETTO TABLE slices_and_descendants AS
SELECT
  parent.name name,
  descendant.name descendant_name,
  parent.dur dur_ns,
  parent.id id
FROM shade_list_builder_build_list_slices parent
LEFT JOIN descendant_slice(parent.id) AS descendant;
)_d3l1m1t3r_"
;

const char kAndroidSysuiUpdateNotifOnUiModeChangedMetric[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE android.slices;

-- Table of updateNotifOnUiModeChanged slices
DROP TABLE IF EXISTS sysui_update_notif_on_ui_mode_changed_slices;
CREATE PERFETTO TABLE sysui_update_notif_on_ui_mode_changed_slices AS
SELECT
  s.name name,
  dur,
  s.id id
FROM slice s
  JOIN thread_track ON thread_track.id = s.track_id
  JOIN thread USING (utid)
WHERE
  thread.is_main_thread AND
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  s.dur > 0 AND (
    s.name GLOB 'updateNotifOnUiModeChanged'
  );

-- Table of updateNotifOnUiModeChanged slices statistical performance information
DROP TABLE IF EXISTS sysui_update_notif_on_ui_mode_changed_metric;
CREATE PERFETTO TABLE sysui_update_notif_on_ui_mode_changed_metric AS
SELECT
  s.name name,
  COUNT(s.name) AS count,
  cast(avg(dur) as int) average_dur_ns,
  max(dur) maximum_dur_ns
FROM sysui_update_notif_on_ui_mode_changed_slices s
GROUP BY s.name;

DROP VIEW IF EXISTS sysui_update_notif_on_ui_mode_changed_metric_output;
CREATE PERFETTO VIEW sysui_update_notif_on_ui_mode_changed_metric_output AS
SELECT SysuiUpdateNotifOnUiModeChangedMetric(
        'all_slices_performance', (
            SELECT SysUiSlicePerformanceStatisticalData(
                'name', a.name,
                'cnt', a.count,
                'avg_dur_ms', cast (a.average_dur_ns / 1000000 as int),
                'max_dur_ms', cast (a.maximum_dur_ns / 1000000 as int),
                'avg_dur_ns', a.average_dur_ns,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(                'max_dur_ns', a.maximum_dur_ns
            )
            FROM sysui_update_notif_on_ui_mode_changed_metric a
        ),
        'slice', (
            SELECT RepeatedField(
                SysuiUpdateNotifOnUiModeChangedMetric_SliceDuration(
                    'name', a.name,
                    'dur_ms', cast (a.dur / 1000000 as int),
                    'dur_ns', a.dur
                )
            )
            FROM sysui_update_notif_on_ui_mode_changed_slices a
            ORDER BY dur DESC
        )
);
)_d3l1m1t3r_"
;

const char kAndroidUnsymbolizedFrames[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- On Linux/Android perfetto profilers (heapprofd, traced_perf) record the
-- .note.gnu.build-id as build_id. Within Google, this can be used as a lookup
-- key for most cases, but not for Chrome/Webview. Chrome is special and stores
-- symbols indexed by "breadkpad module ID". Breakpad module ID can be derived
-- with the following formula:
--      base::StrCat({module_id->substr(6, 2), module_id->substr(4, 2),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(--                    module_id->substr(2, 2), module_id->substr(0, 2),
--                    module_id->substr(10, 2), module_id->substr(8, 2),
--                    module_id->substr(14, 2), module_id->substr(12, 2),
--                    module_id->substr(16, 16), "0"});
-- See also https://source.chromium.org/chromium/chromium/src/+/main:services/tracing/public/cpp/stack_sampling/tracing_sampler_profiler.cc;l=603;drc=cba00174ca338153b9c4f0c31ddbabaac7dd38c7
-- Note that in SQL SUBSTR() indexes are 1-based, not 0 based.
DROP VIEW IF EXISTS mangled_stack_profile_mapping;
CREATE PERFETTO VIEW mangled_stack_profile_mapping AS
SELECT
  id,
  name,
  build_id,
  CASE ((name GLOB '*libmonochrome_64.so'
    OR name GLOB '*libchrome.so'
    OR name GLOB '*libmonochrome.so'
    OR name GLOB '*libwebviewchromium.so'
    OR name GLOB '*libchromium_android_linker.so'
  ) AND length(build_id) >= 40)
  WHEN 0 THEN build_id
  ELSE (
    SUBSTR(build_id, 7, 2)
    || SUBSTR(build_id, 5, 2)
    || SUBSTR(build_id, 3, 2)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    || SUBSTR(build_id, 1, 2)
    || SUBSTR(build_id, 11, 2)
    || SUBSTR(build_id, 9, 2)
    || SUBSTR(build_id, 15, 2)
    || SUBSTR(build_id, 13, 2)
    || SUBSTR(build_id, 17, 16)
    || '0')
  END AS google_lookup_id
FROM stack_profile_mapping;

DROP VIEW IF EXISTS unsymbolized_frames_view;
CREATE PERFETTO VIEW unsymbolized_frames_view AS
SELECT UnsymbolizedFrames_Frame(
    'module', spm.name,
    'build_id', spm.build_id,
    'address', spf.rel_pc,
    'google_lookup_id', spm.google_lookup_id
) AS frame_proto
FROM stack_profile_frame spf
JOIN mangled_stack_profile_mapping spm
  ON spf.mapping = spm.id
WHERE spm.build_id != ''
  AND spf.symbol_set_id IS NULL;

DROP VIEW IF EXISTS unsymbolized_frames_output;
CREATE PERFETTO VIEW unsymbolized_frames_output AS
SELECT UnsymbolizedFrames(
  'frames',
  (SELECT RepeatedField(frame_proto) FROM unsymbolized_frames_view)
);

)_d3l1m1t3r_"
;

const char kChromeActualPowerByCategory[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the 'License');
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an 'AS IS' BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- This is a templated metric that takes 3 parameters:
-- input: name of a table/view which must have columns: id, ts, dur and a
--   "category" column
-- output: name of the view that will be created
-- category: name of the category column in the input table, which will be
--   preserved in the output

SELECT RUN_METRIC('chrome/chrome_processes.sql');
SELECT RUN_METRIC('android/power_drain_in_watts.sql');
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- SPAN_JOIN does not yet support non-integer partitions so add an integer
-- column that corresponds to the power rail name.
DROP TABLE IF EXISTS power_rail_name_mapping;
CREATE PERFETTO TABLE power_rail_name_mapping AS
SELECT DISTINCT name,
  ROW_NUMBER() OVER() AS idx
FROM drain_in_watts;

DROP VIEW IF EXISTS mapped_drain_in_watts;
CREATE PERFETTO VIEW mapped_drain_in_watts AS
SELECT d.name, ts, dur, drain_w, idx
FROM drain_in_watts d
JOIN power_rail_name_mapping p ON d.name = p.name;

DROP TABLE IF EXISTS real_{{input}}_power;
CREATE VIRTUAL TABLE real_{{input}}_power USING SPAN_JOIN(
  {{input}},
  mapped_drain_in_watts PARTITIONED idx
);

-- Actual power usage for chrome across the categorised slices contained in the
-- input table broken down by subsystem.
DROP VIEW IF EXISTS {{output}};
CREATE PERFETTO VIEW {{output}} AS
SELECT s.id,
  ts,
  dur,
  {{category}},
  subsystem,
  joules,
  joules / dur * 1e9 AS drain_w
FROM (
    SELECT id,
      subsystem,
      SUM(drain_w * dur / 1e9) AS joules
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    FROM real_{{input}}_power
    JOIN power_counters
    WHERE real_{{input}}_power.name = power_counters.name
    GROUP BY id,
      subsystem
  ) p
JOIN {{input}} s
WHERE s.id = p.id
ORDER BY s.id;

SELECT id,
  subsystem,
  SUM(drain_w * dur / 1e9) AS joules
FROM real_{{input}}_power
JOIN power_counters
WHERE real_{{input}}_power.name = power_counters.name
GROUP BY id,
  subsystem;

)_d3l1m1t3r_"
;

const char kChromeActualPowerByRailMode[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the 'License');
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an 'AS IS' BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

SELECT RUN_METRIC('chrome/rail_modes.sql');

-- Creates a view called real_power_by_rail_mode, containing the actual power
-- usage for chrome broken down by RAIL Mode (subdivided by subsystem).
SELECT RUN_METRIC(
    'chrome/actual_power_by_category.sql',
    'input', 'combined_overall_rail_slices',
    'output', 'real_power_by_rail_mode',
    'category', 'rail_mode'
  );

)_d3l1m1t3r_"
;

const char kChromeChromeArgsClassNames[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Creates a table view with a list of class names with a specific key
-- from the "args" table per |package_name| & |version_code|.
-- |package_name| and |version_code| can be NULL.

DROP VIEW IF EXISTS chrome_args_class_names_per_version;
CREATE PERFETTO VIEW chrome_args_class_names_per_version AS
WITH class_info AS (
  SELECT
    package_list.package_name AS package_name,
    package_list.version_code AS version_code,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    RepeatedField(args.string_value) AS class_names
  FROM args
  JOIN slice
    ON args.arg_set_id = slice.arg_set_id
      AND args.flat_key = 'android_view_dump.activity.view.class_name'
  JOIN thread_track
    ON slice.track_id = thread_track.id
  JOIN thread
    ON thread_track.utid = thread.utid
  JOIN process
    ON thread.upid = process.upid
  LEFT JOIN package_list
    ON process.uid = package_list.uid
  GROUP BY package_name, version_code
)
SELECT
  ChromeArgsClassNames_ChromeArgsClassNamesPerVersion(
    'package_name', package_name,
    'version_code', version_code,
    'class_name', class_names
  ) AS class_names_per_version
FROM class_info;

DROP VIEW IF EXISTS chrome_args_class_names_output;
CREATE PERFETTO VIEW chrome_args_class_names_output
AS
SELECT
  ChromeArgsClassNames(
    'class_names_per_version', RepeatedField(class_names_per_version)
  )
FROM chrome_args_class_names_per_version;

)_d3l1m1t3r_"
;

const char kChromeChromeEventMetadata[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the 'License');
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an 'AS IS' BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- Creates a view containing name-value pairs extracted from
-- chrome_event.metadata. Some names can have multiple values:
-- e.g. trace-category
DROP VIEW IF EXISTS chrome_event_metadata;
CREATE PERFETTO VIEW chrome_event_metadata AS
WITH metadata (arg_set_id) AS (
  SELECT arg_set_id
  FROM raw
  WHERE name = "chrome_event.metadata"
)
-- TODO(b/173201788): Once this is fixed, extract all the fields.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT 'os-name' AS name,
  EXTRACT_ARG(metadata.arg_set_id, 'os-name') AS value
FROM metadata
UNION
SELECT "trace-category" AS name,
  value AS category
FROM metadata, json_each(
    json_extract(
      EXTRACT_ARG(metadata.arg_set_id, "trace-config"),
      '$.included_categories'
    )
  );

)_d3l1m1t3r_"
;

const char kChromeChromeHistogramHashes[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

DROP VIEW IF EXISTS chrome_histogram_hashes_output;

CREATE PERFETTO VIEW chrome_histogram_hashes_output AS
SELECT ChromeHistogramHashes(
  'hash', (
    SELECT RepeatedField(int_value)
    FROM args
    WHERE key = 'chrome_histogram_sample.name_hash'
    ORDER BY int_value
  )
);

)_d3l1m1t3r_"
;

const char kChromeChromeInputToBrowserIntervals[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
-- WARNING: This metric should not be used as a source of truth. It is under
--          active development and the values & meaning might change without
--          notice.

-- The final table includes the time between the arrival of gesture update
-- input timestamp, and the time it started being processed by CrBrowserMain.

SELECT RUN_METRIC(
  'chrome/chrome_input_to_browser_intervals_template.sql',
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  'slice_table_name', 'slice',
  'function_prefix', ''
);

)_d3l1m1t3r_"
;

const char kChromeChromeInputToBrowserIntervalsBase[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
-- WARNING: This metric should not be used as a source of truth. It is under
--          active development and the values & meaning might change without
--          notice.

-- Given a slice id of an event, get timestamp of the most recent flow
-- event on the Chrome IO thread that preceded this slice.
-- This helps us identify the last flow event on the IO thread before
-- letting the browser main thread be aware of input.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- We need this for flings (generated by the GPU process) and blocked
-- touch moves that are forwarded from the renderer.
-- Returning the slice id for the flow_out on the chrome IO thread.
CREATE OR REPLACE PERFETTO FUNCTION {{function_prefix}}PRECEDING_IO_THREAD_EVENT_FLOW_ID(id LONG)
RETURNS LONG AS
SELECT MAX(flow.slice_out) AS id
FROM PRECEDING_FLOW(($id)) flow;

-- Returns a Chrome task which contains the given slice.
CREATE OR REPLACE PERFETTO FUNCTION {{function_prefix}}GET_ENCLOSING_CHROME_TASK_NAME(
  slice_id LONG
)
RETURNS STRING AS
SELECT
  task.name
FROM ancestor_slice($slice_id)
JOIN chrome_tasks task USING (id)
LIMIT 1;

CREATE OR REPLACE PERFETTO FUNCTION {{function_prefix}}GET_SCROLL_TYPE(
  blocked_gesture BOOL,
  task_name STRING
)
RETURNS STRING AS
SELECT
  CASE WHEN ($blocked_gesture)
  THEN (SELECT
          CASE WHEN ($task_name) glob "viz.mojom.BeginFrameObserver *"
          THEN "fling"
          WHEN ($task_name) glob "blink.mojom.WidgetInputHandler *"
          THEN "blocking_touch_move"
)_d3l1m1t3r_"
R"_d3l1m1t3r_(          ELSE "unknown" END)
  ELSE "regular" END AS delay_type;

-- Get all InputLatency::GestureScrollUpdate events, to use their
-- flows later on to decide how much time we waited from queueing the event
-- until we started processing it.
DROP VIEW IF EXISTS chrome_valid_gesture_updates;
CREATE PERFETTO VIEW chrome_valid_gesture_updates
AS
SELECT
  name,
  EXTRACT_ARG(
    arg_set_id, 'chrome_latency_info.trace_id') AS trace_id,
  ts,
  id,
  dur
FROM
  {{slice_table_name}}
WHERE
  name = 'InputLatency::GestureScrollUpdate'
  AND EXTRACT_ARG(
    arg_set_id, "chrome_latency_info.is_coalesced")
  = 0
ORDER BY trace_id;

-- Get all chrome_latency_info_for_gesture_slices where trace_ids are not -1,
-- as those are faulty, then join with the GestureScrollUpdate table to get
-- only slices associated with update events.
DROP VIEW IF EXISTS chrome_flow_slices_for_gestures;
CREATE PERFETTO VIEW chrome_flow_slices_for_gestures
AS
SELECT
  s.ts,
  EXTRACT_ARG(
    s.arg_set_id, 'chrome_latency_info.trace_id') AS trace_id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  s.arg_set_id,
  s.id,
  s.track_id,
  s.dur
FROM
  {{slice_table_name}} s
JOIN chrome_valid_gesture_updates
  ON
    chrome_valid_gesture_updates.trace_id = EXTRACT_ARG(
      s.arg_set_id, 'chrome_latency_info.trace_id')
    AND s.ts >= chrome_valid_gesture_updates.ts
    AND s.ts + s.dur
    <= chrome_valid_gesture_updates.ts + chrome_valid_gesture_updates.dur
WHERE
  s.name = 'LatencyInfo.Flow'
  AND trace_id != -1;

-- Tie chrome_latency_info_for_gesture_slices slices to processes to avoid
-- calculating intervals per process as multiple chrome instances can be up
-- on system traces.
DROP VIEW IF EXISTS chrome_flow_slices_for_gestures_tied_process;
CREATE PERFETTO VIEW chrome_flow_slices_for_gestures_tied_process
AS
SELECT
  ts,
  trace_id,
  arg_set_id,
  chrome_flow_slices_for_gestures.id,
  dur,
  thread.upid
FROM
  chrome_flow_slices_for_gestures
JOIN thread_track ON chrome_flow_slices_for_gestures.track_id = thread_track.id
JOIN thread ON thread_track.utid = thread.utid
  AND is_main_thread;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Index all flows per trace_id, to get the first flow event per input
-- GestureScrollUpdate, this will later be used to calculate the time
-- from receiving input to the first flow event appearing.
DROP TABLE IF EXISTS chrome_indexed_flow_per_gesture;
CREATE PERFETTO TABLE chrome_indexed_flow_per_gesture
AS
SELECT
  ts,
  trace_id,
  arg_set_id,
  id,
  ROW_NUMBER()
  OVER (
    PARTITION BY trace_id, upid
    ORDER BY
      ts ASC
  ) AS flow_order,
  upid,
  dur
FROM
  chrome_flow_slices_for_gestures_tied_process;

-- TODO(b/235067134) all the previous views including this one are
-- reimplementations of gesture_jank.sql with less restrictions, let's
-- merge both of them into one script or make this script a base for the
-- other.
-- Get the first flow event per gesture.
DROP VIEW IF EXISTS chrome_first_flow_per_gesture;
CREATE PERFETTO VIEW chrome_first_flow_per_gesture
AS
SELECT
  *
FROM
  chrome_indexed_flow_per_gesture
WHERE
  flow_order = 1;

-- The decision for processing on the browser main thread for a frame can be
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- instant, or delayed by the renderer in cases where the renderer needs to
-- decide whether the touch move is an ScrollUpdate or not, and in other cases
-- for flings, the scroll itself will be generated by the viz compositor thread
-- on each vsync interval.
DROP VIEW IF EXISTS chrome_categorized_first_flow_events;
CREATE PERFETTO VIEW chrome_categorized_first_flow_events
AS
SELECT
  *,
  NOT COALESCE((
    SELECT
      COUNT()
    FROM
      ancestor_slice(chrome_first_flow_per_gesture.id) ancestor_slices
    WHERE
      -- sendTouchEvent means the event wasn't delayed by the renderer
      -- and is not a fling generated by the viz compositor thread(GPU process).
      ancestor_slices.name = "sendTouchEvent"
  )
  = 1, FALSE) AS blocked_gesture
FROM
  chrome_first_flow_per_gesture;

-- For cases where it's not blocked, get the timestamp of input as the
-- beginning of time we theoretically could have started processing
-- the input event, which is the timestamp of the GestureScrollUpdate event
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- otherwise fall back to the top level slice to check the timestamp
-- of it's calling flow
DROP VIEW IF EXISTS chrome_input_to_browser_interval_slice_ids;
CREATE PERFETTO VIEW chrome_input_to_browser_interval_slice_ids
AS
SELECT
  chrome_categorized_first_flow_events.id AS window_end_id,
  chrome_categorized_first_flow_events.ts AS window_end_ts,
  -- If blocked, get the flow_out slice's timestamp as our beginning
  -- given that the flow_in is coming to our toplevel parent task
  CASE
    WHEN blocked_gesture
      THEN
      {{function_prefix}}PRECEDING_IO_THREAD_EVENT_FLOW_ID(chrome_categorized_first_flow_events.id)
    ELSE
      -- TODO(b/236590359): is selecting here better or join and ordering by?
      -- Let's benchmark and modify accordingly.
      (
        SELECT
          chrome_gestures.id
        FROM
          chrome_valid_gesture_updates chrome_gestures
        WHERE
          chrome_gestures.trace_id = chrome_categorized_first_flow_events.trace_id
          AND chrome_gestures.ts <= chrome_categorized_first_flow_events.ts
)_d3l1m1t3r_"
R"_d3l1m1t3r_(          AND chrome_gestures.ts + chrome_gestures.dur >= chrome_categorized_first_flow_events.ts
          + chrome_categorized_first_flow_events.dur
      )
  END AS window_start_id,
  blocked_gesture,
  upid
FROM
  chrome_categorized_first_flow_events;
)_d3l1m1t3r_"
;

const char kChromeChromeInputToBrowserIntervalsTemplate[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
-- WARNING: This metric should not be used as a source of truth. It is under
--          active development and the values & meaning might change without
--          notice.

-- The final table includes the time between the arrival of gesture update
-- input timestamp, and the time it started being processed by CrBrowserMain.

INCLUDE PERFETTO MODULE chrome.tasks;

SELECT RUN_METRIC(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  'chrome/chrome_input_to_browser_intervals_base.sql',
  'slice_table_name', '{{slice_table_name}}',
  'function_prefix', '{{function_prefix}}'
);

DROP TABLE IF EXISTS chrome_input_to_browser_intervals;
CREATE PERFETTO TABLE chrome_input_to_browser_intervals
AS
SELECT
  (SELECT ts FROM {{slice_table_name}} WHERE id = window_start_id) AS window_start_ts,
  window_start_id,
  window_end_ts,
  window_end_id,
  blocked_gesture,
  upid,
  {{function_prefix}}GET_SCROLL_TYPE(blocked_gesture, {{function_prefix}}GET_ENCLOSING_CHROME_TASK_NAME(window_end_id)) AS scroll_type
FROM chrome_input_to_browser_interval_slice_ids;

)_d3l1m1t3r_"
;

const char kChromeChromeLongTasks[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
-- WARNING: This metric should not be used as a source of truth. It is under
--          active development and the values & meaning might change without
--          notice.

INCLUDE PERFETTO MODULE chrome.tasks;

-- Extract mojo information for the long-task-tracking scenario for specific
-- names. For example, LongTaskTracker slices may have associated IPC
-- metadata, or InterestingTask slices for input may have associated IPC to
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- determine whether the task is fling/etc.
CREATE OR REPLACE PERFETTO FUNCTION select_long_task_slices(name STRING)
RETURNS TABLE(
  interface_name STRING,
  ipc_hash INT,
  message_type STRING,
  id INT,
  task_name STRING)
AS
WITH slices_with_mojo_data AS (
  SELECT
      EXTRACT_ARG(
        arg_set_id,
        "chrome_mojo_event_info.mojo_interface_tag"
      ) AS interface_name,
      EXTRACT_ARG(
        arg_set_id,
        "chrome_mojo_event_info.ipc_hash"
      ) AS ipc_hash,
      CASE
        WHEN EXTRACT_ARG(arg_set_id, "chrome_mojo_event_info.is_reply") THEN "reply"
        ELSE "message"
      END AS message_type,
      id
  FROM slice
  WHERE
    category GLOB "*scheduler.long_tasks*"
    AND name = $name
)
SELECT
  *,
  printf("%s %s(hash=%s)", interface_name, message_type, ipc_hash) as task_name
FROM slices_with_mojo_data;

CREATE OR REPLACE PERFETTO FUNCTION is_long_choreographer_task(dur LONG)
RETURNS BOOL AS
SELECT $dur >= 4 * 1e6;

-- Note that not all slices will be mojo slices; filter on interface_name IS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- NOT NULL for mojo slices specifically.
DROP TABLE IF EXISTS long_tasks_extracted_slices;
CREATE PERFETTO TABLE long_tasks_extracted_slices AS
SELECT * FROM SELECT_LONG_TASK_SLICES(/*name*/'LongTaskTracker');

-- Create |long_tasks_internal_tbl| table, which gathers all of the
-- information needed to produce the full name + metadata required
-- for LongTaskTracker slices. Unlike toplevel slices, which will
-- have nested descendants, LongTaskTracker slices will store all of
-- the relevant information within the single slice.
DROP TABLE IF EXISTS long_tasks_internal_tbl;
CREATE PERFETTO TABLE long_tasks_internal_tbl AS
WITH
  raw_extracted_values AS (
    SELECT
      mojo.id,
      mojo.interface_name,
      mojo.ipc_hash,
      mojo.message_type,
      _get_posted_from(s.arg_set_id) as posted_from
    FROM long_tasks_extracted_slices mojo
    JOIN slice s ON mojo.id = s.id
  )
SELECT
  id,
  CASE
    WHEN interface_name IS NOT NULL
      THEN printf('%s %s (hash=%d)', interface_name, message_type, ipc_hash)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    ELSE
      _format_scheduler_task_name(posted_from)
    END AS full_name,
  interface_name IS NOT NULL AS is_mojo
FROM raw_extracted_values;

-- Attach java views to its associated LongTaskTracker slice, as they
-- will be on different tracks. This follows the same logic as creating
-- chrome_slices_with_java_views_internal, differing only in how a
-- descendent is calculated.
DROP VIEW IF EXISTS long_task_slices_with_java_views;
CREATE PERFETTO VIEW long_task_slices_with_java_views AS
WITH
  -- Select UI thread BeginMainFrames frames.
  root_slices AS (
    SELECT *
    FROM _SELECT_BEGIN_MAIN_FRAME_JAVA_SLICES('LongTaskTracker')
    UNION ALL
    SELECT id, "Choreographer" as kind, ts, dur, name
    FROM slice
    WHERE is_long_choreographer_task(dur)
      AND name GLOB "Looper.dispatch: android.view.Choreographer$FrameHandler*"
  ),
  -- Intermediate step to allow us to sort java view names.
  root_slice_and_java_view_not_grouped AS (
    SELECT
      s1.id, s1.kind, s2.name AS java_view_name
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    FROM root_slices s1
    JOIN _chrome_java_views s2
      ON (
        s1.ts < s2.ts AND s1.ts + s1.dur > s2.ts + s2.dur)
  )
SELECT
  s1.id,
  s1.kind,
  GROUP_CONCAT(DISTINCT s2.java_view_name) AS java_views
FROM root_slices s1
LEFT JOIN root_slice_and_java_view_not_grouped s2
  USING (id)
GROUP BY s1.id;

DROP VIEW IF EXISTS chrome_long_tasks_internal;
CREATE PERFETTO VIEW chrome_long_tasks_internal AS
WITH -- Generate full names for tasks with java views.
  java_views_tasks AS (
    SELECT
      printf('%s(java_views=%s)', kind, java_views) as full_name,
      _get_java_views_task_type(kind) AS task_type,
      id
    FROM long_task_slices_with_java_views
    WHERE kind = "SingleThreadProxy::BeginMainFrame"
  ),
  scheduler_tasks_with_mojo AS (
    SELECT
      full_name,
      'mojo' as task_type,
      id
    FROM long_tasks_internal_tbl
    WHERE is_mojo
  ),
  navigation_tasks AS (
    SELECT
      -- NOTE: unless Navigation category is enabled and recorded on the same
      -- track as the LongTaskTracker slice, frame type will always be unknown.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      printf('%s (%s)',
        _human_readable_navigation_task_name(full_name),
        IFNULL(_extract_frame_type(id), 'unknown frame type')) AS full_name,
      'navigation_task' AS task_type,
      id
    FROM scheduler_tasks_with_mojo
    WHERE _human_readable_navigation_task_name(full_name) IS NOT NULL
  )
SELECT
  COALESCE(s4.full_name, s3.full_name, s2.full_name, s1.full_name) AS full_name,
  COALESCE(s4.task_type, s3.task_type, s2.task_type, 'scheduler') as task_type,
  s1.id as id
FROM long_tasks_internal_tbl s1
LEFT JOIN scheduler_tasks_with_mojo s2 ON s2.id = s1.id
LEFT JOIN java_views_tasks s3 ON s3.id = s1.id
LEFT JOIN navigation_tasks s4 ON s4.id = s1.id
UNION ALL
-- Choreographer slices won't necessarily be associated with an overlying
-- LongTaskTracker slice, so join them separately.
SELECT
  printf('%s(java_views=%s)', kind, java_views) as full_name,
  _get_java_views_task_type(kind) AS task_type,
  id
FROM long_task_slices_with_java_views
WHERE kind = "Choreographer";
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
DROP VIEW IF EXISTS chrome_long_tasks;
CREATE PERFETTO VIEW chrome_long_tasks AS
SELECT
  full_name,
  task_type,
  thread.name AS thread_name,
  thread.utid,
  process.name AS process_name,
  thread.upid,
  ts.*
FROM chrome_long_tasks_internal cti
JOIN slice ts USING (id)
JOIN thread_track tt ON ts.track_id = tt.id
JOIN thread USING (utid)
JOIN process USING (upid);

)_d3l1m1t3r_"
;

const char kChromeChromeLongTasksDelayingInputProcessing[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
-- WARNING: This metric should not be used as a source of truth. It is under
--          active development and the values & meaning might change without
--          notice.

SELECT RUN_METRIC(
  'chrome/chrome_long_tasks.sql'
);

-- Input tasks/flows are recorded almost the same way as they are in top-level
-- slices, however the input task will not necessarily be a parent of the
-- latencyInfo slice. As such, we can utilize much of the existing input to
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- browser interval base calculations. Determining whether an input is a fling
-- or other blocked input will need to be calculated differently, below.
SELECT RUN_METRIC(
  'chrome/chrome_input_to_browser_intervals_base.sql',
  'slice_table_name', 'slice',
  'function_prefix', ''
);

-- Needed for calculating chrome input to browser intervals.
-- Input IPCs are not necessarily always long tasks, hence a new slice name.
DROP TABLE IF EXISTS chrome_input_to_browser_intervals_long_tasks;
CREATE PERFETTO TABLE chrome_input_to_browser_intervals_long_tasks
AS
SELECT
  (SELECT ts FROM slice WHERE id = window_start_id) AS window_start_ts,
  window_start_id,
  window_end_ts,
  window_end_id,
  blocked_gesture,
  cis.upid,
  GET_SCROLL_TYPE(blocked_gesture, lts.task_name) AS scroll_type
FROM chrome_input_to_browser_interval_slice_ids cis
LEFT JOIN (
  SELECT
    m.task_name,
    m.id,
    upid,
    s.ts,
    s.dur
  FROM
    SELECT_LONG_TASK_SLICES('InterestingTask_ProcessingTime') m
    JOIN slice s USING(id)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    JOIN thread_track tt ON s.track_id = tt.id JOIN thread USING (utid)
) lts
ON cis.upid = lts.upid
  AND (cis.window_end_ts > lts.ts AND cis.window_end_ts <= lts.ts + dur);

-- Calculating chrome tasks delaying input will be the same, just using the
-- long-task based tables instead of chrome_tasks.
SELECT RUN_METRIC(
  'chrome/chrome_tasks_delaying_input_processing_base.sql',
  'duration_causing_jank_ms', '4',
  'task_table_name', 'chrome_long_tasks',
  'input_browser_interval_table_name', 'chrome_input_to_browser_intervals_long_tasks',
  'function_prefix', ''
);
)_d3l1m1t3r_"
;

const char kChromeChromePerformanceMarkHashes[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

DROP VIEW IF EXISTS chrome_performance_mark_hashes_output;

CREATE PERFETTO VIEW chrome_performance_mark_hashes_output AS
SELECT ChromePerformanceMarkHashes(
  'site_hash', (
    SELECT RepeatedField(int_value)
    FROM args
    WHERE key = 'chrome_hashed_performance_mark.site_hash'
    ORDER BY int_value
  ),
  'mark_hash', (
    SELECT RepeatedField(int_value)
    FROM args
    WHERE key = 'chrome_hashed_performance_mark.mark_hash'
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    ORDER BY int_value
  )
);

)_d3l1m1t3r_"
;

const char kChromeChromeProcesses[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- Table to map any of the various chrome process names to a type (e.g. Browser,
-- Renderer, GPU Process, etc).
DROP VIEW IF EXISTS all_chrome_processes;
CREATE PERFETTO VIEW all_chrome_processes AS
SELECT upid, IFNULL(pt.string_value, '') AS process_type
FROM process
-- A process is a Chrome process if it has a chrome.process_type arg.
-- The value of the arg may be NULL.
-- All Chromium producers emit chrome_process field in their process track
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- descriptor when Chromium track event data source is enabled.
-- So this returns all processes in Chrome traces, and a subset of processes
-- in system traces.
JOIN
  (SELECT arg_set_id, string_value FROM args WHERE key = 'chrome.process_type')
  pt
  ON process.arg_set_id = pt.arg_set_id;

-- A view of all Chrome threads.
DROP VIEW IF EXISTS all_chrome_threads;
CREATE PERFETTO VIEW all_chrome_threads AS
SELECT utid, thread.upid, thread.name
FROM thread, all_chrome_processes
WHERE thread.upid = all_chrome_processes.upid;

-- For sandboxed and privileged processes (found in Android system traces), use
-- the main thread name to type of process.
DROP VIEW IF EXISTS chrome_subprocess_types;
CREATE PERFETTO VIEW chrome_subprocess_types AS
-- Sometimes you can get multiple threads in a trace marked main_thread, but
-- they appear to have the same name so just use one of them.
SELECT DISTINCT p.upid,
  SUBSTR(t.name, 3, LENGTH(t.name) - 6) AS sandbox_type
FROM all_chrome_processes p
JOIN all_chrome_threads t ON p.upid = t.upid
)_d3l1m1t3r_"
R"_d3l1m1t3r_(WHERE process_type IN ("Sandboxed", "Privileged")
  AND t.name GLOB "Cr*Main";

-- Contains all the chrome processes from process with an extra column,
-- process_type.
DROP VIEW IF EXISTS chrome_process;
CREATE PERFETTO VIEW chrome_process AS
SELECT PROCESS.*,
  IIF(sandbox_type IS NULL, process_type, sandbox_type) AS process_type
FROM PROCESS
JOIN (
    SELECT a.upid,
      sandbox_type,
      process_type
    FROM all_chrome_processes a
    LEFT JOIN chrome_subprocess_types s ON a.upid = s.upid
  ) c ON PROCESS.upid = c.upid;

-- Contains all the chrome threads from thread with an extra column,
-- canonical_name, that should contain a thread that's the same in both chrome
-- and system traces.
DROP VIEW IF EXISTS chrome_thread;

CREATE PERFETTO VIEW chrome_thread AS
SELECT thread.*,
  CASE
    WHEN thread.name GLOB "Cr*Main" THEN "CrProcessMain"
    WHEN thread.name IS NULL THEN "Unknown"
    ELSE thread.name
  END AS canonical_name
FROM (
    SELECT t.utid,
      p.*
    FROM all_chrome_threads t
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    JOIN chrome_process p ON t.upid = p.upid
  ) c
JOIN thread ON thread.utid = c.utid;

)_d3l1m1t3r_"
;

const char kChromeChromeReliableRange[] = R"_d3l1m1t3r_(-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- The "reliable range" is defined as follows:
-- 1. If a thread_track has a first_packet_on_sequence flag, the thread data is reliable for the
--    entire duration of the trace.
-- 2. Otherwise, the thread data is reliable from the first thread event till the end of the trace.
-- 3. The "reliable range" is an intersection of reliable thread ranges for all threads such that:
--   a. The number of events on the thread is at or above 25p.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(--   b. The event rate for the thread is at or above 75p.
-- Note: this metric considers only chrome processes and their threads, i.e. the ones coming
-- from track_event's.

-- Extracts an int value with the given name from the metadata table.
CREATE OR REPLACE PERFETTO FUNCTION _extract_int_metadata(
  -- The name of the metadata entry.
  name STRING)
-- int_value for the given name. NULL if there's no such entry.
RETURNS LONG AS
SELECT int_value FROM metadata WHERE name = ($name);

DROP VIEW IF EXISTS chrome_event_stats_per_thread;

CREATE PERFETTO VIEW chrome_event_stats_per_thread
AS
SELECT
  COUNT(*) AS cnt, CAST(COUNT(*) AS DOUBLE) / (MAX(ts + dur) - MIN(ts)) AS rate, utid
FROM thread_track
JOIN slice
  ON thread_track.id = slice.track_id
WHERE EXTRACT_ARG(source_arg_set_id, 'source') = 'descriptor'
GROUP BY utid;

DROP VIEW IF EXISTS chrome_event_cnt_cutoff;

-- Ignore the bottom 25% of threads by event count. 25% is a somewhat arbitrary number. It creates a
-- cutoff at around 10 events for a typical trace, and threads with fewer events are usually:
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- 1. Not particularly interesting for the reliable range definition.
-- 2. Create a lot of noise for other metrics, such as event rate.
CREATE PERFETTO VIEW chrome_event_cnt_cutoff
AS
SELECT cnt
FROM
  chrome_event_stats_per_thread
ORDER BY
  cnt
LIMIT
  1
  OFFSET(
    (SELECT COUNT(*) FROM chrome_event_stats_per_thread) / 4);

DROP VIEW IF EXISTS chrome_event_rate_cutoff;

-- Choose the top 25% event rate. 25% is a somewhat arbitrary number. The goal is to strike
-- balance between not cropping too many events and making sure that the chance of data loss in the
-- range declared "reliable" is low.
CREATE PERFETTO VIEW chrome_event_rate_cutoff
AS
SELECT rate
FROM
  chrome_event_stats_per_thread
ORDER BY
  rate
LIMIT
  1
  OFFSET(
    (SELECT COUNT(*) FROM chrome_event_stats_per_thread) * 3 / 4);

DROP VIEW IF EXISTS chrome_reliable_range_per_thread;

-- This view includes only threads with event count and rate above the cutoff points defined
-- above.
-- See b/239830951 for the analysis showing why we don't want to include all threads here
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- (TL;DR - it makes the "reliable range" too short for a typical trace).
CREATE PERFETTO VIEW chrome_reliable_range_per_thread
AS
SELECT
  utid,
  MIN(ts) AS start,
  MAX(IFNULL(EXTRACT_ARG(source_arg_set_id, 'has_first_packet_on_sequence'), 0))
  AS has_first_packet_on_sequence
FROM thread_track
JOIN slice
  ON thread_track.id = slice.track_id
WHERE
  utid IN (
    SELECT utid
    FROM chrome_event_stats_per_thread
    LEFT JOIN chrome_event_cnt_cutoff
      ON 1
    LEFT JOIN chrome_event_rate_cutoff
      ON 1
    WHERE
      chrome_event_stats_per_thread.cnt >= chrome_event_cnt_cutoff.cnt
      AND chrome_event_stats_per_thread.rate >= chrome_event_rate_cutoff.rate
  )
GROUP BY utid;

-- Finds Browser and Renderer processes with a missing main thread. If there
-- is such a process, the trace definitely has thread data loss, and no part
-- of the trace is trustworthy/reliable.
-- As of Jan 2023, all tracing scenarios emit some data from the Browser and
-- Renderer main thread (assuming that the corresponding process is present).
)_d3l1m1t3r_"
R"_d3l1m1t3r_(DROP VIEW IF EXISTS chrome_processes_with_missing_main;

CREATE PERFETTO VIEW chrome_processes_with_missing_main
AS
SELECT
  upid
FROM (
  SELECT upid, utid
  FROM process
  LEFT JOIN
    -- We can't use is_main_thread column for Chrome traces - Renderer
    -- processes have is_main_thread = 0 for the logical main thread.
    (SELECT utid, upid FROM thread WHERE thread.name GLOB '*[Mm]ain*')
  USING (upid)
  WHERE
    EXTRACT_ARG(process.arg_set_id, 'chrome.process_type')
      IN ('Browser', 'Renderer', 'Gpu')
)
WHERE utid is NULL;

DROP VIEW IF EXISTS chrome_processes_data_loss_free_period;

CREATE PERFETTO VIEW chrome_processes_data_loss_free_period
AS
SELECT
  upid AS limiting_upid,
  -- If reliable_from is NULL, the process has data loss until the end of the trace.
  IFNULL(reliable_from, (SELECT MAX(ts + dur) FROM slice)) AS start
FROM
  (
    SELECT upid, reliable_from
    FROM experimental_missing_chrome_processes
    UNION ALL
    -- A missing main thread means that the process data is unreliable for the
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    -- entire duration of the trace.
    SELECT upid, NULL AS reliable_from
    FROM chrome_processes_with_missing_main
  )
ORDER BY start DESC
LIMIT 1;

DROP VIEW IF EXISTS chrome_reliable_range;

CREATE PERFETTO VIEW chrome_reliable_range
AS
SELECT
  -- If the trace has a cropping packet, we don't want to recompute the reliable
  -- based on cropped track events - the result might be incorrect.
  IFNULL(_extract_int_metadata('range_of_interest_start_us') * 1000,
         MAX(thread_start, data_loss_free_start)) AS start,
  IIF(_extract_int_metadata('range_of_interest_start_us') IS NOT NULL,
      'Range of interest packet',
      IIF(limiting_upid IN (SELECT upid FROM chrome_processes_with_missing_main),
          'Missing main thread for upid=' || limiting_upid,
          IIF(thread_start >= data_loss_free_start,
              'First slice for utid=' || limiting_utid,
               'Missing process data for upid=' || limiting_upid))) AS reason,
  limiting_upid AS debug_limiting_upid,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  limiting_utid AS debug_limiting_utid
FROM
  (SELECT
    COALESCE(MAX(start), 0) AS thread_start,
    utid AS limiting_utid,
    COALESCE((SELECT start FROM chrome_processes_data_loss_free_period), 0) AS data_loss_free_start,
    (SELECT limiting_upid FROM chrome_processes_data_loss_free_period) AS limiting_upid
    FROM chrome_reliable_range_per_thread
    WHERE has_first_packet_on_sequence = 0);

)_d3l1m1t3r_"
;

const char kChromeChromeScrollInputsPerFrame[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- This metric calculates the number of user inputs during a scroll per frame
-- generated, this can be used to track smoothness.
-- For normal input, we expect 2 inputs per frame, for flings, we expect
-- 1 input per frame as flings are generated once per vsync.
-- The numbers mentioned above are estimates in the ideal case scenario.

INCLUDE PERFETTO MODULE chrome.scroll_jank.utils;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(INCLUDE PERFETTO MODULE common.slices;

-- Grab all GestureScrollUpdate slices.
DROP VIEW IF EXISTS chrome_all_scroll_updates;
CREATE PERFETTO VIEW chrome_all_scroll_updates AS
SELECT
  S.id,
  chrome_get_most_recent_scroll_begin_id(ts) AS scroll_id,
  has_descendant_slice_with_name(S.id, "SubmitCompositorFrameToPresentationCompositorFrame")
  AS is_presented,
  ts,
  dur,
  track_id
FROM slice S JOIN args USING(arg_set_id)
WHERE NAME = "EventLatency"
AND args.string_value GLOB "*GESTURE_SCROLL_UPDATE";

-- Count number of input GestureScrollUpdates per scroll.
DROP VIEW IF EXISTS chrome_update_count_per_scroll;
CREATE PERFETTO VIEW chrome_update_count_per_scroll AS
SELECT
  CAST(COUNT() AS FLOAT) AS count,
  scroll_id,
  dur,
  track_id
FROM chrome_all_scroll_updates
GROUP BY scroll_id;

-- Count the number of input GestureScrollUpdates that were converted
-- frames per scroll.
DROP VIEW IF EXISTS chrome_presented_update_count_per_scroll;
CREATE PERFETTO VIEW chrome_presented_update_count_per_scroll AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  CAST(COUNT() AS FLOAT) AS presented_count,
  scroll_id,
  id,
  track_id,
  dur
FROM chrome_all_scroll_updates
WHERE is_presented
GROUP BY scroll_id;

-- Get the average number of inputs per frame per scroll.
DROP VIEW IF EXISTS chrome_avg_scroll_inputs_per_frame;
CREATE PERFETTO VIEW chrome_avg_scroll_inputs_per_frame AS
SELECT
  count / presented_count AS avg_inputs_per_frame_per_scroll,
  scroll_id,
  presented_count
FROM chrome_presented_update_count_per_scroll
JOIN chrome_update_count_per_scroll USING(scroll_id);

-- Get the last scroll update event that wasn't coalesced before the
-- current scroll update.
DROP VIEW IF EXISTS chrome_frame_main_input_id;
CREATE PERFETTO VIEW chrome_frame_main_input_id AS
SELECT
  id,
  scroll_id,
  is_presented,
  ts,
  dur,
  track_id,
  (SELECT
    MAX(id)
    FROM chrome_all_scroll_updates parent_scrolls
    WHERE is_presented
      AND parent_scrolls.ts <= scrolls.ts) AS presented_scroll_id
FROM chrome_all_scroll_updates scrolls;

-- Count the number of inputs per presented frame.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(DROP VIEW IF EXISTS chrome_scroll_inputs_per_frame;
CREATE PERFETTO VIEW chrome_scroll_inputs_per_frame AS
SELECT
  COUNT() AS count_for_frame,
  presented_scroll_id,
  ts,
  dur,
  id AS slice_id,
  track_id
FROM
  chrome_frame_main_input_id
GROUP BY presented_scroll_id;

)_d3l1m1t3r_"
;

const char kChromeChromeScrollJankCausedByScheduling[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

SELECT RUN_METRIC('chrome/chrome_input_to_browser_intervals.sql');

-- Script params:
-- {{dur_causes_jank_ms}} : The duration of a task barrage on the Chrome
-- main thread that will delay input causing jank.

-- Filter intervals to only durations longer than {{dur_causes_jank_ms}}.
DROP VIEW IF EXISTS chrome_input_to_browser_longer_intervals;
CREATE PERFETTO VIEW chrome_input_to_browser_longer_intervals AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  *
FROM chrome_input_to_browser_intervals
WHERE
  (window_end_ts - window_start_ts) >= {{dur_causes_jank_ms}} * 1e6;

-- Assign tasks to each delay interval that we could have started
-- processing input but didn't on the main thread, and sum those
-- tasks.
-- We filter java out here as we're interested in tasks that delayed
-- yielding to java native work, and we filter tasks that are more
-- than 8ms here as those are handled separately and are not regarded
-- as scheduling issues.
DROP VIEW IF EXISTS chrome_task_barrages_per_interval;
CREATE PERFETTO VIEW chrome_task_barrages_per_interval AS
SELECT
  GROUP_CONCAT(DISTINCT full_name) AS full_name,
  SUM(dur / 1e6) AS total_duration_ms,
  SUM(thread_dur / 1e6) AS total_thread_duration_ms,
  MIN(id) AS first_id_per_task_barrage,
  MAX(id) AS last_id_per_task_barrage,
  COUNT(*) AS count,
  window_start_id,
  window_start_ts,
  window_end_id,
  window_end_ts,
  scroll_type
FROM
  (
    SELECT * FROM (
      SELECT
        chrome_tasks.full_name AS full_name,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(        chrome_tasks.dur AS dur,
        chrome_tasks.thread_dur AS thread_dur,
        chrome_tasks.ts AS ts,
        chrome_tasks.id,
        chrome_tasks.upid
      FROM
        chrome_tasks
      WHERE
        chrome_tasks.thread_name = "CrBrowserMain"
        AND task_type != "java"
        AND task_type != "choreographer"
      ORDER BY chrome_tasks.ts
    ) tasks
    JOIN chrome_input_to_browser_longer_intervals
      ON (tasks.ts + tasks.dur)
        > chrome_input_to_browser_longer_intervals.window_start_ts
        AND (tasks.ts + tasks.dur)
        < chrome_input_to_browser_longer_intervals.window_end_ts
        AND tasks.ts > chrome_input_to_browser_longer_intervals.window_start_ts
        AND tasks.ts < chrome_input_to_browser_longer_intervals.window_end_ts
        -- For cases when there are multiple chrome instances.
        AND tasks.upid = chrome_input_to_browser_longer_intervals.upid
    ORDER BY window_start_ts, window_end_ts
  )
GROUP BY window_start_ts, window_end_ts;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Filter to task barrages that took more than 8ms, as barrages
-- that lasted less than that are unlikely to have caused jank.
DROP VIEW IF EXISTS chrome_scroll_jank_caused_by_scheduling;
CREATE PERFETTO VIEW chrome_scroll_jank_caused_by_scheduling AS
SELECT *
FROM chrome_task_barrages_per_interval
WHERE total_duration_ms > {{dur_causes_jank_ms}} AND count > 1
ORDER BY total_duration_ms DESC;

)_d3l1m1t3r_"
;

const char kChromeChromeScrollJankV3[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE chrome.scroll_jank.scroll_jank_v3;

DROP VIEW IF EXISTS chrome_scroll_jank_v3_intermediate;

-- An "intermediate" view for computing `chrome_scroll_jank_v3_output` below.
--
-- @column trace_num_frames          The number of frames in the trace.
-- @column trace_num_janky_frames    The number of delayed/janky frames in the
--                                   trace.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column vsync_interval            The standard vsync interval.
-- @column scrolls                   A proto amalgamation of metrics per scroll
--                                   including the number of frames, number of
--                                   janky frames, percent of janky frames,
--                                   maximum presentation delay, and the causes
--                                   of jank (cause, sub-cause, delay).
CREATE PERFETTO VIEW chrome_scroll_jank_v3_intermediate AS
SELECT
  -- MAX does not matter for these aggregations, since the values are the
  -- same across rows.
  (SELECT COUNT(*) FROM chrome_frame_info_with_delay)
    AS trace_num_frames,
  (SELECT COUNT(*) FROM chrome_janky_frames)
    AS trace_num_janky_frames,
  causes.vsync_interval,
  RepeatedField(
    ChromeScrollJankV3_Scroll(
      'num_frames',
      frames.num_frames,
      'num_janky_frames',
      frames.num_janky_frames,
      'scroll_jank_percentage',
      frames.scroll_jank_percentage,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      'max_delay_since_last_frame',
      causes.max_delay_since_last_frame,
      'scroll_jank_causes',
      causes.scroll_jank_causes))
    AS scrolls
FROM
  chrome_frames_per_scroll AS frames
INNER JOIN chrome_causes_per_scroll AS causes
  ON frames.scroll_id = causes.scroll_id;

DROP VIEW IF EXISTS chrome_scroll_jank_v3_output;

-- For producing a "native" Perfetto UI metric.
--
-- @column scroll_jank_summary     A proto amalgamation summarizing all of the
--                                 scroll jank in a trace, including the number
--                                 of frames, janky frames, percentage of janky
--                                 frames, vsync interval, and a summary of this
--                                 data (including individual causes) for each
--                                 scroll.
CREATE PERFETTO VIEW chrome_scroll_jank_v3_output AS
SELECT
  ChromeScrollJankV3(
    'trace_num_frames',
    trace_num_frames,
    'trace_num_janky_frames',
    trace_num_janky_frames,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'trace_scroll_jank_percentage',
    100.0 * trace_num_janky_frames / trace_num_frames,
    'vsync_interval_ms',
    vsync_interval,
    'scrolls',
    scrolls) AS scroll_jank_summary
FROM
  chrome_scroll_jank_v3_intermediate;

)_d3l1m1t3r_"
;

const char kChromeChromeSliceNames[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.


DROP VIEW IF EXISTS chrome_slice_names_output;

CREATE PERFETTO VIEW chrome_slice_names_output AS
SELECT ChromeSliceNames(
  'chrome_version_code', (
    SELECT RepeatedField(int_value)
    FROM metadata
    WHERE name GLOB 'cr-*playstore_version_code'
    ORDER BY int_value
  ),
  'slice_name', (
    SELECT RepeatedField(DISTINCT(name))
    FROM slice
    WHERE name IS NOT NULL
    ORDER BY name
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  )
);

)_d3l1m1t3r_"
;

const char kChromeChromeStackSamplesForTask[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- Params:
-- @target_duration_ms: find stack samples on tasks that are longer than
-- this value

-- @thread_name: thread name to look for stack samples on

-- @task_name: a task name following chrome_tasks.sql naming convention to
-- find stack samples on.

INCLUDE PERFETTO MODULE chrome.tasks;

CREATE OR REPLACE PERFETTO FUNCTION describe_symbol(symbol STRING, frame_name STRING)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(RETURNS STRING AS
SELECT COALESCE($symbol,
  CASE WHEN demangle($frame_name) IS NULL
  THEN $frame_name
  ELSE demangle($frame_name)
  END);

-- Get all Chrome tasks that match a specific name on a specific thread.
-- The timestamps for those tasks are going to be used later on to gather
-- information about stack traces that were collected during running them.
DROP VIEW IF EXISTS chrome_targeted_task;
CREATE PERFETTO VIEW chrome_targeted_task AS
SELECT
  chrome_tasks.full_name AS full_name,
  chrome_tasks.dur AS dur,
  chrome_tasks.ts AS ts,
  chrome_tasks.id AS id,
  utid AS utid
FROM
  chrome_tasks
WHERE
  chrome_tasks.dur >= {{target_duration_ms}} * 1e6
  AND chrome_tasks.thread_name = {{thread_name}}
  AND chrome_tasks.full_name = {{task_name}};


-- Get all frames attached to callsite ids, as frames can be
-- reused between stack frames, callsite ids are unique per
-- stack sample.
DROP VIEW IF EXISTS chrome_non_symbolized_frames;
CREATE PERFETTO VIEW chrome_non_symbolized_frames AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  frames.name AS frame_name,
  callsite.id AS callsite_id,
  *
FROM
  stack_profile_frame frames
JOIN stack_profile_callsite callsite
  ON callsite.frame_id = frames.id;

-- Only lowest child frames are join-able with chrome_non_symbolized_frames
-- which we need for the time at which the callstack was taken.
DROP VIEW IF EXISTS chrome_symbolized_child_frames;
CREATE PERFETTO VIEW chrome_symbolized_child_frames AS
SELECT
  thread.name AS thread_name,
  sample.utid AS sample_utid,
  *
FROM
  chrome_non_symbolized_frames frames
JOIN cpu_profile_stack_sample sample USING(callsite_id)
JOIN thread USING(utid)
JOIN process USING(upid);

-- Not all frames are symbolized, in cases where those frames
-- are not symbolized, use the file name as it is usually descriptive
-- of the function.
DROP VIEW IF EXISTS chrome_thread_symbolized_child_frames;
CREATE PERFETTO VIEW chrome_thread_symbolized_child_frames AS
SELECT
  describe_symbol(symbol.name, frame_name) AS description,
  depth,
  ts,
  callsite_id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  sample_utid
FROM chrome_symbolized_child_frames
LEFT JOIN stack_profile_symbol symbol USING(symbol_set_id)
WHERE thread_name = {{thread_name}} ORDER BY ts DESC;

-- Since only leaf stack frames have a timestamp, let's export this
-- timestamp to all it's ancestor frames to use it later on for
-- filtering frames within specific windows
DROP VIEW IF EXISTS chrome_non_symbolized_frames_timed;
CREATE PERFETTO VIEW chrome_non_symbolized_frames_timed AS
SELECT
  chrome_non_symbolized_frames.frame_name,
  chrome_non_symbolized_frames.depth,
  chrome_thread_symbolized_child_frames.ts,
  chrome_thread_symbolized_child_frames.sample_utid,
  chrome_non_symbolized_frames.callsite_id,
  symbol_set_id,
  chrome_non_symbolized_frames.frame_id
FROM chrome_thread_symbolized_child_frames
JOIN experimental_ancestor_stack_profile_callsite(
    chrome_thread_symbolized_child_frames.callsite_id) child
JOIN chrome_non_symbolized_frames
  ON chrome_non_symbolized_frames.callsite_id = child.id;

DROP VIEW IF EXISTS chrome_frames_timed_and_symbolized;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO VIEW chrome_frames_timed_and_symbolized AS
SELECT
  describe_symbol(symbol.name, frame_name) AS description,
  ts,
  depth,
  callsite_id,
  sample_utid
FROM chrome_non_symbolized_frames_timed
LEFT JOIN stack_profile_symbol symbol
  USING(symbol_set_id)
ORDER BY DEPTH ASC;

-- Union leaf stack frames with all stack frames after the timestamp
-- is attached to get a view of all frames timestamped.
DROP VIEW IF EXISTS all_frames;
CREATE PERFETTO VIEW all_frames AS
SELECT
  *
FROM
  (SELECT
    * FROM
    chrome_frames_timed_and_symbolized
    UNION
    SELECT
      description,
      ts,
      depth,
      callsite_id,
      sample_utid
    FROM chrome_thread_symbolized_child_frames)
ORDER BY depth ASC;

-- Filter stack samples that happened only during the specified
-- task on the specified thread.
DROP VIEW IF EXISTS chrome_stack_samples_for_task;
CREATE PERFETTO VIEW chrome_stack_samples_for_task AS
SELECT
  all_frames.*
FROM
  all_frames JOIN
  chrome_targeted_task ON
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    all_frames.sample_utid = chrome_targeted_task.utid
    AND all_frames.ts >= chrome_targeted_task.ts
    AND all_frames.ts <= chrome_targeted_task.ts + chrome_targeted_task.dur;

)_d3l1m1t3r_"
;

const char kChromeChromeTasks[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- Compat layer for old clients.
-- TODO(altimin): Remove it once everyone uses stdlib directly.
INCLUDE PERFETTO MODULE chrome.tasks;

)_d3l1m1t3r_"
;

const char kChromeChromeTasksDelayingInputProcessing[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Script params:
-- {{duration_causing_jank_ms}} : The duration of a single task that would cause
-- jank, by delaying input from being handled on the main thread.

SELECT RUN_METRIC(
  'chrome/chrome_tasks_delaying_input_processing_template.sql',
  'duration_causing_jank_ms', '{{duration_causing_jank_ms}}',
  'slice_table_name', 'slice',
  'function_prefix', ''
);

)_d3l1m1t3r_"
;

const char kChromeChromeTasksDelayingInputProcessingBase[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Script params:
-- {{duration_causing_jank_ms}} : The duration of a single task that would cause
-- jank, by delaying input from being handled on the main thread.
-- {{task_table_name}} : The table tracking chrome tasks which will be used to
-- determine which chrome tasks are causing the delay. One of chrome_tasks or
-- chrome_long_tasks.
-- {{input_browser_interval_table_name}} : The table tracking chrome input to
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- browser interval. This may differ based on whether the scenario is for
-- topLevel events or LongTask events.

CREATE OR REPLACE PERFETTO FUNCTION {{function_prefix}}SELECT_SLOW_BROWSER_TASKS()
RETURNS TABLE(full_name STRING, dur INT, ts INT, id INT, upid INT, thread_dur INT) AS
SELECT
  task_table.full_name AS full_name,
  task_table.dur AS dur,
  task_table.ts AS ts,
  task_table.id AS id,
  task_table.upid AS upid,
  thread_dur
FROM
  {{task_table_name}} task_table
WHERE
  task_table.dur >= {{duration_causing_jank_ms}} * 1e6
  AND task_table.thread_name = "CrBrowserMain";

-- Get the tasks that was running for more than 8ms within windows
-- that we could have started processing input but did not on the
-- main thread, because it was blocked by those tasks.
DROP VIEW IF EXISTS chrome_tasks_delaying_input_processing_unaggregated;
CREATE PERFETTO VIEW chrome_tasks_delaying_input_processing_unaggregated AS
SELECT
  tasks.full_name AS full_name,
  tasks.dur / 1e6 AS duration_ms,
  id AS slice_id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  thread_dur / 1e6 AS thread_dur_ms,
  input_tbl.window_start_id,
  input_tbl.window_end_id
FROM ({{function_prefix}}SELECT_SLOW_BROWSER_TASKS()) tasks
JOIN {{input_browser_interval_table_name}} input_tbl
  ON tasks.ts + tasks.dur > input_tbl.window_start_ts
    AND tasks.ts + tasks.dur < input_tbl.window_end_ts
    AND tasks.upid = input_tbl.upid;

-- Same task can delay multiple GestureUpdates, this step dedups
-- multiple occrences of the same slice_id
DROP VIEW IF EXISTS chrome_tasks_delaying_input_processing;
CREATE PERFETTO VIEW chrome_tasks_delaying_input_processing AS
SELECT
  full_name,
  duration_ms,
  slice_id,
  thread_dur_ms
FROM chrome_tasks_delaying_input_processing_unaggregated
GROUP BY slice_id;

-- Get the tasks that were running for more than 8ms within windows
-- that we could have started processing input but did not on the
-- main thread, because it was blocked by those tasks.
DROP VIEW IF EXISTS chrome_tasks_delaying_input_processing_summary;
CREATE PERFETTO VIEW chrome_tasks_delaying_input_processing_summary AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  full_name AS full_name,
  AVG(duration_ms) AS avg_duration_ms,
  AVG(thread_dur_ms) AS avg_thread_duration_ms,
  MIN(duration_ms) AS min_task_duration,
  MAX(duration_ms) AS max_task_duration,
  SUM(duration_ms) AS total_duration_ms,
  SUM(thread_dur_ms) AS total_thread_duration_ms,
  GROUP_CONCAT(slice_id, '-') AS slice_ids,
  COUNT(*) AS count
FROM
  chrome_tasks_delaying_input_processing
GROUP BY
  full_name;

)_d3l1m1t3r_"
;

const char kChromeChromeTasksDelayingInputProcessingTemplate[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Script params:
-- {{duration_causing_jank_ms}} : The duration of a single task that would cause
-- jank, by delaying input from being handled on the main thread.

SELECT RUN_METRIC(
  'chrome/chrome_input_to_browser_intervals_template.sql',
  'slice_table_name', '{{slice_table_name}}',
  'function_prefix', '{{function_prefix}}'
);

SELECT RUN_METRIC(
  'chrome/chrome_tasks_delaying_input_processing_base.sql',
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  'duration_causing_jank_ms', '{{duration_causing_jank_ms}}',
  'task_table_name', 'chrome_tasks',
  'input_browser_interval_table_name', 'chrome_input_to_browser_intervals',
  'function_prefix', '{{function_prefix}}'
);

)_d3l1m1t3r_"
;

const char kChromeChromeThreadSlice[] = R"_d3l1m1t3r_(--
-- Copyright 2021 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

SELECT RUN_METRIC('chrome/chrome_processes.sql');

-- Grab all the thread tracks which are found in chrome threads.
DROP VIEW IF EXISTS chrome_track;
CREATE PERFETTO VIEW chrome_track AS
SELECT
  *
FROM thread_track
WHERE utid IN (SELECT utid FROM chrome_thread);

-- From all the chrome thread tracks select all the slice details for thread
-- slices.
DROP VIEW IF EXISTS chrome_thread_slice;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO VIEW chrome_thread_slice AS
SELECT
  slice.*
FROM
  slice JOIN
  chrome_track ON
    chrome_track.id = slice.track_id
WHERE
  track_id IN (SELECT id FROM chrome_track);

)_d3l1m1t3r_"
;

const char kChromeChromeUnsymbolizedArgs[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- To get mangled stack profile mappings.
SELECT RUN_METRIC('android/unsymbolized_frames.sql');

DROP VIEW IF EXISTS chrome_unsymbolized_args_view;

CREATE PERFETTO VIEW chrome_unsymbolized_args_view AS
SELECT ChromeUnsymbolizedArgs_Arg(
    'module', spm.name,
    'build_id', spm.build_id,
    'address', unsymbolized_arg.rel_pc,
    'google_lookup_id', spm.google_lookup_id
) AS arg_proto
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM
  (
    SELECT arg_rel_pc.rel_pc AS rel_pc, arg_mapping_id.mapping_id AS mapping_id
    FROM
      (
        SELECT arg_set_id, int_value AS rel_pc
        FROM args
        WHERE key = "chrome_mojo_event_info.mojo_interface_method.native_symbol.rel_pc"
      ) arg_rel_pc
    JOIN
      (
        SELECT
          arg_set_id,
          int_value AS mapping_id
        FROM args
        WHERE key = "chrome_mojo_event_info.mojo_interface_method.native_symbol.mapping_id"
      ) arg_mapping_id
      ON arg_rel_pc.arg_set_id = arg_mapping_id.arg_set_id
  ) unsymbolized_arg
JOIN mangled_stack_profile_mapping spm
  ON unsymbolized_arg.mapping_id = spm.id
WHERE spm.build_id != '';

DROP VIEW IF EXISTS chrome_unsymbolized_args_output;

CREATE PERFETTO VIEW chrome_unsymbolized_args_output AS
SELECT ChromeUnsymbolizedArgs(
    'args',
    (SELECT RepeatedField(arg_proto) FROM chrome_unsymbolized_args_view)
);

)_d3l1m1t3r_"
;

const char kChromeChromeUserEventHashes[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

DROP VIEW IF EXISTS chrome_user_event_hashes_output;

CREATE PERFETTO VIEW chrome_user_event_hashes_output AS
SELECT ChromeUserEventHashes(
  'action_hash', (
    SELECT RepeatedField(int_value)
    FROM args
    WHERE key = 'chrome_user_event.action_hash'
    ORDER BY int_value
  )
);

)_d3l1m1t3r_"
;

const char kChromeCpuTimeByCategory[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the 'License');
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an 'AS IS' BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- This is a templated metric that takes 3 parameters:
-- input: name of a table/view which must have columns: id, ts, dur and a
--   "category" column
-- output: name of the view that will be created
-- category: name of the category column in the input table, which will be
--   preserved in the output

SELECT RUN_METRIC('chrome/chrome_processes.sql');

-- CPU time slices for Chrome threads.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(DROP VIEW IF EXISTS chrome_cpu_slices;
CREATE PERFETTO VIEW chrome_cpu_slices AS
SELECT counters.id AS counter_id,
  track_id,
  ts,
  lead(ts) OVER (
    PARTITION BY track_id
    ORDER BY ts
  ) - ts AS dur,
  CAST(
    lead(value) OVER (
      PARTITION BY track_id
      ORDER BY ts
    ) - value AS "INT64"
  ) AS cpu_dur
FROM counters,
  (
    SELECT thread_counter_track.id
    FROM chrome_thread
    JOIN thread_counter_track ON chrome_thread.utid = thread_counter_track.utid
  ) AS t
WHERE t.id = track_id;

DROP TABLE IF EXISTS {{input}}_cpu_time;
CREATE VIRTUAL TABLE {{input}}_cpu_time USING SPAN_JOIN(
  {{input}},
  chrome_cpu_slices PARTITIONED track_id
);

-- View containing the CPU time used (across all cores) for each category slice
-- from input.
-- This will slightly overestimate the CPU time for some category slices as the
-- cpu time slices don't always line up with the category slices. However the
-- CPU slices are small enough this makes very little difference.
DROP VIEW IF EXISTS {{output}};
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO VIEW {{output}} AS
SELECT s.id,
  s.ts,
  s.dur,
  s.{{category}},
  SUM(cpu_dur) AS cpu_dur
FROM {{input}}_cpu_time r
JOIN {{input}} s
WHERE r.id = s.id
GROUP BY r.id;

)_d3l1m1t3r_"
;

const char kChromeCpuTimeByRailMode[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the 'License');
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an 'AS IS' BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

SELECT RUN_METRIC('chrome/rail_modes.sql');

-- Creates a view cpu_time_by_rail_mode containing the CPU time used (across all
-- cores) for each RAIL Mode slice in combined_overall_rail_slices.
SELECT RUN_METRIC('chrome/cpu_time_by_category.sql',
    'input', 'combined_overall_rail_slices',
    'output', 'cpu_time_by_rail_mode',
    'category', 'rail_mode'
  );

)_d3l1m1t3r_"
;

const char kChromeEstimatedPowerByCategory[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the 'License');
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an 'AS IS' BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- This is a templated metric that takes 3 parameters:
-- input: name of a table/view which must have columns: id, ts, dur and a
--   "category" column
-- output: name of the view that will be created
-- category: name of the category column in the input table, which will be
--   preserved in the output

SELECT RUN_METRIC('chrome/chrome_processes.sql');
SELECT RUN_METRIC('android/android_proxy_power.sql');
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- View containing estimated power slices broken down by cpu.
DROP VIEW IF EXISTS power_per_chrome_thread;
CREATE PERFETTO VIEW power_per_chrome_thread AS
SELECT ts,
  dur,
  cpu,
  power_per_thread.utid,
  end_state,
  priority,
  power_ma,
  power_per_thread.type,
  name AS thread_name,
  upid,
  is_main_thread
FROM power_per_thread
JOIN chrome_thread
WHERE power_per_thread.utid = chrome_thread.utid;

DROP TABLE IF EXISTS {{input}}_power;
CREATE VIRTUAL TABLE {{input}}_power USING SPAN_JOIN(
  {{input}},
  power_per_chrome_thread PARTITIONED utid
);

-- Estimated power usage for chrome across the categroy slices contained in
-- input.
DROP VIEW IF EXISTS {{output}};
CREATE PERFETTO VIEW {{output}} AS
SELECT id,
  ts,
  dur,
  {{category}},
  mas,
  mas / dur * 1e9 AS ma
FROM (
    SELECT s.id,
      s.ts,
      s.dur,
      s.{{category}},
      SUM(r.power_ma * r.dur) / 1e9 AS mas
    FROM {{input}}_power r
    JOIN {{input}} s
    WHERE r.id = s.id
    GROUP BY s.id
  );

)_d3l1m1t3r_"
;

const char kChromeEstimatedPowerByRailMode[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the 'License');
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an 'AS IS' BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

SELECT RUN_METRIC('chrome/rail_modes.sql');

-- Creates a view called power_by_rail_mode, containing the estimated CPU power
-- usage for chrome broken down by RAIL Mode.
SELECT RUN_METRIC(
    'chrome/estimated_power_by_category.sql',
    'input', 'combined_overall_rail_slices',
    'output', 'power_by_rail_mode',
    'category', 'rail_mode'
  );

)_d3l1m1t3r_"
;

const char kChromeExperimentalReliableChromeTasksDelayingInputProcessing[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Script params:
-- {{duration_causing_jank_ms}} : The duration of a single task that would cause
-- jank, by delaying input from being handled on the main thread.

SELECT RUN_METRIC('chrome/chrome_reliable_range.sql') AS suppress_query_output;

DROP VIEW IF EXISTS chrome_reliable_slice;

CREATE PERFETTO VIEW chrome_reliable_slice AS
SELECT *
FROM slice
WHERE ts + dur >= (SELECT start FROM chrome_reliable_range);
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
SELECT RUN_METRIC(
  'chrome/chrome_tasks_delaying_input_processing_template.sql',
  'duration_causing_jank_ms', '{{duration_causing_jank_ms}}',
  'slice_table_name', 'chrome_reliable_slice',
  'function_prefix', 'EXPERIMENTAL_RELIABLE_'
);

)_d3l1m1t3r_"
;

const char kChromeGestureFlowEvent[] = R"_d3l1m1t3r_(--
-- Copyright 2021 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the 'License');
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an 'AS IS' BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
-- While handling a InputLatency::{{gesture_update}} event a sequence of Flows
-- define the critical path from Beginning to End. This metric breaks down the
-- flows for the same InputLatency::{{gesture_update}} event.
--
-- WARNING: This metric should not be used as a source of truth. It is under
--          active development and the values & meaning might change without
--          notice.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Provides the {{prefix}}_jank table which gives us all the {{gesture_update}}
-- events we care about and labels them janky or not.
SELECT RUN_METRIC('chrome/{{prefix}}_jank.sql');

-- We get all latency_info that have valid trace_ids, And we make a synthetic
-- one for the beginning of each {{gesture_update}} event so we can track the
-- time between receiving the input and being converted into a gesture.
--
-- flows with a trace_id of -1 are incomplete and are difficult to reason about
-- (especially if {{gesture_update}} flows end up getting -1). so ignore them
-- for this table.
DROP VIEW IF EXISTS {{prefix}}_latency_info_flow_step_and_ancestors;
CREATE PERFETTO VIEW {{prefix}}_latency_info_flow_step_and_ancestors AS
SELECT
  *
FROM (
    SELECT
      slice.name,
      slice.id,
      slice.ts,
      slice.dur,
      slice.track_id,
      EXTRACT_ARG(slice.arg_set_id, 'chrome_latency_info.trace_id') AS trace_id,
      EXTRACT_ARG(slice.arg_set_id, 'chrome_latency_info.step') AS step,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      COALESCE(ancestor_zero.name, slice.name) AS ancestor_name_zero,
      COALESCE(ancestor_zero.id, slice.id) AS ancestor_id_zero,
      COALESCE(ancestor_zero.ts, slice.ts) AS ancestor_ts_zero,
      COALESCE(ancestor_zero.dur, slice.dur) AS ancestor_dur_zero,
      COALESCE(ancestor_one.name, slice.name) AS ancestor_name_one,
      COALESCE(ancestor_one.id, slice.id) AS ancestor_id_one,
      COALESCE(ancestor_one.ts, slice.ts) AS ancestor_ts_one,
      COALESCE(ancestor_one.dur, slice.dur) AS ancestor_dur_one
    FROM
      slice LEFT JOIN
      ancestor_slice(slice.id) AS ancestor_zero
      ON ancestor_zero.depth = 0 LEFT JOIN
      ancestor_slice(slice.id) AS ancestor_one ON ancestor_one.depth = 1
    WHERE
      slice.name = 'LatencyInfo.Flow'
      AND EXTRACT_ARG(slice.arg_set_id, 'chrome_latency_info.trace_id') != -1
  ) flow JOIN (
    SELECT
      id AS gesture_slice_id,
      ts AS gesture_ts,
      dur AS {{prefix}}_dur,
      track_id AS gesture_track_id,
      trace_id AS {{prefix}}_trace_id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      jank,
      {{id_field}},
      avg_vsync_interval
    FROM {{prefix}}_jank
  ) gesture ON
    flow.trace_id = gesture.{{prefix}}_trace_id
UNION ALL
SELECT
  'InputLatency::{{gesture_update}}' AS name,
  id,
  ts,
  dur,
  track_id,
  trace_id,
  'AsyncBegin' AS step,
  'InputLatency::{{gesture_update}}' AS ancestor_name_zero,
  id AS ancestor_id_zero,
  ts AS ancestor_ts_zero,
  0 AS ancestor_dur_zero,
  'InputLatency::{{gesture_update}}' AS ancestor_name_one,
  id AS ancestor_id_one,
  ts AS ancestor_ts_one,
  0 AS ancestor_dur_one,
  id AS gesture_slice_id,
  ts AS gesture_ts,
  dur AS {{prefix}}_dur,
  track_id AS gesture_track_id,
  trace_id AS {{prefix}}_trace_id,
  jank,
  {{id_field}},
  avg_vsync_interval
FROM {{prefix}}_jank
ORDER BY {{id_field}} ASC, trace_id ASC, ts ASC;

-- See b/184134310, but "ThreadController active" spans multiple tasks and when
-- the top level parent is this event we should use the second event instead.
DROP VIEW IF EXISTS {{prefix}}_latency_info_flow_step;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO VIEW {{prefix}}_latency_info_flow_step AS
SELECT
  *,
  CASE WHEN ancestor_name_zero != "ThreadController active" THEN
      ancestor_name_zero ELSE ancestor_name_one END AS ancestor_name,
  CASE WHEN ancestor_name_zero != "ThreadController active" THEN
      ancestor_id_zero ELSE ancestor_id_one END AS ancestor_id,
  CASE WHEN ancestor_name_zero != "ThreadController active" THEN
      ancestor_ts_zero ELSE ancestor_ts_one END AS ancestor_ts,
  CASE WHEN ancestor_name_zero != "ThreadController active" THEN
      ancestor_dur_zero ELSE ancestor_dur_one END AS ancestor_dur
FROM {{prefix}}_latency_info_flow_step_and_ancestors;

-- This is a heuristic to figure out which flow event properly joins this
-- {{gesture_update}}. This heuristic is only needed in traces before we added
-- {{id_field}}.
--
-- We select the first |ts| from a flow event after its corresponding
-- {{gesture_update}} has ended. This allows us to use this |ts| to contain all
-- flow events from the start of a particular gesture_slice_id (the slice id of
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- the async event) to that |ts|.
--
-- The reason for this is if these flow events share the same trace_id which can
-- occur if multiple chrome browsers are in the trace (webview & chrome for
-- example). We would normally add flow events from different gestures, but by
-- limiting by the {{gesture_update}} end we can prevent incorrect duplication.
-- This breaks of course if the same trace_id happens at the exact same time in
-- both browsers but this is hopefully unlikely.
DROP VIEW IF EXISTS {{prefix}}_max_latency_info_ts_per_trace_id;
CREATE PERFETTO VIEW {{prefix}}_max_latency_info_ts_per_trace_id AS
SELECT
  gesture_slice_id,
  MIN(ts) AS max_flow_ts
FROM {{prefix}}_latency_info_flow_step
WHERE
  trace_id = {{prefix}}_trace_id
  AND ts > gesture_ts + {{prefix}}_dur
GROUP BY gesture_slice_id;

-- As described by the comments about this uses the heuristic to remove any flow
-- events that aren't contained within the |max_flow_ts| and the beginning of
-- the {{gesture_update}}. This prevents other processes that share the same
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- trace_id from inserting events in the middle.
--
-- Note: Must be a TABLE because it uses a window function which can behave
--       strangely in views.
DROP TABLE IF EXISTS {{prefix}}_latency_info_flow_step_filtered;
CREATE TABLE {{prefix}}_latency_info_flow_step_filtered AS
SELECT
  ROW_NUMBER() OVER (ORDER BY
      flow.{{id_field}} ASC, trace_id ASC, ts ASC) AS row_number,
  *
FROM
  {{prefix}}_latency_info_flow_step flow JOIN
  {{prefix}}_max_latency_info_ts_per_trace_id max_flow ON
    max_flow.gesture_slice_id = flow.gesture_slice_id
WHERE
  ts >= gesture_ts
  AND ts <= max_flow_ts
ORDER BY flow.{{id_field}} ASC, flow.trace_id ASC, flow.ts ASC;

-- Take all the LatencyInfo.Flow events and within a |trace_id| join it with the
-- previous and nextflows. Some events are 'Unknown' when they don't have a step
-- but occur in the middle of the critical path. Most of these are errors though
-- and we've weeded I think all of them out (citation needed).
--
-- Note: Must be a TABLE because it uses a window function which can behave
)_d3l1m1t3r_"
R"_d3l1m1t3r_(--       strangely in views.
DROP TABLE IF EXISTS {{prefix}}_latency_info_flow_null_step_removed;
CREATE PERFETTO TABLE {{prefix}}_latency_info_flow_null_step_removed AS
SELECT
  ROW_NUMBER() OVER (ORDER BY
      curr.{{id_field}} ASC, curr.trace_id ASC, curr.ts ASC
    ) AS row_number,
    curr.id,
    curr.ts,
    curr.dur,
    curr.track_id,
    curr.trace_id,
    curr.{{id_field}},
    curr.avg_vsync_interval,
    curr.gesture_slice_id,
    curr.gesture_ts,
    curr.{{prefix}}_dur,
    curr.gesture_track_id,
    curr.jank,
    curr.ancestor_id,
    curr.ancestor_ts,
    curr.ancestor_dur,
    curr.ancestor_ts + curr.ancestor_dur AS ancestor_end,
    COALESCE(
      curr.step,
      CASE WHEN
          prev.{{id_field}} != curr.{{id_field}}
          OR prev.trace_id != curr.trace_id
          OR prev.trace_id IS NULL
          OR prev.step = 'AsyncBegin' THEN
        'Begin'
      ELSE
        CASE WHEN
          next.{{id_field}} != curr.{{id_field}}
          OR next.trace_id != curr.trace_id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(          OR next.trace_id IS NULL THEN
          'End'
          ELSE
            'Unknown'
        END
      END
    ) AS step
  FROM
    {{prefix}}_latency_info_flow_step_filtered curr LEFT JOIN
    {{prefix}}_latency_info_flow_step_filtered prev ON
      curr.row_number - 1 = prev.row_number LEFT JOIN
    {{prefix}}_latency_info_flow_step_filtered next ON
      curr.row_number + 1 = next.row_number
  ORDER BY curr.{{id_field}} ASC, curr.trace_id ASC, curr.ts ASC;

-- Now that we've got the steps all named properly we want to join them with the
-- next step so we can compute the difference between the end of the current
-- step and the beginning of the next step.
DROP VIEW IF EXISTS {{prefix}}_flow_event;
CREATE PERFETTO VIEW {{prefix}}_flow_event AS
SELECT
  curr.trace_id,
  curr.id,
  curr.ts,
  curr.dur,
  curr.track_id,
  curr.{{id_field}},
  curr.avg_vsync_interval,
  curr.gesture_slice_id AS {{prefix}}_slice_id,
  curr.gesture_ts AS {{prefix}}_ts,
  curr.{{prefix}}_dur AS {{prefix}}_dur,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  curr.gesture_track_id AS {{prefix}}_track_id,
  curr.jank,
  curr.step,
  curr.ancestor_id,
  curr.ancestor_ts,
  curr.ancestor_dur,
  curr.ancestor_end,
  next.id AS next_id,
  next.ts AS next_ts,
  next.dur AS next_dur,
  next.track_id AS next_track_id,
  next.trace_id AS next_trace_id,
  next.step AS next_step,
  CASE WHEN next.trace_id = curr.trace_id THEN
      next.ancestor_ts
    ELSE
      NULL
  END AS maybe_next_ancestor_ts
FROM
  {{prefix}}_latency_info_flow_null_step_removed curr LEFT JOIN
  {{prefix}}_latency_info_flow_null_step_removed next ON
    curr.row_number + 1 = next.row_number
ORDER BY curr.{{id_field}}, curr.trace_id, curr.ts;

)_d3l1m1t3r_"
;

const char kChromeGestureFlowEventQueuingDelay[] = R"_d3l1m1t3r_(--
-- Copyright 2021 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the 'License');
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an 'AS IS' BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
-- This metric takes each flow event in a InputLatency::{gesture_update} and
-- and computes the time from the ancestor_end of the current flow to the
-- ancestor_ts of the next flow event. This is a reasonable approximation of the
-- time we waited for the next step in the critical flow to start.

-- Provides the {{prefix}}_flow_event table which gives us all the flow events
-- with associated {gesture_update} events we care about and labels them
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- janky or not.
SELECT RUN_METRIC('chrome/{{prefix}}_flow_event.sql');

-- Take each flow and next flow (from {{prefix}}_flow_event table) and generate
-- the metric name as well as compute the time between.
DROP VIEW IF EXISTS {{prefix}}_flow_event_queuing_delay;

CREATE PERFETTO VIEW {{prefix}}_flow_event_queuing_delay AS
SELECT
  trace_id,
  id,
  ts,
  dur,
  track_id,
  {{id_field}},
  avg_vsync_interval,
  {{prefix}}_slice_id,
  {{prefix}}_ts,
  {{prefix}}_dur,
  {{prefix}}_track_id,
  jank,
  step,
  ancestor_id,
  ancestor_ts,
  ancestor_end,
  next_id,
  next_step,
  maybe_next_ancestor_ts,
  next_track_id,
  CASE WHEN trace_id = next_trace_id THEN
      'InputLatency.LatencyInfo.Flow.QueuingDelay.'
      || CASE WHEN
        jank IS NOT NULL
        AND jank = 1
        THEN
        'Jank.'
        ELSE
          'NoJank.'
      END
      || step || '-to-' || next_step
    ELSE
      step
  END AS description,
  CASE WHEN maybe_next_ancestor_ts IS NULL THEN
      NULL
    ELSE
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      CASE WHEN maybe_next_ancestor_ts > ancestor_end THEN
        (maybe_next_ancestor_ts - ancestor_end)
        ELSE
          0
      END
  END AS queuing_time_ns
FROM {{prefix}}_flow_event
ORDER BY {{id_field}}, trace_id, ts;

)_d3l1m1t3r_"
;

const char kChromeGestureJank[] = R"_d3l1m1t3r_(--
-- Copyright 2021 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
-- A collection of templated metrics related to continuous motion gestures that
-- have start, end and update events.
--
-- We define an update to be janky if comparing forwards or backwards (ignoring
-- coalesced updates) a given updates exceeds the duration of its predecessor or
-- successor by 50% of a vsync interval (defaulted to 60 FPS).
--
-- WARNING: This metric should not be used as a source of truth. It is under
)_d3l1m1t3r_"
R"_d3l1m1t3r_(--          active development and the values & meaning might change without
--          notice.

-- A simple table that checks the time between VSync (this can be used to
-- determine if we're refreshing at 90 FPS or 60 FPS.
--
-- Note: In traces without the "Java" category there will be no VSync
--       TraceEvents and this table will be empty.

INCLUDE PERFETTO MODULE chrome.scroll_jank.utils;
INCLUDE PERFETTO MODULE chrome.vsync_intervals;

-- Get all the "begin" and "end" events. We take their IDs to group them
-- together into gestures later and the timestamp and duration to compute the
-- duration of the gesture.
DROP VIEW IF EXISTS {{prefix}}_begin_and_end;
CREATE PERFETTO VIEW {{prefix}}_begin_and_end AS
SELECT
  slice.name,
  slice.id,
  slice.ts,
  slice.dur,
  slice.track_id,
  EXTRACT_ARG(arg_set_id, 'chrome_latency_info.{{id_field}}')
  AS {{id_field}},
  EXTRACT_ARG(arg_set_id, "chrome_latency_info.trace_id") AS trace_id
FROM
  slice
WHERE
  slice.name IN (
    'InputLatency::{{gesture_start}}',
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'InputLatency::{{gesture_end}}'
  )
ORDER BY ts;

-- Now we take the "begin" and the "end" events and join the information into a
-- single row per gesture. We also compute the average Vysnc interval of the
-- gesture (hopefully this would be either 60 FPS for the whole gesture or 90
-- FPS but that isn't always the case). If the trace doesn't contain the VSync
-- TraceEvent we just fall back on assuming its 60 FPS (this is the 1.6e+7 in
-- the COALESCE which corresponds to 16 ms or 60 FPS).
DROP VIEW IF EXISTS joined_{{prefix}}_begin_and_end;
CREATE PERFETTO VIEW joined_{{prefix}}_begin_and_end AS
SELECT
  begin.id AS begin_id,
  begin.ts AS begin_ts,
  begin.dur AS begin_dur,
  begin.track_id AS begin_track_id,
  begin.trace_id AS begin_trace_id,
  COALESCE(begin.{{id_field}}, begin.trace_id)
  AS begin_{{id_field}},
  end.ts AS end_ts,
  end.ts + end.dur AS end_ts_and_dur,
  end.trace_id AS end_trace_id,
  chrome_calculate_avg_vsync_interval(begin.ts, end.ts) AS avg_vsync_interval
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM {{prefix}}_begin_and_end begin JOIN {{prefix}}_begin_and_end end ON
    begin.trace_id < end.trace_id
    AND begin.name = 'InputLatency::{{gesture_start}}'
    AND end.name = 'InputLatency::{{gesture_end}}' AND (
      (
        begin.{{id_field}} IS NULL
        AND end.trace_id = (
          SELECT MIN(trace_id)
          FROM {{prefix}}_begin_and_end in_query
          WHERE
            name = 'InputLatency::{{gesture_end}}'
            AND in_query.trace_id > begin.trace_id
        )
      )
      OR end.{{id_field}} = begin.{{id_field}}
    )
ORDER BY begin.ts;

-- Prepare all gesture updates that were not coalesced to be joined with their
-- respective scrolls to calculate jank
DROP VIEW IF EXISTS gesture_update;
CREATE PERFETTO VIEW gesture_update AS
SELECT
  EXTRACT_ARG(arg_set_id, "chrome_latency_info.trace_id") AS trace_id,
  EXTRACT_ARG(arg_set_id, 'chrome_latency_info.{{id_field}}')
  AS {{id_field}},
  *
FROM
  slice JOIN track ON slice.track_id = track.id
WHERE
  slice.name = 'InputLatency::{{gesture_update}}'
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  AND slice.dur != -1
  AND NOT COALESCE(
    EXTRACT_ARG(arg_set_id, "chrome_latency_info.is_coalesced"),
    TRUE)
  AND slice.arg_set_id IN (
    SELECT arg_set_id
    FROM args
    WHERE args.arg_set_id = slice.arg_set_id
      AND flat_key = 'chrome_latency_info.component_info.component_type'
      AND string_value = 'COMPONENT_INPUT_EVENT_GPU_SWAP_BUFFER'
  );

-- Get the "update" events by name ordered by the |{{id_field}}|, and
-- timestamp. Then compute the number of frames (relative to vsync interval)
-- that each event took. 1.6e+7 is 16 ms in nanoseconds and is used in case
-- there are no VSync events to default to 60 fps. We join each
-- {{gesture_update}} event to the information about its "begin" and "end"
-- events for easy computation later.
--
-- We remove updates with |dur| = -1 because this means we have no "end" event
-- and can't reasonably determine what it should be. We have separate tracking
-- to ensure this only happens at the end of the trace where its expected.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(DROP VIEW IF EXISTS {{id_field}}_update;
CREATE PERFETTO VIEW {{id_field}}_update AS
SELECT
  begin_id,
  begin_ts,
  begin_dur,
  begin_track_id,
  begin_trace_id,
  COALESCE({{id_field}}, begin_trace_id) AS {{id_field}},
  end_ts,
  CASE WHEN
      end_ts_and_dur > ts + dur THEN
      end_ts_and_dur
    ELSE
      ts + dur
  END AS maybe_gesture_end,
  id,
  ts,
  dur,
  track_id,
  trace_id,
  dur / avg_vsync_interval AS gesture_frames_exact,
  avg_vsync_interval
FROM joined_{{prefix}}_begin_and_end begin_and_end JOIN gesture_update ON
  gesture_update.ts <= begin_and_end.end_ts
  AND gesture_update.ts >= begin_and_end.begin_ts
  AND gesture_update.trace_id > begin_and_end.begin_trace_id
  AND gesture_update.trace_id < begin_and_end.end_trace_id AND (
    gesture_update.{{id_field}} IS NULL
    OR gesture_update.{{id_field}} = begin_and_end.begin_{{id_field}}
  )
ORDER BY {{id_field}} ASC, ts ASC;

-- This takes the "update" events and get to the previous "update" event through LAG
-- (previous row and NULL if there isn't one) and the next "update" event through LEAD
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- (next row and again NULL if there isn't one). Then we compute the duration of the
-- event (relative to fps).
--
-- We only compare an "update" event to another event within the same gesture
-- ({{id_field}} = prev/next {{id_field}}). This controls somewhat for
-- variability of gestures.
--
-- Note: Must be a TABLE because it uses a window function which can behave
--       strangely in views.

DROP TABLE IF EXISTS {{prefix}}_jank_maybe_null_prev_and_next_without_precompute;
CREATE TABLE {{prefix}}_jank_maybe_null_prev_and_next_without_precompute AS
SELECT
  *,
  maybe_gesture_end - begin_ts AS {{prefix}}_dur,
  LAG(ts) OVER sorted_frames AS prev_ts,
  LAG({{id_field}}) OVER sorted_frames AS prev_{{id_field}},
  LAG(gesture_frames_exact) OVER sorted_frames AS prev_gesture_frames_exact,
  LEAD(ts) OVER sorted_frames AS next_ts,
  LEAD({{id_field}}) OVER sorted_frames AS next_{{id_field}},
  LEAD(gesture_frames_exact) OVER sorted_frames AS next_gesture_frames_exact
FROM {{id_field}}_update
)_d3l1m1t3r_"
R"_d3l1m1t3r_(WINDOW sorted_frames AS (ORDER BY {{id_field}} ASC, ts ASC)
ORDER BY {{id_field}} ASC, ts ASC;


-- We compute the duration of the event (relative to fps) and see if it
-- increased by more than 0.5 (which is 1/2 of 16 ms at 60 fps, and so on).
--
-- A small number is added to 0.5 in order to make sure that the comparison does
-- not filter out ratios that are precisely 0.5, which can fall a little above
-- or below exact value due to inherent inaccuracy of operations with
-- floating-point numbers. Value 1e-9 have been chosen as follows: the ratio has
-- nanoseconds in numerator and VSync interval in denominator. Assuming refresh
-- rate more than 1 FPS (and therefore VSync interval less than a second), this
-- ratio should increase with increments more than minimal value in numerator
-- (1ns) divided by maximum value in denominator, giving 1e-9.
-- Note: Logic is inside the is_janky_frame function found in jank_utilities.sql.
DROP VIEW IF EXISTS {{prefix}}_jank_maybe_null_prev_and_next;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO VIEW {{prefix}}_jank_maybe_null_prev_and_next AS
SELECT
  *,
    _is_janky_frame({{id_field}}, prev_{{id_field}},
    prev_ts, begin_ts, maybe_gesture_end,
    gesture_frames_exact, prev_gesture_frames_exact) AS prev_jank,
    _is_janky_frame({{id_field}}, next_{{id_field}},
    next_ts, begin_ts, maybe_gesture_end,
    gesture_frames_exact, next_gesture_frames_exact) AS next_jank
FROM {{prefix}}_jank_maybe_null_prev_and_next_without_precompute
ORDER BY {{id_field}} ASC, ts ASC;

-- This just uses prev_jank and next_jank to see if each "update" event is a
-- jank.
--
-- jank_budget is the time in ns that we need to reduce the current
-- gesture (|id|) for this frame not to be considered janky (i.e., how much
-- faster for is_janky_frame() to have not returned true).
--
-- For jank_budget we use the frames_exact of current, previous and next to find
-- the jank budget in exact frame count. We then multiply by avg_vsync_internal
-- to get the jank budget time.
-- Note: Logic is inside the jank_budget function found in jank_utilities.sql.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(DROP VIEW IF EXISTS {{prefix}}_jank;
CREATE PERFETTO VIEW {{prefix}}_jank AS
SELECT
  id AS slice_id,
  (next_jank IS NOT NULL AND next_jank)
  OR (prev_jank IS NOT NULL AND prev_jank)
  AS jank,
  _jank_budget(gesture_frames_exact, prev_gesture_frames_exact,
    next_gesture_frames_exact) * avg_vsync_interval AS jank_budget,
  *
FROM {{prefix}}_jank_maybe_null_prev_and_next
ORDER BY {{id_field}} ASC, ts ASC;

DROP VIEW IF EXISTS {{prefix}}_jank_output;
CREATE PERFETTO VIEW {{prefix}}_jank_output AS
SELECT
  {{proto_name}}(
    '{{prefix}}_jank_percentage', (
      SELECT
        (
          SUM(CASE WHEN jank THEN dur ELSE 0 END) / CAST(SUM(dur) AS REAL)
        ) * 100.0
      FROM {{prefix}}_jank
    ),
    '{{prefix}}_ms', (
      SELECT
        CAST(SUM({{prefix}}_dur) / 1e6 AS REAL)
      FROM (
        SELECT
          MAX({{prefix}}_dur) AS {{prefix}}_dur
        FROM {{prefix}}_jank
        GROUP BY {{id_field}}
      )
    ),
    '{{prefix}}_processing_ms', CAST(SUM(dur) / 1e6 AS REAL),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    '{{prefix}}_jank_processing_ms', (
      SELECT CAST(SUM(dur) / 1e6 AS REAL) FROM {{prefix}}_jank WHERE jank
    ),
    'num_{{prefix}}_update_count', COUNT(*),
    'num_{{prefix}}_update_jank_count', SUM(jank),
    '{{prefix}}_jank_budget_ms', (
      SELECT CAST(SUM(jank_budget) AS REAL) FROM {{prefix}}_jank WHERE jank
    )
  )
FROM {{prefix}}_jank;

)_d3l1m1t3r_"
;

const char kChromeRailModes[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the 'License');
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an 'AS IS' BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

SELECT RUN_METRIC('chrome/chrome_processes.sql');
SELECT RUN_METRIC('chrome/chrome_event_metadata.sql');

-- Priority order for RAIL modes where response has the highest priority and
-- idle has the lowest.
DROP TABLE IF EXISTS rail_modes;
CREATE TABLE rail_modes (
  mode TEXT UNIQUE,
  ordering INT,
  short_name TEXT
);

-- RAIL_MODE_IDLE is used when no frames are visible in the renderer and so this
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- interprets that as background.
-- RAIL_MODE_LOAD is for the time from a navigation until the first meaningful
-- paint (assuming there are no user interactions).
-- RAIL_MODE_RESPONSE is used when the main thread is dealing with a
-- user-interaction (but not for instance for scrolls which may be handled by
-- the compositor).
-- RAIL_MODE_ANIMATION is used when none of the above apply.
-- The enum in chrome is defined in:
-- https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/renderer/platform/scheduler/public/rail_mode_observer.h
INSERT INTO rail_modes
VALUES ('RAIL_MODE_IDLE', 0, 'background'),
('RAIL_MODE_ANIMATION', 1, "animation"),
('RAIL_MODE_LOAD', 2, "load"),
('RAIL_MODE_RESPONSE', 3, "response");


-- Find the max ts + dur for every process
DROP TABLE IF EXISTS max_ts_per_process;
CREATE PERFETTO TABLE max_ts_per_process AS
-- MAX(dur, 0) means unclosed slices just contribute their start time.
SELECT upid,
  MAX(ts + MAX(dur, 0)) AS ts
FROM (
    SELECT upid,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      ts,
      dur
    FROM process_track t
    JOIN slice s
    WHERE s.track_id = t.id
    UNION ALL
    SELECT upid,
      ts,
      dur
    FROM thread_track t
    JOIN thread
    JOIN slice
    WHERE slice.track_id = t.id
      AND thread.utid = t.utid
  )
GROUP BY upid;

-- View containing all Scheduler.RAILMode slices across all Chrome renderer
-- processes.
DROP VIEW IF EXISTS original_rail_mode_slices;
CREATE PERFETTO VIEW original_rail_mode_slices AS
SELECT slice.id,
  slice.ts,
  CASE
    -- Add 1 to the duration to ensure you cannot get a zero-sized RAIL mode
    -- slice, which can throw off the later queries.
    WHEN dur = -1 THEN max_ts_per_process.ts - slice.ts + 1
    ELSE dur
  END AS dur,
  track_id,
  EXTRACT_ARG(
    slice.arg_set_id,
    "chrome_renderer_scheduler_state.rail_mode"
  ) AS rail_mode
FROM max_ts_per_process,
  slice,
  process_track
WHERE slice.name = "Scheduler.RAILMode"
  AND slice.track_id = process_track.id
  AND process_track.upid = max_ts_per_process.upid;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Detect if the trace has an unrealistic length (10 minutes) that probably
-- means some trace events have faulty timestamps and which could throw off any
-- metrics that use the trace.
DROP VIEW IF EXISTS trace_has_realistic_length;
CREATE PERFETTO VIEW trace_has_realistic_length AS
SELECT trace_dur() < 1e9 * 60 * 10 AS value;

-- RAIL_MODE_LOAD seems to get stuck which makes it not very useful so remap it
-- to RAIL_MODE_ANIMATION so it doesn't dominate the overall RAIL mode.
DROP VIEW IF EXISTS rail_mode_slices;
CREATE PERFETTO VIEW rail_mode_slices AS
SELECT ts, dur, track_id,
  CASE
    WHEN rail_mode = "RAIL_MODE_LOAD" THEN "RAIL_MODE_ANIMATION"
    ELSE rail_mode
  END AS rail_mode
FROM original_rail_mode_slices;

-- View containing a collapsed view of rail_mode_slices where there is only one
-- RAIL mode active at a given time. The mode is derived using the priority
-- order in rail_modes.
DROP VIEW IF EXISTS overall_rail_mode_slices;
CREATE PERFETTO VIEW overall_rail_mode_slices AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT s.ts,
  s.end_ts,
  rail_modes.short_name AS rail_mode,
  MAX(rail_modes.ordering)
FROM (
    SELECT ts,
      LEAD(ts, 1, (SELECT MAX(ts + dur) FROM rail_mode_slices)) OVER (
        ORDER BY ts
      ) AS end_ts
    FROM (
        SELECT DISTINCT ts
        FROM rail_mode_slices
      ) start_times
  ) s,
  rail_mode_slices r,
  rail_modes,
  trace_has_realistic_length
WHERE (
    (
      s.ts >= r.ts AND s.ts < r.ts + r.dur
    )
    OR (
      s.end_ts > r.ts AND s.end_ts <= r.ts + r.dur
    )
  )
  AND r.rail_mode = rail_modes.mode
  AND trace_has_realistic_length.value
GROUP BY s.ts;

-- Contains the same data as overall_rail_mode_slices except adjacent slices
-- with the same RAIL mode are combined.
DROP TABLE IF EXISTS combined_overall_rail_slices;
CREATE PERFETTO TABLE combined_overall_rail_slices AS
SELECT ROW_NUMBER() OVER () AS id,
  ts,
  end_ts - ts AS dur,
  rail_mode
FROM (
    SELECT lag(l.end_ts, 1, FIRST) OVER (
        ORDER BY l.ts
      ) AS ts,
      l.end_ts,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      l.rail_mode
    FROM (
        SELECT ts,
          end_ts,
          rail_mode
        FROM overall_rail_mode_slices s
        WHERE NOT EXISTS (
            SELECT NULL
            FROM overall_rail_mode_slices s2
            WHERE s.rail_mode = s2.rail_mode
              AND s.end_ts = s2.ts
          )
      ) AS l,
      (
        SELECT min(ts) AS FIRST
        FROM overall_rail_mode_slices
      )
  );

-- Now we have the RAIL Mode, use other trace events to create a modified RAIL
-- mode that more accurately reflects what the browser/user are doing.

-- First create slices for when there's no animation as indicated by a large gap
-- between vsync events (since it's easier to find gaps than runs of adjacent
-- vsyncs).

-- Mark any large gaps between vsyncs.
-- The value in "not_animating" is always 1. It's just there to be a non-NULL
-- value so the later SPAN_JOIN can find the set-difference.
DROP VIEW IF EXISTS not_animating_slices;
CREATE PERFETTO VIEW not_animating_slices AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(WITH const (vsync_padding, large_gap) AS (
  SELECT
    -- Pad 50ms either side of a vsync
    50000000,
    -- A gap of >200ms between the adjacent vsyncs is treated as a gap in
    -- animation.
    200000000
)
SELECT ts + const.vsync_padding AS ts,
  gap_to_next_vsync - const.vsync_padding * 2 AS dur, 1 AS not_animating
FROM const, (SELECT name,
    ts,
    lead(ts) OVER () - ts AS gap_to_next_vsync,
    dur
  FROM slice
  WHERE name = "VSync")
WHERE gap_to_next_vsync > const.large_gap
UNION
-- Insert a slice between start_ts and the first vsync (or the end of the trace
-- if there are none).
SELECT
  ts,
  dur,
  1
FROM (SELECT start_ts AS ts,
  COALESCE(
    (
    SELECT MIN(ts)
    FROM slice
    WHERE name = "VSync"
) - start_ts - const.vsync_padding,
  end_ts - start_ts
  ) AS dur
  FROM trace_bounds, const)
WHERE dur > 0
UNION
-- Insert a slice between the last vsync and end_ts
SELECT last_vsync AS ts,
  end_ts - last_vsync AS dur,
  1
FROM (
    SELECT MAX(ts) + const.vsync_padding AS last_vsync
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    FROM slice, const
    WHERE name = "VSync"
  ),
  trace_bounds
WHERE last_vsync < end_ts;

-- There are two types of InputLatency:: events:
-- 1) Simple ones that begin at ts and end at ts+dur
-- 2) Paired ones that begin with a "begin" slice and end at an "end" slice.
--
-- Paired events are even trickier because we can't guarantee that the "begin"
-- slice will even be in the trace and because it's possible for multiple begin
-- slices to appear without an intervening end slice.

-- Table of begin and end events along with the increment/decrement to be
-- applied to the appropriate counter (one for each type of paired event). Final
-- column dur_multiplier is used to find the timestamp to mark the event at in
-- the equation event_ts = ts + dur * dur_multiplier. End events have
-- dur_multiplier of 1, which makes their ts the end of the slice rather than
-- the start.
DROP TABLE IF EXISTS input_latency_begin_end_names;
CREATE TABLE input_latency_begin_end_names
(
  full_name TEXT UNIQUE,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  prefix TEXT,
  scroll_increment INT,
  pinch_increment INT,
  touch_increment INT,
  fling_increment INT,
  pointer_increment INT,
  dur_multiplier INT
);

INSERT
OR IGNORE INTO input_latency_begin_end_names
VALUES
("InputLatency::GestureScrollBegin",
  "InputLatency::GestureScroll", 1, 0, 0, 0, 0, 0),
("InputLatency::GestureScrollEnd",
  "InputLatency::GestureScroll", -1, 0, 0, 0, 0, 1),
("InputLatency::GesturePinchBegin",
  "InputLatency::GesturePinch", 0, 1, 0, 0, 0, 0),
("InputLatency::GesturePinchEnd",
  "InputLatency::GesturePinch", 0, -1, 0, 0, 0, 1),
("InputLatency::TouchStart",
  "InputLatency::Touch", 0, 0, 1, 0, 0, 0),
("InputLatency::TouchEnd",
  "InputLatency::Touch", 0, 0, -1, 0, 0, 1),
("InputLatency::GestureFlingStart",
  "InputLatency::GestureFling", 0, 0, 0, 1, 0, 0),
("InputLatency::GestureFlingCancel",
  "InputLatency::GestureFling", 0, 0, 0, -1, 0, 1),
("InputLatency::PointerDown",
  "InputLatency::Pointer", 0, 0, 0, 0, 1, 0),
("InputLatency::PointerUp",
  "InputLatency::Pointer", 0, 0, 0, 0, -1, 1),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("InputLatency::PointerCancel",
  "InputLatency::Pointer", 0, 0, 0, 0, -1, 1);

-- Find all the slices that have split "begin" and "end" slices and maintain a
-- running total for each type, where >0 means that type of input event is
-- ongoing.
DROP VIEW IF EXISTS input_begin_end_slices;
CREATE PERFETTO VIEW input_begin_end_slices AS
SELECT prefix,
  -- Mark the change at the start of "start" slices and the end of "end" slices.
  ts + dur * dur_multiplier AS ts,
  scroll_increment,
  pinch_increment,
  touch_increment,
  fling_increment,
  pointer_increment
FROM slice
JOIN input_latency_begin_end_names ON name = full_name
ORDER BY ts;

-- Combine all the paired input events to get an indication of when any paired
-- input event is ongoing.
DROP VIEW IF EXISTS unified_input_pair_increments;
CREATE PERFETTO VIEW unified_input_pair_increments AS
SELECT ts,
  scroll_increment
  + pinch_increment
  + touch_increment
  + fling_increment
  + pointer_increment AS increment
FROM input_begin_end_slices;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- It's possible there's an end slice without a start slice (as it occurred
-- before the trace started) which would result in (starts - ends) going
-- negative at some point. So find an offset that shifts up all counts so the
-- lowest values becomes zero. It's possible this could still do the wrong thing
-- if there were start AND end slices that are outside the trace bounds, in
-- which case it should count as covering the entire trace, but it's impossible
-- to compensate for that without augmenting the trace events themselves.
DROP VIEW IF EXISTS initial_paired_increment;
CREATE PERFETTO VIEW initial_paired_increment AS
SELECT ts,
  MIN(0, MIN(scroll_total))
  + MIN(0, MIN(pinch_total))
  + MIN(0, MIN(touch_total))
  + MIN(0, MIN(fling_total))
  + MIN(0, MIN(pointer_total)) AS offset
FROM (
    SELECT ts,
      SUM(scroll_increment) OVER(ROWS UNBOUNDED PRECEDING) AS scroll_total,
      SUM(pinch_increment) OVER(ROWS UNBOUNDED PRECEDING) AS pinch_total,
      SUM(touch_increment) OVER(ROWS UNBOUNDED PRECEDING) AS touch_total,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      SUM(fling_increment) OVER(ROWS UNBOUNDED PRECEDING) AS fling_total,
      SUM(pointer_increment) OVER(ROWS UNBOUNDED PRECEDING) AS pointer_total
    FROM input_begin_end_slices
  );

-- Now find all the simple input slices that fully enclose the input they're
-- marking (i.e. not the start or end of a pair).
DROP VIEW IF EXISTS simple_input_slices;
CREATE PERFETTO VIEW simple_input_slices AS
SELECT id,
  name,
  ts,
  dur
FROM slice s
WHERE name GLOB "InputLatency::*"
  AND NOT EXISTS (
    SELECT 1
    FROM slice
    JOIN input_latency_begin_end_names
    WHERE s.name = full_name
  );

-- Turn the simple input slices into +1s and -1s at the start and end of each
-- slice.
DROP VIEW IF EXISTS simple_input_increments;
CREATE PERFETTO VIEW simple_input_increments AS
SELECT ts,
  1 AS increment
FROM simple_input_slices
UNION ALL
SELECT ts + dur,
  -1
FROM simple_input_slices
ORDER BY ts;

-- Combine simple and paired inputs into one, summing all the increments at a
-- given ts.
DROP VIEW IF EXISTS all_input_increments;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO VIEW all_input_increments AS
SELECT ts,
  SUM(increment) AS increment
FROM (
    SELECT *
    FROM simple_input_increments
    UNION ALL
    SELECT *
    FROM unified_input_pair_increments
    ORDER BY ts
  )
GROUP BY ts;

-- Now calculate the cumulative sum of the increments as each ts, giving the
-- total number of outstanding input events at a given time.
DROP VIEW IF EXISTS all_input_totals;
CREATE PERFETTO VIEW all_input_totals AS
SELECT ts,
  SUM(increment) OVER(ROWS UNBOUNDED PRECEDING) > 0 AS input_total
FROM all_input_increments;

-- Now find the transitions from and to 0 and use that to create slices where
-- input events were occurring. The input_active column always contains 1, but
-- is there so that the SPAN_JOIN_LEFT can put NULL in it for RAIL Mode slices
-- that do not have corresponding input events.
DROP VIEW IF EXISTS all_input_slices;
CREATE PERFETTO VIEW all_input_slices AS
SELECT cast(ts as int) as ts,
  dur,
  input_active
FROM (
    SELECT ts,
      lead(ts, 1, end_ts) OVER() - ts AS dur,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      input_active
    FROM trace_bounds,
      (
        SELECT ts,
          input_total > 0 AS input_active
        FROM (
            SELECT ts,
              input_total,
              lag(input_total) OVER() AS prev_input_total
            FROM all_input_totals
          )
        WHERE (input_total > 0 != prev_input_total > 0)
          OR prev_input_total IS NULL
      )
  )
WHERE input_active > 0;

-- Since the scheduler defaults to animation when none of the other RAIL modes
-- apply, animation overestimates the amount of time that actual animation is
-- occurring.
-- So instead we try to divide up animation in other buckets based on other
-- trace events.
DROP VIEW IF EXISTS rail_mode_animation_slices;
CREATE PERFETTO VIEW rail_mode_animation_slices AS
SELECT * FROM combined_overall_rail_slices WHERE rail_mode = "animation";

-- Left-join rail mode animation slices with all_input_slices to find all
-- "animation" slices that should actually be labelled "response".
DROP TABLE IF EXISTS rail_mode_join_inputs;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE VIRTUAL TABLE rail_mode_join_inputs
USING SPAN_LEFT_JOIN(rail_mode_animation_slices, all_input_slices);

-- Left-join rail mode animation slices with not_animating_slices which is
-- based on the gaps between vsync events.
DROP TABLE IF EXISTS rail_mode_join_inputs_join_animation;
CREATE VIRTUAL TABLE rail_mode_join_inputs_join_animation
USING SPAN_LEFT_JOIN(rail_mode_join_inputs, not_animating_slices);

DROP VIEW IF EXISTS has_modified_rail_slices;
CREATE PERFETTO VIEW has_modified_rail_slices AS
SELECT (
    SELECT value
    FROM chrome_event_metadata
    WHERE name = "os-name"
  ) = "Android" AS value;

-- Mapping to allow CamelCased names to be produced from the modified rail
-- modes.
DROP TABLE IF EXISTS modified_rail_mode_prettier;
CREATE TABLE modified_rail_mode_prettier (
  orig_name TEXT UNIQUE,
  pretty_name TEXT
);
INSERT INTO modified_rail_mode_prettier
VALUES ("background", "Background"),
("foreground_idle", "ForegroundIdle"),
("animation", "Animation"),
("load", "Load"),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(("response", "Response");

-- When the RAIL mode is animation, use input/vsync data to conditionally change
-- the mode to response or foreground_idle.
DROP VIEW IF EXISTS unmerged_modified_rail_slices;
CREATE PERFETTO VIEW unmerged_modified_rail_slices AS
SELECT ROW_NUMBER() OVER () AS id,
  ts,
  dur,
  mode
FROM (
    SELECT ts,
      dur,
      CASE
        WHEN input_active IS NOT NULL THEN "response"
        WHEN not_animating IS NULL THEN "animation"
        ELSE "foreground_idle"
      END AS mode
    FROM rail_mode_join_inputs_join_animation
    UNION
    SELECT ts,
      dur,
      rail_mode AS mode
    FROM combined_overall_rail_slices
    WHERE rail_mode != "animation"
  )
-- Since VSync events are only emitted on Android (and the concept of a
-- unified RAIL mode only makes sense if there's just a single Chrome window),
-- don't output anything on other platforms. This will result in all the power
-- and cpu time tables being empty rather than containing bogus results.
WHERE (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    SELECT value
    FROM has_modified_rail_slices
  );

-- The previous query creating unmerged_modified_rail_slices, can create
-- adjacent slices with the same mode. This merges them together as well as
-- adding a unique id to each slice. Rather than directly merging slices
-- together, this instead looks for all the transitions and uses this to
-- reconstruct the slices that should occur between them.
DROP TABLE IF EXISTS modified_rail_slices;
CREATE PERFETTO TABLE modified_rail_slices AS
WITH const (end_ts) AS (SELECT ts + dur
  FROM unmerged_modified_rail_slices
  ORDER BY ts DESC
  LIMIT 1
)
SELECT ROW_NUMBER() OVER () AS id, lag(next_ts) OVER() AS ts,
  ts + dur - lag(next_ts) OVER() AS dur,
  mode AS mode
FROM (
    -- For each row in the original table, create a new row with the information
    -- from the following row, since you can't use lag/lead in WHERE clause.
    --
    -- Transition row at the beginning. "mode" is invalid, so a transition will
    -- always be recorded.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    SELECT *
    FROM (SELECT
          0 AS ts,
          ts AS dur,
          "" AS mode,
          ts AS next_ts,
          dur AS next_dur,
          mode AS next_mode
        FROM unmerged_modified_rail_slices
        LIMIT 1
      )
    UNION ALL
    SELECT ts,
      dur,
      mode,
      lead(ts, 1, end_ts) OVER() AS next_ts,
      lead(dur) OVER() AS next_dur,
      lead(mode) OVER() AS next_mode
    FROM unmerged_modified_rail_slices, const
    UNION ALL
    -- Transition row at the end. "next_mode" is invalid, so a transition will
    -- always be recorded.
    SELECT *
    FROM (SELECT
          ts + dur AS ts,
          0 AS dur,
          mode,
          ts + dur AS next_ts,
          0,
          "" AS next_mode
        FROM unmerged_modified_rail_slices
        ORDER BY ts DESC
        LIMIT 1
      )
  )
WHERE mode != next_mode
-- Retrieve all but the first row.
LIMIT -1 OFFSET 1;

)_d3l1m1t3r_"
;

const char kChromeScrollFlowEvent[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the 'License');
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an 'AS IS' BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
-- While handling a InputLatency::GestureScrollUpdate event a sequence of Flows
-- define the critical path from Beginning to End. This metric breaks down the
-- flows for the same InputLatency::GestureScrollUpdate event.
--
-- WARNING: This metric should not be used as a source of truth. It is under
--          active development and the values & meaning might change without
--          notice.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Provides the scroll_jank table which gives us all the GestureScrollUpdate
-- events we care about and labels them janky or not.
SELECT RUN_METRIC(
    'chrome/gesture_flow_event.sql',
    'prefix', 'scroll',
    'gesture_update', 'GestureScrollUpdate',
    'id_field', 'gesture_scroll_id'
);

)_d3l1m1t3r_"
;

const char kChromeScrollFlowEventQueuingDelay[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the 'License');
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an 'AS IS' BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
-- This metric takes each flow event in a InputLatency::GestureScrollUpdate and
-- and computes the time from the ancestor_end of the current flow to the
-- ancestor_ts of the next flow event. This is a reasonable approximation of the
-- time we waited for the next step in the critical flow to start.

-- Provides the scroll_flow_event table which gives us all the flow events with
-- associated GestureScrollUpdate events we care about and labels them janky or
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- not.
SELECT RUN_METRIC('chrome/gesture_flow_event_queuing_delay.sql',
    'prefix', 'scroll',
    'id_field', 'gesture_scroll_id');

)_d3l1m1t3r_"
;

const char kChromeScrollJank[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
-- A collection of metrics related to GestureScrollUpdate events.
--
-- We define a GestureScrollUpdate to be janky if comparing forwards or
-- backwards (ignoring coalesced updates) a given GestureScrollUpdate exceeds
-- the duration of its predecessor or successor by 50% of a vsync interval
-- (defaulted to 60 FPS).
--
-- WARNING: This metric should not be used as a source of truth. It is under
)_d3l1m1t3r_"
R"_d3l1m1t3r_(--          active development and the values & meaning might change without
--          notice.

SELECT RUN_METRIC(
    'chrome/gesture_jank.sql',
    'prefix', 'scroll',
    'gesture_start', 'GestureScrollBegin',
    'gesture_update', 'GestureScrollUpdate',
    'gesture_end', 'GestureScrollEnd',
    'id_field', 'gesture_scroll_id',
    'proto_name', 'ScrollJank');

)_d3l1m1t3r_"
;

const char kChromeScrollJankCause[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Needed for the scroll_jank table to tell which updates were janky.
SELECT RUN_METRIC('chrome/scroll_jank.sql');

-- Causes of jank which we will join together. The process to add new causes
-- should be pretty straight forward.
--
-- 1) Determine a query (or sequence of queries) which identifies a
--    InputLatency::GestureScrollUpdate (which can be found in the scroll_jank
--    table) that was effected by the cause you are investigating.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- 2) output the InputLatency::GestureScrollUpdate id from the slice table (or
--    scroll_jank table), along with a "true" ish value if that
--    InputLatency::GestureScrollUpdate was affected by your cause
-- 3) Add your new metric file in the SELECT RUN_METRIC lines below.
-- 4) Add a LEFT JOIN on your output table joining on the
--    InputLatency::GestureScrollUpdate id with scroll_jank_cause_joined.
-- 5) modify the scroll_jank_cause_explained_jank to include your cause.
SELECT RUN_METRIC('chrome/scroll_jank_cause_blocking_touch_move.sql');
SELECT RUN_METRIC('chrome/scroll_jank_cause_blocking_task.sql');
SELECT RUN_METRIC('chrome/scroll_jank_cause_get_bitmap.sql');

DROP VIEW IF EXISTS scroll_jank_cause_joined;
CREATE PERFETTO VIEW scroll_jank_cause_joined AS
SELECT
  COALESCE(move.blocking_touch_move, 0) AS blocking_touch_move,
  COALESCE(task.blocked_by_language_detection, 0)
  AS blocked_by_language_detection,
  COALESCE(task.blocked_by_copy_request, 0) AS blocked_by_copy_request,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  COALESCE(bitmap.blocked_by_bitmap, 0) AS blocked_by_bitmap,
  COALESCE(bitmap.blocked_by_toolbar, 0) AS blocked_by_toolbar,
  COALESCE(bitmap.blocked_by_bitmap_no_toolbar, 0)
  AS blocked_by_bitmap_no_toolbar,
  jank.*
FROM
  scroll_jank jank LEFT JOIN
  scroll_jank_cause_blocking_touch_move move
  ON jank.id = move.scroll_id LEFT JOIN
  scroll_jank_cause_blocking_task task
  ON jank.id = task.scroll_id LEFT JOIN
  scroll_jank_cause_get_bitmap bitmap
  ON jank.id = bitmap.scroll_id;

DROP VIEW IF EXISTS scroll_jank_cause_explained_jank;
CREATE PERFETTO VIEW scroll_jank_cause_explained_jank AS
SELECT
  CASE WHEN
      NOT jank
      THEN
      FALSE
    ELSE
      COALESCE(blocking_touch_move
        OR blocked_by_language_detection
        OR blocked_by_copy_request
        OR blocked_by_bitmap, FALSE)
  END AS explained_jank,
  jank.*
FROM scroll_jank_cause_joined jank;

DROP VIEW IF EXISTS scroll_jank_cause;
CREATE PERFETTO VIEW scroll_jank_cause AS
SELECT
  jank AND NOT explained_jank AS unexplained_jank,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  jank.*
FROM scroll_jank_cause_explained_jank jank;

)_d3l1m1t3r_"
;

const char kChromeScrollJankCauseBlockingTask[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Needed for the scroll_jank table to tell which updates were janky.
SELECT RUN_METRIC('chrome/scroll_jank.sql');

--------------------------------------------------------------------------------
-- Get all the track ids relevant to the critical path.
--------------------------------------------------------------------------------

-- Grab the track of the browser. sendTouchEvent is a Java category event which
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- only occurs on the browser. This saves us the trouble of dealing with all the
-- different possible names of the browser (when including system tracing).
DROP VIEW IF EXISTS browser_main_track_id;
CREATE PERFETTO VIEW browser_main_track_id AS
SELECT
  track_id AS id
FROM slice
WHERE
  name = "sendTouchEvent"
LIMIT 1;

DROP VIEW IF EXISTS viz_compositor_track_id;
CREATE PERFETTO VIEW viz_compositor_track_id AS
SELECT
  id
FROM thread_track
WHERE
  utid = (
    SELECT
      utid
    FROM thread
    WHERE
      name = "VizCompositorThread"
  )
LIMIT 1;

-- Grab the track of the GPU. gpu/command_buffer is a toplevel category event
-- which only occurs on the gpu main. This saves us the trouble of dealing with
-- all the different possible names of the GPU process (when including system
-- tracing).
DROP VIEW IF EXISTS gpu_main_track_id;
CREATE PERFETTO VIEW gpu_main_track_id AS
SELECT
  track_id AS id
FROM slice
WHERE
  EXTRACT_ARG(arg_set_id, "task.posted_from.file_name") GLOB
  "*gpu/command_buffer/service/scheduler.cc"
)_d3l1m1t3r_"
R"_d3l1m1t3r_(LIMIT 1;

-- TODO(nuskos): Determine a good way to get all the renderer track_ids (each
--               scroll will have a single renderer main and a single renderer
--               compositor however different scroll updates could have
--               DIFFERENT renderers so bit tricky). Ignore this complexity for
--               now until we have a single task we want to blame jank on.

--------------------------------------------------------------------------------
-- Grab the last LatencyInfo.Flow for each trace_id on the browser main.
--------------------------------------------------------------------------------
DROP VIEW IF EXISTS browser_flows;
CREATE PERFETTO VIEW browser_flows AS
SELECT
  EXTRACT_ARG(arg_set_id, "chrome_latency_info.trace_id") AS trace_id,
  EXTRACT_ARG(arg_set_id, "chrome_latency_info.step") AS flow_step,
  track_id,
  max(ts) AS ts
FROM slice
WHERE
  track_id = (
    SELECT id FROM browser_main_track_id
  )
  AND name = "LatencyInfo.Flow"
GROUP BY trace_id;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Grab the last LatencyInfo.Flow for each trace_id on the VizCompositor.
DROP VIEW IF EXISTS viz_flows;
CREATE PERFETTO VIEW viz_flows AS
SELECT
  EXTRACT_ARG(arg_set_id, "chrome_latency_info.trace_id") AS trace_id,
  EXTRACT_ARG(arg_set_id, "chrome_latency_info.step") AS flow_step,
  track_id,
  max(ts) AS ts
FROM slice
WHERE
  track_id = (
    SELECT id FROM viz_compositor_track_id
  )
  AND name = "LatencyInfo.Flow"
GROUP BY trace_id;

-- Grab the last LatencyInfo.Flow for each trace_id on the GPU main.
DROP VIEW IF EXISTS gpu_flows;
CREATE PERFETTO VIEW gpu_flows AS
SELECT
  EXTRACT_ARG(arg_set_id, "chrome_latency_info.trace_id") AS trace_id,
  EXTRACT_ARG(arg_set_id, "chrome_latency_info.step") AS flow_step,
  track_id,
  max(ts) AS ts
FROM slice
WHERE
  track_id = (
    SELECT id FROM gpu_main_track_id
  )
  AND name = "LatencyInfo.Flow"
GROUP BY trace_id;

--------------------------------------------------------------------------------
-- Finally join the relevant tracks/flows to the individual scrolls.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(--------------------------------------------------------------------------------

-- Keeping only the GestureScrollUpdates join the maximum flows with their
-- associated scrolls. We only keep non-coalesced scrolls.
DROP VIEW IF EXISTS scroll_with_browser_gpu_and_viz_flows;
CREATE PERFETTO VIEW scroll_with_browser_gpu_and_viz_flows AS
SELECT
  scroll.trace_id,
  scroll.scroll_id,
  scroll.ts,
  scroll.dur,
  scroll.track_id,
  browser_flows.ts AS browser_flow_ts,
  browser_flows.flow_step AS browser_flow_step,
  browser_flows.track_id AS browser_track_id,
  viz_flows.ts AS viz_flow_ts,
  viz_flows.flow_step AS viz_flow_step,
  viz_flows.track_id AS viz_track_id,
  gpu_flows.ts AS gpu_flow_ts,
  gpu_flows.flow_step AS gpu_flow_step,
  gpu_flows.track_id AS gpu_track_id
FROM (
  SELECT
    trace_id,
    id AS scroll_id,
    ts,
    dur,
    track_id
  FROM scroll_jank
) scroll JOIN browser_flows ON
  scroll.trace_id = browser_flows.trace_id
JOIN viz_flows ON viz_flows.trace_id = scroll.trace_id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(JOIN gpu_flows ON gpu_flows.trace_id = scroll.trace_id;

--------------------------------------------------------------------------------
-- Below we determine individual causes of blocking tasks.
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- Determine if a CopyOutputRequest blocked any important threads.
--------------------------------------------------------------------------------

-- These are the events that block the Browser Main or the VizCompositor thread.
DROP VIEW IF EXISTS blocking_browser_gpu_and_viz_copies;
CREATE PERFETTO VIEW blocking_browser_gpu_and_viz_copies AS
SELECT
  id,
  ts,
  dur,
  track_id
FROM slice
WHERE
  (
    (
      name = "viz.mojom.CopyOutputResultSender"
      OR name = "GLRenderer::CopyDrawnRenderPass"
    )
    AND track_id = (SELECT id FROM browser_main_track_id)
  ) OR (
    EXTRACT_ARG(arg_set_id, "task.posted_from.file_name") GLOB
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    "*components/viz/common/frame_sinks/copy_output_request.cc"
    AND track_id = (SELECT id FROM viz_compositor_track_id)
  ) OR (
    name = "SkiaOutputSurfaceImplOnGpu::CopyOutput"
    AND track_id = (SELECT id FROM gpu_main_track_id)
  );

-- Determine based on the LatencyInfo.Flow timestamp and the copy task overlap
-- if this scroll might have been delayed because of the copy.
DROP VIEW IF EXISTS blocking_copy_tasks;
CREATE PERFETTO VIEW blocking_copy_tasks AS
SELECT
  scroll.scroll_id,
  scroll.trace_id,
  copy.id,
  copy.ts,
  copy.dur,
  copy.track_id,
  CASE WHEN copy.track_id = scroll.browser_track_id THEN
    COALESCE(copy.ts < scroll.browser_flow_ts, FALSE)
    WHEN copy.track_id = scroll.viz_track_id THEN
      COALESCE(copy.ts < scroll.viz_flow_ts, FALSE)
    WHEN copy.track_id = scroll.gpu_track_id THEN
      COALESCE(copy.ts < scroll.gpu_flow_ts, FALSE)
    ELSE
      FALSE
  END AS blocked_by_copy
FROM
  scroll_with_browser_gpu_and_viz_flows scroll JOIN
  blocking_browser_gpu_and_viz_copies copy ON
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    scroll.ts + scroll.dur >= copy.ts
    AND copy.ts + copy.dur >= scroll.ts;

-- Group by scroll so we can equally join one reply to the ScrollJankAndCauses
-- view.
DROP VIEW IF EXISTS screenshot_overlapping_scrolls;
CREATE PERFETTO VIEW screenshot_overlapping_scrolls AS
SELECT
  scroll_id, trace_id, SUM(blocked_by_copy) > 0 AS blocked_by_copy_request
FROM blocking_copy_tasks
GROUP BY 1, 2;

--------------------------------------------------------------------------------
-- Check for blocking language_detection on the browser thread
--------------------------------------------------------------------------------
DROP VIEW IF EXISTS blocking_browser_language_detection;
CREATE PERFETTO VIEW blocking_browser_language_detection AS
SELECT
  id,
  ts,
  dur,
  track_id
FROM slice
WHERE
  (
    name = "language_detection.mojom.LanguageDetectionService"
    AND track_id = (SELECT id FROM browser_main_track_id)
  );

DROP VIEW IF EXISTS blocking_language_detection_tasks;
CREATE PERFETTO VIEW blocking_language_detection_tasks AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  scroll.scroll_id,
  scroll.trace_id,
  lang.id,
  lang.ts,
  lang.dur,
  lang.track_id,
  CASE WHEN lang.track_id = scroll.browser_track_id THEN
    COALESCE(lang.ts < scroll.browser_flow_ts, FALSE)
  END AS blocked_by_language_detection
FROM
  scroll_with_browser_gpu_and_viz_flows scroll JOIN
  blocking_browser_language_detection lang ON
    scroll.ts + scroll.dur >= lang.ts
    AND lang.ts + lang.dur >= scroll.ts;

DROP VIEW IF EXISTS language_detection_overlapping_scrolls;
CREATE PERFETTO VIEW language_detection_overlapping_scrolls AS
SELECT
  scroll_id, trace_id,
  SUM(blocked_by_language_detection) > 0 AS blocked_by_language_detection
FROM blocking_language_detection_tasks
GROUP BY 1, 2;

--------------------------------------------------------------------------------
-- Finally join the causes together for easy grouping.
--------------------------------------------------------------------------------
DROP VIEW IF EXISTS scroll_jank_cause_blocking_task;
CREATE PERFETTO VIEW scroll_jank_cause_blocking_task AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  lang.scroll_id,
  lang.blocked_by_language_detection,
  copy.blocked_by_copy_request
FROM
  language_detection_overlapping_scrolls lang JOIN
  screenshot_overlapping_scrolls copy ON copy.scroll_id = lang.scroll_id;

)_d3l1m1t3r_"
;

const char kChromeScrollJankCauseBlockingTouchMove[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

SELECT RUN_METRIC('chrome/scroll_jank.sql');

-- Below we want to collect TouchMoves and figure out if they blocked any
-- GestureScrollUpdates. This table gets the TouchMove slice and joins it with
-- the data from the first flow event for that TouchMove.
DROP TABLE IF EXISTS touch_move_and_begin_flow;
CREATE PERFETTO TABLE touch_move_and_begin_flow AS
SELECT
  flow.begin_flow_id,
  flow.begin_flow_ts,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  flow.begin_flow_track_id,
  move.*
FROM (
    SELECT
      EXTRACT_ARG(arg_set_id, "chrome_latency_info.trace_id") AS trace_id,
      *
    FROM slice move
    WHERE name = "InputLatency::TouchMove"
  ) move JOIN (
    SELECT
      MIN(id) AS begin_flow_id,
      track_id AS begin_flow_track_id,
      ts AS begin_flow_ts,
      EXTRACT_ARG(arg_set_id, "chrome_latency_info.trace_id")
      AS begin_flow_trace_id
    FROM slice
    WHERE
      name = "LatencyInfo.Flow"
      AND EXTRACT_ARG(arg_set_id, "chrome_latency_info.step") IS NULL
    GROUP BY begin_flow_trace_id
  ) flow ON flow.begin_flow_trace_id = move.trace_id;

-- Now we take the TouchMove and beginning flow event and figure out if there
-- is an end flow event on the same browser track_id. This will allow us to see
-- if it was blocking because if they share the same parent stack then they
-- weren't blocking.
DROP TABLE IF EXISTS touch_move_begin_and_end_flow;
CREATE PERFETTO TABLE touch_move_begin_and_end_flow AS
SELECT
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  flow.end_flow_id,
  flow.end_flow_ts,
  flow.end_flow_track_id,
  move.*
FROM touch_move_and_begin_flow move LEFT JOIN (
    SELECT
      MAX(id) AS end_flow_id,
      ts AS end_flow_ts,
      track_id AS end_flow_track_id,
      EXTRACT_ARG(arg_set_id, "chrome_latency_info.trace_id")
      AS end_flow_trace_id
    FROM slice
    WHERE
      name = "LatencyInfo.Flow"
      AND EXTRACT_ARG(arg_set_id, "chrome_latency_info.step") IS NULL
    GROUP BY end_flow_trace_id
  ) flow ON
    flow.end_flow_trace_id = move.trace_id
    AND move.begin_flow_track_id = flow.end_flow_track_id
    AND flow.end_flow_id != move.begin_flow_id
WHERE flow.end_flow_id IS NOT NULL;

-- Now that we have the begin and the end we need to find the parent stack of
-- both. If the end didn't happen on the browser (end is NULL), then we can
-- ignore it because it couldn't have generated a GestureScrollUpdate.
DROP TABLE IF EXISTS touch_move_with_ancestor;
CREATE PERFETTO TABLE touch_move_with_ancestor AS
SELECT
  begin.id AS begin_ancestor_id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  end.id AS end_ancestor_id,
  end.ts AS end_ancestor_ts,
  end.dur AS end_ancestor_dur,
  end.track_id AS end_ancestor_track_id,
  move.*
FROM
  touch_move_begin_and_end_flow move JOIN
  ancestor_slice(begin_flow_id) begin ON begin.depth = 0 LEFT JOIN
  ancestor_slice(end_flow_id) end ON end.depth = 0;

-- Now take the parent stack for the end and find if a GestureScrollUpdate was
-- launched that share the same parent as the end flow event for the TouchMove.
-- This is the GestureScrollUpdate that the TouchMove blocked (or didn't block)
-- depending on if the begin flow event is in the same stack.
DROP TABLE IF EXISTS blocking_touch_move_with_scroll_update;
CREATE PERFETTO TABLE blocking_touch_move_with_scroll_update AS
SELECT
  move.begin_ancestor_id != move.end_ancestor_id AS blocking_touch_move,
  scroll.scroll_begin_flow_id,
  scroll.scroll_begin_flow_trace_id,
  scroll.scroll_id,
  move.*
FROM touch_move_with_ancestor move LEFT JOIN (
  SELECT in_flow.*, in_scroll.scroll_id FROM (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    SELECT
      MIN(slice.id) AS scroll_begin_flow_id,
      slice.ts AS scroll_begin_flow_ts,
      slice.track_id AS scroll_begin_flow_track_id,
      EXTRACT_ARG(slice.arg_set_id, "chrome_latency_info.trace_id")
      AS scroll_begin_flow_trace_id,
      ancestor.id AS scroll_begin_flow_ancestor_id
    FROM
      slice LEFT JOIN
      ancestor_slice(slice.id) AS ancestor ON ancestor.depth = 0
    WHERE
      slice.name = "LatencyInfo.Flow"
      AND EXTRACT_ARG(slice.arg_set_id, "chrome_latency_info.step") IS NULL
    GROUP BY scroll_begin_flow_trace_id
  ) in_flow JOIN (
    SELECT
      id AS scroll_id,
      EXTRACT_ARG(arg_set_id, "chrome_latency_info.trace_id")
      AS scroll_trace_id
    FROM slice in_scroll
    WHERE
      name = "InputLatency::GestureScrollUpdate"
      AND dur != -1
      AND NOT EXTRACT_ARG(arg_set_id, "chrome_latency_info.is_coalesced")
  ) in_scroll ON
    in_scroll.scroll_trace_id = in_flow.scroll_begin_flow_trace_id
) scroll ON
  scroll.scroll_begin_flow_track_id = move.end_ancestor_track_id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  AND scroll.scroll_begin_flow_ancestor_id = move.end_ancestor_id
  AND scroll.scroll_begin_flow_ts > move.end_ancestor_ts
  AND scroll.scroll_begin_flow_ts < move.end_ancestor_ts + move.end_ancestor_dur
  AND scroll.scroll_begin_flow_id > move.end_ancestor_id
WHERE scroll.scroll_id IS NOT NULL;

-- Now filter out any TouchMoves that weren't during a complete scroll. Most of
-- the other ones will be null anyway since they won't have
-- GestureScrollUpdates.
DROP VIEW IF EXISTS scroll_jank_cause_blocking_touch_move;
CREATE PERFETTO VIEW scroll_jank_cause_blocking_touch_move AS
SELECT
  id,
  ts,
  dur,
  track_id,
  blocking_touch_move,
  scroll_id
FROM joined_scroll_begin_and_end begin_and_end JOIN (
    SELECT
      *
    FROM blocking_touch_move_with_scroll_update
  ) touch ON
    touch.ts <= begin_and_end.end_ts
    AND touch.ts > begin_and_end.begin_ts + begin_and_end.begin_dur
    AND touch.trace_id > begin_and_end.begin_trace_id
    AND touch.trace_id < begin_and_end.end_trace_id;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
)_d3l1m1t3r_"
;

const char kChromeScrollJankCauseGetBitmap[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Needed for the scroll_jank table to tell which updates were janky.
SELECT RUN_METRIC('chrome/scroll_jank.sql');

--------------------------------------------------------------------------------
-- Get all the track ids relevant to the critical path.
--------------------------------------------------------------------------------

-- Grab the track of the browser. sendTouchEvent is a Java category event which
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- only occurs on the browser. This saves us the trouble of dealing with all the
-- different possible names of the browser (when including system tracing).
DROP VIEW IF EXISTS browser_main_track_id;
CREATE PERFETTO VIEW browser_main_track_id AS
SELECT
  track_id AS id
FROM slice
WHERE
  name = "sendTouchEvent"
LIMIT 1;

--------------------------------------------------------------------------------
-- Grab the last LatencyInfo.Flow for each trace_id on the browser main.
--------------------------------------------------------------------------------
DROP VIEW IF EXISTS browser_flows;
CREATE PERFETTO VIEW browser_flows AS
SELECT
  EXTRACT_ARG(arg_set_id, "chrome_latency_info.trace_id") AS trace_id,
  EXTRACT_ARG(arg_set_id, "chrome_latency_info.step") AS flow_step,
  track_id,
  max(ts) AS ts
FROM slice
WHERE
  track_id = (
    SELECT id FROM browser_main_track_id
  )
  AND name = "LatencyInfo.Flow"
GROUP BY trace_id;

--------------------------------------------------------------------------------
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- Join the relevant tracks/flows to the individual scrolls.
--------------------------------------------------------------------------------

-- Keeping only the GestureScrollUpdates join the maximum flows on the browser
-- thread.
DROP VIEW IF EXISTS scroll_with_browser_flows;
CREATE PERFETTO VIEW scroll_with_browser_flows AS
SELECT
  scroll.trace_id,
  scroll.scroll_id,
  scroll.ts,
  scroll.dur,
  scroll.track_id,
  browser_flows.ts AS browser_flow_ts,
  browser_flows.flow_step AS browser_flow_step,
  browser_flows.track_id AS browser_track_id
FROM (
  SELECT
    trace_id,
    id AS scroll_id,
    ts,
    dur,
    track_id
  FROM scroll_jank
) scroll JOIN browser_flows ON
  scroll.trace_id = browser_flows.trace_id;

--------------------------------------------------------------------------------
-- Below we determine if there was any bitmaps taken on the browser main.
--------------------------------------------------------------------------------
DROP VIEW IF EXISTS get_bitmap_calls;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO VIEW get_bitmap_calls AS
SELECT
  id,
  ts,
  dur,
  track_id
FROM slice
WHERE
  slice.name = "ViewResourceAdapter:getBitmap"
  AND track_id = (SELECT id FROM browser_main_track_id);

DROP VIEW IF EXISTS toolbar_bitmaps;
CREATE PERFETTO VIEW toolbar_bitmaps AS
SELECT
  slice.id,
  slice.ts,
  slice.dur,
  slice.track_id,
  ancestor.id AS ancestor_id
FROM
  slice JOIN
  ancestor_slice(slice.id) AS ancestor ON
    ancestor.depth = slice.depth - 1
WHERE
  slice.name = "ToolbarLayout.draw"
  AND ancestor.name = "ViewResourceAdapter:getBitmap"
  AND slice.track_id = (SELECT id FROM browser_main_track_id);

DROP VIEW IF EXISTS get_bitmaps_and_toolbar;
CREATE PERFETTO VIEW get_bitmaps_and_toolbar AS
SELECT
  bitmap.id AS id,
  bitmap.ts AS ts,
  bitmap.dur AS dur,
  bitmap.track_id AS track_id,
  toolbar.id AS toolbar_id,
  toolbar.ts AS toolbar_ts,
  toolbar.dur AS toolbar_dur,
  toolbar.track_id AS toolbar_track_id
FROM
  get_bitmap_calls bitmap LEFT JOIN
  toolbar_bitmaps toolbar ON
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    toolbar.ancestor_id = bitmap.id;

--------------------------------------------------------------------------------
-- Take bitmaps and determine if it could have been blocked by a scroll. I.E. if
-- the bitmap occurred after the start of the GestureScrollUpdate but before the
-- last flow on the browser thread (the GestureScrollUpdate can't be blocked
-- by a browser thread slice once its done on the browser thread).
--------------------------------------------------------------------------------
DROP VIEW IF EXISTS blocking_bitmap_tasks;
CREATE PERFETTO VIEW blocking_bitmap_tasks AS
SELECT
  scroll.scroll_id,
  scroll.trace_id,
  bitmap.id,
  bitmap.ts,
  bitmap.dur,
  bitmap.track_id,
  COALESCE(bitmap.track_id = scroll.browser_track_id
    AND bitmap.ts < scroll.browser_flow_ts, FALSE) AS blocked_by_bitmap,
  COALESCE(bitmap.track_id = scroll.browser_track_id
    AND bitmap.toolbar_id IS NOT NULL
    AND bitmap.ts < scroll.browser_flow_ts, FALSE) AS blocked_by_toolbar,
  COALESCE(bitmap.track_id = scroll.browser_track_id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    AND bitmap.toolbar_id IS NULL
    AND bitmap.ts < scroll.browser_flow_ts, FALSE) AS blocked_by_bitmap_no_toolbar
FROM
  scroll_with_browser_flows scroll JOIN
  get_bitmaps_and_toolbar bitmap ON
    scroll.ts + scroll.dur >= bitmap.ts
    AND bitmap.ts + bitmap.dur >= scroll.ts;


--------------------------------------------------------------------------------
-- Remove duplicate tasks blocking so that there is only a boolean per
-- scroll_id.
--------------------------------------------------------------------------------
DROP VIEW IF EXISTS scroll_jank_cause_get_bitmap;
CREATE PERFETTO VIEW scroll_jank_cause_get_bitmap AS
SELECT
  scroll_id,
  trace_id,
  SUM(blocked_by_bitmap) > 0 AS blocked_by_bitmap,
  SUM(blocked_by_toolbar) > 0 AS blocked_by_toolbar,
  SUM(blocked_by_bitmap_no_toolbar) > 0 AS blocked_by_bitmap_no_toolbar
FROM blocking_bitmap_tasks
GROUP BY 1, 2;

)_d3l1m1t3r_"
;

const char kChromeScrollJankCauseQueuingDelay[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the 'License');
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an 'AS IS' BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

SELECT RUN_METRIC('chrome/chrome_thread_slice.sql');
SELECT RUN_METRIC('chrome/scroll_flow_event_queuing_delay.sql');

-- See b/184134310 why we remove ThreadController active.
DROP VIEW IF EXISTS blocking_tasks_no_threadcontroller_active;
CREATE PERFETTO VIEW blocking_tasks_no_threadcontroller_active AS
SELECT
  slice.*,
  ancestor.id AS task_ancestor_id,
  ancestor.name AS task_ancestor_name
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM
  chrome_thread_slice AS slice LEFT JOIN
  ancestor_slice(slice.id) AS ancestor ON ancestor.id = slice.parent_id
WHERE
  slice.name != "ThreadController active"
  AND (slice.depth = 0 OR ancestor.name = "ThreadController active");

-- Sort track ids to optimize joining with slices
-- as engine doesn't do the sort to join in O(LogN)
-- per row by default
-- TODO(243897379): switch this back to a view once we understand why rolling SQLite to
-- 3.39.2 causes slowdowns.
DROP TABLE IF EXISTS chrome_annotated_threads_and_processes;
CREATE PERFETTO TABLE chrome_annotated_threads_and_processes AS
SELECT
  thread_track.id AS track_id,
  chrome_thread.canonical_name AS thread_name,
  chrome_process.process_type AS process_name
FROM
  thread_track JOIN
  chrome_thread JOIN
  chrome_process ON
    thread_track.utid = chrome_thread.utid
    AND chrome_thread.upid = chrome_process.upid
ORDER BY
  track_id ASC;

-- See b/166441398 & crbug/1094361 for why we remove threadpool (originally
-- the -to-End step). In essence -to-End is often reported on the ThreadPool
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- after the fact with explicit timestamps so it being blocked isn't noteworthy.
-- TODO(243897379): switch this back to a view once we understand why rolling SQLite to
-- 3.39.2 causes slowdowns.
DROP TABLE IF EXISTS blocking_chrome_tasks_without_threadpool;
CREATE PERFETTO TABLE blocking_chrome_tasks_without_threadpool AS
SELECT
  slice.*,
  annotations.thread_name AS thread_name,
  annotations.process_name AS process_name
FROM
  blocking_tasks_no_threadcontroller_active AS slice JOIN
  chrome_annotated_threads_and_processes AS annotations ON
    annotations.track_id = slice.track_id
WHERE
  NOT(thread_name GLOB "*ThreadPool*");

-- This view grabs any slice that could have prevented any GestureScrollUpdate
-- flow event from being run (queuing delays). For RunTask we know that its
-- generic (and thus hard to figure out whats the cause) so we grab the src
-- location to make it more meaningful.
--
-- See b/184134310 for why we allow depth = 1 and ancestor.id is null (which
-- implies its a "ThreadController active" slice because we removed it
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- previously).
DROP TABLE IF EXISTS blocking_tasks_queuing_delay;
CREATE PERFETTO TABLE blocking_tasks_queuing_delay AS
SELECT
  EXTRACT_ARG(slice.arg_set_id, "task.posted_from.file_name") AS file,
  EXTRACT_ARG(slice.arg_set_id, "task.posted_from.function_name") AS function,
  trace_id,
  queuing_time_ns,
  avg_vsync_interval,
  next_track_id,
  CASE WHEN queuing.ancestor_end <= slice.ts THEN
      CASE WHEN slice.ts + slice.dur <= queuing.maybe_next_ancestor_ts THEN
        slice.dur
        ELSE
          queuing.maybe_next_ancestor_ts - slice.ts
      END
    ELSE
      CASE WHEN slice.ts + slice.dur <= queuing.maybe_next_ancestor_ts THEN
        slice.ts + slice.dur - queuing.ancestor_end
        ELSE
          queuing.maybe_next_ancestor_ts - queuing.ancestor_end
      END
  END AS dur_overlapping_ns,
  description,
  scroll_slice_id,
  scroll_ts,
  scroll_dur,
  scroll_track_id,
  jank,
  slice.*
FROM
  scroll_flow_event_queuing_delay queuing JOIN
  blocking_chrome_tasks_without_threadpool AS slice ON
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    slice.ts + slice.dur > queuing.ancestor_end
    AND queuing.maybe_next_ancestor_ts > slice.ts
    AND slice.track_id = queuing.next_track_id
WHERE
  queuing_time_ns IS NOT NULL
  AND queuing_time_ns > 0;

-- Now for each toplevel task (depth = 0 from above) we want to grab all their
-- children slices. This is done by joining on descendant_slice which is a
-- trace processor defined operator. This will results in 1 row for every
-- descendant slice. So all fields in base.* will be repeated ONCE for each
-- child, but if it has no slice it will occur only once but all the
-- |descendant_.*| fields will be NULL because of the LEFT JOIN.
-- Additionally for mojo events we replace the descendant_name with just the
-- "interface_name" since that is more descriptive for our jank purposes.
DROP VIEW IF EXISTS all_descendant_blocking_tasks_queuing_delay;
CREATE PERFETTO VIEW all_descendant_blocking_tasks_queuing_delay AS
SELECT
  descendant.id AS descendant_id,
  descendant.ts AS descendant_ts,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  descendant.dur AS descendant_dur,
  COALESCE(
    IIF(descendant.arg_set_id IS NOT NULL,
      EXTRACT_ARG(descendant.arg_set_id,
        "chrome_mojo_event_info.watcher_notify_interface_tag"),
      NULL),
    IIF(descendant.arg_set_id IS NOT NULL,
      EXTRACT_ARG(descendant.arg_set_id,
        "chrome_mojo_event_info.mojo_interface_tag"),
      NULL),
    descendant.name) AS descendant_name,
  EXTRACT_ARG(descendant.arg_set_id,
    "chrome_mojo_event_info.ipc_hash") AS descendant_ipc_hash,
  descendant.parent_id AS descendant_parent_id,
  descendant.depth AS descendant_depth,
  descendant.category AS descendant_category,
  base.*
FROM
  blocking_tasks_queuing_delay base LEFT JOIN
  descendant_slice(base.id) AS descendant;

DROP TABLE IF EXISTS all_descendant_blocking_tasks_queuing_delay_with_cpu_time;
CREATE PERFETTO TABLE all_descendant_blocking_tasks_queuing_delay_with_cpu_time AS
SELECT
  cpu.thread_dur AS descendant_thread_dur,
  CAST(cpu.thread_dur AS REAL) / descendant.thread_dur
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  AS descendant_cpu_percentage,
  CAST(cpu.thread_dur AS REAL)
  / (descendant.thread_dur
    / (1 << (descendant.descendant_depth - 1))) > 0.5
  AS descendant_cpu_time_above_relative_threshold,
  descendant_dur / descendant.dur AS descendant_dur_percentage,
  descendant_dur
  / (descendant.dur / (1 << (descendant.descendant_depth - 1))) > 0.5
  AS descendant_dur_above_relative_threshold,
  descendant.*
FROM
  all_descendant_blocking_tasks_queuing_delay descendant LEFT JOIN (
    SELECT
      id, thread_dur
    FROM chrome_thread_slice
  ) AS cpu ON
    cpu.id = descendant.descendant_id;

-- Now that we've generated the descendant count how many siblings each row
-- has. Recall that all the top level tasks are repeated but each row represents
-- a descendant slice. This means since we LEFT JOIN we will say a slice has 0
-- siblings if it has no descendants (which is true), and otherwise we will
-- compute the siblings as the count of all slices with the same parent minus
-- the current slice.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(DROP VIEW IF EXISTS counted_descendant_blocking_tasks_queuing_delay;
CREATE PERFETTO VIEW counted_descendant_blocking_tasks_queuing_delay AS
SELECT
  base.*,
  COALESCE(single_descendant.number_of_siblings, 0) AS number_of_siblings
FROM
  all_descendant_blocking_tasks_queuing_delay_with_cpu_time base LEFT JOIN (
    SELECT
      descendant_parent_id,
      COUNT(*) - 1 AS number_of_siblings
    FROM all_descendant_blocking_tasks_queuing_delay_with_cpu_time
    WHERE descendant_parent_id IS NOT NULL
    GROUP BY 1
  ) single_descendant ON
    single_descendant.descendant_parent_id = base.descendant_parent_id;

-- Now we group by the |id| which is the top level task id and find the first
-- descendant_depth where we have a sibling. We need this because we only want
-- to include single descendant slices in our metric name to keep it easy to
-- reason about what that code is doing.
DROP VIEW IF EXISTS blocking_tasks_queuing_delay_with_invalid_depth;
CREATE PERFETTO VIEW blocking_tasks_queuing_delay_with_invalid_depth AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  base.*,
  (
    descendant_cpu_time_above_relative_threshold
    AND descendant_cpu_percentage > 0.05
  ) OR (
    descendant_dur_above_relative_threshold
    AND descendant_dur_percentage > 0.05
  ) AS descendant_major_slice,
  COALESCE(depth.invalid_depth, 10) AS invalid_depth
FROM
  counted_descendant_blocking_tasks_queuing_delay base LEFT JOIN (
    SELECT
      id,
      MIN(descendant_depth) AS invalid_depth
    FROM counted_descendant_blocking_tasks_queuing_delay
    WHERE number_of_siblings >= 1
    GROUP BY 1
  ) AS depth ON base.id = depth.id
ORDER BY
  descendant_depth ASC,
  descendant_cpu_percentage DESC,
  descendant_dur_percentage DESC;

-- Now to get back to a single output per top level task we group by all the
-- toplevel fields and aggregate the descendant fields. We only include the
-- descendant if their depth is less than the first depth with siblings (the
-- |invalid_depth|).
DROP VIEW IF EXISTS descendant_blocking_tasks_queuing_delay;
CREATE PERFETTO VIEW descendant_blocking_tasks_queuing_delay AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  id,
  ts,
  dur,
  track_id,
  trace_id,
  name,
  category,
  scroll_slice_id AS scroll_id,
  scroll_ts,
  scroll_dur,
  scroll_track_id,
  jank,
  queuing_time_ns,
  dur_overlapping_ns,
  description,
  replace(file, rtrim(file, replace(file, '/', '')), '') AS file,
  thread_name,
  process_name,
  function,
  avg_vsync_interval,
  GROUP_CONCAT(
    CASE WHEN descendant_depth < invalid_depth OR descendant_major_slice THEN
        descendant_id
      ELSE
        NULL
    END,
    "-") AS descendant_id,
  GROUP_CONCAT(
    CASE WHEN descendant_depth < invalid_depth OR descendant_major_slice THEN
        descendant_ts
      ELSE
        NULL
    END,
    "-") AS descendant_ts,
  GROUP_CONCAT(
    CASE WHEN descendant_depth < invalid_depth OR descendant_major_slice THEN
        descendant_dur
      ELSE
        NULL
    END,
    "-") AS descendant_dur,
  GROUP_CONCAT(
    CASE WHEN descendant_depth < invalid_depth OR descendant_major_slice THEN
        descendant_name
      ELSE
)_d3l1m1t3r_"
R"_d3l1m1t3r_(        NULL
    END, "-") AS descendant_name,
  GROUP_CONCAT(
    CASE WHEN descendant_depth < invalid_depth OR descendant_major_slice THEN
        descendant_thread_dur
      ELSE
        NULL
    END,
    "-") AS descendant_thread_dur,
  GROUP_CONCAT(
    CASE WHEN descendant_depth < invalid_depth OR descendant_major_slice THEN
        descendant_cpu_percentage
      ELSE
        NULL
    END,
    "-") AS descendant_cpu_time,
  GROUP_CONCAT(
    CASE WHEN descendant_category = "mojom" THEN
        descendant_name
      ELSE
        NULL
    END,
    "-") AS mojom_name,
  -- All ipc_hashes should be equal so just select the first non-null one.
  MIN(descendant_ipc_hash) AS mojom_ipc_hash,
  GROUP_CONCAT(
    CASE WHEN
        descendant_category = "toplevel"
        AND descendant_name NOT GLOB "*ThreadController*" THEN
        descendant_name
      ELSE
        NULL
    END,
    "-") AS toplevel_name,
  GROUP_CONCAT(
    CASE WHEN descendant_category = "Java" THEN
        descendant_name
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      ELSE
        NULL
    END,
    "-") AS java_name
FROM
  blocking_tasks_queuing_delay_with_invalid_depth
GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20
ORDER BY descendant_cpu_percentage DESC;

-- Function prototype: takes a - separated list of slice names (formed by
-- the GROUP_CONCAT above) and returns the first slice if any or NULL
-- otherwise.
CREATE OR REPLACE PERFETTO FUNCTION get_first_slice_name_or_null(name STRING)
-- Returns the first slice name or NULL
RETURNS STRING AS
-- Performs the actual string modification, takes the either the whole string
-- if there is no - or up to the first '-'. SUBSTR returns NULL if $name is
-- NULL.
SELECT SUBSTR($name, 0,
  CASE WHEN INSTR($name, "-") = 0 THEN
    LENGTH($name)+1 ELSE
    INSTR($name, "-")
  END);

-- Function prototype: takes a - separated list of slice names (formed by
-- the GROUP_CONCAT above) and checks for certain important view names and
-- falls back on get_first_slice_name_or_null if it can't find one.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE OR REPLACE PERFETTO FUNCTION get_java_slice_summary_or_null(name STRING)
-- Returns the summary of the provided list of java slice names.
RETURNS STRING AS
-- Performs a bunch of GLOB matches in an order, now there could be multiple
-- matches (both Toolbar & TabList could be true) so the order matters in
-- tagging since we dont support multiple tagging of values. Ideally we would
-- determine which one was the longest duration, but this should be sufficient
-- for now.
SELECT
  CASE WHEN $name GLOB "*ToolbarControlContainer*" THEN
    "ToolbarControlContainer"
  WHEN $name GLOB "*ToolbarProgressBar*" THEN
    "ToolbarProgressBar"
  WHEN $name GLOB "*TabGroupUiToolbarView*" THEN
    "TabGroupUiToolbarView"
  WHEN $name GLOB "*TabGridThumbnailView*" THEN
    "TabGridThumbnailView"
  WHEN $name GLOB "*TabThumbnailView" THEN
    "TabThumbnailView"
  WHEN $name GLOB "*TabGridDialogView*" THEN
    "TabGridDialogView"
  WHEN $name GLOB "*BottomContainer*" THEN
    "BottomContainer"
  WHEN $name GLOB "*FeedSwipeRefreshLayout*" THEN
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    "FeedSwipeRefreshLayout"
  WHEN $name GLOB "*AutocompleteEditText*" THEN
    "AutocompleteEditText"
  WHEN $name GLOB "*HomeButton*" THEN
    "HomeButton"
  WHEN $name GLOB "*ToggleTabStackButton*" THEN
    "ToggleTabStackButton"
  WHEN $name GLOB "*ListMenuButton*" THEN
    "ListMenuButton"
  WHEN $name GLOB "*ScrimView*" THEN
    "ScrimView"
  WHEN $name GLOB "*ChromeImageView*" THEN
    "ChromeImageView"
  WHEN $name GLOB "*AppCompatImageView*" THEN
    "AppCompatImageView"
  WHEN $name GLOB "*ChromeImageButton*" THEN
    "ChromeImageButton"
  WHEN $name GLOB "*AppCompatImageButton*" THEN
    "AppCompatImageButton"
  WHEN $name GLOB "*TabListRecyclerView*" THEN
    "TabListRecyclerView"
  ELSE
    get_first_slice_name_or_null($name)
  END;

-- Function prototype: takes slice name, category and descendant_name and
-- determines if this event should be classified as unknown or not.
--
-- Returns either "-UnknownEvent" or "".
CREATE OR REPLACE PERFETTO FUNCTION unknown_event_or_empty_string(name STRING,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(                                                   cat STRING,
                                                   has_descendant STRING)
RETURNS STRING AS
-- If our current event has a posted from we consider it already categorized
-- even if we dont have events underneath it. If its java often we wont have
-- sub events, and finally if its a single event we just use its name there
-- isn't anything under to use so just leave it at that.
SELECT
  CASE WHEN
    $name = "ThreadControllerImpl::RunTask" OR
    $cat = "Java" OR
    $has_descendant IS NULL THEN
      "" ELSE
      "-UnknownEvent"
    END;

-- Function prototype: Takes a slice name, function, and file, and determines
-- if we should use the slice name, or if its a RunTask event uses the
-- function & file name, however if the RunTask posted from is one of the
-- simple_watcher paths we collapse them for attributation.
CREATE OR REPLACE PERFETTO FUNCTION top_level_name(name STRING, function STRING, file STRING)
RETURNS STRING AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- The difference for the mojom functions are:
--  1) PostDispatchNextMessageFromPipe:
--         We knew that there is a message in the pipe, didnt try to set up a
--         SimpleWatcher to monitor when a new one arrives.
--  2) ArmOrNotify:
--         We tried to set up SimpleWatcher, but the setup failed as the
--         message arrived as we were setting this up, so we posted a task
--         instead.
--  3) Notify:
--         SimpleWatcher was set up and after a period of monitoring detected
--         a new message.
-- For our jank use case this distinction isnt very useful so we group them
-- together.
SELECT
    CASE WHEN $name = "ThreadControllerImpl::RunTask" THEN
      CASE WHEN $function IN
          ("PostDispatchNextMessageFromPipe", "ArmOrNotify", "Notify") THEN
        "posted-from-mojo-pipe"
      ELSE
        "posted-from-" || $function || "()-in-" || $file
      END
  ELSE
    $name
  END;

-- Create a common name for each "cause" based on the slice stack we found.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(DROP VIEW IF EXISTS scroll_jank_cause_queuing_delay_temp;
CREATE PERFETTO VIEW scroll_jank_cause_queuing_delay_temp AS
SELECT
  top_level_name(name, function, file) || COALESCE(
    "-" || descendant_name, "") AS location,
  top_level_name(name, function, file) || COALESCE(
    "-" || get_first_slice_name_or_null(mojom_name)
    || COALESCE("(ipc=" || mojom_ipc_hash || ")", ""),
    "-" || get_first_slice_name_or_null(toplevel_name)
    || COALESCE("(ipc=" || mojom_ipc_hash || ")", ""),
    "-" || get_java_slice_summary_or_null(java_name),
    unknown_event_or_empty_string(name, category, descendant_name)
  ) AS restricted_location,
  base.*
FROM descendant_blocking_tasks_queuing_delay base;

-- Figure out the average time taken during non-janky scrolls updates for each
-- TraceEvent (metric_name) stack.
DROP VIEW IF EXISTS scroll_jank_cause_queuing_delay_average_no_jank_time;
CREATE PERFETTO VIEW scroll_jank_cause_queuing_delay_average_no_jank_time AS
SELECT
  location,
  AVG(dur_overlapping_ns) AS avg_dur_overlapping_ns
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM scroll_jank_cause_queuing_delay_temp
WHERE NOT jank
GROUP BY 1;

-- Again figure out the average time, but based on a more restricted set of
-- trace events.
DROP VIEW IF EXISTS scroll_jank_cause_queuing_delay_average_no_jank_time_restricted;
CREATE PERFETTO VIEW scroll_jank_cause_queuing_delay_average_no_jank_time_restricted AS
SELECT
  restricted_location,
  AVG(dur_overlapping_ns) AS avg_dur_overlapping_ns_restricted
FROM scroll_jank_cause_queuing_delay_temp
WHERE NOT jank
GROUP BY 1;


-- Join every row (jank and non-jank with the average non-jank time for the
-- given metric_name).
DROP VIEW IF EXISTS scroll_jank_cause_queuing_delay_unannotated;
CREATE PERFETTO VIEW scroll_jank_cause_queuing_delay_unannotated AS
SELECT
  base.*,
  'InputLatency.LatencyInfo.Flow.QueuingDelay.'
  || CASE WHEN jank THEN 'Jank' ELSE 'NoJank' END || '.BlockingTasksUs.'
  || base.location AS metric_name,
  COALESCE(avg_no_jank.avg_dur_overlapping_ns, 0)
  AS avg_no_jank_dur_overlapping_ns
FROM
  scroll_jank_cause_queuing_delay_temp base LEFT JOIN
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  scroll_jank_cause_queuing_delay_average_no_jank_time avg_no_jank ON
    base.location = avg_no_jank.location;

-- Join in the restricted set of trace events average as well to form the final output.
DROP VIEW IF EXISTS scroll_jank_cause_queuing_delay;
CREATE PERFETTO VIEW scroll_jank_cause_queuing_delay AS
SELECT
  base.*,
  'QueuingDelay.'
  || CASE WHEN jank THEN 'Jank' ELSE 'NoJank' END || '.BlockingTasksUs.'
  || base.restricted_location AS restricted_metric_name,
  COALESCE(avg_no_jank.avg_dur_overlapping_ns_restricted, 0)
  AS avg_no_jank_dur_overlapping_ns_restricted
FROM
  scroll_jank_cause_queuing_delay_unannotated base LEFT JOIN
  scroll_jank_cause_queuing_delay_average_no_jank_time_restricted avg_no_jank ON
    base.restricted_location = avg_no_jank.restricted_location;

)_d3l1m1t3r_"
;

const char kChromeSufficientChromeProcesses[] = R"_d3l1m1t3r_(--
-- Copyright 2021 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
-- Get all chrome processes and threads tables set up.
SELECT RUN_METRIC('chrome/chrome_processes.sql');

-- When working on InputLatency events we need to ensure we have all the events
-- from the browser, renderer, and GPU processes. This query isn't quite
-- perfect. In system tracing we could have 3 browser processes all in the
-- background and this would match, but for now its the best we can do (renderer
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- and GPU names on android are quite complicated, but this should filter 99%
-- (citation needed) of what we want.
--
-- See b/151077536 for historical context.
DROP VIEW IF EXISTS sufficient_chrome_processes;
CREATE PERFETTO VIEW sufficient_chrome_processes AS
SELECT
  CASE WHEN (
      SELECT COUNT(*) FROM chrome_process) = 0
    THEN
    FALSE
    ELSE (
      SELECT COUNT(*) >= 3 FROM (
        SELECT name FROM chrome_process
        WHERE
          name GLOB "Browser"
          OR name GLOB "Renderer"
          OR name GLOB "Gpu"
          OR name GLOB 'com.android.chrome*'
          OR name GLOB 'com.chrome.beta*'
          OR name GLOB 'com.chrome.dev*'
          OR name GLOB 'com.chrome.canary*'
          OR name GLOB 'com.google.android.apps.chrome*'
          OR name GLOB 'org.chromium.chrome*'
        GROUP BY name
      )) END AS have_enough_chrome_processes;

)_d3l1m1t3r_"
;

const char kChromeTestChromeMetric[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

DROP VIEW IF EXISTS test_chrome_metric_output;
CREATE PERFETTO VIEW test_chrome_metric_output AS
SELECT TestChromeMetric('test_value', 1);

)_d3l1m1t3r_"
;

const char kChromeTouchFlowEvent[] = R"_d3l1m1t3r_(--
-- Copyright 2021 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the 'License');
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an 'AS IS' BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
-- While handling a InputLatency::TouchMove event a sequence of Flows define the
-- critical path from Beginning to End. This metric breaks down the flows for
-- the same InputLatency::TouchMove event.
--
-- WARNING: This metric should not be used as a source of truth. It is under
--          active development and the values & meaning might change without
--          notice.

-- Provides the touch_jank table which gives us all the TouchMove events we care
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- about and labels them janky or not.
SELECT RUN_METRIC(
    'chrome/gesture_flow_event.sql',
    'prefix', 'touch',
    'gesture_update', 'TouchMove',
    'id_field', 'touch_id'
);

)_d3l1m1t3r_"
;

const char kChromeTouchFlowEventQueuingDelay[] = R"_d3l1m1t3r_(--
-- Copyright 2021 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the 'License');
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an 'AS IS' BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
-- This metric takes each flow event in a InputLatency::GestureScrollUpdate and
-- and computes the time from the ancestor_end of the current flow to the
-- ancestor_ts of the next flow event. This is a reasonable approximation of the
-- time we waited for the next step in the critical flow to start.

-- Provides the scroll_flow_event table which gives us all the flow events with
-- associated TouchMove events we care about and labels them janky or not.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT RUN_METRIC('chrome/gesture_flow_event_queuing_delay.sql',
    'prefix', 'touch',
    'id_field', 'touch_id');

)_d3l1m1t3r_"
;

const char kChromeTouchJank[] = R"_d3l1m1t3r_(--
-- Copyright 2021 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
-- A collection of metrics related to TouchMove events.
--
-- We define a TouchMove to be janky if comparing forwards or backwards
-- (ignoring coalesced updates) a given TouchMove exceeds the duration of its
-- predecessor or successor by 50% of a vsync interval (defaulted to 60 FPS).
--
-- WARNING: This metric should not be used as a source of truth. It is under
--          active development and the values & meaning might change without
)_d3l1m1t3r_"
R"_d3l1m1t3r_(--          notice.

SELECT RUN_METRIC(
    'chrome/gesture_jank.sql',
    'prefix', 'touch',
    'gesture_start', 'TouchStart',
    'gesture_update', 'TouchMove',
    'gesture_end', 'TouchEnd',
    'id_field', 'touch_id',
    'proto_name', 'TouchJank');

)_d3l1m1t3r_"
;

const char kCommonParentSlice[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE deprecated.v42.common.slices;

)_d3l1m1t3r_"
;

const char kExperimentalChromeDroppedFrames[] = R"_d3l1m1t3r_(--
-- Copyright 2021 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Find all dropped frames, i.e. all PipelineReporters slices whose
-- state is 'STATE_DROPPED'.
DROP TABLE IF EXISTS dropped_pipeline_reporter_slice;
CREATE PERFETTO TABLE dropped_pipeline_reporter_slice AS
SELECT slice.* FROM slice
JOIN args
  ON slice.arg_set_id = args.arg_set_id
WHERE
  slice.name = 'PipelineReporter'
  AND args.string_value = 'STATE_DROPPED';

-- Find the upid of the proccesses where the dropped frames occur.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(DROP VIEW IF EXISTS dropped_frames_with_upid;
CREATE PERFETTO VIEW dropped_frames_with_upid AS
SELECT
  dropped_pipeline_reporter_slice.ts,
  process_track.upid
FROM dropped_pipeline_reporter_slice
JOIN process_track
  ON dropped_pipeline_reporter_slice.track_id = process_track.id;

-- Find the name and pid of the processes.
-- If the process name represents a file's pathname, the path part will be
-- removed from the display name of the process.
DROP VIEW IF EXISTS dropped_frames_with_process_info;
CREATE PERFETTO VIEW dropped_frames_with_process_info AS
SELECT
  dropped_frames_with_upid.ts,
  REPLACE(
    process.name,
    RTRIM(
      process.name,
      REPLACE(process.name, '/', '')
    ),
    '') AS process_name,
  process.pid AS process_id
FROM dropped_frames_with_upid
JOIN process
  ON dropped_frames_with_upid.upid = process.upid;

-- Create the derived event track for dropped frames.
-- All tracks generated from chrome_dropped_frames_event are
-- placed under a track group named 'Dropped Frames', whose summary
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- track is the first track ('All Processes') in chrome_dropped_frames_event.
-- Note that the 'All Processes' track is generated only when dropped frames
-- come from more than one origin process.
DROP VIEW IF EXISTS chrome_dropped_frames_event;
CREATE PERFETTO VIEW chrome_dropped_frames_event AS
SELECT
  'slice' AS track_type,
  'All Processes' AS track_name,
  ts,
  0 AS dur,
  'Dropped Frame' AS slice_name,
  'Dropped Frames' AS group_name
FROM dropped_frames_with_process_info
WHERE (SELECT COUNT(DISTINCT process_id)
                    FROM dropped_frames_with_process_info) > 1
GROUP BY ts
UNION ALL
SELECT
  'slice' AS track_type,
  COALESCE(process_name, 'Process') || ' ' || process_id AS track_name,
  ts,
  0 AS dur,
  'Dropped Frame' AS slice_name,
  'Dropped Frames' AS group_name
FROM dropped_frames_with_process_info
GROUP BY process_id, ts;

-- Create the dropped frames metric output.
DROP VIEW IF EXISTS chrome_dropped_frames_output;
CREATE PERFETTO VIEW chrome_dropped_frames_output AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT ChromeDroppedFrames(
  'dropped_frame', (
    SELECT RepeatedField(
      ChromeDroppedFrames_DroppedFrame(
        'ts', ts,
        'process_name', process_name,
        'pid', process_id
      )
    )
    FROM dropped_frames_with_process_info
    ORDER BY ts
  )
);

)_d3l1m1t3r_"
;

const char kExperimentalChromeLongLatency[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Find all long EventLatency slices > 100ms and also get the
-- type of the event stored as 'debug.event' argument.
-- In order to group all events
-- Note that a long latency event is represented by the ending time
-- of an EventLatency slice, i.e. the timestamp of the frame presentation
-- that reflects the event.
DROP VIEW IF EXISTS long_eventlatency_slice;
CREATE PERFETTO VIEW long_eventlatency_slice AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  ts + dur AS ts,
  dur,
  id,
  track_id,
  EXTRACT_ARG(arg_set_id, 'debug.event') AS event_type
FROM slice WHERE name = 'EventLatency' AND dur > 100000000;

-- Find the upid of the proccesses where the long latency occur.
DROP VIEW IF EXISTS long_latency_with_upid;
CREATE PERFETTO VIEW long_latency_with_upid AS
SELECT
  long_eventlatency_slice.ts,
  long_eventlatency_slice.event_type,
  process_track.upid
FROM long_eventlatency_slice
JOIN process_track
  ON long_eventlatency_slice.track_id = process_track.id;

-- Find the name and pid of the processes.
-- Long latency events with the same timestamp and from the same process
-- are considered one single long latency occurrence.
-- If the process name represents a file's pathname, the path part will be
-- removed from the display name of the process.
DROP VIEW IF EXISTS long_latency_with_process_info;
CREATE PERFETTO VIEW long_latency_with_process_info AS
SELECT
  long_latency_with_upid.ts,
  GROUP_CONCAT(DISTINCT long_latency_with_upid.event_type) AS event_type,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  REPLACE(
    process.name,
    RTRIM(
      process.name,
      REPLACE(process.name, '/', '')
    ),
    '') AS process_name,
  process.pid AS process_id
FROM long_latency_with_upid
JOIN process
  ON long_latency_with_upid.upid = process.upid
GROUP BY ts, process.pid;

-- Create the derived event track for long latency.
-- All tracks generated from chrome_long_latency_event are
-- placed under a track group named 'Long Latency', whose summary
-- track is the first track ('All Processes') in chrome_long_latency_event.
-- Note that the 'All Processes' track is generated only when there are more
-- than one source of long latency events.
DROP VIEW IF EXISTS chrome_long_latency_event;
CREATE PERFETTO VIEW chrome_long_latency_event AS
SELECT
  'slice' AS track_type,
  'All Processes' AS track_name,
  ts,
  0 AS dur,
  event_type AS slice_name,
  'Long Latency' AS group_name
FROM long_latency_with_process_info
WHERE (SELECT COUNT(DISTINCT process_id)
                    FROM long_latency_with_process_info) > 1
)_d3l1m1t3r_"
R"_d3l1m1t3r_(GROUP BY ts
UNION ALL
SELECT
  'slice' AS track_type,
  process_name || ' ' || process_id AS track_name,
  ts,
  0 AS dur,
  event_type AS slice_name,
  'Long Latency' AS group_name
FROM long_latency_with_process_info
GROUP BY ts;

-- Create the long latency metric output.
DROP VIEW IF EXISTS chrome_long_latency_output;
CREATE PERFETTO VIEW chrome_long_latency_output AS
SELECT ChromeLongLatency(
  'long_latency', (
    SELECT RepeatedField(
      ChromeLongLatency_LongLatency(
        'ts', ts,
        'event_type', event_type,
        'process_name', process_name,
        'pid', process_id
      )
    )
    FROM long_latency_with_process_info
    ORDER BY ts
  )
);

)_d3l1m1t3r_"
;

const char kExperimentalFrameTimes[] = R"_d3l1m1t3r_(--
-- Copyright 2021 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

DROP VIEW IF EXISTS InteractionEvents;
CREATE PERFETTO VIEW InteractionEvents AS
SELECT
  ts, dur, ts AS ts_ir, dur AS dur_ir
FROM slice WHERE name GLOB 'Interaction.*';

DROP VIEW IF EXISTS GestureLegacyEvents;
CREATE PERFETTO VIEW GestureLegacyEvents AS
SELECT
  ts,
  EXTRACT_ARG(arg_set_id, 'legacy_event.phase') AS phase
FROM raw
WHERE EXTRACT_ARG(arg_set_id, 'legacy_event.name') = 'SyntheticGestureController::running';
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Convert pairs of 'S' and 'F' events into slices with ts and dur.
DROP VIEW IF EXISTS GestureEvents;
CREATE PERFETTO VIEW GestureEvents AS
SELECT
  ts, dur, ts AS ts_ge, dur AS dur_ge
FROM (
  SELECT
    ts,
    phase,
    LEAD(ts) OVER (ORDER BY ts) - ts AS dur
  FROM GestureLegacyEvents
)
WHERE phase = 'S';

DROP TABLE IF EXISTS InteractionEventsJoinGestureEvents;
CREATE VIRTUAL TABLE InteractionEventsJoinGestureEvents
USING SPAN_LEFT_JOIN(InteractionEvents, GestureEvents);

--------------------------------------------------------------------------------
-- Interesting segments are:
-- 1) If there's a gesture overlapping with interaction, then gesture's range.
-- 2) Else, interaction's range.

DROP VIEW IF EXISTS InterestingSegments;
CREATE PERFETTO VIEW InterestingSegments AS
WITH pre_cast AS (
  SELECT  -- 1) Gestures overlapping interactions.
    ts_ge AS ts,
    dur_ge AS dur
  FROM InteractionEventsJoinGestureEvents
  WHERE ts_ge IS NOT NULL
  GROUP BY ts_ge
  UNION ALL
  SELECT  -- 2) Interactions without gestures.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    ts_ir AS ts,
    dur_ir AS dur
  FROM InteractionEventsJoinGestureEvents
  WHERE ts_ge IS NULL
  GROUP BY ts_ir
  HAVING COUNT(*) = 1
)
SELECT
  CAST(ts AS BIGINT) AS ts,
  CAST(dur AS BIGINT) AS dur
FROM pre_cast;

--------------------------------------------------------------------------------
-- On ChromeOS, DRM events, if they exist, are the source of truth. Otherwise,
-- look for display rendering stats.
-- On Android, the TBMv2 version relied on Surface Flinger events that are
-- currently unavailable in proto traces. So results may be different from
-- the TBMv2 version on this platform.

DROP TABLE IF EXISTS DisplayCompositorPresentationEvents;
CREATE TABLE DisplayCompositorPresentationEvents AS
SELECT ts, FALSE AS exp
FROM slice
WHERE name = 'DrmEventFlipComplete'
GROUP BY ts;

INSERT INTO DisplayCompositorPresentationEvents
SELECT ts, FALSE AS exp
FROM slice
WHERE
  name = 'vsync_before'
  AND NOT EXISTS (SELECT * FROM DisplayCompositorPresentationEvents)
GROUP BY ts;

INSERT INTO DisplayCompositorPresentationEvents
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT ts, FALSE AS exp
FROM slice
WHERE
  name = 'BenchmarkInstrumentation::DisplayRenderingStats'
  AND NOT EXISTS (SELECT * FROM DisplayCompositorPresentationEvents)
GROUP BY ts;

INSERT INTO DisplayCompositorPresentationEvents
SELECT ts, TRUE AS exp
FROM slice
WHERE name = 'Display::FrameDisplayed'
GROUP BY ts;

DROP VIEW IF EXISTS FrameSegments;
CREATE PERFETTO VIEW FrameSegments AS
SELECT
  ts,
  LEAD(ts) OVER wnd - ts AS dur,
  ts AS ts_fs,
  LEAD(ts) OVER wnd - ts AS dur_fs,
  exp
FROM DisplayCompositorPresentationEvents
WINDOW wnd AS (PARTITION BY exp ORDER BY ts);

DROP TABLE IF EXISTS FrameSegmentsJoinInterestingSegments;
CREATE VIRTUAL TABLE FrameSegmentsJoinInterestingSegments USING
SPAN_JOIN(FrameSegments, InterestingSegments);

DROP VIEW IF EXISTS FrameTimes;
CREATE PERFETTO VIEW FrameTimes AS
SELECT dur / 1e6 AS dur_ms, exp
FROM FrameSegmentsJoinInterestingSegments
WHERE ts = ts_fs AND dur = dur_fs;

--------------------------------------------------------------------------------
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- Determine frame rate

DROP VIEW IF EXISTS RefreshPeriodAndroid;
CREATE PERFETTO VIEW RefreshPeriodAndroid AS
-- Not implemented yet.
SELECT NULL AS interval_ms;

DROP VIEW IF EXISTS RefreshPeriodNonAndroid;
CREATE PERFETTO VIEW RefreshPeriodNonAndroid AS
SELECT EXTRACT_ARG(arg_set_id, 'debug.args.interval_us') / 1e3 AS interval_ms
FROM slice
JOIN thread_track ON (slice.track_id = thread_track.id)
JOIN thread ON (thread_track.utid = thread.utid)
WHERE thread.name = 'Compositor' AND slice.name = 'Scheduler::BeginFrame'
LIMIT 1;

DROP VIEW IF EXISTS RefreshPeriodDefault;
CREATE PERFETTO VIEW RefreshPeriodDefault AS
SELECT 1000.0 / 60 AS interval_ms;

DROP TABLE IF EXISTS RefreshPeriod;
CREATE PERFETTO TABLE RefreshPeriod AS
SELECT COALESCE(
  (SELECT interval_ms FROM RefreshPeriodAndroid),
  (SELECT interval_ms FROM RefreshPeriodNonAndroid),
  (SELECT interval_ms FROM RefreshPeriodDefault)
) AS interval_ms;

--------------------------------------------------------------------------------
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- Compute average FPS

DROP VIEW IF EXISTS ValidFrameTimes;
CREATE PERFETTO VIEW ValidFrameTimes AS
SELECT
  dur_ms / (SELECT interval_ms FROM RefreshPeriod) AS length,
  exp
FROM FrameTimes
WHERE dur_ms / (SELECT interval_ms FROM RefreshPeriod) >= 0.5;

DROP VIEW IF EXISTS AvgSurfaceFps;
CREATE PERFETTO VIEW AvgSurfaceFps AS
SELECT
  exp,
  1e3 * COUNT(*) / (SELECT SUM(dur_ms) FROM FrameTimes WHERE exp = valid.exp) AS fps
FROM ValidFrameTimes valid
GROUP BY exp;

DROP VIEW IF EXISTS frame_times_output;
CREATE PERFETTO VIEW frame_times_output AS
SELECT FrameTimes(
  'frame_time', (SELECT RepeatedField(dur_ms) FROM FrameTimes WHERE NOT exp),
  'exp_frame_time', (SELECT RepeatedField(dur_ms) FROM FrameTimes WHERE exp),
  'avg_surface_fps', (SELECT fps FROM AvgSurfaceFps WHERE NOT exp),
  'exp_avg_surface_fps', (SELECT fps FROM AvgSurfaceFps WHERE exp)
);

)_d3l1m1t3r_"
;

const char kExperimentalMediaMetric[] = R"_d3l1m1t3r_(--
-- Copyright 2021 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the 'License');
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an 'AS IS' BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

SELECT RUN_METRIC('chrome/chrome_processes.sql');

-- Helper for thread slices
DROP VIEW IF EXISTS thread_slice;
CREATE PERFETTO VIEW thread_slice AS
SELECT s.*, thread.utid, thread.upid
FROM slice s
JOIN thread_track ON s.track_id = thread_track.id
JOIN thread USING(utid);

--------------------------------------------------------------------------------
-- Find all playbacks on renderer main threads.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
DROP VIEW IF EXISTS PlaybackStart;
CREATE PERFETTO VIEW PlaybackStart AS
SELECT
  EXTRACT_ARG(s.arg_set_id, 'debug.id') AS playback_id,
  s.ts AS playback_start,
  upid
FROM slice s
JOIN thread_track ON s.track_id = thread_track.id
JOIN thread USING(utid)
WHERE
  s.name = 'WebMediaPlayerImpl::DoLoad'
  AND thread.name = 'CrRendererMain';

--------------------------------------------------------------------------------
-- Find the first video render time after the playback to compute
-- time_to_video_play.

DROP VIEW IF EXISTS VideoStart;
CREATE PERFETTO VIEW VideoStart AS
SELECT
  playback_id,
  playback_start,
  PlaybackStart.upid,
  MIN(s.ts) AS video_start
FROM PlaybackStart, thread_slice s
WHERE
  s.name = 'VideoRendererImpl::Render'
  AND EXTRACT_ARG(s.arg_set_id, 'debug.id') = playback_id
  AND s.upid = PlaybackStart.upid
GROUP BY playback_id, playback_start, PlaybackStart.upid;

--------------------------------------------------------------------------------
-- Find the first audio render time after the playback to compute
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- time_to_audio_play.

DROP VIEW IF EXISTS AudioStart;
CREATE PERFETTO VIEW AudioStart AS
SELECT
  playback_id,
  playback_start,
  PlaybackStart.upid,
  MIN(s.ts) AS audio_start
FROM PlaybackStart, thread_slice s
WHERE
  s.name = 'AudioRendererImpl::Render'
  AND EXTRACT_ARG(s.arg_set_id, 'debug.id') = playback_id
  AND s.upid = PlaybackStart.upid
GROUP BY playback_id, playback_start, PlaybackStart.upid;

--------------------------------------------------------------------------------
-- Sum up the dropped frame count from all such events for each playback to
-- compute dropped_frame_count.

DROP VIEW IF EXISTS DroppedFrameCount;
CREATE PERFETTO VIEW DroppedFrameCount AS
SELECT
  playback_id,
  vs.upid,
  SUM(
    CASE
      WHEN s.arg_set_id IS NULL THEN 0
      ELSE EXTRACT_ARG(s.arg_set_id, 'debug.count') END
  ) AS dropped_frame_count
FROM VideoStart vs
LEFT JOIN thread_slice s ON
  s.name = 'VideoFramesDropped'
  AND EXTRACT_ARG(s.arg_set_id, 'debug.id') = playback_id
  AND s.upid = vs.upid
)_d3l1m1t3r_"
R"_d3l1m1t3r_(GROUP BY playback_id, vs.upid;

--------------------------------------------------------------------------------
-- Compute seek times.

-- Find the seeks.
DROP VIEW IF EXISTS SeekStart;
CREATE PERFETTO VIEW SeekStart AS
SELECT
  playback_id,
  PlaybackStart.upid,
  s.ts AS seek_start,
  EXTRACT_ARG(s.arg_set_id, 'debug.target') AS seek_target
FROM PlaybackStart
LEFT JOIN thread_slice s
WHERE
  s.name = 'WebMediaPlayerImpl::DoSeek'
  AND EXTRACT_ARG(s.arg_set_id, 'debug.id') = playback_id
  AND s.upid = PlaybackStart.upid;

-- Partition by the next seek's ts, so that we can filter for events occurring
-- within each seek's window below.
DROP VIEW IF EXISTS SeekPartitioned;
CREATE PERFETTO VIEW SeekPartitioned AS
SELECT
  *,
  LEAD(seek_start) OVER (
    PARTITION BY playback_id, upid
    ORDER BY seek_start ASC
  ) AS seek_end
FROM SeekStart;

-- Find the subsequent matching pipeline seeks that occur before the next seek.
DROP VIEW IF EXISTS PipelineSeek;
CREATE PERFETTO VIEW PipelineSeek AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  seek.*,
  (
    SELECT MIN(s.ts)
    FROM thread_slice s
    WHERE
      s.name = 'WebMediaPlayerImpl::OnPipelineSeeked'
      AND EXTRACT_ARG(s.arg_set_id, 'debug.id') = seek.playback_id
      AND EXTRACT_ARG(s.arg_set_id, 'debug.target') = seek.seek_target
      AND s.upid = seek.upid
      AND s.ts >= seek.seek_start
      AND (seek.seek_end IS NULL OR s.ts < seek.seek_end)
  ) AS pipeline_seek
FROM SeekPartitioned seek;

-- Find the subsequent buffering events that occur before the next seek.
DROP VIEW IF EXISTS SeekComplete;
CREATE PERFETTO VIEW SeekComplete AS
SELECT
  seek.*,
  (
    SELECT MIN(s.ts)
    FROM thread_slice s
    WHERE
      s.name = 'WebMediaPlayerImpl::BufferingHaveEnough'
      AND EXTRACT_ARG(s.arg_set_id, 'debug.id') = seek.playback_id
      AND s.upid = seek.upid
      AND s.ts >= seek.pipeline_seek
      AND (seek.seek_end IS NULL OR s.ts < seek.seek_end)
  ) AS seek_complete
FROM PipelineSeek seek;

-- Find the subsequent buffering events that occur before the next seek.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(DROP VIEW IF EXISTS ValidSeek;
CREATE PERFETTO VIEW ValidSeek AS
SELECT
  s.*
FROM SeekComplete s
WHERE
  s.pipeline_seek IS NOT NULL
  AND s.seek_complete IS NOT NULL;

--------------------------------------------------------------------------------
-- Find playback end timestamps and their duration for playbacks without seeks
-- to compute buffering_time.

-- Helper view that shows either video or audio start for each playback
DROP VIEW IF EXISTS AVStart;
CREATE PERFETTO VIEW AVStart AS
SELECT
  v.playback_id,
  v.playback_start,
  v.upid,
  v.video_start AS av_start
FROM VideoStart v
UNION
SELECT
  a.playback_id,
  a.playback_start,
  a.upid,
  a.audio_start AS av_start
FROM AudioStart a
WHERE a.playback_id NOT IN (SELECT playback_id FROM VideoStart);

-- Find the corresponding media end events and their reported duration.
DROP VIEW IF EXISTS PlaybackEnd;
CREATE PERFETTO VIEW PlaybackEnd AS
SELECT
  AVStart.*,
  slice.ts AS playback_end,
  EXTRACT_ARG(slice.arg_set_id, 'debug.duration') * 1e9 AS duration
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM AVStart
JOIN slice ON slice.id = (
  SELECT s.id
  FROM thread_slice s
  WHERE
    s.name = 'WebMediaPlayerImpl::OnEnded'
    AND EXTRACT_ARG(s.arg_set_id, 'debug.id') = AVStart.playback_id
    AND s.upid = AVStart.upid
  ORDER BY s.ts ASC
  LIMIT 1
  )
WHERE NOT EXISTS (
  SELECT 1 FROM SeekStart
  WHERE SeekStart.playback_id = AVStart.playback_id
);

--------------------------------------------------------------------------------
-- Find maximum video roughness and freezing events per playback.

DROP VIEW IF EXISTS VideoRoughness;
CREATE PERFETTO VIEW VideoRoughness AS
SELECT
  playback_id,
  playback_start,
  PlaybackStart.upid,
  MAX(EXTRACT_ARG(s.arg_set_id, 'debug.roughness')) AS roughness
FROM PlaybackStart
JOIN thread_slice s
WHERE
  s.name = 'VideoPlaybackRoughness'
  AND EXTRACT_ARG(s.arg_set_id, 'debug.id') = playback_id
  AND s.upid = PlaybackStart.upid
GROUP BY playback_id, playback_start, PlaybackStart.upid;

DROP VIEW IF EXISTS VideoFreezing;
CREATE PERFETTO VIEW VideoFreezing AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  playback_id,
  playback_start,
  PlaybackStart.upid,
  MAX(EXTRACT_ARG(s.arg_set_id, 'debug.freezing')) AS freezing
FROM PlaybackStart
JOIN thread_slice s
WHERE
  s.name = 'VideoPlaybackFreezing'
  AND EXTRACT_ARG(s.arg_set_id, 'debug.id') = playback_id
  AND s.upid = PlaybackStart.upid
GROUP BY playback_id, playback_start, PlaybackStart.upid;

--------------------------------------------------------------------------------
-- Output to proto

DROP VIEW IF EXISTS media_metric_output;
CREATE PERFETTO VIEW media_metric_output AS
SELECT MediaMetric(
  'time_to_video_play', (
    SELECT RepeatedField((video_start - playback_start) / 1e6)
    FROM VideoStart
  ),
  'time_to_audio_play', (
    SELECT RepeatedField((audio_start - playback_start) / 1e6)
    FROM AudioStart
  ),
  'dropped_frame_count', (
    SELECT RepeatedField(CAST(dropped_frame_count AS INTEGER))
    FROM DroppedFrameCount
  ),
  'buffering_time', (
    SELECT RepeatedField((playback_end - duration - av_start) / 1e6)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    FROM PlaybackEnd
  ),
  'roughness', (
    SELECT RepeatedField(roughness / 1e0)
    FROM VideoRoughness
  ),
  'freezing', (
    SELECT RepeatedField(freezing / 1e0)
    FROM VideoFreezing
  ),
  'seek_time', (
    SELECT RepeatedField((seek_complete - seek_start) / 1e6)
    FROM ValidSeek
  ),
  'pipeline_seek_time', (
    SELECT RepeatedField((pipeline_seek - seek_start) / 1e6)
    FROM ValidSeek
  )
);

)_d3l1m1t3r_"
;

const char kExperimentalReportedByPage[] = R"_d3l1m1t3r_(--
-- Copyright 2021 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

--------------------------------------------------------------------------------
-- Collect page-reported events for each renderer. Note that we don't need to
-- match up process ids, because the unique nav_id ensures we're only comparing
-- corresponding events.

DROP VIEW IF EXISTS page_reported_events;
CREATE PERFETTO VIEW page_reported_events AS
SELECT ts, name, EXTRACT_ARG(arg_set_id, "debug.data.navigationId") AS nav_id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM slice
WHERE category = 'blink.user_timing'
  AND (name = 'navigationStart' OR name GLOB 'telemetry:reported_by_page:*')
ORDER BY nav_id, ts ASC;

--------------------------------------------------------------------------------
-- Compute the duration from the corresponding navigation start for each
-- reported event.

DROP VIEW IF EXISTS page_reported_durations;
CREATE PERFETTO VIEW page_reported_durations AS
SELECT p.name, (p.ts - (
    SELECT MAX(ts) FROM page_reported_events
    WHERE
      nav_id = p.nav_id
      AND ts < p.ts AND (
        -- Viewable/interactive markers measure time from nav start.
        (p.name GLOB 'telemetry:reported_by_page:*'
         AND p.name NOT GLOB 'telemetry:reported_by_page:benchmark*'
         AND name = 'navigationStart')
        -- Benchmark end markers measure time from the most recent begin marker.
        OR (p.name = 'telemetry:reported_by_page:benchmark_end'
            AND name = 'telemetry:reported_by_page:benchmark_begin')
      ))
) / 1e6 AS dur_ms
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM page_reported_events p;

--------------------------------------------------------------------------------
-- Combine results into the output table.

DROP VIEW IF EXISTS reported_by_page_output;
CREATE PERFETTO VIEW reported_by_page_output AS
SELECT ReportedByPage(
  'time_to_viewable', (
    SELECT RepeatedField(dur_ms) FROM page_reported_durations
    WHERE name = 'telemetry:reported_by_page:viewable'),
  'time_to_interactive', (
    SELECT RepeatedField(dur_ms) FROM page_reported_durations
    WHERE name = 'telemetry:reported_by_page:interactive'),
  'benchmark_time', (
    SELECT RepeatedField(dur_ms) FROM page_reported_durations
    WHERE name = 'telemetry:reported_by_page:benchmark_end')
);

)_d3l1m1t3r_"
;

const char kWebviewWebviewJankApproximation[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- We approximate WebView-related app janks by selecting WebView renderer
-- slices and overlapping them with app jank slices for known apps.

-- Select all WebView processes
DROP VIEW IF EXISTS webview_processes;
CREATE PERFETTO VIEW webview_processes AS
SELECT * FROM process
WHERE name IN ('com.google.android.gm',
  'com.google.android.googlequicksearchbox',
  'com.google.android.apps.searchlite',
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  'com.google.android.apps.magazines');

-- Select all system processes
DROP VIEW IF EXISTS system_processes;
CREATE PERFETTO VIEW system_processes AS
SELECT * FROM process
WHERE name IN ('com.android.systemui',
  '/system/bin/surfaceflinger',
  'system_server');

-- Select all slices related to startup
DROP TABLE IF EXISTS webview_browser_startup_slices;
CREATE PERFETTO TABLE webview_browser_startup_slices AS
SELECT slice.id AS browser_startup_id, slice.ts, slice.dur
FROM slice
WHERE name = 'WebViewChromium.init';

-- Select all scheduler slices from WebView renderer processes
DROP TABLE IF EXISTS webview_renderer_slices;
CREATE PERFETTO TABLE webview_renderer_slices AS
SELECT sched_slice.id as renderer_id, sched_slice.ts, sched_slice.dur
FROM sched_slice
JOIN thread
USING(utid)
JOIN process
USING (upid)
WHERE process.name GLOB '*webview*Sand*';

-- Select all jank slices
DROP TABLE IF EXISTS all_self_jank_slices;
CREATE PERFETTO TABLE all_self_jank_slices AS
SELECT *
FROM actual_frame_timeline_slice
)_d3l1m1t3r_"
R"_d3l1m1t3r_(WHERE jank_type NOT IN ('None', 'Buffer Stuffing')
  AND jank_tag = 'Self Jank';

-- Select all jank slices from WebView processes
-- @column id Id of jank slice from a WebView process
-- @column ts Timestamp of the start of jank slice in a WebView process (in nanoseconds)
-- @column dur Duration of jank slice in a WebView process (in nanoseconds)
DROP VIEW IF EXISTS webview_app_jank_slices;
CREATE PERFETTO VIEW webview_app_jank_slices AS
SELECT * FROM all_self_jank_slices
WHERE upid IN (SELECT upid FROM webview_processes);

-- Select all jank slices from all processes except system processes
-- @column id Id of jank slice from all processes except system processes
-- @column ts Timestamp of the start of jank slice from all processes except system processes (in nanoseconds)
-- @column dur Duration of the jank slice from all processes except system processes (in nanoseconds)
DROP VIEW IF EXISTS webview_all_app_jank_slices;
CREATE PERFETTO VIEW webview_all_app_jank_slices AS
SELECT * FROM all_self_jank_slices
)_d3l1m1t3r_"
R"_d3l1m1t3r_(WHERE upid NOT IN (SELECT upid FROM system_processes);

-- Select jank slices from WebView processes overlapping WebView renderer
-- scheduler slices
-- @column id Id of jank slice from WebView processes overlapping WebView renderer
-- @column ts Timestamp of the start of jank slice from WebView processes overlapping WebView renderer (in nanoseconds)
-- @column dur Duration of jank slice from WebView processes overlapping WebView renderer (in nanoseconds)
DROP TABLE IF EXISTS webview_jank_slices;
CREATE VIRTUAL TABLE webview_jank_slices
USING SPAN_JOIN(webview_renderer_slices,
                webview_app_jank_slices);

-- Select jank slices overlapping WebView startup slices
-- @column id Id of jank slice overlapping WebView startup slices
-- @column ts Timestamp of the start of jank slice overlapping WebView startup slices (in nanoseconds)
-- @column dur Duration of jank slice overlapping WebView startup slices (in nanoseconds)
DROP TABLE IF EXISTS webview_browser_startup_jank_slices;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE VIRTUAL TABLE webview_browser_startup_jank_slices
USING SPAN_JOIN(webview_browser_startup_slices,
               webview_app_jank_slices);

-- Select jank slices from all processes except system processes overlapping
-- WebView renderer scheduler slices
-- @column id Id of jank slice from all processes except system processes overlapping WebView renderer scheduler slices
-- @column ts Timestamp of the start of jank slice from all processes except system processes overlapping WebView renderer scheduler slices (in nanoseconds)
-- @column dur Duration of jank slice from all processes except system processes overlapping WebView renderer scheduler slices (in nanoseconds)
DROP TABLE IF EXISTS webview_total_jank_slices;
CREATE VIRTUAL TABLE webview_total_jank_slices
USING SPAN_JOIN(webview_renderer_slices,
                webview_all_app_jank_slices);

-- Select jank slices from WebView processes overlapping WebView renderer
-- scheduler slices excluding WebView startup slices
-- @column id Id of jank slice from WebView processes overlapping WebView renderer scheduler slices excluding WebView startup slices
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column ts Timestamp of the start of jank slice from WebView processes overlapping WebView renderer scheduler slices excluding WebView startup slices (in nanoseconds)
-- @column dur Duration of jank slice from WebView processes overlapping WebView renderer scheduler slices excluding WebView startup slices (in nanoseconds)
DROP VIEW IF EXISTS webview_janks_slices_without_startup;
CREATE PERFETTO VIEW webview_janks_slices_without_startup AS
SELECT * FROM webview_jank_slices
WHERE id NOT IN (SELECT id FROM webview_browser_startup_jank_slices);

-- Summary for all types of janks
-- @column webview_janks janks in WebView apps that overlap with WebView renderer
-- @column webview_janks_without_startup same as above but excluding startup
-- @column webview_app_janks janks in WebView apps
-- @column webview_total_janks janks in all apps (except system) that overlap with WebView renderer
-- @column total_janks janks in all apps (except system)
DROP VIEW IF EXISTS webview_jank_approximation_summary;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO VIEW webview_jank_approximation_summary AS
WITH wvj AS (SELECT COUNT(DISTINCT(id)) AS webview_janks
  FROM webview_jank_slices),
wvjwos AS (SELECT COUNT(DISTINCT(id))
  AS webview_janks_without_startup FROM webview_janks_slices_without_startup),
wvaj AS (SELECT COUNT(DISTINCT(id))
  AS webview_app_janks FROM webview_app_jank_slices),
wvtj AS (SELECT COUNT(DISTINCT(id)) AS webview_total_janks
  FROM webview_total_jank_slices),
tj AS (SELECT COUNT(DISTINCT(id))
  AS total_janks FROM webview_all_app_jank_slices)
SELECT *
from wvj, wvjwos, wvaj, wvtj, tj;

DROP VIEW IF EXISTS webview_jank_approximation_output;
CREATE PERFETTO VIEW webview_jank_approximation_output AS
SELECT WebViewJankApproximation(
  'webview_janks', (SELECT webview_janks FROM webview_jank_approximation_summary),
  'webview_janks_without_startup', (SELECT webview_janks_without_startup FROM webview_jank_approximation_summary),
  'webview_app_janks', (SELECT webview_app_janks FROM webview_jank_approximation_summary),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  'webview_total_janks', (SELECT webview_total_janks FROM webview_jank_approximation_summary),
  'total_janks', (SELECT total_janks FROM webview_jank_approximation_summary)
);
)_d3l1m1t3r_"
;

const char kWebviewWebviewPowerUsage[] = R"_d3l1m1t3r_(--
-- Copyright 2020 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- WebView is embedded in the hosting app's main process, which means it shares some threads
-- with the host app's work. We approximate WebView-related power usage
-- by selecting user slices that belong to WebView and estimating their power use
-- through the CPU time they consume at different core frequencies.
-- This file populates a summary table that can be used to produce metrics in different formats.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
SELECT RUN_METRIC('android/android_proxy_power.sql');
SELECT RUN_METRIC('android/cpu_info.sql');

DROP TABLE IF EXISTS top_level_slice;

-- Select topmost slices from the 'toplevel' and 'Java' categories.
-- Filter out Looper events since they are likely to belong to the host app.
-- Slices are only used to calculate the contribution of the browser process,
-- renderer contribution will be calculated as the sum of all renderer processes' usage.
CREATE PERFETTO TABLE top_level_slice AS
SELECT *
FROM slice WHERE
  depth = 0
  AND ((category GLOB '*toplevel*' OR category = 'Java')
    AND name NOT GLOB '*looper*');

DROP TABLE IF EXISTS webview_browser_slices;

-- Match top-level slices to threads and hosting apps.
-- This excludes any renderer slices because renderer processes are counted
-- as a whole separately.
-- Slices from Chrome browser processes are also excluded.
CREATE PERFETTO TABLE webview_browser_slices AS
SELECT
  top_level_slice.ts,
  top_level_slice.dur,
  thread_track.utid,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  process.upid AS upid,
  extract_arg(process.arg_set_id, 'chrome.host_app_package_name') AS app_name
FROM top_level_slice
JOIN thread_track
  ON top_level_slice.track_id = thread_track.id
JOIN process
  ON thread.upid = process.upid
JOIN thread
  ON thread_track.utid = thread.utid
WHERE process.name NOT GLOB '*SandboxedProcessService*'
  AND process.name NOT GLOB '*chrome*'
  AND app_name IS NOT NULL;

DROP TABLE IF EXISTS webview_browser_slices_power;

-- Assign power usage to WebView browser slices.
CREATE VIRTUAL TABLE webview_browser_slices_power
USING SPAN_JOIN(power_per_thread PARTITIONED utid,
                webview_browser_slices PARTITIONED utid);

DROP TABLE IF EXISTS webview_browser_slices_power_summary;

-- Calculate the power usage of all WebView browser slices for each app
-- in milliampere-seconds.
CREATE PERFETTO TABLE webview_browser_slices_power_summary AS
SELECT
  app_name,
  SUM(dur * COALESCE(power_ma, 0) / 1e9) AS power_mas
FROM webview_browser_slices_power
GROUP BY app_name;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
DROP TABLE IF EXISTS webview_renderer_threads;

-- All threads of all WebView renderer processes.
CREATE PERFETTO TABLE webview_renderer_threads AS
SELECT
  thread.utid AS utid,
  extract_arg(process.arg_set_id, 'chrome.host_app_package_name') AS app_name
FROM process
JOIN thread
  ON thread.upid = process.upid
WHERE process.name GLOB '*webview*SandboxedProcessService*'
  AND app_name IS NOT NULL;

DROP TABLE IF EXISTS webview_renderer_power_summary;

-- Calculate the power usage of all WebView renderer processes for each app
-- in milliampere-seconds.
CREATE PERFETTO TABLE webview_renderer_power_summary AS
SELECT
  app_name,
  SUM(dur * COALESCE(power_ma, 0) / 1e9) AS power_mas
FROM power_per_thread
JOIN webview_renderer_threads
  ON power_per_thread.utid = webview_renderer_threads.utid
GROUP BY app_name;

DROP TABLE IF EXISTS webview_renderer_power_per_core_type;

-- Calculate the power usage of all WebView renderer processes for each app
-- in milliampere-seconds grouped by core type.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO TABLE webview_renderer_power_per_core_type AS
SELECT
  app_name,
  core_type_per_cpu.core_type AS core_type,
  SUM(dur * COALESCE(power_ma, 0) / 1e9) AS power_mas
FROM power_per_thread
JOIN webview_renderer_threads
  ON power_per_thread.utid = webview_renderer_threads.utid
JOIN core_type_per_cpu
  ON power_per_thread.cpu = core_type_per_cpu.cpu
GROUP BY app_name, core_type_per_cpu.core_type;

DROP TABLE IF EXISTS host_app_threads;

-- All threads of hosting apps (this is a superset of webview_browser_slices).
-- 1) select all threads that had any WebView browser slices associated with them;
-- 2) get all threads for processes matching threads from 1).
-- For example, only some of app's threads wrote any slices, but we are selecting
-- all threads for this app's process.
-- Excludes all renderer processes and Chrome browser processes.
CREATE PERFETTO TABLE host_app_threads AS
SELECT
  thread.utid AS utid,
  thread.name AS name,
  extract_arg(process.arg_set_id, 'chrome.host_app_package_name') AS app_name
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM thread
JOIN process ON thread.upid = process.upid
WHERE thread.upid IN
  (SELECT DISTINCT(webview_browser_slices.upid) FROM webview_browser_slices)
  AND process.name NOT GLOB '*SandboxedProcessService*'
  AND process.name NOT GLOB '*chrome*'
  AND app_name IS NOT NULL;

DROP TABLE IF EXISTS host_app_power_summary;

-- Calculate the power usage of all WebView (host app+browser) processes for each app
-- in milliampere-seconds.
CREATE PERFETTO TABLE host_app_power_summary AS
SELECT
  app_name,
  SUM(dur * COALESCE(power_ma, 0) / 1e9) AS power_mas
FROM power_per_thread
JOIN host_app_threads
  ON power_per_thread.utid = host_app_threads.utid
GROUP BY app_name;

DROP TABLE IF EXISTS host_app_power_per_core_type;

-- Calculate the power usage of all WebView (host app+browser) processes for each app
-- in milliampere-seconds grouped by core type.
CREATE PERFETTO TABLE host_app_power_per_core_type AS
SELECT
  app_name,
  core_type_per_cpu.core_type AS core_type,
  SUM(dur * COALESCE(power_ma, 0) / 1e9) AS power_mas
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM power_per_thread
JOIN host_app_threads
  ON power_per_thread.utid = host_app_threads.utid
JOIN core_type_per_cpu
  ON power_per_thread.cpu = core_type_per_cpu.cpu
GROUP BY app_name, core_type_per_cpu.core_type;

DROP TABLE IF EXISTS webview_only_threads;

-- A subset of the host app threads that are WebView-specific.
CREATE PERFETTO TABLE webview_only_threads AS
SELECT *
FROM host_app_threads
WHERE name GLOB 'Chrome*' OR name GLOB 'CookieMonster*'
  OR name GLOB 'CompositorTileWorker*' OR name GLOB 'ThreadPool*ground*'
  OR NAME GLOB 'ThreadPoolService*' OR name GLOB 'VizCompositorThread*'
  OR name IN ('AudioThread', 'DedicatedWorker thread', 'GpuMemoryThread',
    'JavaBridge', 'LevelDBEnv.IDB', 'MemoryInfra', 'NetworkService', 'VizWebView');

DROP TABLE IF EXISTS webview_only_power_summary;

-- Calculate the power usage of all WebView-specific host app threads
-- (browser + in-process renderers) for each app in milliampere-seconds.
CREATE PERFETTO TABLE webview_only_power_summary AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  app_name,
  SUM(dur * COALESCE(power_ma, 0) / 1e9) AS power_mas
FROM power_per_thread
JOIN webview_only_threads
  ON power_per_thread.utid = webview_only_threads.utid
GROUP BY app_name;

DROP TABLE IF EXISTS webview_only_power_per_core_type;

-- Calculate the power usage of all WebView-specific host app threads
-- for each app in milliampere-seconds grouped by core type.
CREATE PERFETTO TABLE webview_only_power_per_core_type AS
SELECT app_name,
  core_type_per_cpu.core_type AS core_type,
  SUM(dur * COALESCE(power_ma, 0) / 1e9) AS power_mas
FROM power_per_thread
JOIN webview_only_threads
  ON power_per_thread.utid = webview_only_threads.utid
JOIN core_type_per_cpu
  ON power_per_thread.cpu = core_type_per_cpu.cpu
GROUP BY app_name, core_type_per_cpu.core_type;

-- Create views for output.

DROP TABLE IF EXISTS total_app_power_output;

CREATE PERFETTO TABLE total_app_power_output AS
SELECT
  host_app_power_summary.app_name AS app_name,
  host_app_power_summary.power_mas AS total_mas,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  host_app_power_little_cores_mas.power_mas AS little_cores_mas,
  host_app_power_big_cores_mas.power_mas AS big_cores_mas,
  host_app_power_bigger_cores_mas.power_mas AS bigger_cores_mas
FROM host_app_power_summary LEFT JOIN host_app_power_per_core_type AS host_app_power_little_cores_mas
  ON host_app_power_summary.app_name = host_app_power_little_cores_mas.app_name
    AND host_app_power_little_cores_mas.core_type = 'little'
LEFT JOIN host_app_power_per_core_type AS host_app_power_big_cores_mas
  ON host_app_power_summary.app_name = host_app_power_big_cores_mas.app_name
    AND host_app_power_big_cores_mas.core_type = 'big'
LEFT JOIN host_app_power_per_core_type AS host_app_power_bigger_cores_mas
  ON host_app_power_summary.app_name = host_app_power_bigger_cores_mas.app_name
    AND host_app_power_bigger_cores_mas.core_type = 'bigger';

DROP TABLE IF EXISTS webview_renderer_power_output;

CREATE PERFETTO TABLE webview_renderer_power_output AS
SELECT
  webview_renderer_power_summary.app_name AS app_name,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  webview_renderer_power_summary.power_mas AS total_mas,
  webview_renderer_little_power.power_mas AS little_cores_mas,
  webview_renderer_big_power.power_mas AS big_cores_mas,
  webview_renderer_bigger_power.power_mas AS bigger_cores_mas
FROM webview_renderer_power_summary LEFT JOIN webview_renderer_power_per_core_type AS webview_renderer_little_power
  ON webview_renderer_power_summary.app_name = webview_renderer_little_power.app_name
    AND webview_renderer_little_power.core_type = 'little'
LEFT JOIN webview_renderer_power_per_core_type AS webview_renderer_big_power
  ON webview_renderer_power_summary.app_name = webview_renderer_big_power.app_name
    AND webview_renderer_big_power.core_type = 'big'
LEFT JOIN webview_renderer_power_per_core_type AS webview_renderer_bigger_power
  ON webview_renderer_power_summary.app_name = webview_renderer_bigger_power.app_name
    AND webview_renderer_bigger_power.core_type = 'bigger';

DROP TABLE IF EXISTS webview_only_power_output;

CREATE PERFETTO TABLE webview_only_power_output AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  webview_only_power_summary.app_name AS app_name,
  webview_only_power_summary.power_mas AS total_mas,
  webview_only_power_little_cores_mas.power_mas AS little_cores_mas,
  webview_only_power_big_cores_mas.power_mas AS big_cores_mas,
  webview_only_power_bigger_cores_mas.power_mas AS bigger_cores_mas
FROM webview_only_power_summary LEFT JOIN webview_only_power_per_core_type AS webview_only_power_little_cores_mas
  ON webview_only_power_summary.app_name = webview_only_power_little_cores_mas.app_name
    AND webview_only_power_little_cores_mas.core_type = 'little'
LEFT JOIN webview_only_power_per_core_type AS webview_only_power_big_cores_mas
  ON webview_only_power_summary.app_name = webview_only_power_big_cores_mas.app_name
    AND webview_only_power_big_cores_mas.core_type = 'big'
LEFT JOIN webview_only_power_per_core_type AS webview_only_power_bigger_cores_mas
  ON webview_only_power_summary.app_name = webview_only_power_bigger_cores_mas.app_name
    AND webview_only_power_bigger_cores_mas.core_type = 'bigger';
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
DROP TABLE IF EXISTS total_device_power;

-- Calculate the power usage of the device in milliampere-seconds.
CREATE PERFETTO TABLE total_device_power AS
SELECT SUM(dur * COALESCE(power_ma, 0) / 1e9) AS power_mas
FROM power_per_thread;

)_d3l1m1t3r_"
;

struct FileToSql {
  const char* path;
  const char* sql;
};

const FileToSql kFileToSql[] = {
  {"trace_metadata.sql", kTraceMetadata},

  {"trace_stats.sql", kTraceStats},

  {"android/ad_services_metric.sql", kAndroidAdServicesMetric},

  {"android/android_anr.sql", kAndroidAndroidAnr},

  {"android/android_auto_multiuser.sql", kAndroidAndroidAutoMultiuser},

  {"android/android_batt.sql", kAndroidAndroidBatt},

  {"android/android_binder.sql", kAndroidAndroidBinder},

  {"android/android_blocking_calls_cuj_metric.sql", kAndroidAndroidBlockingCallsCujMetric},

  {"android/android_blocking_calls_unagg.sql", kAndroidAndroidBlockingCallsUnagg},

  {"android/android_boot.sql", kAndroidAndroidBoot},

  {"android/android_boot_unagg.sql", kAndroidAndroidBootUnagg},

  {"android/android_broadcasts.sql", kAndroidAndroidBroadcasts},

  {"android/android_camera.sql", kAndroidAndroidCamera},

  {"android/android_camera_unagg.sql", kAndroidAndroidCameraUnagg},

  {"android/android_cpu.sql", kAndroidAndroidCpu},

  {"android/android_cpu_agg.sql", kAndroidAndroidCpuAgg},

  {"android/android_cpu_raw_metrics_per_core.sql", kAndroidAndroidCpuRawMetricsPerCore},

  {"android/android_dma_heap.sql", kAndroidAndroidDmaHeap},

  {"android/android_dvfs.sql", kAndroidAndroidDvfs},

  {"android/android_fastrpc.sql", kAndroidAndroidFastrpc},

  {"android/android_frame_timeline_metric.sql", kAndroidAndroidFrameTimelineMetric},

  {"android/android_garbage_collection_unagg.sql", kAndroidAndroidGarbageCollectionUnagg},

  {"android/android_gpu.sql", kAndroidAndroidGpu},

  {"android/android_hwcomposer.sql", kAndroidAndroidHwcomposer},

  {"android/android_hwui_metric.sql", kAndroidAndroidHwuiMetric},

  {"android/android_hwui_threads.sql", kAndroidAndroidHwuiThreads},

  {"android/android_io.sql", kAndroidAndroidIo},

  {"android/android_io_unagg.sql", kAndroidAndroidIoUnagg},

  {"android/android_ion.sql", kAndroidAndroidIon},

  {"android/android_irq_runtime.sql", kAndroidAndroidIrqRuntime},

  {"android/android_jank_cuj.sql", kAndroidAndroidJankCuj},

  {"android/android_lmk.sql", kAndroidAndroidLmk},

  {"android/android_lmk_reason.sql", kAndroidAndroidLmkReason},

  {"android/android_mem.sql", kAndroidAndroidMem},

  {"android/android_mem_unagg.sql", kAndroidAndroidMemUnagg},

  {"android/android_monitor_contention.sql", kAndroidAndroidMonitorContention},

  {"android/android_monitor_contention_agg.sql", kAndroidAndroidMonitorContentionAgg},

  {"android/android_multiuser.sql", kAndroidAndroidMultiuser},

  {"android/android_multiuser_populator.sql", kAndroidAndroidMultiuserPopulator},

  {"android/android_netperf.sql", kAndroidAndroidNetperf},

  {"android/android_oom_adjuster.sql", kAndroidAndroidOomAdjuster},

  {"android/android_other_traces.sql", kAndroidAndroidOtherTraces},

  {"android/android_package_list.sql", kAndroidAndroidPackageList},

  {"android/android_powrails.sql", kAndroidAndroidPowrails},

  {"android/android_proxy_power.sql", kAndroidAndroidProxyPower},

  {"android/android_rt_runtime.sql", kAndroidAndroidRtRuntime},

  {"android/android_simpleperf.sql", kAndroidAndroidSimpleperf},

  {"android/android_startup.sql", kAndroidAndroidStartup},

  {"android/android_surfaceflinger.sql", kAndroidAndroidSurfaceflinger},

  {"android/android_sysui_notifications_blocking_calls_metric.sql", kAndroidAndroidSysuiNotificationsBlockingCallsMetric},

  {"android/android_task_names.sql", kAndroidAndroidTaskNames},

  {"android/android_trace_quality.sql", kAndroidAndroidTraceQuality},

  {"android/android_trusty_workqueues.sql", kAndroidAndroidTrustyWorkqueues},

  {"android/codec_metrics.sql", kAndroidCodecMetrics},

  {"android/composer_execution.sql", kAndroidComposerExecution},

  {"android/composition_layers.sql", kAndroidCompositionLayers},

  {"android/counter_span_view_merged.sql", kAndroidCounterSpanViewMerged},

  {"android/cpu_info.sql", kAndroidCpuInfo},

  {"android/display_metrics.sql", kAndroidDisplayMetrics},

  {"android/frame_missed.sql", kAndroidFrameMissed},

  {"android/g2d.sql", kAndroidG2d},

  {"android/g2d_duration.sql", kAndroidG2dDuration},

  {"android/global_counter_span_view.sql", kAndroidGlobalCounterSpanView},

  {"android/gpu_counter_span_view.sql", kAndroidGpuCounterSpanView},

  {"android/jank/cujs.sql", kAndroidJankCujs},

  {"android/jank/cujs_boundaries.sql", kAndroidJankCujsBoundaries},

  {"android/jank/frames.sql", kAndroidJankFrames},

  {"android/jank/internal/counters.sql", kAndroidJankInternalCounters},

  {"android/jank/internal/derived_events.sql", kAndroidJankInternalDerivedEvents},

  {"android/jank/internal/query_base.sql", kAndroidJankInternalQueryBase},

  {"android/jank/internal/query_frame_slice.sql", kAndroidJankInternalQueryFrameSlice},

  {"android/jank/params.sql", kAndroidJankParams},

  {"android/jank/query_functions.sql", kAndroidJankQueryFunctions},

  {"android/jank/relevant_slices.sql", kAndroidJankRelevantSlices},

  {"android/jank/relevant_threads.sql", kAndroidJankRelevantThreads},

  {"android/jank/slices.sql", kAndroidJankSlices},

  {"android/java_heap_class_stats.sql", kAndroidJavaHeapClassStats},

  {"android/java_heap_histogram.sql", kAndroidJavaHeapHistogram},

  {"android/java_heap_stats.sql", kAndroidJavaHeapStats},

  {"android/mem_stats_priority_breakdown.sql", kAndroidMemStatsPriorityBreakdown},

  {"android/network_activity_template.sql", kAndroidNetworkActivityTemplate},

  {"android/p_state.sql", kAndroidPState},

  {"android/power_drain_in_watts.sql", kAndroidPowerDrainInWatts},

  {"android/power_profile_data.sql", kAndroidPowerProfileData},

  {"android/power_profile_data/barbet.sql", kAndroidPowerProfileDataBarbet},

  {"android/power_profile_data/bluejay.sql", kAndroidPowerProfileDataBluejay},

  {"android/power_profile_data/blueline.sql", kAndroidPowerProfileDataBlueline},

  {"android/power_profile_data/bonito.sql", kAndroidPowerProfileDataBonito},

  {"android/power_profile_data/bramble.sql", kAndroidPowerProfileDataBramble},

  {"android/power_profile_data/coral.sql", kAndroidPowerProfileDataCoral},

  {"android/power_profile_data/crosshatch.sql", kAndroidPowerProfileDataCrosshatch},

  {"android/power_profile_data/flame.sql", kAndroidPowerProfileDataFlame},

  {"android/power_profile_data/marlin.sql", kAndroidPowerProfileDataMarlin},

  {"android/power_profile_data/oriole.sql", kAndroidPowerProfileDataOriole},

  {"android/power_profile_data/raven.sql", kAndroidPowerProfileDataRaven},

  {"android/power_profile_data/redfin.sql", kAndroidPowerProfileDataRedfin},

  {"android/power_profile_data/sargo.sql", kAndroidPowerProfileDataSargo},

  {"android/power_profile_data/shusky.sql", kAndroidPowerProfileDataShusky},

  {"android/power_profile_data/sunfish.sql", kAndroidPowerProfileDataSunfish},

  {"android/power_profile_data/taimen.sql", kAndroidPowerProfileDataTaimen},

  {"android/power_profile_data/walleye.sql", kAndroidPowerProfileDataWalleye},

  {"android/process_counter_span_view.sql", kAndroidProcessCounterSpanView},

  {"android/process_mem.sql", kAndroidProcessMem},

  {"android/process_metadata.sql", kAndroidProcessMetadata},

  {"android/process_oom_score.sql", kAndroidProcessOomScore},

  {"android/process_unagg_mem_view.sql", kAndroidProcessUnaggMemView},

  {"android/profiler_smaps.sql", kAndroidProfilerSmaps},

  {"android/span_view_stats.sql", kAndroidSpanViewStats},

  {"android/startup/android_app_process_starts.sql", kAndroidStartupAndroidAppProcessStarts},

  {"android/startup/gc_slices.sql", kAndroidStartupGcSlices},

  {"android/startup/hsc.sql", kAndroidStartupHsc},

  {"android/startup/launches.sql", kAndroidStartupLaunches},

  {"android/startup/launches_maxsdk28.sql", kAndroidStartupLaunchesMaxsdk28},

  {"android/startup/launches_minsdk29.sql", kAndroidStartupLaunchesMinsdk29},

  {"android/startup/launches_minsdk33.sql", kAndroidStartupLaunchesMinsdk33},

  {"android/startup/mcycles_per_launch.sql", kAndroidStartupMcyclesPerLaunch},

  {"android/startup/slice_functions.sql", kAndroidStartupSliceFunctions},

  {"android/startup/slow_start_reasons.sql", kAndroidStartupSlowStartReasons},

  {"android/startup/system_state.sql", kAndroidStartupSystemState},

  {"android/startup/thread_state_breakdown.sql", kAndroidStartupThreadStateBreakdown},

  {"android/sysui_notif_shade_list_builder_metric.sql", kAndroidSysuiNotifShadeListBuilderMetric},

  {"android/sysui_notif_shade_list_builder_slices.sql", kAndroidSysuiNotifShadeListBuilderSlices},

  {"android/sysui_update_notif_on_ui_mode_changed_metric.sql", kAndroidSysuiUpdateNotifOnUiModeChangedMetric},

  {"android/unsymbolized_frames.sql", kAndroidUnsymbolizedFrames},

  {"chrome/actual_power_by_category.sql", kChromeActualPowerByCategory},

  {"chrome/actual_power_by_rail_mode.sql", kChromeActualPowerByRailMode},

  {"chrome/chrome_args_class_names.sql", kChromeChromeArgsClassNames},

  {"chrome/chrome_event_metadata.sql", kChromeChromeEventMetadata},

  {"chrome/chrome_histogram_hashes.sql", kChromeChromeHistogramHashes},

  {"chrome/chrome_input_to_browser_intervals.sql", kChromeChromeInputToBrowserIntervals},

  {"chrome/chrome_input_to_browser_intervals_base.sql", kChromeChromeInputToBrowserIntervalsBase},

  {"chrome/chrome_input_to_browser_intervals_template.sql", kChromeChromeInputToBrowserIntervalsTemplate},

  {"chrome/chrome_long_tasks.sql", kChromeChromeLongTasks},

  {"chrome/chrome_long_tasks_delaying_input_processing.sql", kChromeChromeLongTasksDelayingInputProcessing},

  {"chrome/chrome_performance_mark_hashes.sql", kChromeChromePerformanceMarkHashes},

  {"chrome/chrome_processes.sql", kChromeChromeProcesses},

  {"chrome/chrome_reliable_range.sql", kChromeChromeReliableRange},

  {"chrome/chrome_scroll_inputs_per_frame.sql", kChromeChromeScrollInputsPerFrame},

  {"chrome/chrome_scroll_jank_caused_by_scheduling.sql", kChromeChromeScrollJankCausedByScheduling},

  {"chrome/chrome_scroll_jank_v3.sql", kChromeChromeScrollJankV3},

  {"chrome/chrome_slice_names.sql", kChromeChromeSliceNames},

  {"chrome/chrome_stack_samples_for_task.sql", kChromeChromeStackSamplesForTask},

  {"chrome/chrome_tasks.sql", kChromeChromeTasks},

  {"chrome/chrome_tasks_delaying_input_processing.sql", kChromeChromeTasksDelayingInputProcessing},

  {"chrome/chrome_tasks_delaying_input_processing_base.sql", kChromeChromeTasksDelayingInputProcessingBase},

  {"chrome/chrome_tasks_delaying_input_processing_template.sql", kChromeChromeTasksDelayingInputProcessingTemplate},

  {"chrome/chrome_thread_slice.sql", kChromeChromeThreadSlice},

  {"chrome/chrome_unsymbolized_args.sql", kChromeChromeUnsymbolizedArgs},

  {"chrome/chrome_user_event_hashes.sql", kChromeChromeUserEventHashes},

  {"chrome/cpu_time_by_category.sql", kChromeCpuTimeByCategory},

  {"chrome/cpu_time_by_rail_mode.sql", kChromeCpuTimeByRailMode},

  {"chrome/estimated_power_by_category.sql", kChromeEstimatedPowerByCategory},

  {"chrome/estimated_power_by_rail_mode.sql", kChromeEstimatedPowerByRailMode},

  {"chrome/experimental_reliable_chrome_tasks_delaying_input_processing.sql", kChromeExperimentalReliableChromeTasksDelayingInputProcessing},

  {"chrome/gesture_flow_event.sql", kChromeGestureFlowEvent},

  {"chrome/gesture_flow_event_queuing_delay.sql", kChromeGestureFlowEventQueuingDelay},

  {"chrome/gesture_jank.sql", kChromeGestureJank},

  {"chrome/rail_modes.sql", kChromeRailModes},

  {"chrome/scroll_flow_event.sql", kChromeScrollFlowEvent},

  {"chrome/scroll_flow_event_queuing_delay.sql", kChromeScrollFlowEventQueuingDelay},

  {"chrome/scroll_jank.sql", kChromeScrollJank},

  {"chrome/scroll_jank_cause.sql", kChromeScrollJankCause},

  {"chrome/scroll_jank_cause_blocking_task.sql", kChromeScrollJankCauseBlockingTask},

  {"chrome/scroll_jank_cause_blocking_touch_move.sql", kChromeScrollJankCauseBlockingTouchMove},

  {"chrome/scroll_jank_cause_get_bitmap.sql", kChromeScrollJankCauseGetBitmap},

  {"chrome/scroll_jank_cause_queuing_delay.sql", kChromeScrollJankCauseQueuingDelay},

  {"chrome/sufficient_chrome_processes.sql", kChromeSufficientChromeProcesses},

  {"chrome/test_chrome_metric.sql", kChromeTestChromeMetric},

  {"chrome/touch_flow_event.sql", kChromeTouchFlowEvent},

  {"chrome/touch_flow_event_queuing_delay.sql", kChromeTouchFlowEventQueuingDelay},

  {"chrome/touch_jank.sql", kChromeTouchJank},

  {"common/parent_slice.sql", kCommonParentSlice},

  {"experimental/chrome_dropped_frames.sql", kExperimentalChromeDroppedFrames},

  {"experimental/chrome_long_latency.sql", kExperimentalChromeLongLatency},

  {"experimental/frame_times.sql", kExperimentalFrameTimes},

  {"experimental/media_metric.sql", kExperimentalMediaMetric},

  {"experimental/reported_by_page.sql", kExperimentalReportedByPage},

  {"webview/webview_jank_approximation.sql", kWebviewWebviewJankApproximation},

  {"webview/webview_power_usage.sql", kWebviewWebviewPowerUsage},
};

}  // namespace sql_metrics
}  // namespace trace_processor
}  // namespace perfetto
