// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_CHROME_SCENARIO_CONFIG_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_CHROME_SCENARIO_CONFIG_PROTO_H_

#include <stddef.h>
#include <stdint.h>

#include "perfetto/protozero/field_writer.h"
#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {
class NestedScenarioConfig;
class ScenarioConfig;
class TraceConfig;
class TriggerRule;
class TriggerRule_HistogramTrigger;
class TriggerRule_RepeatingInterval;
} // Namespace pbzero.
} // Namespace protos.
} // Namespace perfetto.

namespace perfetto {
namespace protos {
namespace pbzero {

class TracingTriggerRulesConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  TracingTriggerRulesConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TracingTriggerRulesConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TracingTriggerRulesConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_rules() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> rules() const { return GetRepeated<::protozero::ConstBytes>(1); }
};

class TracingTriggerRulesConfig : public ::protozero::Message {
 public:
  using Decoder = TracingTriggerRulesConfig_Decoder;
  enum : int32_t {
    kRulesFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.TracingTriggerRulesConfig"; }


  using FieldMetadata_Rules =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      TriggerRule,
      TracingTriggerRulesConfig>;

  static constexpr FieldMetadata_Rules kRules{};
  template <typename T = TriggerRule> T* add_rules() {
    return BeginNestedMessage<T>(1);
  }

};

class ChromeFieldTracingConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ChromeFieldTracingConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeFieldTracingConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeFieldTracingConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_scenarios() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> scenarios() const { return GetRepeated<::protozero::ConstBytes>(1); }
};

class ChromeFieldTracingConfig : public ::protozero::Message {
 public:
  using Decoder = ChromeFieldTracingConfig_Decoder;
  enum : int32_t {
    kScenariosFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ChromeFieldTracingConfig"; }


  using FieldMetadata_Scenarios =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ScenarioConfig,
      ChromeFieldTracingConfig>;

  static constexpr FieldMetadata_Scenarios kScenarios{};
  template <typename T = ScenarioConfig> T* add_scenarios() {
    return BeginNestedMessage<T>(1);
  }

};

class ScenarioConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ScenarioConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ScenarioConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ScenarioConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_scenario_name() const { return at<1>().valid(); }
  ::protozero::ConstChars scenario_name() const { return at<1>().as_string(); }
  bool has_start_rules() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> start_rules() const { return GetRepeated<::protozero::ConstBytes>(2); }
  bool has_stop_rules() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> stop_rules() const { return GetRepeated<::protozero::ConstBytes>(3); }
  bool has_upload_rules() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> upload_rules() const { return GetRepeated<::protozero::ConstBytes>(4); }
  bool has_setup_rules() const { return at<5>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> setup_rules() const { return GetRepeated<::protozero::ConstBytes>(5); }
  bool has_trace_config() const { return at<6>().valid(); }
  ::protozero::ConstBytes trace_config() const { return at<6>().as_bytes(); }
  bool has_nested_scenarios() const { return at<7>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> nested_scenarios() const { return GetRepeated<::protozero::ConstBytes>(7); }
};

class ScenarioConfig : public ::protozero::Message {
 public:
  using Decoder = ScenarioConfig_Decoder;
  enum : int32_t {
    kScenarioNameFieldNumber = 1,
    kStartRulesFieldNumber = 2,
    kStopRulesFieldNumber = 3,
    kUploadRulesFieldNumber = 4,
    kSetupRulesFieldNumber = 5,
    kTraceConfigFieldNumber = 6,
    kNestedScenariosFieldNumber = 7,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ScenarioConfig"; }


  using FieldMetadata_ScenarioName =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      ScenarioConfig>;

  static constexpr FieldMetadata_ScenarioName kScenarioName{};
  void set_scenario_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_ScenarioName::kFieldId, data, size);
  }
  void set_scenario_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_ScenarioName::kFieldId, chars.data, chars.size);
  }
  void set_scenario_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_ScenarioName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_StartRules =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      TriggerRule,
      ScenarioConfig>;

  static constexpr FieldMetadata_StartRules kStartRules{};
  template <typename T = TriggerRule> T* add_start_rules() {
    return BeginNestedMessage<T>(2);
  }


  using FieldMetadata_StopRules =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      TriggerRule,
      ScenarioConfig>;

  static constexpr FieldMetadata_StopRules kStopRules{};
  template <typename T = TriggerRule> T* add_stop_rules() {
    return BeginNestedMessage<T>(3);
  }


  using FieldMetadata_UploadRules =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      TriggerRule,
      ScenarioConfig>;

  static constexpr FieldMetadata_UploadRules kUploadRules{};
  template <typename T = TriggerRule> T* add_upload_rules() {
    return BeginNestedMessage<T>(4);
  }


  using FieldMetadata_SetupRules =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      TriggerRule,
      ScenarioConfig>;

  static constexpr FieldMetadata_SetupRules kSetupRules{};
  template <typename T = TriggerRule> T* add_setup_rules() {
    return BeginNestedMessage<T>(5);
  }


  using FieldMetadata_TraceConfig =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      TraceConfig,
      ScenarioConfig>;

  static constexpr FieldMetadata_TraceConfig kTraceConfig{};
  template <typename T = TraceConfig> T* set_trace_config() {
    return BeginNestedMessage<T>(6);
  }


  using FieldMetadata_NestedScenarios =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      NestedScenarioConfig,
      ScenarioConfig>;

  static constexpr FieldMetadata_NestedScenarios kNestedScenarios{};
  template <typename T = NestedScenarioConfig> T* add_nested_scenarios() {
    return BeginNestedMessage<T>(7);
  }

};

class NestedScenarioConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  NestedScenarioConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit NestedScenarioConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit NestedScenarioConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_scenario_name() const { return at<1>().valid(); }
  ::protozero::ConstChars scenario_name() const { return at<1>().as_string(); }
  bool has_start_rules() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> start_rules() const { return GetRepeated<::protozero::ConstBytes>(2); }
  bool has_stop_rules() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> stop_rules() const { return GetRepeated<::protozero::ConstBytes>(3); }
  bool has_upload_rules() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> upload_rules() const { return GetRepeated<::protozero::ConstBytes>(4); }
};

class NestedScenarioConfig : public ::protozero::Message {
 public:
  using Decoder = NestedScenarioConfig_Decoder;
  enum : int32_t {
    kScenarioNameFieldNumber = 1,
    kStartRulesFieldNumber = 2,
    kStopRulesFieldNumber = 3,
    kUploadRulesFieldNumber = 4,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.NestedScenarioConfig"; }


  using FieldMetadata_ScenarioName =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      NestedScenarioConfig>;

  static constexpr FieldMetadata_ScenarioName kScenarioName{};
  void set_scenario_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_ScenarioName::kFieldId, data, size);
  }
  void set_scenario_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_ScenarioName::kFieldId, chars.data, chars.size);
  }
  void set_scenario_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_ScenarioName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_StartRules =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      TriggerRule,
      NestedScenarioConfig>;

  static constexpr FieldMetadata_StartRules kStartRules{};
  template <typename T = TriggerRule> T* add_start_rules() {
    return BeginNestedMessage<T>(2);
  }


  using FieldMetadata_StopRules =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      TriggerRule,
      NestedScenarioConfig>;

  static constexpr FieldMetadata_StopRules kStopRules{};
  template <typename T = TriggerRule> T* add_stop_rules() {
    return BeginNestedMessage<T>(3);
  }


  using FieldMetadata_UploadRules =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      TriggerRule,
      NestedScenarioConfig>;

  static constexpr FieldMetadata_UploadRules kUploadRules{};
  template <typename T = TriggerRule> T* add_upload_rules() {
    return BeginNestedMessage<T>(4);
  }

};

class TriggerRule_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TriggerRule_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TriggerRule_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TriggerRule_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_trigger_chance() const { return at<2>().valid(); }
  float trigger_chance() const { return at<2>().as_float(); }
  bool has_delay_ms() const { return at<3>().valid(); }
  uint64_t delay_ms() const { return at<3>().as_uint64(); }
  bool has_activation_delay_ms() const { return at<8>().valid(); }
  uint64_t activation_delay_ms() const { return at<8>().as_uint64(); }
  bool has_manual_trigger_name() const { return at<4>().valid(); }
  ::protozero::ConstChars manual_trigger_name() const { return at<4>().as_string(); }
  bool has_histogram() const { return at<5>().valid(); }
  ::protozero::ConstBytes histogram() const { return at<5>().as_bytes(); }
  bool has_repeating_interval() const { return at<6>().valid(); }
  ::protozero::ConstBytes repeating_interval() const { return at<6>().as_bytes(); }
};

class TriggerRule : public ::protozero::Message {
 public:
  using Decoder = TriggerRule_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kTriggerChanceFieldNumber = 2,
    kDelayMsFieldNumber = 3,
    kActivationDelayMsFieldNumber = 8,
    kManualTriggerNameFieldNumber = 4,
    kHistogramFieldNumber = 5,
    kRepeatingIntervalFieldNumber = 6,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.TriggerRule"; }

  using HistogramTrigger = ::perfetto::protos::pbzero::TriggerRule_HistogramTrigger;
  using RepeatingInterval = ::perfetto::protos::pbzero::TriggerRule_RepeatingInterval;

  using FieldMetadata_Name =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      TriggerRule>;

  static constexpr FieldMetadata_Name kName{};
  void set_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Name::kFieldId, data, size);
  }
  void set_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Name::kFieldId, chars.data, chars.size);
  }
  void set_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Name::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_TriggerChance =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kFloat,
      float,
      TriggerRule>;

  static constexpr FieldMetadata_TriggerChance kTriggerChance{};
  void set_trigger_chance(float value) {
    static constexpr uint32_t field_id = FieldMetadata_TriggerChance::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kFloat>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_DelayMs =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      TriggerRule>;

  static constexpr FieldMetadata_DelayMs kDelayMs{};
  void set_delay_ms(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_DelayMs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ActivationDelayMs =
    ::protozero::proto_utils::FieldMetadata<
      8,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      TriggerRule>;

  static constexpr FieldMetadata_ActivationDelayMs kActivationDelayMs{};
  void set_activation_delay_ms(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ActivationDelayMs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ManualTriggerName =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      TriggerRule>;

  static constexpr FieldMetadata_ManualTriggerName kManualTriggerName{};
  void set_manual_trigger_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_ManualTriggerName::kFieldId, data, size);
  }
  void set_manual_trigger_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_ManualTriggerName::kFieldId, chars.data, chars.size);
  }
  void set_manual_trigger_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_ManualTriggerName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Histogram =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      TriggerRule_HistogramTrigger,
      TriggerRule>;

  static constexpr FieldMetadata_Histogram kHistogram{};
  template <typename T = TriggerRule_HistogramTrigger> T* set_histogram() {
    return BeginNestedMessage<T>(5);
  }


  using FieldMetadata_RepeatingInterval =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      TriggerRule_RepeatingInterval,
      TriggerRule>;

  static constexpr FieldMetadata_RepeatingInterval kRepeatingInterval{};
  template <typename T = TriggerRule_RepeatingInterval> T* set_repeating_interval() {
    return BeginNestedMessage<T>(6);
  }

};

class TriggerRule_RepeatingInterval_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TriggerRule_RepeatingInterval_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TriggerRule_RepeatingInterval_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TriggerRule_RepeatingInterval_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_period_ms() const { return at<1>().valid(); }
  uint64_t period_ms() const { return at<1>().as_uint64(); }
  bool has_randomized() const { return at<2>().valid(); }
  bool randomized() const { return at<2>().as_bool(); }
};

class TriggerRule_RepeatingInterval : public ::protozero::Message {
 public:
  using Decoder = TriggerRule_RepeatingInterval_Decoder;
  enum : int32_t {
    kPeriodMsFieldNumber = 1,
    kRandomizedFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.TriggerRule.RepeatingInterval"; }


  using FieldMetadata_PeriodMs =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      TriggerRule_RepeatingInterval>;

  static constexpr FieldMetadata_PeriodMs kPeriodMs{};
  void set_period_ms(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_PeriodMs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Randomized =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      TriggerRule_RepeatingInterval>;

  static constexpr FieldMetadata_Randomized kRandomized{};
  void set_randomized(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_Randomized::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }
};

class TriggerRule_HistogramTrigger_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TriggerRule_HistogramTrigger_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TriggerRule_HistogramTrigger_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TriggerRule_HistogramTrigger_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_histogram_name() const { return at<1>().valid(); }
  ::protozero::ConstChars histogram_name() const { return at<1>().as_string(); }
  bool has_min_value() const { return at<2>().valid(); }
  int64_t min_value() const { return at<2>().as_int64(); }
  bool has_max_value() const { return at<3>().valid(); }
  int64_t max_value() const { return at<3>().as_int64(); }
};

class TriggerRule_HistogramTrigger : public ::protozero::Message {
 public:
  using Decoder = TriggerRule_HistogramTrigger_Decoder;
  enum : int32_t {
    kHistogramNameFieldNumber = 1,
    kMinValueFieldNumber = 2,
    kMaxValueFieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.TriggerRule.HistogramTrigger"; }


  using FieldMetadata_HistogramName =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      TriggerRule_HistogramTrigger>;

  static constexpr FieldMetadata_HistogramName kHistogramName{};
  void set_histogram_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_HistogramName::kFieldId, data, size);
  }
  void set_histogram_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_HistogramName::kFieldId, chars.data, chars.size);
  }
  void set_histogram_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_HistogramName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_MinValue =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      TriggerRule_HistogramTrigger>;

  static constexpr FieldMetadata_MinValue kMinValue{};
  void set_min_value(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_MinValue::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_MaxValue =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      TriggerRule_HistogramTrigger>;

  static constexpr FieldMetadata_MaxValue kMaxValue{};
  void set_max_value(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_MaxValue::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
