// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ETW_ETW_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ETW_ETW_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class ReadyThreadEtwEvent;
class CSwitchEtwEvent;
enum ReadyThreadEtwEvent_AdjustReason : int;
enum ReadyThreadEtwEvent_TraceFlag : int;
enum CSwitchEtwEvent_OldThreadWaitReason : int;
enum CSwitchEtwEvent_OldThreadWaitMode : int;
enum CSwitchEtwEvent_OldThreadState : int;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {
enum ReadyThreadEtwEvent_AdjustReason : int {
  ReadyThreadEtwEvent_AdjustReason_IGNORE_THE_INCREMENT = 0,
  ReadyThreadEtwEvent_AdjustReason_APPLY_INCREMENT = 1,
  ReadyThreadEtwEvent_AdjustReason_APPLY_INCREMENT_BOOST = 2,
};
enum ReadyThreadEtwEvent_TraceFlag : int {
  ReadyThreadEtwEvent_TraceFlag_TRACE_FLAG_UNSPECIFIED = 0,
  ReadyThreadEtwEvent_TraceFlag_THREAD_READIED = 1,
  ReadyThreadEtwEvent_TraceFlag_KERNEL_STACK_SWAPPED_OUT = 2,
  ReadyThreadEtwEvent_TraceFlag_PROCESS_ADDRESS_SWAPPED_OUT = 4,
};
enum CSwitchEtwEvent_OldThreadWaitReason : int {
  CSwitchEtwEvent_OldThreadWaitReason_EXECUTIVE = 0,
  CSwitchEtwEvent_OldThreadWaitReason_FREE_PAGE = 1,
  CSwitchEtwEvent_OldThreadWaitReason_PAGE_IN = 2,
  CSwitchEtwEvent_OldThreadWaitReason_POOL_ALLOCATION = 3,
  CSwitchEtwEvent_OldThreadWaitReason_DELAY_EXECUTION = 4,
  CSwitchEtwEvent_OldThreadWaitReason_SUSPEND = 5,
  CSwitchEtwEvent_OldThreadWaitReason_USER_REQUEST = 6,
  CSwitchEtwEvent_OldThreadWaitReason_WR_EXECUTIVE = 7,
  CSwitchEtwEvent_OldThreadWaitReason_WR_FREE_PAGE = 8,
  CSwitchEtwEvent_OldThreadWaitReason_WR_PAGE_IN = 9,
  CSwitchEtwEvent_OldThreadWaitReason_WR_POOL_ALLOCATION = 10,
  CSwitchEtwEvent_OldThreadWaitReason_WR_DELAY_EXECUTION = 11,
  CSwitchEtwEvent_OldThreadWaitReason_WR_SUSPENDED = 12,
  CSwitchEtwEvent_OldThreadWaitReason_WR_USER_REQUEST = 13,
  CSwitchEtwEvent_OldThreadWaitReason_WR_EVENT_PAIR = 14,
  CSwitchEtwEvent_OldThreadWaitReason_WR_QUEUE = 15,
  CSwitchEtwEvent_OldThreadWaitReason_WR_LPC_RECEIVER = 16,
  CSwitchEtwEvent_OldThreadWaitReason_WR_LPC_REPLY = 17,
  CSwitchEtwEvent_OldThreadWaitReason_WR_VIRTUAL_MEMORY = 18,
  CSwitchEtwEvent_OldThreadWaitReason_WR_PAGE_OUT = 19,
  CSwitchEtwEvent_OldThreadWaitReason_WR_RENDEZ_VOUS = 20,
  CSwitchEtwEvent_OldThreadWaitReason_WR_KEYED_EVENT = 21,
  CSwitchEtwEvent_OldThreadWaitReason_WR_TERMINATED = 22,
  CSwitchEtwEvent_OldThreadWaitReason_WR_PROCESS_IN_SWAP = 23,
  CSwitchEtwEvent_OldThreadWaitReason_WR_CPU_RATE_CONTROL = 24,
  CSwitchEtwEvent_OldThreadWaitReason_WR_CALLOUT_STACK = 25,
  CSwitchEtwEvent_OldThreadWaitReason_WR_KERNEL = 26,
  CSwitchEtwEvent_OldThreadWaitReason_WR_RESOURCE = 27,
  CSwitchEtwEvent_OldThreadWaitReason_WR_PUSH_LOCK = 28,
  CSwitchEtwEvent_OldThreadWaitReason_WR_MUTEX = 29,
  CSwitchEtwEvent_OldThreadWaitReason_WR_QUANTUM_END = 30,
  CSwitchEtwEvent_OldThreadWaitReason_WR_DISPATCH_INT = 31,
  CSwitchEtwEvent_OldThreadWaitReason_WR_PREEMPTED = 32,
  CSwitchEtwEvent_OldThreadWaitReason_WR_YIELD_EXECUTION = 33,
  CSwitchEtwEvent_OldThreadWaitReason_WR_FAST_MUTEX = 34,
  CSwitchEtwEvent_OldThreadWaitReason_WR_GUARD_MUTEX = 35,
  CSwitchEtwEvent_OldThreadWaitReason_WR_RUNDOWN = 36,
  CSwitchEtwEvent_OldThreadWaitReason_MAXIMUM_WAIT_REASON = 37,
};
enum CSwitchEtwEvent_OldThreadWaitMode : int {
  CSwitchEtwEvent_OldThreadWaitMode_KERNEL_MODE = 0,
  CSwitchEtwEvent_OldThreadWaitMode_USER_MODE = 1,
};
enum CSwitchEtwEvent_OldThreadState : int {
  CSwitchEtwEvent_OldThreadState_INITIALIZED = 0,
  CSwitchEtwEvent_OldThreadState_READY = 1,
  CSwitchEtwEvent_OldThreadState_RUNNING = 2,
  CSwitchEtwEvent_OldThreadState_STANDBY = 3,
  CSwitchEtwEvent_OldThreadState_TERMINATED = 4,
  CSwitchEtwEvent_OldThreadState_WAITING = 5,
  CSwitchEtwEvent_OldThreadState_TRANSITION = 6,
  CSwitchEtwEvent_OldThreadState_DEFERRED_READY = 7,
};

class PERFETTO_EXPORT_COMPONENT ReadyThreadEtwEvent : public ::protozero::CppMessageObj {
 public:
  using AdjustReason = ReadyThreadEtwEvent_AdjustReason;
  static constexpr auto IGNORE_THE_INCREMENT = ReadyThreadEtwEvent_AdjustReason_IGNORE_THE_INCREMENT;
  static constexpr auto APPLY_INCREMENT = ReadyThreadEtwEvent_AdjustReason_APPLY_INCREMENT;
  static constexpr auto APPLY_INCREMENT_BOOST = ReadyThreadEtwEvent_AdjustReason_APPLY_INCREMENT_BOOST;
  static constexpr auto AdjustReason_MIN = ReadyThreadEtwEvent_AdjustReason_IGNORE_THE_INCREMENT;
  static constexpr auto AdjustReason_MAX = ReadyThreadEtwEvent_AdjustReason_APPLY_INCREMENT_BOOST;
  using TraceFlag = ReadyThreadEtwEvent_TraceFlag;
  static constexpr auto TRACE_FLAG_UNSPECIFIED = ReadyThreadEtwEvent_TraceFlag_TRACE_FLAG_UNSPECIFIED;
  static constexpr auto THREAD_READIED = ReadyThreadEtwEvent_TraceFlag_THREAD_READIED;
  static constexpr auto KERNEL_STACK_SWAPPED_OUT = ReadyThreadEtwEvent_TraceFlag_KERNEL_STACK_SWAPPED_OUT;
  static constexpr auto PROCESS_ADDRESS_SWAPPED_OUT = ReadyThreadEtwEvent_TraceFlag_PROCESS_ADDRESS_SWAPPED_OUT;
  static constexpr auto TraceFlag_MIN = ReadyThreadEtwEvent_TraceFlag_TRACE_FLAG_UNSPECIFIED;
  static constexpr auto TraceFlag_MAX = ReadyThreadEtwEvent_TraceFlag_PROCESS_ADDRESS_SWAPPED_OUT;
  enum FieldNumbers {
    kTThreadIdFieldNumber = 1,
    kAdjustReasonFieldNumber = 2,
    kAdjustIncrementFieldNumber = 3,
    kFlagFieldNumber = 4,
  };

  ReadyThreadEtwEvent();
  ~ReadyThreadEtwEvent() override;
  ReadyThreadEtwEvent(ReadyThreadEtwEvent&&) noexcept;
  ReadyThreadEtwEvent& operator=(ReadyThreadEtwEvent&&);
  ReadyThreadEtwEvent(const ReadyThreadEtwEvent&);
  ReadyThreadEtwEvent& operator=(const ReadyThreadEtwEvent&);
  bool operator==(const ReadyThreadEtwEvent&) const;
  bool operator!=(const ReadyThreadEtwEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_t_thread_id() const { return _has_field_[1]; }
  uint32_t t_thread_id() const { return t_thread_id_; }
  void set_t_thread_id(uint32_t value) { t_thread_id_ = value; _has_field_.set(1); }

  bool has_adjust_reason() const { return _has_field_[2]; }
  ReadyThreadEtwEvent_AdjustReason adjust_reason() const { return adjust_reason_; }
  void set_adjust_reason(ReadyThreadEtwEvent_AdjustReason value) { adjust_reason_ = value; _has_field_.set(2); }

  bool has_adjust_increment() const { return _has_field_[3]; }
  int32_t adjust_increment() const { return adjust_increment_; }
  void set_adjust_increment(int32_t value) { adjust_increment_ = value; _has_field_.set(3); }

  bool has_flag() const { return _has_field_[4]; }
  ReadyThreadEtwEvent_TraceFlag flag() const { return flag_; }
  void set_flag(ReadyThreadEtwEvent_TraceFlag value) { flag_ = value; _has_field_.set(4); }

 private:
  uint32_t t_thread_id_{};
  ReadyThreadEtwEvent_AdjustReason adjust_reason_{};
  int32_t adjust_increment_{};
  ReadyThreadEtwEvent_TraceFlag flag_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT CSwitchEtwEvent : public ::protozero::CppMessageObj {
 public:
  using OldThreadWaitReason = CSwitchEtwEvent_OldThreadWaitReason;
  static constexpr auto EXECUTIVE = CSwitchEtwEvent_OldThreadWaitReason_EXECUTIVE;
  static constexpr auto FREE_PAGE = CSwitchEtwEvent_OldThreadWaitReason_FREE_PAGE;
  static constexpr auto PAGE_IN = CSwitchEtwEvent_OldThreadWaitReason_PAGE_IN;
  static constexpr auto POOL_ALLOCATION = CSwitchEtwEvent_OldThreadWaitReason_POOL_ALLOCATION;
  static constexpr auto DELAY_EXECUTION = CSwitchEtwEvent_OldThreadWaitReason_DELAY_EXECUTION;
  static constexpr auto SUSPEND = CSwitchEtwEvent_OldThreadWaitReason_SUSPEND;
  static constexpr auto USER_REQUEST = CSwitchEtwEvent_OldThreadWaitReason_USER_REQUEST;
  static constexpr auto WR_EXECUTIVE = CSwitchEtwEvent_OldThreadWaitReason_WR_EXECUTIVE;
  static constexpr auto WR_FREE_PAGE = CSwitchEtwEvent_OldThreadWaitReason_WR_FREE_PAGE;
  static constexpr auto WR_PAGE_IN = CSwitchEtwEvent_OldThreadWaitReason_WR_PAGE_IN;
  static constexpr auto WR_POOL_ALLOCATION = CSwitchEtwEvent_OldThreadWaitReason_WR_POOL_ALLOCATION;
  static constexpr auto WR_DELAY_EXECUTION = CSwitchEtwEvent_OldThreadWaitReason_WR_DELAY_EXECUTION;
  static constexpr auto WR_SUSPENDED = CSwitchEtwEvent_OldThreadWaitReason_WR_SUSPENDED;
  static constexpr auto WR_USER_REQUEST = CSwitchEtwEvent_OldThreadWaitReason_WR_USER_REQUEST;
  static constexpr auto WR_EVENT_PAIR = CSwitchEtwEvent_OldThreadWaitReason_WR_EVENT_PAIR;
  static constexpr auto WR_QUEUE = CSwitchEtwEvent_OldThreadWaitReason_WR_QUEUE;
  static constexpr auto WR_LPC_RECEIVER = CSwitchEtwEvent_OldThreadWaitReason_WR_LPC_RECEIVER;
  static constexpr auto WR_LPC_REPLY = CSwitchEtwEvent_OldThreadWaitReason_WR_LPC_REPLY;
  static constexpr auto WR_VIRTUAL_MEMORY = CSwitchEtwEvent_OldThreadWaitReason_WR_VIRTUAL_MEMORY;
  static constexpr auto WR_PAGE_OUT = CSwitchEtwEvent_OldThreadWaitReason_WR_PAGE_OUT;
  static constexpr auto WR_RENDEZ_VOUS = CSwitchEtwEvent_OldThreadWaitReason_WR_RENDEZ_VOUS;
  static constexpr auto WR_KEYED_EVENT = CSwitchEtwEvent_OldThreadWaitReason_WR_KEYED_EVENT;
  static constexpr auto WR_TERMINATED = CSwitchEtwEvent_OldThreadWaitReason_WR_TERMINATED;
  static constexpr auto WR_PROCESS_IN_SWAP = CSwitchEtwEvent_OldThreadWaitReason_WR_PROCESS_IN_SWAP;
  static constexpr auto WR_CPU_RATE_CONTROL = CSwitchEtwEvent_OldThreadWaitReason_WR_CPU_RATE_CONTROL;
  static constexpr auto WR_CALLOUT_STACK = CSwitchEtwEvent_OldThreadWaitReason_WR_CALLOUT_STACK;
  static constexpr auto WR_KERNEL = CSwitchEtwEvent_OldThreadWaitReason_WR_KERNEL;
  static constexpr auto WR_RESOURCE = CSwitchEtwEvent_OldThreadWaitReason_WR_RESOURCE;
  static constexpr auto WR_PUSH_LOCK = CSwitchEtwEvent_OldThreadWaitReason_WR_PUSH_LOCK;
  static constexpr auto WR_MUTEX = CSwitchEtwEvent_OldThreadWaitReason_WR_MUTEX;
  static constexpr auto WR_QUANTUM_END = CSwitchEtwEvent_OldThreadWaitReason_WR_QUANTUM_END;
  static constexpr auto WR_DISPATCH_INT = CSwitchEtwEvent_OldThreadWaitReason_WR_DISPATCH_INT;
  static constexpr auto WR_PREEMPTED = CSwitchEtwEvent_OldThreadWaitReason_WR_PREEMPTED;
  static constexpr auto WR_YIELD_EXECUTION = CSwitchEtwEvent_OldThreadWaitReason_WR_YIELD_EXECUTION;
  static constexpr auto WR_FAST_MUTEX = CSwitchEtwEvent_OldThreadWaitReason_WR_FAST_MUTEX;
  static constexpr auto WR_GUARD_MUTEX = CSwitchEtwEvent_OldThreadWaitReason_WR_GUARD_MUTEX;
  static constexpr auto WR_RUNDOWN = CSwitchEtwEvent_OldThreadWaitReason_WR_RUNDOWN;
  static constexpr auto MAXIMUM_WAIT_REASON = CSwitchEtwEvent_OldThreadWaitReason_MAXIMUM_WAIT_REASON;
  static constexpr auto OldThreadWaitReason_MIN = CSwitchEtwEvent_OldThreadWaitReason_EXECUTIVE;
  static constexpr auto OldThreadWaitReason_MAX = CSwitchEtwEvent_OldThreadWaitReason_MAXIMUM_WAIT_REASON;
  using OldThreadWaitMode = CSwitchEtwEvent_OldThreadWaitMode;
  static constexpr auto KERNEL_MODE = CSwitchEtwEvent_OldThreadWaitMode_KERNEL_MODE;
  static constexpr auto USER_MODE = CSwitchEtwEvent_OldThreadWaitMode_USER_MODE;
  static constexpr auto OldThreadWaitMode_MIN = CSwitchEtwEvent_OldThreadWaitMode_KERNEL_MODE;
  static constexpr auto OldThreadWaitMode_MAX = CSwitchEtwEvent_OldThreadWaitMode_USER_MODE;
  using OldThreadState = CSwitchEtwEvent_OldThreadState;
  static constexpr auto INITIALIZED = CSwitchEtwEvent_OldThreadState_INITIALIZED;
  static constexpr auto READY = CSwitchEtwEvent_OldThreadState_READY;
  static constexpr auto RUNNING = CSwitchEtwEvent_OldThreadState_RUNNING;
  static constexpr auto STANDBY = CSwitchEtwEvent_OldThreadState_STANDBY;
  static constexpr auto TERMINATED = CSwitchEtwEvent_OldThreadState_TERMINATED;
  static constexpr auto WAITING = CSwitchEtwEvent_OldThreadState_WAITING;
  static constexpr auto TRANSITION = CSwitchEtwEvent_OldThreadState_TRANSITION;
  static constexpr auto DEFERRED_READY = CSwitchEtwEvent_OldThreadState_DEFERRED_READY;
  static constexpr auto OldThreadState_MIN = CSwitchEtwEvent_OldThreadState_INITIALIZED;
  static constexpr auto OldThreadState_MAX = CSwitchEtwEvent_OldThreadState_DEFERRED_READY;
  enum FieldNumbers {
    kNewThreadIdFieldNumber = 1,
    kOldThreadIdFieldNumber = 2,
    kNewThreadPriorityFieldNumber = 3,
    kOldThreadPriorityFieldNumber = 4,
    kPreviousCStateFieldNumber = 5,
    kOldThreadWaitReasonFieldNumber = 6,
    kOldThreadWaitModeFieldNumber = 7,
    kOldThreadStateFieldNumber = 8,
    kOldThreadWaitIdealProcessorFieldNumber = 9,
    kNewThreadWaitTimeFieldNumber = 10,
  };

  CSwitchEtwEvent();
  ~CSwitchEtwEvent() override;
  CSwitchEtwEvent(CSwitchEtwEvent&&) noexcept;
  CSwitchEtwEvent& operator=(CSwitchEtwEvent&&);
  CSwitchEtwEvent(const CSwitchEtwEvent&);
  CSwitchEtwEvent& operator=(const CSwitchEtwEvent&);
  bool operator==(const CSwitchEtwEvent&) const;
  bool operator!=(const CSwitchEtwEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_new_thread_id() const { return _has_field_[1]; }
  uint32_t new_thread_id() const { return new_thread_id_; }
  void set_new_thread_id(uint32_t value) { new_thread_id_ = value; _has_field_.set(1); }

  bool has_old_thread_id() const { return _has_field_[2]; }
  uint32_t old_thread_id() const { return old_thread_id_; }
  void set_old_thread_id(uint32_t value) { old_thread_id_ = value; _has_field_.set(2); }

  bool has_new_thread_priority() const { return _has_field_[3]; }
  int32_t new_thread_priority() const { return new_thread_priority_; }
  void set_new_thread_priority(int32_t value) { new_thread_priority_ = value; _has_field_.set(3); }

  bool has_old_thread_priority() const { return _has_field_[4]; }
  int32_t old_thread_priority() const { return old_thread_priority_; }
  void set_old_thread_priority(int32_t value) { old_thread_priority_ = value; _has_field_.set(4); }

  bool has_previous_c_state() const { return _has_field_[5]; }
  uint32_t previous_c_state() const { return previous_c_state_; }
  void set_previous_c_state(uint32_t value) { previous_c_state_ = value; _has_field_.set(5); }

  bool has_old_thread_wait_reason() const { return _has_field_[6]; }
  CSwitchEtwEvent_OldThreadWaitReason old_thread_wait_reason() const { return old_thread_wait_reason_; }
  void set_old_thread_wait_reason(CSwitchEtwEvent_OldThreadWaitReason value) { old_thread_wait_reason_ = value; _has_field_.set(6); }

  bool has_old_thread_wait_mode() const { return _has_field_[7]; }
  CSwitchEtwEvent_OldThreadWaitMode old_thread_wait_mode() const { return old_thread_wait_mode_; }
  void set_old_thread_wait_mode(CSwitchEtwEvent_OldThreadWaitMode value) { old_thread_wait_mode_ = value; _has_field_.set(7); }

  bool has_old_thread_state() const { return _has_field_[8]; }
  CSwitchEtwEvent_OldThreadState old_thread_state() const { return old_thread_state_; }
  void set_old_thread_state(CSwitchEtwEvent_OldThreadState value) { old_thread_state_ = value; _has_field_.set(8); }

  bool has_old_thread_wait_ideal_processor() const { return _has_field_[9]; }
  int32_t old_thread_wait_ideal_processor() const { return old_thread_wait_ideal_processor_; }
  void set_old_thread_wait_ideal_processor(int32_t value) { old_thread_wait_ideal_processor_ = value; _has_field_.set(9); }

  bool has_new_thread_wait_time() const { return _has_field_[10]; }
  uint32_t new_thread_wait_time() const { return new_thread_wait_time_; }
  void set_new_thread_wait_time(uint32_t value) { new_thread_wait_time_ = value; _has_field_.set(10); }

 private:
  uint32_t new_thread_id_{};
  uint32_t old_thread_id_{};
  int32_t new_thread_priority_{};
  int32_t old_thread_priority_{};
  uint32_t previous_c_state_{};
  CSwitchEtwEvent_OldThreadWaitReason old_thread_wait_reason_{};
  CSwitchEtwEvent_OldThreadWaitMode old_thread_wait_mode_{};
  CSwitchEtwEvent_OldThreadState old_thread_state_{};
  int32_t old_thread_wait_ideal_processor_{};
  uint32_t new_thread_wait_time_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<11> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ETW_ETW_PROTO_CPP_H_
