// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_CHROME_CHROME_METADATA_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_CHROME_CHROME_METADATA_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class BackgroundTracingMetadata;
class BackgroundTracingMetadata_TriggerRule;
class BackgroundTracingMetadata_TriggerRule_NamedRule;
class BackgroundTracingMetadata_TriggerRule_HistogramRule;
class ChromeMetadataPacket;
class ChromeMetadataPacket_FinchHash;
enum BackgroundTracingMetadata_TriggerRule_TriggerType : int;
enum BackgroundTracingMetadata_TriggerRule_NamedRule_EventType : int;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {
enum BackgroundTracingMetadata_TriggerRule_TriggerType : int {
  BackgroundTracingMetadata_TriggerRule_TriggerType_TRIGGER_UNSPECIFIED = 0,
  BackgroundTracingMetadata_TriggerRule_TriggerType_MONITOR_AND_DUMP_WHEN_SPECIFIC_HISTOGRAM_AND_VALUE = 1,
  BackgroundTracingMetadata_TriggerRule_TriggerType_MONITOR_AND_DUMP_WHEN_TRIGGER_NAMED = 2,
};
enum BackgroundTracingMetadata_TriggerRule_NamedRule_EventType : int {
  BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_UNSPECIFIED = 0,
  BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_SESSION_RESTORE = 1,
  BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_NAVIGATION = 2,
  BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_STARTUP = 3,
  BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_REACHED_CODE = 4,
  BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_CONTENT_TRIGGER = 5,
  BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_TEST_RULE = 1000,
};

class PERFETTO_EXPORT_COMPONENT BackgroundTracingMetadata : public ::protozero::CppMessageObj {
 public:
  using TriggerRule = BackgroundTracingMetadata_TriggerRule;
  enum FieldNumbers {
    kTriggeredRuleFieldNumber = 1,
    kActiveRulesFieldNumber = 2,
    kScenarioNameHashFieldNumber = 3,
  };

  BackgroundTracingMetadata();
  ~BackgroundTracingMetadata() override;
  BackgroundTracingMetadata(BackgroundTracingMetadata&&) noexcept;
  BackgroundTracingMetadata& operator=(BackgroundTracingMetadata&&);
  BackgroundTracingMetadata(const BackgroundTracingMetadata&);
  BackgroundTracingMetadata& operator=(const BackgroundTracingMetadata&);
  bool operator==(const BackgroundTracingMetadata&) const;
  bool operator!=(const BackgroundTracingMetadata& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_triggered_rule() const { return _has_field_[1]; }
  const BackgroundTracingMetadata_TriggerRule& triggered_rule() const { return *triggered_rule_; }
  BackgroundTracingMetadata_TriggerRule* mutable_triggered_rule() { _has_field_.set(1); return triggered_rule_.get(); }

  const std::vector<BackgroundTracingMetadata_TriggerRule>& active_rules() const { return active_rules_; }
  std::vector<BackgroundTracingMetadata_TriggerRule>* mutable_active_rules() { return &active_rules_; }
  int active_rules_size() const;
  void clear_active_rules();
  BackgroundTracingMetadata_TriggerRule* add_active_rules();

  bool has_scenario_name_hash() const { return _has_field_[3]; }
  uint32_t scenario_name_hash() const { return scenario_name_hash_; }
  void set_scenario_name_hash(uint32_t value) { scenario_name_hash_ = value; _has_field_.set(3); }

 private:
  ::protozero::CopyablePtr<BackgroundTracingMetadata_TriggerRule> triggered_rule_;
  std::vector<BackgroundTracingMetadata_TriggerRule> active_rules_;
  uint32_t scenario_name_hash_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT BackgroundTracingMetadata_TriggerRule : public ::protozero::CppMessageObj {
 public:
  using HistogramRule = BackgroundTracingMetadata_TriggerRule_HistogramRule;
  using NamedRule = BackgroundTracingMetadata_TriggerRule_NamedRule;
  using TriggerType = BackgroundTracingMetadata_TriggerRule_TriggerType;
  static constexpr auto TRIGGER_UNSPECIFIED = BackgroundTracingMetadata_TriggerRule_TriggerType_TRIGGER_UNSPECIFIED;
  static constexpr auto MONITOR_AND_DUMP_WHEN_SPECIFIC_HISTOGRAM_AND_VALUE = BackgroundTracingMetadata_TriggerRule_TriggerType_MONITOR_AND_DUMP_WHEN_SPECIFIC_HISTOGRAM_AND_VALUE;
  static constexpr auto MONITOR_AND_DUMP_WHEN_TRIGGER_NAMED = BackgroundTracingMetadata_TriggerRule_TriggerType_MONITOR_AND_DUMP_WHEN_TRIGGER_NAMED;
  static constexpr auto TriggerType_MIN = BackgroundTracingMetadata_TriggerRule_TriggerType_TRIGGER_UNSPECIFIED;
  static constexpr auto TriggerType_MAX = BackgroundTracingMetadata_TriggerRule_TriggerType_MONITOR_AND_DUMP_WHEN_TRIGGER_NAMED;
  enum FieldNumbers {
    kTriggerTypeFieldNumber = 1,
    kHistogramRuleFieldNumber = 2,
    kNamedRuleFieldNumber = 3,
    kNameHashFieldNumber = 4,
  };

  BackgroundTracingMetadata_TriggerRule();
  ~BackgroundTracingMetadata_TriggerRule() override;
  BackgroundTracingMetadata_TriggerRule(BackgroundTracingMetadata_TriggerRule&&) noexcept;
  BackgroundTracingMetadata_TriggerRule& operator=(BackgroundTracingMetadata_TriggerRule&&);
  BackgroundTracingMetadata_TriggerRule(const BackgroundTracingMetadata_TriggerRule&);
  BackgroundTracingMetadata_TriggerRule& operator=(const BackgroundTracingMetadata_TriggerRule&);
  bool operator==(const BackgroundTracingMetadata_TriggerRule&) const;
  bool operator!=(const BackgroundTracingMetadata_TriggerRule& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_trigger_type() const { return _has_field_[1]; }
  BackgroundTracingMetadata_TriggerRule_TriggerType trigger_type() const { return trigger_type_; }
  void set_trigger_type(BackgroundTracingMetadata_TriggerRule_TriggerType value) { trigger_type_ = value; _has_field_.set(1); }

  bool has_histogram_rule() const { return _has_field_[2]; }
  const BackgroundTracingMetadata_TriggerRule_HistogramRule& histogram_rule() const { return *histogram_rule_; }
  BackgroundTracingMetadata_TriggerRule_HistogramRule* mutable_histogram_rule() { _has_field_.set(2); return histogram_rule_.get(); }

  bool has_named_rule() const { return _has_field_[3]; }
  const BackgroundTracingMetadata_TriggerRule_NamedRule& named_rule() const { return *named_rule_; }
  BackgroundTracingMetadata_TriggerRule_NamedRule* mutable_named_rule() { _has_field_.set(3); return named_rule_.get(); }

  bool has_name_hash() const { return _has_field_[4]; }
  uint32_t name_hash() const { return name_hash_; }
  void set_name_hash(uint32_t value) { name_hash_ = value; _has_field_.set(4); }

 private:
  BackgroundTracingMetadata_TriggerRule_TriggerType trigger_type_{};
  ::protozero::CopyablePtr<BackgroundTracingMetadata_TriggerRule_HistogramRule> histogram_rule_;
  ::protozero::CopyablePtr<BackgroundTracingMetadata_TriggerRule_NamedRule> named_rule_;
  uint32_t name_hash_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT BackgroundTracingMetadata_TriggerRule_NamedRule : public ::protozero::CppMessageObj {
 public:
  using EventType = BackgroundTracingMetadata_TriggerRule_NamedRule_EventType;
  static constexpr auto UNSPECIFIED = BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_UNSPECIFIED;
  static constexpr auto SESSION_RESTORE = BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_SESSION_RESTORE;
  static constexpr auto NAVIGATION = BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_NAVIGATION;
  static constexpr auto STARTUP = BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_STARTUP;
  static constexpr auto REACHED_CODE = BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_REACHED_CODE;
  static constexpr auto CONTENT_TRIGGER = BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_CONTENT_TRIGGER;
  static constexpr auto TEST_RULE = BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_TEST_RULE;
  static constexpr auto EventType_MIN = BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_UNSPECIFIED;
  static constexpr auto EventType_MAX = BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_TEST_RULE;
  enum FieldNumbers {
    kEventTypeFieldNumber = 1,
    kContentTriggerNameHashFieldNumber = 2,
  };

  BackgroundTracingMetadata_TriggerRule_NamedRule();
  ~BackgroundTracingMetadata_TriggerRule_NamedRule() override;
  BackgroundTracingMetadata_TriggerRule_NamedRule(BackgroundTracingMetadata_TriggerRule_NamedRule&&) noexcept;
  BackgroundTracingMetadata_TriggerRule_NamedRule& operator=(BackgroundTracingMetadata_TriggerRule_NamedRule&&);
  BackgroundTracingMetadata_TriggerRule_NamedRule(const BackgroundTracingMetadata_TriggerRule_NamedRule&);
  BackgroundTracingMetadata_TriggerRule_NamedRule& operator=(const BackgroundTracingMetadata_TriggerRule_NamedRule&);
  bool operator==(const BackgroundTracingMetadata_TriggerRule_NamedRule&) const;
  bool operator!=(const BackgroundTracingMetadata_TriggerRule_NamedRule& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_event_type() const { return _has_field_[1]; }
  BackgroundTracingMetadata_TriggerRule_NamedRule_EventType event_type() const { return event_type_; }
  void set_event_type(BackgroundTracingMetadata_TriggerRule_NamedRule_EventType value) { event_type_ = value; _has_field_.set(1); }

  bool has_content_trigger_name_hash() const { return _has_field_[2]; }
  uint64_t content_trigger_name_hash() const { return content_trigger_name_hash_; }
  void set_content_trigger_name_hash(uint64_t value) { content_trigger_name_hash_ = value; _has_field_.set(2); }

 private:
  BackgroundTracingMetadata_TriggerRule_NamedRule_EventType event_type_{};
  uint64_t content_trigger_name_hash_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT BackgroundTracingMetadata_TriggerRule_HistogramRule : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kHistogramNameHashFieldNumber = 1,
    kHistogramMinTriggerFieldNumber = 2,
    kHistogramMaxTriggerFieldNumber = 3,
  };

  BackgroundTracingMetadata_TriggerRule_HistogramRule();
  ~BackgroundTracingMetadata_TriggerRule_HistogramRule() override;
  BackgroundTracingMetadata_TriggerRule_HistogramRule(BackgroundTracingMetadata_TriggerRule_HistogramRule&&) noexcept;
  BackgroundTracingMetadata_TriggerRule_HistogramRule& operator=(BackgroundTracingMetadata_TriggerRule_HistogramRule&&);
  BackgroundTracingMetadata_TriggerRule_HistogramRule(const BackgroundTracingMetadata_TriggerRule_HistogramRule&);
  BackgroundTracingMetadata_TriggerRule_HistogramRule& operator=(const BackgroundTracingMetadata_TriggerRule_HistogramRule&);
  bool operator==(const BackgroundTracingMetadata_TriggerRule_HistogramRule&) const;
  bool operator!=(const BackgroundTracingMetadata_TriggerRule_HistogramRule& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_histogram_name_hash() const { return _has_field_[1]; }
  uint64_t histogram_name_hash() const { return histogram_name_hash_; }
  void set_histogram_name_hash(uint64_t value) { histogram_name_hash_ = value; _has_field_.set(1); }

  bool has_histogram_min_trigger() const { return _has_field_[2]; }
  int64_t histogram_min_trigger() const { return histogram_min_trigger_; }
  void set_histogram_min_trigger(int64_t value) { histogram_min_trigger_ = value; _has_field_.set(2); }

  bool has_histogram_max_trigger() const { return _has_field_[3]; }
  int64_t histogram_max_trigger() const { return histogram_max_trigger_; }
  void set_histogram_max_trigger(int64_t value) { histogram_max_trigger_ = value; _has_field_.set(3); }

 private:
  uint64_t histogram_name_hash_{};
  int64_t histogram_min_trigger_{};
  int64_t histogram_max_trigger_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT ChromeMetadataPacket : public ::protozero::CppMessageObj {
 public:
  using FinchHash = ChromeMetadataPacket_FinchHash;
  enum FieldNumbers {
    kBackgroundTracingMetadataFieldNumber = 1,
    kChromeVersionCodeFieldNumber = 2,
    kEnabledCategoriesFieldNumber = 3,
    kFieldTrialHashesFieldNumber = 4,
  };

  ChromeMetadataPacket();
  ~ChromeMetadataPacket() override;
  ChromeMetadataPacket(ChromeMetadataPacket&&) noexcept;
  ChromeMetadataPacket& operator=(ChromeMetadataPacket&&);
  ChromeMetadataPacket(const ChromeMetadataPacket&);
  ChromeMetadataPacket& operator=(const ChromeMetadataPacket&);
  bool operator==(const ChromeMetadataPacket&) const;
  bool operator!=(const ChromeMetadataPacket& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_background_tracing_metadata() const { return _has_field_[1]; }
  const BackgroundTracingMetadata& background_tracing_metadata() const { return *background_tracing_metadata_; }
  BackgroundTracingMetadata* mutable_background_tracing_metadata() { _has_field_.set(1); return background_tracing_metadata_.get(); }

  bool has_chrome_version_code() const { return _has_field_[2]; }
  int32_t chrome_version_code() const { return chrome_version_code_; }
  void set_chrome_version_code(int32_t value) { chrome_version_code_ = value; _has_field_.set(2); }

  bool has_enabled_categories() const { return _has_field_[3]; }
  const std::string& enabled_categories() const { return enabled_categories_; }
  void set_enabled_categories(const std::string& value) { enabled_categories_ = value; _has_field_.set(3); }

  const std::vector<ChromeMetadataPacket_FinchHash>& field_trial_hashes() const { return field_trial_hashes_; }
  std::vector<ChromeMetadataPacket_FinchHash>* mutable_field_trial_hashes() { return &field_trial_hashes_; }
  int field_trial_hashes_size() const;
  void clear_field_trial_hashes();
  ChromeMetadataPacket_FinchHash* add_field_trial_hashes();

 private:
  ::protozero::CopyablePtr<BackgroundTracingMetadata> background_tracing_metadata_;
  int32_t chrome_version_code_{};
  std::string enabled_categories_{};
  std::vector<ChromeMetadataPacket_FinchHash> field_trial_hashes_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT ChromeMetadataPacket_FinchHash : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kNameFieldNumber = 1,
    kGroupFieldNumber = 2,
  };

  ChromeMetadataPacket_FinchHash();
  ~ChromeMetadataPacket_FinchHash() override;
  ChromeMetadataPacket_FinchHash(ChromeMetadataPacket_FinchHash&&) noexcept;
  ChromeMetadataPacket_FinchHash& operator=(ChromeMetadataPacket_FinchHash&&);
  ChromeMetadataPacket_FinchHash(const ChromeMetadataPacket_FinchHash&);
  ChromeMetadataPacket_FinchHash& operator=(const ChromeMetadataPacket_FinchHash&);
  bool operator==(const ChromeMetadataPacket_FinchHash&) const;
  bool operator!=(const ChromeMetadataPacket_FinchHash& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_name() const { return _has_field_[1]; }
  uint32_t name() const { return name_; }
  void set_name(uint32_t value) { name_ = value; _has_field_.set(1); }

  bool has_group() const { return _has_field_[2]; }
  uint32_t group() const { return group_; }
  void set_group(uint32_t value) { group_ = value; _has_field_.set(2); }

 private:
  uint32_t name_{};
  uint32_t group_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_CHROME_CHROME_METADATA_PROTO_CPP_H_
