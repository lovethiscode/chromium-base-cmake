// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/trace/chrome/v8.proto

#include "protos/perfetto/trace/chrome/v8.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace perfetto {
namespace protos {
PROTOBUF_CONSTEXPR V8String::V8String(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.encoded_string_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct V8StringDefaultTypeInternal {
  PROTOBUF_CONSTEXPR V8StringDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~V8StringDefaultTypeInternal() {}
  union {
    V8String _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 V8StringDefaultTypeInternal _V8String_default_instance_;
PROTOBUF_CONSTEXPR InternedV8String::InternedV8String(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.iid_)*/uint64_t{0u}
  , /*decltype(_impl_.encoded_string_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct InternedV8StringDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InternedV8StringDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InternedV8StringDefaultTypeInternal() {}
  union {
    InternedV8String _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InternedV8StringDefaultTypeInternal _InternedV8String_default_instance_;
PROTOBUF_CONSTEXPR InternedV8JsScript::InternedV8JsScript(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/nullptr
  , /*decltype(_impl_.source_)*/nullptr
  , /*decltype(_impl_.iid_)*/uint64_t{0u}
  , /*decltype(_impl_.script_id_)*/0
  , /*decltype(_impl_.type_)*/0} {}
struct InternedV8JsScriptDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InternedV8JsScriptDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InternedV8JsScriptDefaultTypeInternal() {}
  union {
    InternedV8JsScript _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InternedV8JsScriptDefaultTypeInternal _InternedV8JsScript_default_instance_;
PROTOBUF_CONSTEXPR InternedV8WasmScript::InternedV8WasmScript(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.iid_)*/uint64_t{0u}
  , /*decltype(_impl_.script_id_)*/0} {}
struct InternedV8WasmScriptDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InternedV8WasmScriptDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InternedV8WasmScriptDefaultTypeInternal() {}
  union {
    InternedV8WasmScript _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InternedV8WasmScriptDefaultTypeInternal _InternedV8WasmScript_default_instance_;
PROTOBUF_CONSTEXPR InternedV8JsFunction::InternedV8JsFunction(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.iid_)*/uint64_t{0u}
  , /*decltype(_impl_.v8_js_function_name_iid_)*/uint64_t{0u}
  , /*decltype(_impl_.v8_js_script_iid_)*/uint64_t{0u}
  , /*decltype(_impl_.is_toplevel_)*/false
  , /*decltype(_impl_.kind_)*/0
  , /*decltype(_impl_.byte_offset_)*/0u} {}
struct InternedV8JsFunctionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InternedV8JsFunctionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InternedV8JsFunctionDefaultTypeInternal() {}
  union {
    InternedV8JsFunction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InternedV8JsFunctionDefaultTypeInternal _InternedV8JsFunction_default_instance_;
PROTOBUF_CONSTEXPR InternedV8Isolate_CodeRange::InternedV8Isolate_CodeRange(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.base_address_)*/uint64_t{0u}
  , /*decltype(_impl_.size_)*/uint64_t{0u}
  , /*decltype(_impl_.embedded_blob_code_copy_start_address_)*/uint64_t{0u}
  , /*decltype(_impl_.is_process_wide_)*/false} {}
struct InternedV8Isolate_CodeRangeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InternedV8Isolate_CodeRangeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InternedV8Isolate_CodeRangeDefaultTypeInternal() {}
  union {
    InternedV8Isolate_CodeRange _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InternedV8Isolate_CodeRangeDefaultTypeInternal _InternedV8Isolate_CodeRange_default_instance_;
PROTOBUF_CONSTEXPR InternedV8Isolate::InternedV8Isolate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.code_range_)*/nullptr
  , /*decltype(_impl_.iid_)*/uint64_t{0u}
  , /*decltype(_impl_.pid_)*/0u
  , /*decltype(_impl_.isolate_id_)*/0
  , /*decltype(_impl_.embedded_blob_code_start_address_)*/uint64_t{0u}
  , /*decltype(_impl_.embedded_blob_code_size_)*/uint64_t{0u}} {}
struct InternedV8IsolateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InternedV8IsolateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InternedV8IsolateDefaultTypeInternal() {}
  union {
    InternedV8Isolate _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InternedV8IsolateDefaultTypeInternal _InternedV8Isolate_default_instance_;
PROTOBUF_CONSTEXPR V8JsCode::V8JsCode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.v8_isolate_iid_)*/uint64_t{0u}
  , /*decltype(_impl_.v8_js_function_iid_)*/uint64_t{0u}
  , /*decltype(_impl_.tid_)*/0u
  , /*decltype(_impl_.tier_)*/0
  , /*decltype(_impl_.instruction_start_)*/uint64_t{0u}
  , /*decltype(_impl_.instruction_size_bytes_)*/uint64_t{0u}
  , /*decltype(_impl_.instructions_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct V8JsCodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR V8JsCodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~V8JsCodeDefaultTypeInternal() {}
  union {
    V8JsCode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 V8JsCodeDefaultTypeInternal _V8JsCode_default_instance_;
PROTOBUF_CONSTEXPR V8InternalCode::V8InternalCode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.machine_code_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.v8_isolate_iid_)*/uint64_t{0u}
  , /*decltype(_impl_.tid_)*/0u
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.instruction_start_)*/uint64_t{0u}
  , /*decltype(_impl_.instruction_size_bytes_)*/uint64_t{0u}
  , /*decltype(_impl_.builtin_id_)*/0} {}
struct V8InternalCodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR V8InternalCodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~V8InternalCodeDefaultTypeInternal() {}
  union {
    V8InternalCode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 V8InternalCodeDefaultTypeInternal _V8InternalCode_default_instance_;
PROTOBUF_CONSTEXPR V8WasmCode::V8WasmCode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.function_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.machine_code_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.v8_isolate_iid_)*/uint64_t{0u}
  , /*decltype(_impl_.v8_wasm_script_iid_)*/uint64_t{0u}
  , /*decltype(_impl_.tid_)*/0u
  , /*decltype(_impl_.tier_)*/0
  , /*decltype(_impl_.instruction_start_)*/uint64_t{0u}
  , /*decltype(_impl_.instruction_size_bytes_)*/uint64_t{0u}
  , /*decltype(_impl_.code_offset_in_module_)*/0} {}
struct V8WasmCodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR V8WasmCodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~V8WasmCodeDefaultTypeInternal() {}
  union {
    V8WasmCode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 V8WasmCodeDefaultTypeInternal _V8WasmCode_default_instance_;
PROTOBUF_CONSTEXPR V8RegExpCode::V8RegExpCode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.machine_code_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pattern_)*/nullptr
  , /*decltype(_impl_.v8_isolate_iid_)*/uint64_t{0u}
  , /*decltype(_impl_.instruction_start_)*/uint64_t{0u}
  , /*decltype(_impl_.instruction_size_bytes_)*/uint64_t{0u}
  , /*decltype(_impl_.tid_)*/0u} {}
struct V8RegExpCodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR V8RegExpCodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~V8RegExpCodeDefaultTypeInternal() {}
  union {
    V8RegExpCode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 V8RegExpCodeDefaultTypeInternal _V8RegExpCode_default_instance_;
PROTOBUF_CONSTEXPR V8CodeMove::V8CodeMove(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.isolate_iid_)*/uint64_t{0u}
  , /*decltype(_impl_.from_instruction_start_address_)*/uint64_t{0u}
  , /*decltype(_impl_.to_instruction_start_address_)*/uint64_t{0u}
  , /*decltype(_impl_.instruction_size_bytes_)*/uint64_t{0u}
  , /*decltype(_impl_.tid_)*/0u
  , /*decltype(_impl_.to_instructions_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct V8CodeMoveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR V8CodeMoveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~V8CodeMoveDefaultTypeInternal() {}
  union {
    V8CodeMove _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 V8CodeMoveDefaultTypeInternal _V8CodeMove_default_instance_;
PROTOBUF_CONSTEXPR V8CodeDefaults::V8CodeDefaults(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tid_)*/0u} {}
struct V8CodeDefaultsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR V8CodeDefaultsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~V8CodeDefaultsDefaultTypeInternal() {}
  union {
    V8CodeDefaults _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 V8CodeDefaultsDefaultTypeInternal _V8CodeDefaults_default_instance_;
}  // namespace protos
}  // namespace perfetto
namespace perfetto {
namespace protos {
bool InternedV8JsScript_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> InternedV8JsScript_Type_strings[7] = {};

static const char InternedV8JsScript_Type_names[] =
  "TYPE_EVAL"
  "TYPE_EXTENSION"
  "TYPE_INSPECTOR"
  "TYPE_MODULE"
  "TYPE_NATIVE"
  "TYPE_NORMAL"
  "TYPE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry InternedV8JsScript_Type_entries[] = {
  { {InternedV8JsScript_Type_names + 0, 9}, 2 },
  { {InternedV8JsScript_Type_names + 9, 14}, 5 },
  { {InternedV8JsScript_Type_names + 23, 14}, 6 },
  { {InternedV8JsScript_Type_names + 37, 11}, 3 },
  { {InternedV8JsScript_Type_names + 48, 11}, 4 },
  { {InternedV8JsScript_Type_names + 59, 11}, 1 },
  { {InternedV8JsScript_Type_names + 70, 12}, 0 },
};

static const int InternedV8JsScript_Type_entries_by_number[] = {
  6, // 0 -> TYPE_UNKNOWN
  5, // 1 -> TYPE_NORMAL
  0, // 2 -> TYPE_EVAL
  3, // 3 -> TYPE_MODULE
  4, // 4 -> TYPE_NATIVE
  1, // 5 -> TYPE_EXTENSION
  2, // 6 -> TYPE_INSPECTOR
};

const std::string& InternedV8JsScript_Type_Name(
    InternedV8JsScript_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          InternedV8JsScript_Type_entries,
          InternedV8JsScript_Type_entries_by_number,
          7, InternedV8JsScript_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      InternedV8JsScript_Type_entries,
      InternedV8JsScript_Type_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     InternedV8JsScript_Type_strings[idx].get();
}
bool InternedV8JsScript_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InternedV8JsScript_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      InternedV8JsScript_Type_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<InternedV8JsScript_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr InternedV8JsScript_Type InternedV8JsScript::TYPE_UNKNOWN;
constexpr InternedV8JsScript_Type InternedV8JsScript::TYPE_NORMAL;
constexpr InternedV8JsScript_Type InternedV8JsScript::TYPE_EVAL;
constexpr InternedV8JsScript_Type InternedV8JsScript::TYPE_MODULE;
constexpr InternedV8JsScript_Type InternedV8JsScript::TYPE_NATIVE;
constexpr InternedV8JsScript_Type InternedV8JsScript::TYPE_EXTENSION;
constexpr InternedV8JsScript_Type InternedV8JsScript::TYPE_INSPECTOR;
constexpr InternedV8JsScript_Type InternedV8JsScript::Type_MIN;
constexpr InternedV8JsScript_Type InternedV8JsScript::Type_MAX;
constexpr int InternedV8JsScript::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool InternedV8JsFunction_Kind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> InternedV8JsFunction_Kind_strings[28] = {};

static const char InternedV8JsFunction_Kind_names[] =
  "KIND_ARROW_FUNCTION"
  "KIND_ASYNC_ARROW_FUNCTION"
  "KIND_ASYNC_CONCISE_GENERATOR_METHOD"
  "KIND_ASYNC_CONCISE_METHOD"
  "KIND_ASYNC_FUNCTION"
  "KIND_ASYNC_GENERATOR_FUNCTION"
  "KIND_ASYNC_MODULE"
  "KIND_BASE_CONSTRUCTOR"
  "KIND_CLASS_MEMBERS_INITIALIZER_FUNCTION"
  "KIND_CLASS_STATIC_INITIALIZER_FUNCTION"
  "KIND_CONCISE_GENERATOR_METHOD"
  "KIND_CONCISE_METHOD"
  "KIND_DEFAULT_BASE_CONSTRUCTOR"
  "KIND_DEFAULT_DERIVED_CONSTRUCTOR"
  "KIND_DERIVED_CONSTRUCTOR"
  "KIND_GENERATOR_FUNCTION"
  "KIND_GETTER_FUNCTION"
  "KIND_INVALID"
  "KIND_MODULE"
  "KIND_NORMAL_FUNCTION"
  "KIND_SETTER_FUNCTION"
  "KIND_STATIC_ASYNC_CONCISE_GENERATOR_METHOD"
  "KIND_STATIC_ASYNC_CONCISE_METHOD"
  "KIND_STATIC_CONCISE_GENERATOR_METHOD"
  "KIND_STATIC_CONCISE_METHOD"
  "KIND_STATIC_GETTER_FUNCTION"
  "KIND_STATIC_SETTER_FUNCTION"
  "KIND_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry InternedV8JsFunction_Kind_entries[] = {
  { {InternedV8JsFunction_Kind_names + 0, 19}, 12 },
  { {InternedV8JsFunction_Kind_names + 19, 25}, 13 },
  { {InternedV8JsFunction_Kind_names + 44, 35}, 17 },
  { {InternedV8JsFunction_Kind_names + 79, 25}, 15 },
  { {InternedV8JsFunction_Kind_names + 104, 19}, 14 },
  { {InternedV8JsFunction_Kind_names + 123, 29}, 19 },
  { {InternedV8JsFunction_Kind_names + 152, 17}, 3 },
  { {InternedV8JsFunction_Kind_names + 169, 21}, 4 },
  { {InternedV8JsFunction_Kind_names + 190, 39}, 25 },
  { {InternedV8JsFunction_Kind_names + 229, 38}, 26 },
  { {InternedV8JsFunction_Kind_names + 267, 29}, 21 },
  { {InternedV8JsFunction_Kind_names + 296, 19}, 23 },
  { {InternedV8JsFunction_Kind_names + 315, 29}, 5 },
  { {InternedV8JsFunction_Kind_names + 344, 32}, 6 },
  { {InternedV8JsFunction_Kind_names + 376, 24}, 7 },
  { {InternedV8JsFunction_Kind_names + 400, 23}, 20 },
  { {InternedV8JsFunction_Kind_names + 423, 20}, 8 },
  { {InternedV8JsFunction_Kind_names + 443, 12}, 27 },
  { {InternedV8JsFunction_Kind_names + 455, 11}, 2 },
  { {InternedV8JsFunction_Kind_names + 466, 20}, 1 },
  { {InternedV8JsFunction_Kind_names + 486, 20}, 10 },
  { {InternedV8JsFunction_Kind_names + 506, 42}, 18 },
  { {InternedV8JsFunction_Kind_names + 548, 32}, 16 },
  { {InternedV8JsFunction_Kind_names + 580, 36}, 22 },
  { {InternedV8JsFunction_Kind_names + 616, 26}, 24 },
  { {InternedV8JsFunction_Kind_names + 642, 27}, 9 },
  { {InternedV8JsFunction_Kind_names + 669, 27}, 11 },
  { {InternedV8JsFunction_Kind_names + 696, 12}, 0 },
};

static const int InternedV8JsFunction_Kind_entries_by_number[] = {
  27, // 0 -> KIND_UNKNOWN
  19, // 1 -> KIND_NORMAL_FUNCTION
  18, // 2 -> KIND_MODULE
  6, // 3 -> KIND_ASYNC_MODULE
  7, // 4 -> KIND_BASE_CONSTRUCTOR
  12, // 5 -> KIND_DEFAULT_BASE_CONSTRUCTOR
  13, // 6 -> KIND_DEFAULT_DERIVED_CONSTRUCTOR
  14, // 7 -> KIND_DERIVED_CONSTRUCTOR
  16, // 8 -> KIND_GETTER_FUNCTION
  25, // 9 -> KIND_STATIC_GETTER_FUNCTION
  20, // 10 -> KIND_SETTER_FUNCTION
  26, // 11 -> KIND_STATIC_SETTER_FUNCTION
  0, // 12 -> KIND_ARROW_FUNCTION
  1, // 13 -> KIND_ASYNC_ARROW_FUNCTION
  4, // 14 -> KIND_ASYNC_FUNCTION
  3, // 15 -> KIND_ASYNC_CONCISE_METHOD
  22, // 16 -> KIND_STATIC_ASYNC_CONCISE_METHOD
  2, // 17 -> KIND_ASYNC_CONCISE_GENERATOR_METHOD
  21, // 18 -> KIND_STATIC_ASYNC_CONCISE_GENERATOR_METHOD
  5, // 19 -> KIND_ASYNC_GENERATOR_FUNCTION
  15, // 20 -> KIND_GENERATOR_FUNCTION
  10, // 21 -> KIND_CONCISE_GENERATOR_METHOD
  23, // 22 -> KIND_STATIC_CONCISE_GENERATOR_METHOD
  11, // 23 -> KIND_CONCISE_METHOD
  24, // 24 -> KIND_STATIC_CONCISE_METHOD
  8, // 25 -> KIND_CLASS_MEMBERS_INITIALIZER_FUNCTION
  9, // 26 -> KIND_CLASS_STATIC_INITIALIZER_FUNCTION
  17, // 27 -> KIND_INVALID
};

const std::string& InternedV8JsFunction_Kind_Name(
    InternedV8JsFunction_Kind value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          InternedV8JsFunction_Kind_entries,
          InternedV8JsFunction_Kind_entries_by_number,
          28, InternedV8JsFunction_Kind_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      InternedV8JsFunction_Kind_entries,
      InternedV8JsFunction_Kind_entries_by_number,
      28, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     InternedV8JsFunction_Kind_strings[idx].get();
}
bool InternedV8JsFunction_Kind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InternedV8JsFunction_Kind* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      InternedV8JsFunction_Kind_entries, 28, name, &int_value);
  if (success) {
    *value = static_cast<InternedV8JsFunction_Kind>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr InternedV8JsFunction_Kind InternedV8JsFunction::KIND_UNKNOWN;
constexpr InternedV8JsFunction_Kind InternedV8JsFunction::KIND_NORMAL_FUNCTION;
constexpr InternedV8JsFunction_Kind InternedV8JsFunction::KIND_MODULE;
constexpr InternedV8JsFunction_Kind InternedV8JsFunction::KIND_ASYNC_MODULE;
constexpr InternedV8JsFunction_Kind InternedV8JsFunction::KIND_BASE_CONSTRUCTOR;
constexpr InternedV8JsFunction_Kind InternedV8JsFunction::KIND_DEFAULT_BASE_CONSTRUCTOR;
constexpr InternedV8JsFunction_Kind InternedV8JsFunction::KIND_DEFAULT_DERIVED_CONSTRUCTOR;
constexpr InternedV8JsFunction_Kind InternedV8JsFunction::KIND_DERIVED_CONSTRUCTOR;
constexpr InternedV8JsFunction_Kind InternedV8JsFunction::KIND_GETTER_FUNCTION;
constexpr InternedV8JsFunction_Kind InternedV8JsFunction::KIND_STATIC_GETTER_FUNCTION;
constexpr InternedV8JsFunction_Kind InternedV8JsFunction::KIND_SETTER_FUNCTION;
constexpr InternedV8JsFunction_Kind InternedV8JsFunction::KIND_STATIC_SETTER_FUNCTION;
constexpr InternedV8JsFunction_Kind InternedV8JsFunction::KIND_ARROW_FUNCTION;
constexpr InternedV8JsFunction_Kind InternedV8JsFunction::KIND_ASYNC_ARROW_FUNCTION;
constexpr InternedV8JsFunction_Kind InternedV8JsFunction::KIND_ASYNC_FUNCTION;
constexpr InternedV8JsFunction_Kind InternedV8JsFunction::KIND_ASYNC_CONCISE_METHOD;
constexpr InternedV8JsFunction_Kind InternedV8JsFunction::KIND_STATIC_ASYNC_CONCISE_METHOD;
constexpr InternedV8JsFunction_Kind InternedV8JsFunction::KIND_ASYNC_CONCISE_GENERATOR_METHOD;
constexpr InternedV8JsFunction_Kind InternedV8JsFunction::KIND_STATIC_ASYNC_CONCISE_GENERATOR_METHOD;
constexpr InternedV8JsFunction_Kind InternedV8JsFunction::KIND_ASYNC_GENERATOR_FUNCTION;
constexpr InternedV8JsFunction_Kind InternedV8JsFunction::KIND_GENERATOR_FUNCTION;
constexpr InternedV8JsFunction_Kind InternedV8JsFunction::KIND_CONCISE_GENERATOR_METHOD;
constexpr InternedV8JsFunction_Kind InternedV8JsFunction::KIND_STATIC_CONCISE_GENERATOR_METHOD;
constexpr InternedV8JsFunction_Kind InternedV8JsFunction::KIND_CONCISE_METHOD;
constexpr InternedV8JsFunction_Kind InternedV8JsFunction::KIND_STATIC_CONCISE_METHOD;
constexpr InternedV8JsFunction_Kind InternedV8JsFunction::KIND_CLASS_MEMBERS_INITIALIZER_FUNCTION;
constexpr InternedV8JsFunction_Kind InternedV8JsFunction::KIND_CLASS_STATIC_INITIALIZER_FUNCTION;
constexpr InternedV8JsFunction_Kind InternedV8JsFunction::KIND_INVALID;
constexpr InternedV8JsFunction_Kind InternedV8JsFunction::Kind_MIN;
constexpr InternedV8JsFunction_Kind InternedV8JsFunction::Kind_MAX;
constexpr int InternedV8JsFunction::Kind_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool V8JsCode_Tier_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> V8JsCode_Tier_strings[6] = {};

static const char V8JsCode_Tier_names[] =
  "TIER_IGNITION"
  "TIER_MAGLEV"
  "TIER_SPARKPLUG"
  "TIER_TURBOFAN"
  "TIER_TURBOSHAFT"
  "TIER_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry V8JsCode_Tier_entries[] = {
  { {V8JsCode_Tier_names + 0, 13}, 1 },
  { {V8JsCode_Tier_names + 13, 11}, 3 },
  { {V8JsCode_Tier_names + 24, 14}, 2 },
  { {V8JsCode_Tier_names + 38, 13}, 5 },
  { {V8JsCode_Tier_names + 51, 15}, 4 },
  { {V8JsCode_Tier_names + 66, 12}, 0 },
};

static const int V8JsCode_Tier_entries_by_number[] = {
  5, // 0 -> TIER_UNKNOWN
  0, // 1 -> TIER_IGNITION
  2, // 2 -> TIER_SPARKPLUG
  1, // 3 -> TIER_MAGLEV
  4, // 4 -> TIER_TURBOSHAFT
  3, // 5 -> TIER_TURBOFAN
};

const std::string& V8JsCode_Tier_Name(
    V8JsCode_Tier value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          V8JsCode_Tier_entries,
          V8JsCode_Tier_entries_by_number,
          6, V8JsCode_Tier_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      V8JsCode_Tier_entries,
      V8JsCode_Tier_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     V8JsCode_Tier_strings[idx].get();
}
bool V8JsCode_Tier_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, V8JsCode_Tier* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      V8JsCode_Tier_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<V8JsCode_Tier>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr V8JsCode_Tier V8JsCode::TIER_UNKNOWN;
constexpr V8JsCode_Tier V8JsCode::TIER_IGNITION;
constexpr V8JsCode_Tier V8JsCode::TIER_SPARKPLUG;
constexpr V8JsCode_Tier V8JsCode::TIER_MAGLEV;
constexpr V8JsCode_Tier V8JsCode::TIER_TURBOSHAFT;
constexpr V8JsCode_Tier V8JsCode::TIER_TURBOFAN;
constexpr V8JsCode_Tier V8JsCode::Tier_MIN;
constexpr V8JsCode_Tier V8JsCode::Tier_MAX;
constexpr int V8JsCode::Tier_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool V8InternalCode_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> V8InternalCode_Type_strings[10] = {};

static const char V8InternalCode_Type_names[] =
  "TYPE_BUILTIN"
  "TYPE_BYTECODE_HANDLER"
  "TYPE_C_WASM_ENTRY"
  "TYPE_FOR_TESTING"
  "TYPE_JS_TO_JS_FUNCTION"
  "TYPE_JS_TO_WASM_FUNCTION"
  "TYPE_UNKNOWN"
  "TYPE_WASM_FUNCTION"
  "TYPE_WASM_TO_CAPI_FUNCTION"
  "TYPE_WASM_TO_JS_FUNCTION";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry V8InternalCode_Type_entries[] = {
  { {V8InternalCode_Type_names + 0, 12}, 3 },
  { {V8InternalCode_Type_names + 12, 21}, 1 },
  { {V8InternalCode_Type_names + 33, 17}, 9 },
  { {V8InternalCode_Type_names + 50, 16}, 2 },
  { {V8InternalCode_Type_names + 66, 22}, 8 },
  { {V8InternalCode_Type_names + 88, 24}, 7 },
  { {V8InternalCode_Type_names + 112, 12}, 0 },
  { {V8InternalCode_Type_names + 124, 18}, 4 },
  { {V8InternalCode_Type_names + 142, 26}, 5 },
  { {V8InternalCode_Type_names + 168, 24}, 6 },
};

static const int V8InternalCode_Type_entries_by_number[] = {
  6, // 0 -> TYPE_UNKNOWN
  1, // 1 -> TYPE_BYTECODE_HANDLER
  3, // 2 -> TYPE_FOR_TESTING
  0, // 3 -> TYPE_BUILTIN
  7, // 4 -> TYPE_WASM_FUNCTION
  8, // 5 -> TYPE_WASM_TO_CAPI_FUNCTION
  9, // 6 -> TYPE_WASM_TO_JS_FUNCTION
  5, // 7 -> TYPE_JS_TO_WASM_FUNCTION
  4, // 8 -> TYPE_JS_TO_JS_FUNCTION
  2, // 9 -> TYPE_C_WASM_ENTRY
};

const std::string& V8InternalCode_Type_Name(
    V8InternalCode_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          V8InternalCode_Type_entries,
          V8InternalCode_Type_entries_by_number,
          10, V8InternalCode_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      V8InternalCode_Type_entries,
      V8InternalCode_Type_entries_by_number,
      10, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     V8InternalCode_Type_strings[idx].get();
}
bool V8InternalCode_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, V8InternalCode_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      V8InternalCode_Type_entries, 10, name, &int_value);
  if (success) {
    *value = static_cast<V8InternalCode_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr V8InternalCode_Type V8InternalCode::TYPE_UNKNOWN;
constexpr V8InternalCode_Type V8InternalCode::TYPE_BYTECODE_HANDLER;
constexpr V8InternalCode_Type V8InternalCode::TYPE_FOR_TESTING;
constexpr V8InternalCode_Type V8InternalCode::TYPE_BUILTIN;
constexpr V8InternalCode_Type V8InternalCode::TYPE_WASM_FUNCTION;
constexpr V8InternalCode_Type V8InternalCode::TYPE_WASM_TO_CAPI_FUNCTION;
constexpr V8InternalCode_Type V8InternalCode::TYPE_WASM_TO_JS_FUNCTION;
constexpr V8InternalCode_Type V8InternalCode::TYPE_JS_TO_WASM_FUNCTION;
constexpr V8InternalCode_Type V8InternalCode::TYPE_JS_TO_JS_FUNCTION;
constexpr V8InternalCode_Type V8InternalCode::TYPE_C_WASM_ENTRY;
constexpr V8InternalCode_Type V8InternalCode::Type_MIN;
constexpr V8InternalCode_Type V8InternalCode::Type_MAX;
constexpr int V8InternalCode::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool V8WasmCode_Tier_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> V8WasmCode_Tier_strings[3] = {};

static const char V8WasmCode_Tier_names[] =
  "TIER_LIFTOFF"
  "TIER_TURBOFAN"
  "TIER_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry V8WasmCode_Tier_entries[] = {
  { {V8WasmCode_Tier_names + 0, 12}, 1 },
  { {V8WasmCode_Tier_names + 12, 13}, 2 },
  { {V8WasmCode_Tier_names + 25, 12}, 0 },
};

static const int V8WasmCode_Tier_entries_by_number[] = {
  2, // 0 -> TIER_UNKNOWN
  0, // 1 -> TIER_LIFTOFF
  1, // 2 -> TIER_TURBOFAN
};

const std::string& V8WasmCode_Tier_Name(
    V8WasmCode_Tier value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          V8WasmCode_Tier_entries,
          V8WasmCode_Tier_entries_by_number,
          3, V8WasmCode_Tier_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      V8WasmCode_Tier_entries,
      V8WasmCode_Tier_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     V8WasmCode_Tier_strings[idx].get();
}
bool V8WasmCode_Tier_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, V8WasmCode_Tier* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      V8WasmCode_Tier_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<V8WasmCode_Tier>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr V8WasmCode_Tier V8WasmCode::TIER_UNKNOWN;
constexpr V8WasmCode_Tier V8WasmCode::TIER_LIFTOFF;
constexpr V8WasmCode_Tier V8WasmCode::TIER_TURBOFAN;
constexpr V8WasmCode_Tier V8WasmCode::Tier_MIN;
constexpr V8WasmCode_Tier V8WasmCode::Tier_MAX;
constexpr int V8WasmCode::Tier_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class V8String::_Internal {
 public:
};

V8String::V8String(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.V8String)
}
V8String::V8String(const V8String& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  V8String* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.encoded_string_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_encoded_string();
  switch (from.encoded_string_case()) {
    case kLatin1: {
      _this->_internal_set_latin1(from._internal_latin1());
      break;
    }
    case kUtf16Le: {
      _this->_internal_set_utf16_le(from._internal_utf16_le());
      break;
    }
    case kUtf16Be: {
      _this->_internal_set_utf16_be(from._internal_utf16_be());
      break;
    }
    case ENCODED_STRING_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.V8String)
}

inline void V8String::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.encoded_string_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_encoded_string();
}

V8String::~V8String() {
  // @@protoc_insertion_point(destructor:perfetto.protos.V8String)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void V8String::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_encoded_string()) {
    clear_encoded_string();
  }
}

void V8String::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void V8String::clear_encoded_string() {
// @@protoc_insertion_point(one_of_clear_start:perfetto.protos.V8String)
  switch (encoded_string_case()) {
    case kLatin1: {
      _impl_.encoded_string_.latin1_.Destroy();
      break;
    }
    case kUtf16Le: {
      _impl_.encoded_string_.utf16_le_.Destroy();
      break;
    }
    case kUtf16Be: {
      _impl_.encoded_string_.utf16_be_.Destroy();
      break;
    }
    case ENCODED_STRING_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = ENCODED_STRING_NOT_SET;
}


void V8String::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.V8String)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_encoded_string();
  _internal_metadata_.Clear<std::string>();
}

const char* V8String::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes latin1 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_latin1();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes utf16_le = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_utf16_le();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes utf16_be = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_utf16_be();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* V8String::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.V8String)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (encoded_string_case()) {
    case kLatin1: {
      target = stream->WriteBytesMaybeAliased(
          1, this->_internal_latin1(), target);
      break;
    }
    case kUtf16Le: {
      target = stream->WriteBytesMaybeAliased(
          2, this->_internal_utf16_le(), target);
      break;
    }
    case kUtf16Be: {
      target = stream->WriteBytesMaybeAliased(
          3, this->_internal_utf16_be(), target);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.V8String)
  return target;
}

size_t V8String::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.V8String)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (encoded_string_case()) {
    // bytes latin1 = 1;
    case kLatin1: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_latin1());
      break;
    }
    // bytes utf16_le = 2;
    case kUtf16Le: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_utf16_le());
      break;
    }
    // bytes utf16_be = 3;
    case kUtf16Be: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_utf16_be());
      break;
    }
    case ENCODED_STRING_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void V8String::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const V8String*>(
      &from));
}

void V8String::MergeFrom(const V8String& from) {
  V8String* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.V8String)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.encoded_string_case()) {
    case kLatin1: {
      _this->_internal_set_latin1(from._internal_latin1());
      break;
    }
    case kUtf16Le: {
      _this->_internal_set_utf16_le(from._internal_utf16_le());
      break;
    }
    case kUtf16Be: {
      _this->_internal_set_utf16_be(from._internal_utf16_be());
      break;
    }
    case ENCODED_STRING_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void V8String::CopyFrom(const V8String& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.V8String)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool V8String::IsInitialized() const {
  return true;
}

void V8String::InternalSwap(V8String* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.encoded_string_, other->_impl_.encoded_string_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string V8String::GetTypeName() const {
  return "perfetto.protos.V8String";
}


// ===================================================================

class InternedV8String::_Internal {
 public:
  using HasBits = decltype(std::declval<InternedV8String>()._impl_._has_bits_);
  static void set_has_iid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

InternedV8String::InternedV8String(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.InternedV8String)
}
InternedV8String::InternedV8String(const InternedV8String& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  InternedV8String* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.iid_){}
    , decltype(_impl_.encoded_string_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.iid_ = from._impl_.iid_;
  clear_has_encoded_string();
  switch (from.encoded_string_case()) {
    case kLatin1: {
      _this->_internal_set_latin1(from._internal_latin1());
      break;
    }
    case kUtf16Le: {
      _this->_internal_set_utf16_le(from._internal_utf16_le());
      break;
    }
    case kUtf16Be: {
      _this->_internal_set_utf16_be(from._internal_utf16_be());
      break;
    }
    case ENCODED_STRING_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.InternedV8String)
}

inline void InternedV8String::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.iid_){uint64_t{0u}}
    , decltype(_impl_.encoded_string_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_encoded_string();
}

InternedV8String::~InternedV8String() {
  // @@protoc_insertion_point(destructor:perfetto.protos.InternedV8String)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InternedV8String::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_encoded_string()) {
    clear_encoded_string();
  }
}

void InternedV8String::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InternedV8String::clear_encoded_string() {
// @@protoc_insertion_point(one_of_clear_start:perfetto.protos.InternedV8String)
  switch (encoded_string_case()) {
    case kLatin1: {
      _impl_.encoded_string_.latin1_.Destroy();
      break;
    }
    case kUtf16Le: {
      _impl_.encoded_string_.utf16_le_.Destroy();
      break;
    }
    case kUtf16Be: {
      _impl_.encoded_string_.utf16_be_.Destroy();
      break;
    }
    case ENCODED_STRING_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = ENCODED_STRING_NOT_SET;
}


void InternedV8String::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.InternedV8String)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.iid_ = uint64_t{0u};
  clear_encoded_string();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* InternedV8String::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 iid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_iid(&has_bits);
          _impl_.iid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes latin1 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_latin1();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes utf16_le = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_utf16_le();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes utf16_be = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_utf16_be();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InternedV8String::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.InternedV8String)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 iid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_iid(), target);
  }

  switch (encoded_string_case()) {
    case kLatin1: {
      target = stream->WriteBytesMaybeAliased(
          2, this->_internal_latin1(), target);
      break;
    }
    case kUtf16Le: {
      target = stream->WriteBytesMaybeAliased(
          3, this->_internal_utf16_le(), target);
      break;
    }
    case kUtf16Be: {
      target = stream->WriteBytesMaybeAliased(
          4, this->_internal_utf16_be(), target);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.InternedV8String)
  return target;
}

size_t InternedV8String::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.InternedV8String)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 iid = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_iid());
  }

  switch (encoded_string_case()) {
    // bytes latin1 = 2;
    case kLatin1: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_latin1());
      break;
    }
    // bytes utf16_le = 3;
    case kUtf16Le: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_utf16_le());
      break;
    }
    // bytes utf16_be = 4;
    case kUtf16Be: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_utf16_be());
      break;
    }
    case ENCODED_STRING_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InternedV8String::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const InternedV8String*>(
      &from));
}

void InternedV8String::MergeFrom(const InternedV8String& from) {
  InternedV8String* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.InternedV8String)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_iid()) {
    _this->_internal_set_iid(from._internal_iid());
  }
  switch (from.encoded_string_case()) {
    case kLatin1: {
      _this->_internal_set_latin1(from._internal_latin1());
      break;
    }
    case kUtf16Le: {
      _this->_internal_set_utf16_le(from._internal_utf16_le());
      break;
    }
    case kUtf16Be: {
      _this->_internal_set_utf16_be(from._internal_utf16_be());
      break;
    }
    case ENCODED_STRING_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void InternedV8String::CopyFrom(const InternedV8String& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.InternedV8String)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InternedV8String::IsInitialized() const {
  return true;
}

void InternedV8String::InternalSwap(InternedV8String* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.iid_, other->_impl_.iid_);
  swap(_impl_.encoded_string_, other->_impl_.encoded_string_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string InternedV8String::GetTypeName() const {
  return "perfetto.protos.InternedV8String";
}


// ===================================================================

class InternedV8JsScript::_Internal {
 public:
  using HasBits = decltype(std::declval<InternedV8JsScript>()._impl_._has_bits_);
  static void set_has_iid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_script_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::perfetto::protos::V8String& name(const InternedV8JsScript* msg);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::perfetto::protos::V8String& source(const InternedV8JsScript* msg);
  static void set_has_source(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::perfetto::protos::V8String&
InternedV8JsScript::_Internal::name(const InternedV8JsScript* msg) {
  return *msg->_impl_.name_;
}
const ::perfetto::protos::V8String&
InternedV8JsScript::_Internal::source(const InternedV8JsScript* msg) {
  return *msg->_impl_.source_;
}
InternedV8JsScript::InternedV8JsScript(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.InternedV8JsScript)
}
InternedV8JsScript::InternedV8JsScript(const InternedV8JsScript& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  InternedV8JsScript* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){nullptr}
    , decltype(_impl_.source_){nullptr}
    , decltype(_impl_.iid_){}
    , decltype(_impl_.script_id_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_name()) {
    _this->_impl_.name_ = new ::perfetto::protos::V8String(*from._impl_.name_);
  }
  if (from._internal_has_source()) {
    _this->_impl_.source_ = new ::perfetto::protos::V8String(*from._impl_.source_);
  }
  ::memcpy(&_impl_.iid_, &from._impl_.iid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.iid_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.InternedV8JsScript)
}

inline void InternedV8JsScript::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){nullptr}
    , decltype(_impl_.source_){nullptr}
    , decltype(_impl_.iid_){uint64_t{0u}}
    , decltype(_impl_.script_id_){0}
    , decltype(_impl_.type_){0}
  };
}

InternedV8JsScript::~InternedV8JsScript() {
  // @@protoc_insertion_point(destructor:perfetto.protos.InternedV8JsScript)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InternedV8JsScript::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.name_;
  if (this != internal_default_instance()) delete _impl_.source_;
}

void InternedV8JsScript::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InternedV8JsScript::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.InternedV8JsScript)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.name_ != nullptr);
      _impl_.name_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.source_ != nullptr);
      _impl_.source_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.iid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.type_) -
        reinterpret_cast<char*>(&_impl_.iid_)) + sizeof(_impl_.type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* InternedV8JsScript::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 iid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_iid(&has_bits);
          _impl_.iid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 script_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_script_id(&has_bits);
          _impl_.script_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .perfetto.protos.InternedV8JsScript.Type type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::perfetto::protos::InternedV8JsScript_Type_IsValid(val))) {
            _internal_set_type(static_cast<::perfetto::protos::InternedV8JsScript_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .perfetto.protos.V8String name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_name(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .perfetto.protos.V8String source = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_source(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InternedV8JsScript::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.InternedV8JsScript)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 iid = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_iid(), target);
  }

  // optional int32 script_id = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_script_id(), target);
  }

  // optional .perfetto.protos.InternedV8JsScript.Type type = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_type(), target);
  }

  // optional .perfetto.protos.V8String name = 4;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::name(this),
        _Internal::name(this).GetCachedSize(), target, stream);
  }

  // optional .perfetto.protos.V8String source = 5;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::source(this),
        _Internal::source(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.InternedV8JsScript)
  return target;
}

size_t InternedV8JsScript::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.InternedV8JsScript)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .perfetto.protos.V8String name = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.name_);
    }

    // optional .perfetto.protos.V8String source = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.source_);
    }

    // optional uint64 iid = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_iid());
    }

    // optional int32 script_id = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_script_id());
    }

    // optional .perfetto.protos.InternedV8JsScript.Type type = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InternedV8JsScript::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const InternedV8JsScript*>(
      &from));
}

void InternedV8JsScript::MergeFrom(const InternedV8JsScript& from) {
  InternedV8JsScript* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.InternedV8JsScript)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_name()->::perfetto::protos::V8String::MergeFrom(
          from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_source()->::perfetto::protos::V8String::MergeFrom(
          from._internal_source());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.iid_ = from._impl_.iid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.script_id_ = from._impl_.script_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void InternedV8JsScript::CopyFrom(const InternedV8JsScript& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.InternedV8JsScript)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InternedV8JsScript::IsInitialized() const {
  return true;
}

void InternedV8JsScript::InternalSwap(InternedV8JsScript* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InternedV8JsScript, _impl_.type_)
      + sizeof(InternedV8JsScript::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(InternedV8JsScript, _impl_.name_)>(
          reinterpret_cast<char*>(&_impl_.name_),
          reinterpret_cast<char*>(&other->_impl_.name_));
}

std::string InternedV8JsScript::GetTypeName() const {
  return "perfetto.protos.InternedV8JsScript";
}


// ===================================================================

class InternedV8WasmScript::_Internal {
 public:
  using HasBits = decltype(std::declval<InternedV8WasmScript>()._impl_._has_bits_);
  static void set_has_iid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_script_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

InternedV8WasmScript::InternedV8WasmScript(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.InternedV8WasmScript)
}
InternedV8WasmScript::InternedV8WasmScript(const InternedV8WasmScript& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  InternedV8WasmScript* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.url_){}
    , decltype(_impl_.iid_){}
    , decltype(_impl_.script_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    _this->_impl_.url_.Set(from._internal_url(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.iid_, &from._impl_.iid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.script_id_) -
    reinterpret_cast<char*>(&_impl_.iid_)) + sizeof(_impl_.script_id_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.InternedV8WasmScript)
}

inline void InternedV8WasmScript::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.url_){}
    , decltype(_impl_.iid_){uint64_t{0u}}
    , decltype(_impl_.script_id_){0}
  };
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

InternedV8WasmScript::~InternedV8WasmScript() {
  // @@protoc_insertion_point(destructor:perfetto.protos.InternedV8WasmScript)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InternedV8WasmScript::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.url_.Destroy();
}

void InternedV8WasmScript::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InternedV8WasmScript::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.InternedV8WasmScript)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.url_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.iid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.script_id_) -
        reinterpret_cast<char*>(&_impl_.iid_)) + sizeof(_impl_.script_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* InternedV8WasmScript::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 iid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_iid(&has_bits);
          _impl_.iid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 script_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_script_id(&has_bits);
          _impl_.script_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string url = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InternedV8WasmScript::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.InternedV8WasmScript)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 iid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_iid(), target);
  }

  // optional int32 script_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_script_id(), target);
  }

  // optional string url = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_url(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.InternedV8WasmScript)
  return target;
}

size_t InternedV8WasmScript::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.InternedV8WasmScript)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string url = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url());
    }

    // optional uint64 iid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_iid());
    }

    // optional int32 script_id = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_script_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InternedV8WasmScript::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const InternedV8WasmScript*>(
      &from));
}

void InternedV8WasmScript::MergeFrom(const InternedV8WasmScript& from) {
  InternedV8WasmScript* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.InternedV8WasmScript)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_url(from._internal_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.iid_ = from._impl_.iid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.script_id_ = from._impl_.script_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void InternedV8WasmScript::CopyFrom(const InternedV8WasmScript& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.InternedV8WasmScript)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InternedV8WasmScript::IsInitialized() const {
  return true;
}

void InternedV8WasmScript::InternalSwap(InternedV8WasmScript* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_, lhs_arena,
      &other->_impl_.url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InternedV8WasmScript, _impl_.script_id_)
      + sizeof(InternedV8WasmScript::_impl_.script_id_)
      - PROTOBUF_FIELD_OFFSET(InternedV8WasmScript, _impl_.iid_)>(
          reinterpret_cast<char*>(&_impl_.iid_),
          reinterpret_cast<char*>(&other->_impl_.iid_));
}

std::string InternedV8WasmScript::GetTypeName() const {
  return "perfetto.protos.InternedV8WasmScript";
}


// ===================================================================

class InternedV8JsFunction::_Internal {
 public:
  using HasBits = decltype(std::declval<InternedV8JsFunction>()._impl_._has_bits_);
  static void set_has_iid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_v8_js_function_name_iid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_v8_js_script_iid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_toplevel(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_kind(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_byte_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

InternedV8JsFunction::InternedV8JsFunction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.InternedV8JsFunction)
}
InternedV8JsFunction::InternedV8JsFunction(const InternedV8JsFunction& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  InternedV8JsFunction* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.iid_){}
    , decltype(_impl_.v8_js_function_name_iid_){}
    , decltype(_impl_.v8_js_script_iid_){}
    , decltype(_impl_.is_toplevel_){}
    , decltype(_impl_.kind_){}
    , decltype(_impl_.byte_offset_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.iid_, &from._impl_.iid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.byte_offset_) -
    reinterpret_cast<char*>(&_impl_.iid_)) + sizeof(_impl_.byte_offset_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.InternedV8JsFunction)
}

inline void InternedV8JsFunction::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.iid_){uint64_t{0u}}
    , decltype(_impl_.v8_js_function_name_iid_){uint64_t{0u}}
    , decltype(_impl_.v8_js_script_iid_){uint64_t{0u}}
    , decltype(_impl_.is_toplevel_){false}
    , decltype(_impl_.kind_){0}
    , decltype(_impl_.byte_offset_){0u}
  };
}

InternedV8JsFunction::~InternedV8JsFunction() {
  // @@protoc_insertion_point(destructor:perfetto.protos.InternedV8JsFunction)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InternedV8JsFunction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void InternedV8JsFunction::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InternedV8JsFunction::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.InternedV8JsFunction)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.iid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.byte_offset_) -
        reinterpret_cast<char*>(&_impl_.iid_)) + sizeof(_impl_.byte_offset_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* InternedV8JsFunction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 iid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_iid(&has_bits);
          _impl_.iid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 v8_js_function_name_iid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_v8_js_function_name_iid(&has_bits);
          _impl_.v8_js_function_name_iid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 v8_js_script_iid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_v8_js_script_iid(&has_bits);
          _impl_.v8_js_script_iid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_toplevel = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_toplevel(&has_bits);
          _impl_.is_toplevel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .perfetto.protos.InternedV8JsFunction.Kind kind = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::perfetto::protos::InternedV8JsFunction_Kind_IsValid(val))) {
            _internal_set_kind(static_cast<::perfetto::protos::InternedV8JsFunction_Kind>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 byte_offset = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_byte_offset(&has_bits);
          _impl_.byte_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InternedV8JsFunction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.InternedV8JsFunction)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 iid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_iid(), target);
  }

  // optional uint64 v8_js_function_name_iid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_v8_js_function_name_iid(), target);
  }

  // optional uint64 v8_js_script_iid = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_v8_js_script_iid(), target);
  }

  // optional bool is_toplevel = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_is_toplevel(), target);
  }

  // optional .perfetto.protos.InternedV8JsFunction.Kind kind = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_kind(), target);
  }

  // optional uint32 byte_offset = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_byte_offset(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.InternedV8JsFunction)
  return target;
}

size_t InternedV8JsFunction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.InternedV8JsFunction)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 iid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_iid());
    }

    // optional uint64 v8_js_function_name_iid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_v8_js_function_name_iid());
    }

    // optional uint64 v8_js_script_iid = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_v8_js_script_iid());
    }

    // optional bool is_toplevel = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional .perfetto.protos.InternedV8JsFunction.Kind kind = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_kind());
    }

    // optional uint32 byte_offset = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_byte_offset());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InternedV8JsFunction::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const InternedV8JsFunction*>(
      &from));
}

void InternedV8JsFunction::MergeFrom(const InternedV8JsFunction& from) {
  InternedV8JsFunction* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.InternedV8JsFunction)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.iid_ = from._impl_.iid_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.v8_js_function_name_iid_ = from._impl_.v8_js_function_name_iid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.v8_js_script_iid_ = from._impl_.v8_js_script_iid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.is_toplevel_ = from._impl_.is_toplevel_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.kind_ = from._impl_.kind_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.byte_offset_ = from._impl_.byte_offset_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void InternedV8JsFunction::CopyFrom(const InternedV8JsFunction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.InternedV8JsFunction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InternedV8JsFunction::IsInitialized() const {
  return true;
}

void InternedV8JsFunction::InternalSwap(InternedV8JsFunction* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InternedV8JsFunction, _impl_.byte_offset_)
      + sizeof(InternedV8JsFunction::_impl_.byte_offset_)
      - PROTOBUF_FIELD_OFFSET(InternedV8JsFunction, _impl_.iid_)>(
          reinterpret_cast<char*>(&_impl_.iid_),
          reinterpret_cast<char*>(&other->_impl_.iid_));
}

std::string InternedV8JsFunction::GetTypeName() const {
  return "perfetto.protos.InternedV8JsFunction";
}


// ===================================================================

class InternedV8Isolate_CodeRange::_Internal {
 public:
  using HasBits = decltype(std::declval<InternedV8Isolate_CodeRange>()._impl_._has_bits_);
  static void set_has_base_address(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_embedded_blob_code_copy_start_address(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_process_wide(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

InternedV8Isolate_CodeRange::InternedV8Isolate_CodeRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.InternedV8Isolate.CodeRange)
}
InternedV8Isolate_CodeRange::InternedV8Isolate_CodeRange(const InternedV8Isolate_CodeRange& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  InternedV8Isolate_CodeRange* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.base_address_){}
    , decltype(_impl_.size_){}
    , decltype(_impl_.embedded_blob_code_copy_start_address_){}
    , decltype(_impl_.is_process_wide_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.base_address_, &from._impl_.base_address_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_process_wide_) -
    reinterpret_cast<char*>(&_impl_.base_address_)) + sizeof(_impl_.is_process_wide_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.InternedV8Isolate.CodeRange)
}

inline void InternedV8Isolate_CodeRange::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.base_address_){uint64_t{0u}}
    , decltype(_impl_.size_){uint64_t{0u}}
    , decltype(_impl_.embedded_blob_code_copy_start_address_){uint64_t{0u}}
    , decltype(_impl_.is_process_wide_){false}
  };
}

InternedV8Isolate_CodeRange::~InternedV8Isolate_CodeRange() {
  // @@protoc_insertion_point(destructor:perfetto.protos.InternedV8Isolate.CodeRange)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InternedV8Isolate_CodeRange::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void InternedV8Isolate_CodeRange::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InternedV8Isolate_CodeRange::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.InternedV8Isolate.CodeRange)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.base_address_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_process_wide_) -
        reinterpret_cast<char*>(&_impl_.base_address_)) + sizeof(_impl_.is_process_wide_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* InternedV8Isolate_CodeRange::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 base_address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_base_address(&has_bits);
          _impl_.base_address_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 embedded_blob_code_copy_start_address = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_embedded_blob_code_copy_start_address(&has_bits);
          _impl_.embedded_blob_code_copy_start_address_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_process_wide = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_process_wide(&has_bits);
          _impl_.is_process_wide_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InternedV8Isolate_CodeRange::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.InternedV8Isolate.CodeRange)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 base_address = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_base_address(), target);
  }

  // optional uint64 size = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_size(), target);
  }

  // optional uint64 embedded_blob_code_copy_start_address = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_embedded_blob_code_copy_start_address(), target);
  }

  // optional bool is_process_wide = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_is_process_wide(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.InternedV8Isolate.CodeRange)
  return target;
}

size_t InternedV8Isolate_CodeRange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.InternedV8Isolate.CodeRange)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 base_address = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_base_address());
    }

    // optional uint64 size = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_size());
    }

    // optional uint64 embedded_blob_code_copy_start_address = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_embedded_blob_code_copy_start_address());
    }

    // optional bool is_process_wide = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InternedV8Isolate_CodeRange::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const InternedV8Isolate_CodeRange*>(
      &from));
}

void InternedV8Isolate_CodeRange::MergeFrom(const InternedV8Isolate_CodeRange& from) {
  InternedV8Isolate_CodeRange* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.InternedV8Isolate.CodeRange)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.base_address_ = from._impl_.base_address_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.embedded_blob_code_copy_start_address_ = from._impl_.embedded_blob_code_copy_start_address_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.is_process_wide_ = from._impl_.is_process_wide_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void InternedV8Isolate_CodeRange::CopyFrom(const InternedV8Isolate_CodeRange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.InternedV8Isolate.CodeRange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InternedV8Isolate_CodeRange::IsInitialized() const {
  return true;
}

void InternedV8Isolate_CodeRange::InternalSwap(InternedV8Isolate_CodeRange* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InternedV8Isolate_CodeRange, _impl_.is_process_wide_)
      + sizeof(InternedV8Isolate_CodeRange::_impl_.is_process_wide_)
      - PROTOBUF_FIELD_OFFSET(InternedV8Isolate_CodeRange, _impl_.base_address_)>(
          reinterpret_cast<char*>(&_impl_.base_address_),
          reinterpret_cast<char*>(&other->_impl_.base_address_));
}

std::string InternedV8Isolate_CodeRange::GetTypeName() const {
  return "perfetto.protos.InternedV8Isolate.CodeRange";
}


// ===================================================================

class InternedV8Isolate::_Internal {
 public:
  using HasBits = decltype(std::declval<InternedV8Isolate>()._impl_._has_bits_);
  static void set_has_iid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_isolate_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::perfetto::protos::InternedV8Isolate_CodeRange& code_range(const InternedV8Isolate* msg);
  static void set_has_code_range(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_embedded_blob_code_start_address(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_embedded_blob_code_size(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::perfetto::protos::InternedV8Isolate_CodeRange&
InternedV8Isolate::_Internal::code_range(const InternedV8Isolate* msg) {
  return *msg->_impl_.code_range_;
}
InternedV8Isolate::InternedV8Isolate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.InternedV8Isolate)
}
InternedV8Isolate::InternedV8Isolate(const InternedV8Isolate& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  InternedV8Isolate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.code_range_){nullptr}
    , decltype(_impl_.iid_){}
    , decltype(_impl_.pid_){}
    , decltype(_impl_.isolate_id_){}
    , decltype(_impl_.embedded_blob_code_start_address_){}
    , decltype(_impl_.embedded_blob_code_size_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_code_range()) {
    _this->_impl_.code_range_ = new ::perfetto::protos::InternedV8Isolate_CodeRange(*from._impl_.code_range_);
  }
  ::memcpy(&_impl_.iid_, &from._impl_.iid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.embedded_blob_code_size_) -
    reinterpret_cast<char*>(&_impl_.iid_)) + sizeof(_impl_.embedded_blob_code_size_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.InternedV8Isolate)
}

inline void InternedV8Isolate::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.code_range_){nullptr}
    , decltype(_impl_.iid_){uint64_t{0u}}
    , decltype(_impl_.pid_){0u}
    , decltype(_impl_.isolate_id_){0}
    , decltype(_impl_.embedded_blob_code_start_address_){uint64_t{0u}}
    , decltype(_impl_.embedded_blob_code_size_){uint64_t{0u}}
  };
}

InternedV8Isolate::~InternedV8Isolate() {
  // @@protoc_insertion_point(destructor:perfetto.protos.InternedV8Isolate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InternedV8Isolate::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.code_range_;
}

void InternedV8Isolate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InternedV8Isolate::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.InternedV8Isolate)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.code_range_ != nullptr);
    _impl_.code_range_->Clear();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&_impl_.iid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.embedded_blob_code_size_) -
        reinterpret_cast<char*>(&_impl_.iid_)) + sizeof(_impl_.embedded_blob_code_size_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* InternedV8Isolate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 iid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_iid(&has_bits);
          _impl_.iid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_pid(&has_bits);
          _impl_.pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 isolate_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_isolate_id(&has_bits);
          _impl_.isolate_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .perfetto.protos.InternedV8Isolate.CodeRange code_range = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_code_range(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 embedded_blob_code_start_address = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_embedded_blob_code_start_address(&has_bits);
          _impl_.embedded_blob_code_start_address_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 embedded_blob_code_size = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_embedded_blob_code_size(&has_bits);
          _impl_.embedded_blob_code_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InternedV8Isolate::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.InternedV8Isolate)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 iid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_iid(), target);
  }

  // optional uint32 pid = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_pid(), target);
  }

  // optional int32 isolate_id = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_isolate_id(), target);
  }

  // optional .perfetto.protos.InternedV8Isolate.CodeRange code_range = 4;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::code_range(this),
        _Internal::code_range(this).GetCachedSize(), target, stream);
  }

  // optional uint64 embedded_blob_code_start_address = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_embedded_blob_code_start_address(), target);
  }

  // optional uint64 embedded_blob_code_size = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_embedded_blob_code_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.InternedV8Isolate)
  return target;
}

size_t InternedV8Isolate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.InternedV8Isolate)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .perfetto.protos.InternedV8Isolate.CodeRange code_range = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.code_range_);
    }

    // optional uint64 iid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_iid());
    }

    // optional uint32 pid = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_pid());
    }

    // optional int32 isolate_id = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_isolate_id());
    }

    // optional uint64 embedded_blob_code_start_address = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_embedded_blob_code_start_address());
    }

    // optional uint64 embedded_blob_code_size = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_embedded_blob_code_size());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InternedV8Isolate::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const InternedV8Isolate*>(
      &from));
}

void InternedV8Isolate::MergeFrom(const InternedV8Isolate& from) {
  InternedV8Isolate* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.InternedV8Isolate)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_code_range()->::perfetto::protos::InternedV8Isolate_CodeRange::MergeFrom(
          from._internal_code_range());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.iid_ = from._impl_.iid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pid_ = from._impl_.pid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.isolate_id_ = from._impl_.isolate_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.embedded_blob_code_start_address_ = from._impl_.embedded_blob_code_start_address_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.embedded_blob_code_size_ = from._impl_.embedded_blob_code_size_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void InternedV8Isolate::CopyFrom(const InternedV8Isolate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.InternedV8Isolate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InternedV8Isolate::IsInitialized() const {
  return true;
}

void InternedV8Isolate::InternalSwap(InternedV8Isolate* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InternedV8Isolate, _impl_.embedded_blob_code_size_)
      + sizeof(InternedV8Isolate::_impl_.embedded_blob_code_size_)
      - PROTOBUF_FIELD_OFFSET(InternedV8Isolate, _impl_.code_range_)>(
          reinterpret_cast<char*>(&_impl_.code_range_),
          reinterpret_cast<char*>(&other->_impl_.code_range_));
}

std::string InternedV8Isolate::GetTypeName() const {
  return "perfetto.protos.InternedV8Isolate";
}


// ===================================================================

class V8JsCode::_Internal {
 public:
  using HasBits = decltype(std::declval<V8JsCode>()._impl_._has_bits_);
  static void set_has_v8_isolate_iid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_tid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_v8_js_function_iid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_tier(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_instruction_start(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_instruction_size_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

V8JsCode::V8JsCode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.V8JsCode)
}
V8JsCode::V8JsCode(const V8JsCode& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  V8JsCode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.v8_isolate_iid_){}
    , decltype(_impl_.v8_js_function_iid_){}
    , decltype(_impl_.tid_){}
    , decltype(_impl_.tier_){}
    , decltype(_impl_.instruction_start_){}
    , decltype(_impl_.instruction_size_bytes_){}
    , decltype(_impl_.instructions_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.v8_isolate_iid_, &from._impl_.v8_isolate_iid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.instruction_size_bytes_) -
    reinterpret_cast<char*>(&_impl_.v8_isolate_iid_)) + sizeof(_impl_.instruction_size_bytes_));
  clear_has_instructions();
  switch (from.instructions_case()) {
    case kMachineCode: {
      _this->_internal_set_machine_code(from._internal_machine_code());
      break;
    }
    case kBytecode: {
      _this->_internal_set_bytecode(from._internal_bytecode());
      break;
    }
    case INSTRUCTIONS_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.V8JsCode)
}

inline void V8JsCode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.v8_isolate_iid_){uint64_t{0u}}
    , decltype(_impl_.v8_js_function_iid_){uint64_t{0u}}
    , decltype(_impl_.tid_){0u}
    , decltype(_impl_.tier_){0}
    , decltype(_impl_.instruction_start_){uint64_t{0u}}
    , decltype(_impl_.instruction_size_bytes_){uint64_t{0u}}
    , decltype(_impl_.instructions_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_instructions();
}

V8JsCode::~V8JsCode() {
  // @@protoc_insertion_point(destructor:perfetto.protos.V8JsCode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void V8JsCode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_instructions()) {
    clear_instructions();
  }
}

void V8JsCode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void V8JsCode::clear_instructions() {
// @@protoc_insertion_point(one_of_clear_start:perfetto.protos.V8JsCode)
  switch (instructions_case()) {
    case kMachineCode: {
      _impl_.instructions_.machine_code_.Destroy();
      break;
    }
    case kBytecode: {
      _impl_.instructions_.bytecode_.Destroy();
      break;
    }
    case INSTRUCTIONS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = INSTRUCTIONS_NOT_SET;
}


void V8JsCode::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.V8JsCode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.v8_isolate_iid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.instruction_size_bytes_) -
        reinterpret_cast<char*>(&_impl_.v8_isolate_iid_)) + sizeof(_impl_.instruction_size_bytes_));
  }
  clear_instructions();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* V8JsCode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 v8_isolate_iid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_v8_isolate_iid(&has_bits);
          _impl_.v8_isolate_iid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_tid(&has_bits);
          _impl_.tid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 v8_js_function_iid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_v8_js_function_iid(&has_bits);
          _impl_.v8_js_function_iid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .perfetto.protos.V8JsCode.Tier tier = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::perfetto::protos::V8JsCode_Tier_IsValid(val))) {
            _internal_set_tier(static_cast<::perfetto::protos::V8JsCode_Tier>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint64 instruction_start = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_instruction_start(&has_bits);
          _impl_.instruction_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 instruction_size_bytes = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_instruction_size_bytes(&has_bits);
          _impl_.instruction_size_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes machine_code = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_machine_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes bytecode = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_bytecode();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* V8JsCode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.V8JsCode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 v8_isolate_iid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_v8_isolate_iid(), target);
  }

  // optional uint32 tid = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_tid(), target);
  }

  // optional uint64 v8_js_function_iid = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_v8_js_function_iid(), target);
  }

  // optional .perfetto.protos.V8JsCode.Tier tier = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_tier(), target);
  }

  // optional uint64 instruction_start = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_instruction_start(), target);
  }

  // optional uint64 instruction_size_bytes = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_instruction_size_bytes(), target);
  }

  switch (instructions_case()) {
    case kMachineCode: {
      target = stream->WriteBytesMaybeAliased(
          7, this->_internal_machine_code(), target);
      break;
    }
    case kBytecode: {
      target = stream->WriteBytesMaybeAliased(
          8, this->_internal_bytecode(), target);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.V8JsCode)
  return target;
}

size_t V8JsCode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.V8JsCode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 v8_isolate_iid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_v8_isolate_iid());
    }

    // optional uint64 v8_js_function_iid = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_v8_js_function_iid());
    }

    // optional uint32 tid = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tid());
    }

    // optional .perfetto.protos.V8JsCode.Tier tier = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_tier());
    }

    // optional uint64 instruction_start = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_instruction_start());
    }

    // optional uint64 instruction_size_bytes = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_instruction_size_bytes());
    }

  }
  switch (instructions_case()) {
    // bytes machine_code = 7;
    case kMachineCode: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_machine_code());
      break;
    }
    // bytes bytecode = 8;
    case kBytecode: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_bytecode());
      break;
    }
    case INSTRUCTIONS_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void V8JsCode::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const V8JsCode*>(
      &from));
}

void V8JsCode::MergeFrom(const V8JsCode& from) {
  V8JsCode* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.V8JsCode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.v8_isolate_iid_ = from._impl_.v8_isolate_iid_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.v8_js_function_iid_ = from._impl_.v8_js_function_iid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.tid_ = from._impl_.tid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.tier_ = from._impl_.tier_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.instruction_start_ = from._impl_.instruction_start_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.instruction_size_bytes_ = from._impl_.instruction_size_bytes_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  switch (from.instructions_case()) {
    case kMachineCode: {
      _this->_internal_set_machine_code(from._internal_machine_code());
      break;
    }
    case kBytecode: {
      _this->_internal_set_bytecode(from._internal_bytecode());
      break;
    }
    case INSTRUCTIONS_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void V8JsCode::CopyFrom(const V8JsCode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.V8JsCode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool V8JsCode::IsInitialized() const {
  return true;
}

void V8JsCode::InternalSwap(V8JsCode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(V8JsCode, _impl_.instruction_size_bytes_)
      + sizeof(V8JsCode::_impl_.instruction_size_bytes_)
      - PROTOBUF_FIELD_OFFSET(V8JsCode, _impl_.v8_isolate_iid_)>(
          reinterpret_cast<char*>(&_impl_.v8_isolate_iid_),
          reinterpret_cast<char*>(&other->_impl_.v8_isolate_iid_));
  swap(_impl_.instructions_, other->_impl_.instructions_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string V8JsCode::GetTypeName() const {
  return "perfetto.protos.V8JsCode";
}


// ===================================================================

class V8InternalCode::_Internal {
 public:
  using HasBits = decltype(std::declval<V8InternalCode>()._impl_._has_bits_);
  static void set_has_v8_isolate_iid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_tid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_builtin_id(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_instruction_start(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_instruction_size_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_machine_code(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

V8InternalCode::V8InternalCode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.V8InternalCode)
}
V8InternalCode::V8InternalCode(const V8InternalCode& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  V8InternalCode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.machine_code_){}
    , decltype(_impl_.v8_isolate_iid_){}
    , decltype(_impl_.tid_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.instruction_start_){}
    , decltype(_impl_.instruction_size_bytes_){}
    , decltype(_impl_.builtin_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.machine_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_machine_code()) {
    _this->_impl_.machine_code_.Set(from._internal_machine_code(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.v8_isolate_iid_, &from._impl_.v8_isolate_iid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.builtin_id_) -
    reinterpret_cast<char*>(&_impl_.v8_isolate_iid_)) + sizeof(_impl_.builtin_id_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.V8InternalCode)
}

inline void V8InternalCode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.machine_code_){}
    , decltype(_impl_.v8_isolate_iid_){uint64_t{0u}}
    , decltype(_impl_.tid_){0u}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.instruction_start_){uint64_t{0u}}
    , decltype(_impl_.instruction_size_bytes_){uint64_t{0u}}
    , decltype(_impl_.builtin_id_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.machine_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

V8InternalCode::~V8InternalCode() {
  // @@protoc_insertion_point(destructor:perfetto.protos.V8InternalCode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void V8InternalCode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.machine_code_.Destroy();
}

void V8InternalCode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void V8InternalCode::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.V8InternalCode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.machine_code_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.v8_isolate_iid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.builtin_id_) -
        reinterpret_cast<char*>(&_impl_.v8_isolate_iid_)) + sizeof(_impl_.builtin_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* V8InternalCode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 v8_isolate_iid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_v8_isolate_iid(&has_bits);
          _impl_.v8_isolate_iid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_tid(&has_bits);
          _impl_.tid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .perfetto.protos.V8InternalCode.Type type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::perfetto::protos::V8InternalCode_Type_IsValid(val))) {
            _internal_set_type(static_cast<::perfetto::protos::V8InternalCode_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 builtin_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_builtin_id(&has_bits);
          _impl_.builtin_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 instruction_start = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_instruction_start(&has_bits);
          _impl_.instruction_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 instruction_size_bytes = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_instruction_size_bytes(&has_bits);
          _impl_.instruction_size_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes machine_code = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_machine_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* V8InternalCode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.V8InternalCode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 v8_isolate_iid = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_v8_isolate_iid(), target);
  }

  // optional uint32 tid = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_tid(), target);
  }

  // optional string name = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_name(), target);
  }

  // optional .perfetto.protos.V8InternalCode.Type type = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_type(), target);
  }

  // optional int32 builtin_id = 5;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_builtin_id(), target);
  }

  // optional uint64 instruction_start = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_instruction_start(), target);
  }

  // optional uint64 instruction_size_bytes = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_instruction_size_bytes(), target);
  }

  // optional bytes machine_code = 8;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_machine_code(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.V8InternalCode)
  return target;
}

size_t V8InternalCode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.V8InternalCode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional bytes machine_code = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_machine_code());
    }

    // optional uint64 v8_isolate_iid = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_v8_isolate_iid());
    }

    // optional uint32 tid = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tid());
    }

    // optional .perfetto.protos.V8InternalCode.Type type = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional uint64 instruction_start = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_instruction_start());
    }

    // optional uint64 instruction_size_bytes = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_instruction_size_bytes());
    }

    // optional int32 builtin_id = 5;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_builtin_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void V8InternalCode::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const V8InternalCode*>(
      &from));
}

void V8InternalCode::MergeFrom(const V8InternalCode& from) {
  V8InternalCode* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.V8InternalCode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_machine_code(from._internal_machine_code());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.v8_isolate_iid_ = from._impl_.v8_isolate_iid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.tid_ = from._impl_.tid_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.instruction_start_ = from._impl_.instruction_start_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.instruction_size_bytes_ = from._impl_.instruction_size_bytes_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.builtin_id_ = from._impl_.builtin_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void V8InternalCode::CopyFrom(const V8InternalCode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.V8InternalCode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool V8InternalCode::IsInitialized() const {
  return true;
}

void V8InternalCode::InternalSwap(V8InternalCode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.machine_code_, lhs_arena,
      &other->_impl_.machine_code_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(V8InternalCode, _impl_.builtin_id_)
      + sizeof(V8InternalCode::_impl_.builtin_id_)
      - PROTOBUF_FIELD_OFFSET(V8InternalCode, _impl_.v8_isolate_iid_)>(
          reinterpret_cast<char*>(&_impl_.v8_isolate_iid_),
          reinterpret_cast<char*>(&other->_impl_.v8_isolate_iid_));
}

std::string V8InternalCode::GetTypeName() const {
  return "perfetto.protos.V8InternalCode";
}


// ===================================================================

class V8WasmCode::_Internal {
 public:
  using HasBits = decltype(std::declval<V8WasmCode>()._impl_._has_bits_);
  static void set_has_v8_isolate_iid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_tid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_v8_wasm_script_iid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_function_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_tier(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_code_offset_in_module(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_instruction_start(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_instruction_size_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_machine_code(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

V8WasmCode::V8WasmCode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.V8WasmCode)
}
V8WasmCode::V8WasmCode(const V8WasmCode& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  V8WasmCode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.function_name_){}
    , decltype(_impl_.machine_code_){}
    , decltype(_impl_.v8_isolate_iid_){}
    , decltype(_impl_.v8_wasm_script_iid_){}
    , decltype(_impl_.tid_){}
    , decltype(_impl_.tier_){}
    , decltype(_impl_.instruction_start_){}
    , decltype(_impl_.instruction_size_bytes_){}
    , decltype(_impl_.code_offset_in_module_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.function_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.function_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_function_name()) {
    _this->_impl_.function_name_.Set(from._internal_function_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.machine_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_machine_code()) {
    _this->_impl_.machine_code_.Set(from._internal_machine_code(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.v8_isolate_iid_, &from._impl_.v8_isolate_iid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.code_offset_in_module_) -
    reinterpret_cast<char*>(&_impl_.v8_isolate_iid_)) + sizeof(_impl_.code_offset_in_module_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.V8WasmCode)
}

inline void V8WasmCode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.function_name_){}
    , decltype(_impl_.machine_code_){}
    , decltype(_impl_.v8_isolate_iid_){uint64_t{0u}}
    , decltype(_impl_.v8_wasm_script_iid_){uint64_t{0u}}
    , decltype(_impl_.tid_){0u}
    , decltype(_impl_.tier_){0}
    , decltype(_impl_.instruction_start_){uint64_t{0u}}
    , decltype(_impl_.instruction_size_bytes_){uint64_t{0u}}
    , decltype(_impl_.code_offset_in_module_){0}
  };
  _impl_.function_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.function_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.machine_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

V8WasmCode::~V8WasmCode() {
  // @@protoc_insertion_point(destructor:perfetto.protos.V8WasmCode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void V8WasmCode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.function_name_.Destroy();
  _impl_.machine_code_.Destroy();
}

void V8WasmCode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void V8WasmCode::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.V8WasmCode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.function_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.machine_code_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.v8_isolate_iid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.instruction_size_bytes_) -
        reinterpret_cast<char*>(&_impl_.v8_isolate_iid_)) + sizeof(_impl_.instruction_size_bytes_));
  }
  _impl_.code_offset_in_module_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* V8WasmCode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 v8_isolate_iid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_v8_isolate_iid(&has_bits);
          _impl_.v8_isolate_iid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_tid(&has_bits);
          _impl_.tid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 v8_wasm_script_iid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_v8_wasm_script_iid(&has_bits);
          _impl_.v8_wasm_script_iid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string function_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_function_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .perfetto.protos.V8WasmCode.Tier tier = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::perfetto::protos::V8WasmCode_Tier_IsValid(val))) {
            _internal_set_tier(static_cast<::perfetto::protos::V8WasmCode_Tier>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 code_offset_in_module = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_code_offset_in_module(&has_bits);
          _impl_.code_offset_in_module_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 instruction_start = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_instruction_start(&has_bits);
          _impl_.instruction_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 instruction_size_bytes = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_instruction_size_bytes(&has_bits);
          _impl_.instruction_size_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes machine_code = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_machine_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* V8WasmCode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.V8WasmCode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 v8_isolate_iid = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_v8_isolate_iid(), target);
  }

  // optional uint32 tid = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_tid(), target);
  }

  // optional uint64 v8_wasm_script_iid = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_v8_wasm_script_iid(), target);
  }

  // optional string function_name = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_function_name(), target);
  }

  // optional .perfetto.protos.V8WasmCode.Tier tier = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_tier(), target);
  }

  // optional int32 code_offset_in_module = 6;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_code_offset_in_module(), target);
  }

  // optional uint64 instruction_start = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_instruction_start(), target);
  }

  // optional uint64 instruction_size_bytes = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(8, this->_internal_instruction_size_bytes(), target);
  }

  // optional bytes machine_code = 9;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        9, this->_internal_machine_code(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.V8WasmCode)
  return target;
}

size_t V8WasmCode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.V8WasmCode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string function_name = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_function_name());
    }

    // optional bytes machine_code = 9;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_machine_code());
    }

    // optional uint64 v8_isolate_iid = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_v8_isolate_iid());
    }

    // optional uint64 v8_wasm_script_iid = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_v8_wasm_script_iid());
    }

    // optional uint32 tid = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tid());
    }

    // optional .perfetto.protos.V8WasmCode.Tier tier = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_tier());
    }

    // optional uint64 instruction_start = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_instruction_start());
    }

    // optional uint64 instruction_size_bytes = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_instruction_size_bytes());
    }

  }
  // optional int32 code_offset_in_module = 6;
  if (cached_has_bits & 0x00000100u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_code_offset_in_module());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void V8WasmCode::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const V8WasmCode*>(
      &from));
}

void V8WasmCode::MergeFrom(const V8WasmCode& from) {
  V8WasmCode* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.V8WasmCode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_function_name(from._internal_function_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_machine_code(from._internal_machine_code());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.v8_isolate_iid_ = from._impl_.v8_isolate_iid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.v8_wasm_script_iid_ = from._impl_.v8_wasm_script_iid_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.tid_ = from._impl_.tid_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.tier_ = from._impl_.tier_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.instruction_start_ = from._impl_.instruction_start_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.instruction_size_bytes_ = from._impl_.instruction_size_bytes_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_code_offset_in_module(from._internal_code_offset_in_module());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void V8WasmCode::CopyFrom(const V8WasmCode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.V8WasmCode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool V8WasmCode::IsInitialized() const {
  return true;
}

void V8WasmCode::InternalSwap(V8WasmCode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.function_name_, lhs_arena,
      &other->_impl_.function_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.machine_code_, lhs_arena,
      &other->_impl_.machine_code_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(V8WasmCode, _impl_.code_offset_in_module_)
      + sizeof(V8WasmCode::_impl_.code_offset_in_module_)
      - PROTOBUF_FIELD_OFFSET(V8WasmCode, _impl_.v8_isolate_iid_)>(
          reinterpret_cast<char*>(&_impl_.v8_isolate_iid_),
          reinterpret_cast<char*>(&other->_impl_.v8_isolate_iid_));
}

std::string V8WasmCode::GetTypeName() const {
  return "perfetto.protos.V8WasmCode";
}


// ===================================================================

class V8RegExpCode::_Internal {
 public:
  using HasBits = decltype(std::declval<V8RegExpCode>()._impl_._has_bits_);
  static void set_has_v8_isolate_iid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_tid(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::perfetto::protos::V8String& pattern(const V8RegExpCode* msg);
  static void set_has_pattern(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_instruction_start(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_instruction_size_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_machine_code(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::perfetto::protos::V8String&
V8RegExpCode::_Internal::pattern(const V8RegExpCode* msg) {
  return *msg->_impl_.pattern_;
}
V8RegExpCode::V8RegExpCode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.V8RegExpCode)
}
V8RegExpCode::V8RegExpCode(const V8RegExpCode& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  V8RegExpCode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.machine_code_){}
    , decltype(_impl_.pattern_){nullptr}
    , decltype(_impl_.v8_isolate_iid_){}
    , decltype(_impl_.instruction_start_){}
    , decltype(_impl_.instruction_size_bytes_){}
    , decltype(_impl_.tid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.machine_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_machine_code()) {
    _this->_impl_.machine_code_.Set(from._internal_machine_code(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_pattern()) {
    _this->_impl_.pattern_ = new ::perfetto::protos::V8String(*from._impl_.pattern_);
  }
  ::memcpy(&_impl_.v8_isolate_iid_, &from._impl_.v8_isolate_iid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.tid_) -
    reinterpret_cast<char*>(&_impl_.v8_isolate_iid_)) + sizeof(_impl_.tid_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.V8RegExpCode)
}

inline void V8RegExpCode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.machine_code_){}
    , decltype(_impl_.pattern_){nullptr}
    , decltype(_impl_.v8_isolate_iid_){uint64_t{0u}}
    , decltype(_impl_.instruction_start_){uint64_t{0u}}
    , decltype(_impl_.instruction_size_bytes_){uint64_t{0u}}
    , decltype(_impl_.tid_){0u}
  };
  _impl_.machine_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

V8RegExpCode::~V8RegExpCode() {
  // @@protoc_insertion_point(destructor:perfetto.protos.V8RegExpCode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void V8RegExpCode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.machine_code_.Destroy();
  if (this != internal_default_instance()) delete _impl_.pattern_;
}

void V8RegExpCode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void V8RegExpCode::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.V8RegExpCode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.machine_code_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.pattern_ != nullptr);
      _impl_.pattern_->Clear();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&_impl_.v8_isolate_iid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.tid_) -
        reinterpret_cast<char*>(&_impl_.v8_isolate_iid_)) + sizeof(_impl_.tid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* V8RegExpCode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 v8_isolate_iid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_v8_isolate_iid(&has_bits);
          _impl_.v8_isolate_iid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_tid(&has_bits);
          _impl_.tid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .perfetto.protos.V8String pattern = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_pattern(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 instruction_start = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_instruction_start(&has_bits);
          _impl_.instruction_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 instruction_size_bytes = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_instruction_size_bytes(&has_bits);
          _impl_.instruction_size_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes machine_code = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_machine_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* V8RegExpCode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.V8RegExpCode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 v8_isolate_iid = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_v8_isolate_iid(), target);
  }

  // optional uint32 tid = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_tid(), target);
  }

  // optional .perfetto.protos.V8String pattern = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::pattern(this),
        _Internal::pattern(this).GetCachedSize(), target, stream);
  }

  // optional uint64 instruction_start = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_instruction_start(), target);
  }

  // optional uint64 instruction_size_bytes = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_instruction_size_bytes(), target);
  }

  // optional bytes machine_code = 6;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_machine_code(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.V8RegExpCode)
  return target;
}

size_t V8RegExpCode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.V8RegExpCode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional bytes machine_code = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_machine_code());
    }

    // optional .perfetto.protos.V8String pattern = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.pattern_);
    }

    // optional uint64 v8_isolate_iid = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_v8_isolate_iid());
    }

    // optional uint64 instruction_start = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_instruction_start());
    }

    // optional uint64 instruction_size_bytes = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_instruction_size_bytes());
    }

    // optional uint32 tid = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tid());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void V8RegExpCode::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const V8RegExpCode*>(
      &from));
}

void V8RegExpCode::MergeFrom(const V8RegExpCode& from) {
  V8RegExpCode* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.V8RegExpCode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_machine_code(from._internal_machine_code());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_pattern()->::perfetto::protos::V8String::MergeFrom(
          from._internal_pattern());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.v8_isolate_iid_ = from._impl_.v8_isolate_iid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.instruction_start_ = from._impl_.instruction_start_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.instruction_size_bytes_ = from._impl_.instruction_size_bytes_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.tid_ = from._impl_.tid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void V8RegExpCode::CopyFrom(const V8RegExpCode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.V8RegExpCode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool V8RegExpCode::IsInitialized() const {
  return true;
}

void V8RegExpCode::InternalSwap(V8RegExpCode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.machine_code_, lhs_arena,
      &other->_impl_.machine_code_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(V8RegExpCode, _impl_.tid_)
      + sizeof(V8RegExpCode::_impl_.tid_)
      - PROTOBUF_FIELD_OFFSET(V8RegExpCode, _impl_.pattern_)>(
          reinterpret_cast<char*>(&_impl_.pattern_),
          reinterpret_cast<char*>(&other->_impl_.pattern_));
}

std::string V8RegExpCode::GetTypeName() const {
  return "perfetto.protos.V8RegExpCode";
}


// ===================================================================

class V8CodeMove::_Internal {
 public:
  using HasBits = decltype(std::declval<V8CodeMove>()._impl_._has_bits_);
  static void set_has_isolate_iid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_tid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_from_instruction_start_address(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_to_instruction_start_address(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_instruction_size_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

V8CodeMove::V8CodeMove(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.V8CodeMove)
}
V8CodeMove::V8CodeMove(const V8CodeMove& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  V8CodeMove* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.isolate_iid_){}
    , decltype(_impl_.from_instruction_start_address_){}
    , decltype(_impl_.to_instruction_start_address_){}
    , decltype(_impl_.instruction_size_bytes_){}
    , decltype(_impl_.tid_){}
    , decltype(_impl_.to_instructions_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.isolate_iid_, &from._impl_.isolate_iid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.tid_) -
    reinterpret_cast<char*>(&_impl_.isolate_iid_)) + sizeof(_impl_.tid_));
  clear_has_to_instructions();
  switch (from.to_instructions_case()) {
    case kToMachineCode: {
      _this->_internal_set_to_machine_code(from._internal_to_machine_code());
      break;
    }
    case kToBytecode: {
      _this->_internal_set_to_bytecode(from._internal_to_bytecode());
      break;
    }
    case TO_INSTRUCTIONS_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.V8CodeMove)
}

inline void V8CodeMove::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.isolate_iid_){uint64_t{0u}}
    , decltype(_impl_.from_instruction_start_address_){uint64_t{0u}}
    , decltype(_impl_.to_instruction_start_address_){uint64_t{0u}}
    , decltype(_impl_.instruction_size_bytes_){uint64_t{0u}}
    , decltype(_impl_.tid_){0u}
    , decltype(_impl_.to_instructions_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_to_instructions();
}

V8CodeMove::~V8CodeMove() {
  // @@protoc_insertion_point(destructor:perfetto.protos.V8CodeMove)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void V8CodeMove::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_to_instructions()) {
    clear_to_instructions();
  }
}

void V8CodeMove::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void V8CodeMove::clear_to_instructions() {
// @@protoc_insertion_point(one_of_clear_start:perfetto.protos.V8CodeMove)
  switch (to_instructions_case()) {
    case kToMachineCode: {
      _impl_.to_instructions_.to_machine_code_.Destroy();
      break;
    }
    case kToBytecode: {
      _impl_.to_instructions_.to_bytecode_.Destroy();
      break;
    }
    case TO_INSTRUCTIONS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = TO_INSTRUCTIONS_NOT_SET;
}


void V8CodeMove::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.V8CodeMove)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.isolate_iid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.tid_) -
        reinterpret_cast<char*>(&_impl_.isolate_iid_)) + sizeof(_impl_.tid_));
  }
  clear_to_instructions();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* V8CodeMove::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 isolate_iid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_isolate_iid(&has_bits);
          _impl_.isolate_iid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_tid(&has_bits);
          _impl_.tid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 from_instruction_start_address = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_from_instruction_start_address(&has_bits);
          _impl_.from_instruction_start_address_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 to_instruction_start_address = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_to_instruction_start_address(&has_bits);
          _impl_.to_instruction_start_address_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 instruction_size_bytes = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_instruction_size_bytes(&has_bits);
          _impl_.instruction_size_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes to_machine_code = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_to_machine_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes to_bytecode = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_to_bytecode();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* V8CodeMove::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.V8CodeMove)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 isolate_iid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_isolate_iid(), target);
  }

  // optional uint32 tid = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_tid(), target);
  }

  // optional uint64 from_instruction_start_address = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_from_instruction_start_address(), target);
  }

  // optional uint64 to_instruction_start_address = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_to_instruction_start_address(), target);
  }

  // optional uint64 instruction_size_bytes = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_instruction_size_bytes(), target);
  }

  switch (to_instructions_case()) {
    case kToMachineCode: {
      target = stream->WriteBytesMaybeAliased(
          6, this->_internal_to_machine_code(), target);
      break;
    }
    case kToBytecode: {
      target = stream->WriteBytesMaybeAliased(
          7, this->_internal_to_bytecode(), target);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.V8CodeMove)
  return target;
}

size_t V8CodeMove::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.V8CodeMove)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 isolate_iid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_isolate_iid());
    }

    // optional uint64 from_instruction_start_address = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_from_instruction_start_address());
    }

    // optional uint64 to_instruction_start_address = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_to_instruction_start_address());
    }

    // optional uint64 instruction_size_bytes = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_instruction_size_bytes());
    }

    // optional uint32 tid = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tid());
    }

  }
  switch (to_instructions_case()) {
    // bytes to_machine_code = 6;
    case kToMachineCode: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_to_machine_code());
      break;
    }
    // bytes to_bytecode = 7;
    case kToBytecode: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_to_bytecode());
      break;
    }
    case TO_INSTRUCTIONS_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void V8CodeMove::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const V8CodeMove*>(
      &from));
}

void V8CodeMove::MergeFrom(const V8CodeMove& from) {
  V8CodeMove* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.V8CodeMove)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.isolate_iid_ = from._impl_.isolate_iid_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.from_instruction_start_address_ = from._impl_.from_instruction_start_address_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.to_instruction_start_address_ = from._impl_.to_instruction_start_address_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.instruction_size_bytes_ = from._impl_.instruction_size_bytes_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.tid_ = from._impl_.tid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  switch (from.to_instructions_case()) {
    case kToMachineCode: {
      _this->_internal_set_to_machine_code(from._internal_to_machine_code());
      break;
    }
    case kToBytecode: {
      _this->_internal_set_to_bytecode(from._internal_to_bytecode());
      break;
    }
    case TO_INSTRUCTIONS_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void V8CodeMove::CopyFrom(const V8CodeMove& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.V8CodeMove)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool V8CodeMove::IsInitialized() const {
  return true;
}

void V8CodeMove::InternalSwap(V8CodeMove* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(V8CodeMove, _impl_.tid_)
      + sizeof(V8CodeMove::_impl_.tid_)
      - PROTOBUF_FIELD_OFFSET(V8CodeMove, _impl_.isolate_iid_)>(
          reinterpret_cast<char*>(&_impl_.isolate_iid_),
          reinterpret_cast<char*>(&other->_impl_.isolate_iid_));
  swap(_impl_.to_instructions_, other->_impl_.to_instructions_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string V8CodeMove::GetTypeName() const {
  return "perfetto.protos.V8CodeMove";
}


// ===================================================================

class V8CodeDefaults::_Internal {
 public:
  using HasBits = decltype(std::declval<V8CodeDefaults>()._impl_._has_bits_);
  static void set_has_tid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

V8CodeDefaults::V8CodeDefaults(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.V8CodeDefaults)
}
V8CodeDefaults::V8CodeDefaults(const V8CodeDefaults& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  V8CodeDefaults* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.tid_ = from._impl_.tid_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.V8CodeDefaults)
}

inline void V8CodeDefaults::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tid_){0u}
  };
}

V8CodeDefaults::~V8CodeDefaults() {
  // @@protoc_insertion_point(destructor:perfetto.protos.V8CodeDefaults)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void V8CodeDefaults::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void V8CodeDefaults::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void V8CodeDefaults::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.V8CodeDefaults)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tid_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* V8CodeDefaults::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 tid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_tid(&has_bits);
          _impl_.tid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* V8CodeDefaults::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.V8CodeDefaults)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 tid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_tid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.V8CodeDefaults)
  return target;
}

size_t V8CodeDefaults::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.V8CodeDefaults)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 tid = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void V8CodeDefaults::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const V8CodeDefaults*>(
      &from));
}

void V8CodeDefaults::MergeFrom(const V8CodeDefaults& from) {
  V8CodeDefaults* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.V8CodeDefaults)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_tid()) {
    _this->_internal_set_tid(from._internal_tid());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void V8CodeDefaults::CopyFrom(const V8CodeDefaults& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.V8CodeDefaults)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool V8CodeDefaults::IsInitialized() const {
  return true;
}

void V8CodeDefaults::InternalSwap(V8CodeDefaults* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.tid_, other->_impl_.tid_);
}

std::string V8CodeDefaults::GetTypeName() const {
  return "perfetto.protos.V8CodeDefaults";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace protos
}  // namespace perfetto
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::perfetto::protos::V8String*
Arena::CreateMaybeMessage< ::perfetto::protos::V8String >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::V8String >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::InternedV8String*
Arena::CreateMaybeMessage< ::perfetto::protos::InternedV8String >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::InternedV8String >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::InternedV8JsScript*
Arena::CreateMaybeMessage< ::perfetto::protos::InternedV8JsScript >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::InternedV8JsScript >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::InternedV8WasmScript*
Arena::CreateMaybeMessage< ::perfetto::protos::InternedV8WasmScript >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::InternedV8WasmScript >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::InternedV8JsFunction*
Arena::CreateMaybeMessage< ::perfetto::protos::InternedV8JsFunction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::InternedV8JsFunction >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::InternedV8Isolate_CodeRange*
Arena::CreateMaybeMessage< ::perfetto::protos::InternedV8Isolate_CodeRange >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::InternedV8Isolate_CodeRange >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::InternedV8Isolate*
Arena::CreateMaybeMessage< ::perfetto::protos::InternedV8Isolate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::InternedV8Isolate >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::V8JsCode*
Arena::CreateMaybeMessage< ::perfetto::protos::V8JsCode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::V8JsCode >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::V8InternalCode*
Arena::CreateMaybeMessage< ::perfetto::protos::V8InternalCode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::V8InternalCode >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::V8WasmCode*
Arena::CreateMaybeMessage< ::perfetto::protos::V8WasmCode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::V8WasmCode >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::V8RegExpCode*
Arena::CreateMaybeMessage< ::perfetto::protos::V8RegExpCode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::V8RegExpCode >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::V8CodeMove*
Arena::CreateMaybeMessage< ::perfetto::protos::V8CodeMove >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::V8CodeMove >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::V8CodeDefaults*
Arena::CreateMaybeMessage< ::perfetto::protos::V8CodeDefaults >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::V8CodeDefaults >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
