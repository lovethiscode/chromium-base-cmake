// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/trace/chrome/v8.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_protos_2fperfetto_2ftrace_2fchrome_2fv8_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_protos_2fperfetto_2ftrace_2fchrome_2fv8_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_protos_2fperfetto_2ftrace_2fchrome_2fv8_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_protos_2fperfetto_2ftrace_2fchrome_2fv8_2eproto {
  static const uint32_t offsets[];
};
namespace perfetto {
namespace protos {
class InternedV8Isolate;
struct InternedV8IsolateDefaultTypeInternal;
extern InternedV8IsolateDefaultTypeInternal _InternedV8Isolate_default_instance_;
class InternedV8Isolate_CodeRange;
struct InternedV8Isolate_CodeRangeDefaultTypeInternal;
extern InternedV8Isolate_CodeRangeDefaultTypeInternal _InternedV8Isolate_CodeRange_default_instance_;
class InternedV8JsFunction;
struct InternedV8JsFunctionDefaultTypeInternal;
extern InternedV8JsFunctionDefaultTypeInternal _InternedV8JsFunction_default_instance_;
class InternedV8JsScript;
struct InternedV8JsScriptDefaultTypeInternal;
extern InternedV8JsScriptDefaultTypeInternal _InternedV8JsScript_default_instance_;
class InternedV8String;
struct InternedV8StringDefaultTypeInternal;
extern InternedV8StringDefaultTypeInternal _InternedV8String_default_instance_;
class InternedV8WasmScript;
struct InternedV8WasmScriptDefaultTypeInternal;
extern InternedV8WasmScriptDefaultTypeInternal _InternedV8WasmScript_default_instance_;
class V8CodeDefaults;
struct V8CodeDefaultsDefaultTypeInternal;
extern V8CodeDefaultsDefaultTypeInternal _V8CodeDefaults_default_instance_;
class V8CodeMove;
struct V8CodeMoveDefaultTypeInternal;
extern V8CodeMoveDefaultTypeInternal _V8CodeMove_default_instance_;
class V8InternalCode;
struct V8InternalCodeDefaultTypeInternal;
extern V8InternalCodeDefaultTypeInternal _V8InternalCode_default_instance_;
class V8JsCode;
struct V8JsCodeDefaultTypeInternal;
extern V8JsCodeDefaultTypeInternal _V8JsCode_default_instance_;
class V8RegExpCode;
struct V8RegExpCodeDefaultTypeInternal;
extern V8RegExpCodeDefaultTypeInternal _V8RegExpCode_default_instance_;
class V8String;
struct V8StringDefaultTypeInternal;
extern V8StringDefaultTypeInternal _V8String_default_instance_;
class V8WasmCode;
struct V8WasmCodeDefaultTypeInternal;
extern V8WasmCodeDefaultTypeInternal _V8WasmCode_default_instance_;
}  // namespace protos
}  // namespace perfetto
PROTOBUF_NAMESPACE_OPEN
template<> ::perfetto::protos::InternedV8Isolate* Arena::CreateMaybeMessage<::perfetto::protos::InternedV8Isolate>(Arena*);
template<> ::perfetto::protos::InternedV8Isolate_CodeRange* Arena::CreateMaybeMessage<::perfetto::protos::InternedV8Isolate_CodeRange>(Arena*);
template<> ::perfetto::protos::InternedV8JsFunction* Arena::CreateMaybeMessage<::perfetto::protos::InternedV8JsFunction>(Arena*);
template<> ::perfetto::protos::InternedV8JsScript* Arena::CreateMaybeMessage<::perfetto::protos::InternedV8JsScript>(Arena*);
template<> ::perfetto::protos::InternedV8String* Arena::CreateMaybeMessage<::perfetto::protos::InternedV8String>(Arena*);
template<> ::perfetto::protos::InternedV8WasmScript* Arena::CreateMaybeMessage<::perfetto::protos::InternedV8WasmScript>(Arena*);
template<> ::perfetto::protos::V8CodeDefaults* Arena::CreateMaybeMessage<::perfetto::protos::V8CodeDefaults>(Arena*);
template<> ::perfetto::protos::V8CodeMove* Arena::CreateMaybeMessage<::perfetto::protos::V8CodeMove>(Arena*);
template<> ::perfetto::protos::V8InternalCode* Arena::CreateMaybeMessage<::perfetto::protos::V8InternalCode>(Arena*);
template<> ::perfetto::protos::V8JsCode* Arena::CreateMaybeMessage<::perfetto::protos::V8JsCode>(Arena*);
template<> ::perfetto::protos::V8RegExpCode* Arena::CreateMaybeMessage<::perfetto::protos::V8RegExpCode>(Arena*);
template<> ::perfetto::protos::V8String* Arena::CreateMaybeMessage<::perfetto::protos::V8String>(Arena*);
template<> ::perfetto::protos::V8WasmCode* Arena::CreateMaybeMessage<::perfetto::protos::V8WasmCode>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace perfetto {
namespace protos {

enum InternedV8JsScript_Type : int {
  InternedV8JsScript_Type_TYPE_UNKNOWN = 0,
  InternedV8JsScript_Type_TYPE_NORMAL = 1,
  InternedV8JsScript_Type_TYPE_EVAL = 2,
  InternedV8JsScript_Type_TYPE_MODULE = 3,
  InternedV8JsScript_Type_TYPE_NATIVE = 4,
  InternedV8JsScript_Type_TYPE_EXTENSION = 5,
  InternedV8JsScript_Type_TYPE_INSPECTOR = 6
};
bool InternedV8JsScript_Type_IsValid(int value);
constexpr InternedV8JsScript_Type InternedV8JsScript_Type_Type_MIN = InternedV8JsScript_Type_TYPE_UNKNOWN;
constexpr InternedV8JsScript_Type InternedV8JsScript_Type_Type_MAX = InternedV8JsScript_Type_TYPE_INSPECTOR;
constexpr int InternedV8JsScript_Type_Type_ARRAYSIZE = InternedV8JsScript_Type_Type_MAX + 1;

const std::string& InternedV8JsScript_Type_Name(InternedV8JsScript_Type value);
template<typename T>
inline const std::string& InternedV8JsScript_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InternedV8JsScript_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InternedV8JsScript_Type_Name.");
  return InternedV8JsScript_Type_Name(static_cast<InternedV8JsScript_Type>(enum_t_value));
}
bool InternedV8JsScript_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InternedV8JsScript_Type* value);
enum InternedV8JsFunction_Kind : int {
  InternedV8JsFunction_Kind_KIND_UNKNOWN = 0,
  InternedV8JsFunction_Kind_KIND_NORMAL_FUNCTION = 1,
  InternedV8JsFunction_Kind_KIND_MODULE = 2,
  InternedV8JsFunction_Kind_KIND_ASYNC_MODULE = 3,
  InternedV8JsFunction_Kind_KIND_BASE_CONSTRUCTOR = 4,
  InternedV8JsFunction_Kind_KIND_DEFAULT_BASE_CONSTRUCTOR = 5,
  InternedV8JsFunction_Kind_KIND_DEFAULT_DERIVED_CONSTRUCTOR = 6,
  InternedV8JsFunction_Kind_KIND_DERIVED_CONSTRUCTOR = 7,
  InternedV8JsFunction_Kind_KIND_GETTER_FUNCTION = 8,
  InternedV8JsFunction_Kind_KIND_STATIC_GETTER_FUNCTION = 9,
  InternedV8JsFunction_Kind_KIND_SETTER_FUNCTION = 10,
  InternedV8JsFunction_Kind_KIND_STATIC_SETTER_FUNCTION = 11,
  InternedV8JsFunction_Kind_KIND_ARROW_FUNCTION = 12,
  InternedV8JsFunction_Kind_KIND_ASYNC_ARROW_FUNCTION = 13,
  InternedV8JsFunction_Kind_KIND_ASYNC_FUNCTION = 14,
  InternedV8JsFunction_Kind_KIND_ASYNC_CONCISE_METHOD = 15,
  InternedV8JsFunction_Kind_KIND_STATIC_ASYNC_CONCISE_METHOD = 16,
  InternedV8JsFunction_Kind_KIND_ASYNC_CONCISE_GENERATOR_METHOD = 17,
  InternedV8JsFunction_Kind_KIND_STATIC_ASYNC_CONCISE_GENERATOR_METHOD = 18,
  InternedV8JsFunction_Kind_KIND_ASYNC_GENERATOR_FUNCTION = 19,
  InternedV8JsFunction_Kind_KIND_GENERATOR_FUNCTION = 20,
  InternedV8JsFunction_Kind_KIND_CONCISE_GENERATOR_METHOD = 21,
  InternedV8JsFunction_Kind_KIND_STATIC_CONCISE_GENERATOR_METHOD = 22,
  InternedV8JsFunction_Kind_KIND_CONCISE_METHOD = 23,
  InternedV8JsFunction_Kind_KIND_STATIC_CONCISE_METHOD = 24,
  InternedV8JsFunction_Kind_KIND_CLASS_MEMBERS_INITIALIZER_FUNCTION = 25,
  InternedV8JsFunction_Kind_KIND_CLASS_STATIC_INITIALIZER_FUNCTION = 26,
  InternedV8JsFunction_Kind_KIND_INVALID = 27
};
bool InternedV8JsFunction_Kind_IsValid(int value);
constexpr InternedV8JsFunction_Kind InternedV8JsFunction_Kind_Kind_MIN = InternedV8JsFunction_Kind_KIND_UNKNOWN;
constexpr InternedV8JsFunction_Kind InternedV8JsFunction_Kind_Kind_MAX = InternedV8JsFunction_Kind_KIND_INVALID;
constexpr int InternedV8JsFunction_Kind_Kind_ARRAYSIZE = InternedV8JsFunction_Kind_Kind_MAX + 1;

const std::string& InternedV8JsFunction_Kind_Name(InternedV8JsFunction_Kind value);
template<typename T>
inline const std::string& InternedV8JsFunction_Kind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InternedV8JsFunction_Kind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InternedV8JsFunction_Kind_Name.");
  return InternedV8JsFunction_Kind_Name(static_cast<InternedV8JsFunction_Kind>(enum_t_value));
}
bool InternedV8JsFunction_Kind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InternedV8JsFunction_Kind* value);
enum V8JsCode_Tier : int {
  V8JsCode_Tier_TIER_UNKNOWN = 0,
  V8JsCode_Tier_TIER_IGNITION = 1,
  V8JsCode_Tier_TIER_SPARKPLUG = 2,
  V8JsCode_Tier_TIER_MAGLEV = 3,
  V8JsCode_Tier_TIER_TURBOSHAFT = 4,
  V8JsCode_Tier_TIER_TURBOFAN = 5
};
bool V8JsCode_Tier_IsValid(int value);
constexpr V8JsCode_Tier V8JsCode_Tier_Tier_MIN = V8JsCode_Tier_TIER_UNKNOWN;
constexpr V8JsCode_Tier V8JsCode_Tier_Tier_MAX = V8JsCode_Tier_TIER_TURBOFAN;
constexpr int V8JsCode_Tier_Tier_ARRAYSIZE = V8JsCode_Tier_Tier_MAX + 1;

const std::string& V8JsCode_Tier_Name(V8JsCode_Tier value);
template<typename T>
inline const std::string& V8JsCode_Tier_Name(T enum_t_value) {
  static_assert(::std::is_same<T, V8JsCode_Tier>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function V8JsCode_Tier_Name.");
  return V8JsCode_Tier_Name(static_cast<V8JsCode_Tier>(enum_t_value));
}
bool V8JsCode_Tier_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, V8JsCode_Tier* value);
enum V8InternalCode_Type : int {
  V8InternalCode_Type_TYPE_UNKNOWN = 0,
  V8InternalCode_Type_TYPE_BYTECODE_HANDLER = 1,
  V8InternalCode_Type_TYPE_FOR_TESTING = 2,
  V8InternalCode_Type_TYPE_BUILTIN = 3,
  V8InternalCode_Type_TYPE_WASM_FUNCTION = 4,
  V8InternalCode_Type_TYPE_WASM_TO_CAPI_FUNCTION = 5,
  V8InternalCode_Type_TYPE_WASM_TO_JS_FUNCTION = 6,
  V8InternalCode_Type_TYPE_JS_TO_WASM_FUNCTION = 7,
  V8InternalCode_Type_TYPE_JS_TO_JS_FUNCTION = 8,
  V8InternalCode_Type_TYPE_C_WASM_ENTRY = 9
};
bool V8InternalCode_Type_IsValid(int value);
constexpr V8InternalCode_Type V8InternalCode_Type_Type_MIN = V8InternalCode_Type_TYPE_UNKNOWN;
constexpr V8InternalCode_Type V8InternalCode_Type_Type_MAX = V8InternalCode_Type_TYPE_C_WASM_ENTRY;
constexpr int V8InternalCode_Type_Type_ARRAYSIZE = V8InternalCode_Type_Type_MAX + 1;

const std::string& V8InternalCode_Type_Name(V8InternalCode_Type value);
template<typename T>
inline const std::string& V8InternalCode_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, V8InternalCode_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function V8InternalCode_Type_Name.");
  return V8InternalCode_Type_Name(static_cast<V8InternalCode_Type>(enum_t_value));
}
bool V8InternalCode_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, V8InternalCode_Type* value);
enum V8WasmCode_Tier : int {
  V8WasmCode_Tier_TIER_UNKNOWN = 0,
  V8WasmCode_Tier_TIER_LIFTOFF = 1,
  V8WasmCode_Tier_TIER_TURBOFAN = 2
};
bool V8WasmCode_Tier_IsValid(int value);
constexpr V8WasmCode_Tier V8WasmCode_Tier_Tier_MIN = V8WasmCode_Tier_TIER_UNKNOWN;
constexpr V8WasmCode_Tier V8WasmCode_Tier_Tier_MAX = V8WasmCode_Tier_TIER_TURBOFAN;
constexpr int V8WasmCode_Tier_Tier_ARRAYSIZE = V8WasmCode_Tier_Tier_MAX + 1;

const std::string& V8WasmCode_Tier_Name(V8WasmCode_Tier value);
template<typename T>
inline const std::string& V8WasmCode_Tier_Name(T enum_t_value) {
  static_assert(::std::is_same<T, V8WasmCode_Tier>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function V8WasmCode_Tier_Name.");
  return V8WasmCode_Tier_Name(static_cast<V8WasmCode_Tier>(enum_t_value));
}
bool V8WasmCode_Tier_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, V8WasmCode_Tier* value);
// ===================================================================

class V8String final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.V8String) */ {
 public:
  inline V8String() : V8String(nullptr) {}
  ~V8String() override;
  explicit PROTOBUF_CONSTEXPR V8String(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  V8String(const V8String& from);
  V8String(V8String&& from) noexcept
    : V8String() {
    *this = ::std::move(from);
  }

  inline V8String& operator=(const V8String& from) {
    CopyFrom(from);
    return *this;
  }
  inline V8String& operator=(V8String&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const V8String& default_instance() {
    return *internal_default_instance();
  }
  enum EncodedStringCase {
    kLatin1 = 1,
    kUtf16Le = 2,
    kUtf16Be = 3,
    ENCODED_STRING_NOT_SET = 0,
  };

  static inline const V8String* internal_default_instance() {
    return reinterpret_cast<const V8String*>(
               &_V8String_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(V8String& a, V8String& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(V8String* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(V8String* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  V8String* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<V8String>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const V8String& from);
  void MergeFrom(const V8String& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(V8String* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.V8String";
  }
  protected:
  explicit V8String(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatin1FieldNumber = 1,
    kUtf16LeFieldNumber = 2,
    kUtf16BeFieldNumber = 3,
  };
  // bytes latin1 = 1;
  bool has_latin1() const;
  private:
  bool _internal_has_latin1() const;
  public:
  void clear_latin1();
  const std::string& latin1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_latin1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_latin1();
  PROTOBUF_NODISCARD std::string* release_latin1();
  void set_allocated_latin1(std::string* latin1);
  private:
  const std::string& _internal_latin1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_latin1(const std::string& value);
  std::string* _internal_mutable_latin1();
  public:

  // bytes utf16_le = 2;
  bool has_utf16_le() const;
  private:
  bool _internal_has_utf16_le() const;
  public:
  void clear_utf16_le();
  const std::string& utf16_le() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_utf16_le(ArgT0&& arg0, ArgT... args);
  std::string* mutable_utf16_le();
  PROTOBUF_NODISCARD std::string* release_utf16_le();
  void set_allocated_utf16_le(std::string* utf16_le);
  private:
  const std::string& _internal_utf16_le() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_utf16_le(const std::string& value);
  std::string* _internal_mutable_utf16_le();
  public:

  // bytes utf16_be = 3;
  bool has_utf16_be() const;
  private:
  bool _internal_has_utf16_be() const;
  public:
  void clear_utf16_be();
  const std::string& utf16_be() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_utf16_be(ArgT0&& arg0, ArgT... args);
  std::string* mutable_utf16_be();
  PROTOBUF_NODISCARD std::string* release_utf16_be();
  void set_allocated_utf16_be(std::string* utf16_be);
  private:
  const std::string& _internal_utf16_be() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_utf16_be(const std::string& value);
  std::string* _internal_mutable_utf16_be();
  public:

  void clear_encoded_string();
  EncodedStringCase encoded_string_case() const;
  // @@protoc_insertion_point(class_scope:perfetto.protos.V8String)
 private:
  class _Internal;
  void set_has_latin1();
  void set_has_utf16_le();
  void set_has_utf16_be();

  inline bool has_encoded_string() const;
  inline void clear_has_encoded_string();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union EncodedStringUnion {
      constexpr EncodedStringUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr latin1_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr utf16_le_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr utf16_be_;
    } encoded_string_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fchrome_2fv8_2eproto;
};
// -------------------------------------------------------------------

class InternedV8String final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.InternedV8String) */ {
 public:
  inline InternedV8String() : InternedV8String(nullptr) {}
  ~InternedV8String() override;
  explicit PROTOBUF_CONSTEXPR InternedV8String(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InternedV8String(const InternedV8String& from);
  InternedV8String(InternedV8String&& from) noexcept
    : InternedV8String() {
    *this = ::std::move(from);
  }

  inline InternedV8String& operator=(const InternedV8String& from) {
    CopyFrom(from);
    return *this;
  }
  inline InternedV8String& operator=(InternedV8String&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const InternedV8String& default_instance() {
    return *internal_default_instance();
  }
  enum EncodedStringCase {
    kLatin1 = 2,
    kUtf16Le = 3,
    kUtf16Be = 4,
    ENCODED_STRING_NOT_SET = 0,
  };

  static inline const InternedV8String* internal_default_instance() {
    return reinterpret_cast<const InternedV8String*>(
               &_InternedV8String_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(InternedV8String& a, InternedV8String& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(InternedV8String* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InternedV8String* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InternedV8String* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InternedV8String>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const InternedV8String& from);
  void MergeFrom(const InternedV8String& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InternedV8String* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.InternedV8String";
  }
  protected:
  explicit InternedV8String(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIidFieldNumber = 1,
    kLatin1FieldNumber = 2,
    kUtf16LeFieldNumber = 3,
    kUtf16BeFieldNumber = 4,
  };
  // optional uint64 iid = 1;
  bool has_iid() const;
  private:
  bool _internal_has_iid() const;
  public:
  void clear_iid();
  uint64_t iid() const;
  void set_iid(uint64_t value);
  private:
  uint64_t _internal_iid() const;
  void _internal_set_iid(uint64_t value);
  public:

  // bytes latin1 = 2;
  bool has_latin1() const;
  private:
  bool _internal_has_latin1() const;
  public:
  void clear_latin1();
  const std::string& latin1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_latin1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_latin1();
  PROTOBUF_NODISCARD std::string* release_latin1();
  void set_allocated_latin1(std::string* latin1);
  private:
  const std::string& _internal_latin1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_latin1(const std::string& value);
  std::string* _internal_mutable_latin1();
  public:

  // bytes utf16_le = 3;
  bool has_utf16_le() const;
  private:
  bool _internal_has_utf16_le() const;
  public:
  void clear_utf16_le();
  const std::string& utf16_le() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_utf16_le(ArgT0&& arg0, ArgT... args);
  std::string* mutable_utf16_le();
  PROTOBUF_NODISCARD std::string* release_utf16_le();
  void set_allocated_utf16_le(std::string* utf16_le);
  private:
  const std::string& _internal_utf16_le() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_utf16_le(const std::string& value);
  std::string* _internal_mutable_utf16_le();
  public:

  // bytes utf16_be = 4;
  bool has_utf16_be() const;
  private:
  bool _internal_has_utf16_be() const;
  public:
  void clear_utf16_be();
  const std::string& utf16_be() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_utf16_be(ArgT0&& arg0, ArgT... args);
  std::string* mutable_utf16_be();
  PROTOBUF_NODISCARD std::string* release_utf16_be();
  void set_allocated_utf16_be(std::string* utf16_be);
  private:
  const std::string& _internal_utf16_be() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_utf16_be(const std::string& value);
  std::string* _internal_mutable_utf16_be();
  public:

  void clear_encoded_string();
  EncodedStringCase encoded_string_case() const;
  // @@protoc_insertion_point(class_scope:perfetto.protos.InternedV8String)
 private:
  class _Internal;
  void set_has_latin1();
  void set_has_utf16_le();
  void set_has_utf16_be();

  inline bool has_encoded_string() const;
  inline void clear_has_encoded_string();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t iid_;
    union EncodedStringUnion {
      constexpr EncodedStringUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr latin1_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr utf16_le_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr utf16_be_;
    } encoded_string_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fchrome_2fv8_2eproto;
};
// -------------------------------------------------------------------

class InternedV8JsScript final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.InternedV8JsScript) */ {
 public:
  inline InternedV8JsScript() : InternedV8JsScript(nullptr) {}
  ~InternedV8JsScript() override;
  explicit PROTOBUF_CONSTEXPR InternedV8JsScript(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InternedV8JsScript(const InternedV8JsScript& from);
  InternedV8JsScript(InternedV8JsScript&& from) noexcept
    : InternedV8JsScript() {
    *this = ::std::move(from);
  }

  inline InternedV8JsScript& operator=(const InternedV8JsScript& from) {
    CopyFrom(from);
    return *this;
  }
  inline InternedV8JsScript& operator=(InternedV8JsScript&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const InternedV8JsScript& default_instance() {
    return *internal_default_instance();
  }
  static inline const InternedV8JsScript* internal_default_instance() {
    return reinterpret_cast<const InternedV8JsScript*>(
               &_InternedV8JsScript_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(InternedV8JsScript& a, InternedV8JsScript& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(InternedV8JsScript* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InternedV8JsScript* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InternedV8JsScript* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InternedV8JsScript>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const InternedV8JsScript& from);
  void MergeFrom(const InternedV8JsScript& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InternedV8JsScript* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.InternedV8JsScript";
  }
  protected:
  explicit InternedV8JsScript(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef InternedV8JsScript_Type Type;
  static constexpr Type TYPE_UNKNOWN =
    InternedV8JsScript_Type_TYPE_UNKNOWN;
  static constexpr Type TYPE_NORMAL =
    InternedV8JsScript_Type_TYPE_NORMAL;
  static constexpr Type TYPE_EVAL =
    InternedV8JsScript_Type_TYPE_EVAL;
  static constexpr Type TYPE_MODULE =
    InternedV8JsScript_Type_TYPE_MODULE;
  static constexpr Type TYPE_NATIVE =
    InternedV8JsScript_Type_TYPE_NATIVE;
  static constexpr Type TYPE_EXTENSION =
    InternedV8JsScript_Type_TYPE_EXTENSION;
  static constexpr Type TYPE_INSPECTOR =
    InternedV8JsScript_Type_TYPE_INSPECTOR;
  static inline bool Type_IsValid(int value) {
    return InternedV8JsScript_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    InternedV8JsScript_Type_Type_MIN;
  static constexpr Type Type_MAX =
    InternedV8JsScript_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    InternedV8JsScript_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return InternedV8JsScript_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return InternedV8JsScript_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 4,
    kSourceFieldNumber = 5,
    kIidFieldNumber = 1,
    kScriptIdFieldNumber = 2,
    kTypeFieldNumber = 3,
  };
  // optional .perfetto.protos.V8String name = 4;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const ::perfetto::protos::V8String& name() const;
  PROTOBUF_NODISCARD ::perfetto::protos::V8String* release_name();
  ::perfetto::protos::V8String* mutable_name();
  void set_allocated_name(::perfetto::protos::V8String* name);
  private:
  const ::perfetto::protos::V8String& _internal_name() const;
  ::perfetto::protos::V8String* _internal_mutable_name();
  public:
  void unsafe_arena_set_allocated_name(
      ::perfetto::protos::V8String* name);
  ::perfetto::protos::V8String* unsafe_arena_release_name();

  // optional .perfetto.protos.V8String source = 5;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const ::perfetto::protos::V8String& source() const;
  PROTOBUF_NODISCARD ::perfetto::protos::V8String* release_source();
  ::perfetto::protos::V8String* mutable_source();
  void set_allocated_source(::perfetto::protos::V8String* source);
  private:
  const ::perfetto::protos::V8String& _internal_source() const;
  ::perfetto::protos::V8String* _internal_mutable_source();
  public:
  void unsafe_arena_set_allocated_source(
      ::perfetto::protos::V8String* source);
  ::perfetto::protos::V8String* unsafe_arena_release_source();

  // optional uint64 iid = 1;
  bool has_iid() const;
  private:
  bool _internal_has_iid() const;
  public:
  void clear_iid();
  uint64_t iid() const;
  void set_iid(uint64_t value);
  private:
  uint64_t _internal_iid() const;
  void _internal_set_iid(uint64_t value);
  public:

  // optional int32 script_id = 2;
  bool has_script_id() const;
  private:
  bool _internal_has_script_id() const;
  public:
  void clear_script_id();
  int32_t script_id() const;
  void set_script_id(int32_t value);
  private:
  int32_t _internal_script_id() const;
  void _internal_set_script_id(int32_t value);
  public:

  // optional .perfetto.protos.InternedV8JsScript.Type type = 3;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::perfetto::protos::InternedV8JsScript_Type type() const;
  void set_type(::perfetto::protos::InternedV8JsScript_Type value);
  private:
  ::perfetto::protos::InternedV8JsScript_Type _internal_type() const;
  void _internal_set_type(::perfetto::protos::InternedV8JsScript_Type value);
  public:

  // @@protoc_insertion_point(class_scope:perfetto.protos.InternedV8JsScript)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::perfetto::protos::V8String* name_;
    ::perfetto::protos::V8String* source_;
    uint64_t iid_;
    int32_t script_id_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fchrome_2fv8_2eproto;
};
// -------------------------------------------------------------------

class InternedV8WasmScript final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.InternedV8WasmScript) */ {
 public:
  inline InternedV8WasmScript() : InternedV8WasmScript(nullptr) {}
  ~InternedV8WasmScript() override;
  explicit PROTOBUF_CONSTEXPR InternedV8WasmScript(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InternedV8WasmScript(const InternedV8WasmScript& from);
  InternedV8WasmScript(InternedV8WasmScript&& from) noexcept
    : InternedV8WasmScript() {
    *this = ::std::move(from);
  }

  inline InternedV8WasmScript& operator=(const InternedV8WasmScript& from) {
    CopyFrom(from);
    return *this;
  }
  inline InternedV8WasmScript& operator=(InternedV8WasmScript&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const InternedV8WasmScript& default_instance() {
    return *internal_default_instance();
  }
  static inline const InternedV8WasmScript* internal_default_instance() {
    return reinterpret_cast<const InternedV8WasmScript*>(
               &_InternedV8WasmScript_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(InternedV8WasmScript& a, InternedV8WasmScript& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(InternedV8WasmScript* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InternedV8WasmScript* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InternedV8WasmScript* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InternedV8WasmScript>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const InternedV8WasmScript& from);
  void MergeFrom(const InternedV8WasmScript& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InternedV8WasmScript* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.InternedV8WasmScript";
  }
  protected:
  explicit InternedV8WasmScript(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 3,
    kIidFieldNumber = 1,
    kScriptIdFieldNumber = 2,
  };
  // optional string url = 3;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional uint64 iid = 1;
  bool has_iid() const;
  private:
  bool _internal_has_iid() const;
  public:
  void clear_iid();
  uint64_t iid() const;
  void set_iid(uint64_t value);
  private:
  uint64_t _internal_iid() const;
  void _internal_set_iid(uint64_t value);
  public:

  // optional int32 script_id = 2;
  bool has_script_id() const;
  private:
  bool _internal_has_script_id() const;
  public:
  void clear_script_id();
  int32_t script_id() const;
  void set_script_id(int32_t value);
  private:
  int32_t _internal_script_id() const;
  void _internal_set_script_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:perfetto.protos.InternedV8WasmScript)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    uint64_t iid_;
    int32_t script_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fchrome_2fv8_2eproto;
};
// -------------------------------------------------------------------

class InternedV8JsFunction final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.InternedV8JsFunction) */ {
 public:
  inline InternedV8JsFunction() : InternedV8JsFunction(nullptr) {}
  ~InternedV8JsFunction() override;
  explicit PROTOBUF_CONSTEXPR InternedV8JsFunction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InternedV8JsFunction(const InternedV8JsFunction& from);
  InternedV8JsFunction(InternedV8JsFunction&& from) noexcept
    : InternedV8JsFunction() {
    *this = ::std::move(from);
  }

  inline InternedV8JsFunction& operator=(const InternedV8JsFunction& from) {
    CopyFrom(from);
    return *this;
  }
  inline InternedV8JsFunction& operator=(InternedV8JsFunction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const InternedV8JsFunction& default_instance() {
    return *internal_default_instance();
  }
  static inline const InternedV8JsFunction* internal_default_instance() {
    return reinterpret_cast<const InternedV8JsFunction*>(
               &_InternedV8JsFunction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(InternedV8JsFunction& a, InternedV8JsFunction& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(InternedV8JsFunction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InternedV8JsFunction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InternedV8JsFunction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InternedV8JsFunction>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const InternedV8JsFunction& from);
  void MergeFrom(const InternedV8JsFunction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InternedV8JsFunction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.InternedV8JsFunction";
  }
  protected:
  explicit InternedV8JsFunction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef InternedV8JsFunction_Kind Kind;
  static constexpr Kind KIND_UNKNOWN =
    InternedV8JsFunction_Kind_KIND_UNKNOWN;
  static constexpr Kind KIND_NORMAL_FUNCTION =
    InternedV8JsFunction_Kind_KIND_NORMAL_FUNCTION;
  static constexpr Kind KIND_MODULE =
    InternedV8JsFunction_Kind_KIND_MODULE;
  static constexpr Kind KIND_ASYNC_MODULE =
    InternedV8JsFunction_Kind_KIND_ASYNC_MODULE;
  static constexpr Kind KIND_BASE_CONSTRUCTOR =
    InternedV8JsFunction_Kind_KIND_BASE_CONSTRUCTOR;
  static constexpr Kind KIND_DEFAULT_BASE_CONSTRUCTOR =
    InternedV8JsFunction_Kind_KIND_DEFAULT_BASE_CONSTRUCTOR;
  static constexpr Kind KIND_DEFAULT_DERIVED_CONSTRUCTOR =
    InternedV8JsFunction_Kind_KIND_DEFAULT_DERIVED_CONSTRUCTOR;
  static constexpr Kind KIND_DERIVED_CONSTRUCTOR =
    InternedV8JsFunction_Kind_KIND_DERIVED_CONSTRUCTOR;
  static constexpr Kind KIND_GETTER_FUNCTION =
    InternedV8JsFunction_Kind_KIND_GETTER_FUNCTION;
  static constexpr Kind KIND_STATIC_GETTER_FUNCTION =
    InternedV8JsFunction_Kind_KIND_STATIC_GETTER_FUNCTION;
  static constexpr Kind KIND_SETTER_FUNCTION =
    InternedV8JsFunction_Kind_KIND_SETTER_FUNCTION;
  static constexpr Kind KIND_STATIC_SETTER_FUNCTION =
    InternedV8JsFunction_Kind_KIND_STATIC_SETTER_FUNCTION;
  static constexpr Kind KIND_ARROW_FUNCTION =
    InternedV8JsFunction_Kind_KIND_ARROW_FUNCTION;
  static constexpr Kind KIND_ASYNC_ARROW_FUNCTION =
    InternedV8JsFunction_Kind_KIND_ASYNC_ARROW_FUNCTION;
  static constexpr Kind KIND_ASYNC_FUNCTION =
    InternedV8JsFunction_Kind_KIND_ASYNC_FUNCTION;
  static constexpr Kind KIND_ASYNC_CONCISE_METHOD =
    InternedV8JsFunction_Kind_KIND_ASYNC_CONCISE_METHOD;
  static constexpr Kind KIND_STATIC_ASYNC_CONCISE_METHOD =
    InternedV8JsFunction_Kind_KIND_STATIC_ASYNC_CONCISE_METHOD;
  static constexpr Kind KIND_ASYNC_CONCISE_GENERATOR_METHOD =
    InternedV8JsFunction_Kind_KIND_ASYNC_CONCISE_GENERATOR_METHOD;
  static constexpr Kind KIND_STATIC_ASYNC_CONCISE_GENERATOR_METHOD =
    InternedV8JsFunction_Kind_KIND_STATIC_ASYNC_CONCISE_GENERATOR_METHOD;
  static constexpr Kind KIND_ASYNC_GENERATOR_FUNCTION =
    InternedV8JsFunction_Kind_KIND_ASYNC_GENERATOR_FUNCTION;
  static constexpr Kind KIND_GENERATOR_FUNCTION =
    InternedV8JsFunction_Kind_KIND_GENERATOR_FUNCTION;
  static constexpr Kind KIND_CONCISE_GENERATOR_METHOD =
    InternedV8JsFunction_Kind_KIND_CONCISE_GENERATOR_METHOD;
  static constexpr Kind KIND_STATIC_CONCISE_GENERATOR_METHOD =
    InternedV8JsFunction_Kind_KIND_STATIC_CONCISE_GENERATOR_METHOD;
  static constexpr Kind KIND_CONCISE_METHOD =
    InternedV8JsFunction_Kind_KIND_CONCISE_METHOD;
  static constexpr Kind KIND_STATIC_CONCISE_METHOD =
    InternedV8JsFunction_Kind_KIND_STATIC_CONCISE_METHOD;
  static constexpr Kind KIND_CLASS_MEMBERS_INITIALIZER_FUNCTION =
    InternedV8JsFunction_Kind_KIND_CLASS_MEMBERS_INITIALIZER_FUNCTION;
  static constexpr Kind KIND_CLASS_STATIC_INITIALIZER_FUNCTION =
    InternedV8JsFunction_Kind_KIND_CLASS_STATIC_INITIALIZER_FUNCTION;
  static constexpr Kind KIND_INVALID =
    InternedV8JsFunction_Kind_KIND_INVALID;
  static inline bool Kind_IsValid(int value) {
    return InternedV8JsFunction_Kind_IsValid(value);
  }
  static constexpr Kind Kind_MIN =
    InternedV8JsFunction_Kind_Kind_MIN;
  static constexpr Kind Kind_MAX =
    InternedV8JsFunction_Kind_Kind_MAX;
  static constexpr int Kind_ARRAYSIZE =
    InternedV8JsFunction_Kind_Kind_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Kind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Kind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Kind_Name.");
    return InternedV8JsFunction_Kind_Name(enum_t_value);
  }
  static inline bool Kind_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Kind* value) {
    return InternedV8JsFunction_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIidFieldNumber = 1,
    kV8JsFunctionNameIidFieldNumber = 2,
    kV8JsScriptIidFieldNumber = 3,
    kIsToplevelFieldNumber = 4,
    kKindFieldNumber = 5,
    kByteOffsetFieldNumber = 6,
  };
  // optional uint64 iid = 1;
  bool has_iid() const;
  private:
  bool _internal_has_iid() const;
  public:
  void clear_iid();
  uint64_t iid() const;
  void set_iid(uint64_t value);
  private:
  uint64_t _internal_iid() const;
  void _internal_set_iid(uint64_t value);
  public:

  // optional uint64 v8_js_function_name_iid = 2;
  bool has_v8_js_function_name_iid() const;
  private:
  bool _internal_has_v8_js_function_name_iid() const;
  public:
  void clear_v8_js_function_name_iid();
  uint64_t v8_js_function_name_iid() const;
  void set_v8_js_function_name_iid(uint64_t value);
  private:
  uint64_t _internal_v8_js_function_name_iid() const;
  void _internal_set_v8_js_function_name_iid(uint64_t value);
  public:

  // optional uint64 v8_js_script_iid = 3;
  bool has_v8_js_script_iid() const;
  private:
  bool _internal_has_v8_js_script_iid() const;
  public:
  void clear_v8_js_script_iid();
  uint64_t v8_js_script_iid() const;
  void set_v8_js_script_iid(uint64_t value);
  private:
  uint64_t _internal_v8_js_script_iid() const;
  void _internal_set_v8_js_script_iid(uint64_t value);
  public:

  // optional bool is_toplevel = 4;
  bool has_is_toplevel() const;
  private:
  bool _internal_has_is_toplevel() const;
  public:
  void clear_is_toplevel();
  bool is_toplevel() const;
  void set_is_toplevel(bool value);
  private:
  bool _internal_is_toplevel() const;
  void _internal_set_is_toplevel(bool value);
  public:

  // optional .perfetto.protos.InternedV8JsFunction.Kind kind = 5;
  bool has_kind() const;
  private:
  bool _internal_has_kind() const;
  public:
  void clear_kind();
  ::perfetto::protos::InternedV8JsFunction_Kind kind() const;
  void set_kind(::perfetto::protos::InternedV8JsFunction_Kind value);
  private:
  ::perfetto::protos::InternedV8JsFunction_Kind _internal_kind() const;
  void _internal_set_kind(::perfetto::protos::InternedV8JsFunction_Kind value);
  public:

  // optional uint32 byte_offset = 6;
  bool has_byte_offset() const;
  private:
  bool _internal_has_byte_offset() const;
  public:
  void clear_byte_offset();
  uint32_t byte_offset() const;
  void set_byte_offset(uint32_t value);
  private:
  uint32_t _internal_byte_offset() const;
  void _internal_set_byte_offset(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:perfetto.protos.InternedV8JsFunction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t iid_;
    uint64_t v8_js_function_name_iid_;
    uint64_t v8_js_script_iid_;
    bool is_toplevel_;
    int kind_;
    uint32_t byte_offset_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fchrome_2fv8_2eproto;
};
// -------------------------------------------------------------------

class InternedV8Isolate_CodeRange final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.InternedV8Isolate.CodeRange) */ {
 public:
  inline InternedV8Isolate_CodeRange() : InternedV8Isolate_CodeRange(nullptr) {}
  ~InternedV8Isolate_CodeRange() override;
  explicit PROTOBUF_CONSTEXPR InternedV8Isolate_CodeRange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InternedV8Isolate_CodeRange(const InternedV8Isolate_CodeRange& from);
  InternedV8Isolate_CodeRange(InternedV8Isolate_CodeRange&& from) noexcept
    : InternedV8Isolate_CodeRange() {
    *this = ::std::move(from);
  }

  inline InternedV8Isolate_CodeRange& operator=(const InternedV8Isolate_CodeRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline InternedV8Isolate_CodeRange& operator=(InternedV8Isolate_CodeRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const InternedV8Isolate_CodeRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const InternedV8Isolate_CodeRange* internal_default_instance() {
    return reinterpret_cast<const InternedV8Isolate_CodeRange*>(
               &_InternedV8Isolate_CodeRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(InternedV8Isolate_CodeRange& a, InternedV8Isolate_CodeRange& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(InternedV8Isolate_CodeRange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InternedV8Isolate_CodeRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InternedV8Isolate_CodeRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InternedV8Isolate_CodeRange>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const InternedV8Isolate_CodeRange& from);
  void MergeFrom(const InternedV8Isolate_CodeRange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InternedV8Isolate_CodeRange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.InternedV8Isolate.CodeRange";
  }
  protected:
  explicit InternedV8Isolate_CodeRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBaseAddressFieldNumber = 1,
    kSizeFieldNumber = 2,
    kEmbeddedBlobCodeCopyStartAddressFieldNumber = 3,
    kIsProcessWideFieldNumber = 4,
  };
  // optional uint64 base_address = 1;
  bool has_base_address() const;
  private:
  bool _internal_has_base_address() const;
  public:
  void clear_base_address();
  uint64_t base_address() const;
  void set_base_address(uint64_t value);
  private:
  uint64_t _internal_base_address() const;
  void _internal_set_base_address(uint64_t value);
  public:

  // optional uint64 size = 2;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // optional uint64 embedded_blob_code_copy_start_address = 3;
  bool has_embedded_blob_code_copy_start_address() const;
  private:
  bool _internal_has_embedded_blob_code_copy_start_address() const;
  public:
  void clear_embedded_blob_code_copy_start_address();
  uint64_t embedded_blob_code_copy_start_address() const;
  void set_embedded_blob_code_copy_start_address(uint64_t value);
  private:
  uint64_t _internal_embedded_blob_code_copy_start_address() const;
  void _internal_set_embedded_blob_code_copy_start_address(uint64_t value);
  public:

  // optional bool is_process_wide = 4;
  bool has_is_process_wide() const;
  private:
  bool _internal_has_is_process_wide() const;
  public:
  void clear_is_process_wide();
  bool is_process_wide() const;
  void set_is_process_wide(bool value);
  private:
  bool _internal_is_process_wide() const;
  void _internal_set_is_process_wide(bool value);
  public:

  // @@protoc_insertion_point(class_scope:perfetto.protos.InternedV8Isolate.CodeRange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t base_address_;
    uint64_t size_;
    uint64_t embedded_blob_code_copy_start_address_;
    bool is_process_wide_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fchrome_2fv8_2eproto;
};
// -------------------------------------------------------------------

class InternedV8Isolate final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.InternedV8Isolate) */ {
 public:
  inline InternedV8Isolate() : InternedV8Isolate(nullptr) {}
  ~InternedV8Isolate() override;
  explicit PROTOBUF_CONSTEXPR InternedV8Isolate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InternedV8Isolate(const InternedV8Isolate& from);
  InternedV8Isolate(InternedV8Isolate&& from) noexcept
    : InternedV8Isolate() {
    *this = ::std::move(from);
  }

  inline InternedV8Isolate& operator=(const InternedV8Isolate& from) {
    CopyFrom(from);
    return *this;
  }
  inline InternedV8Isolate& operator=(InternedV8Isolate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const InternedV8Isolate& default_instance() {
    return *internal_default_instance();
  }
  static inline const InternedV8Isolate* internal_default_instance() {
    return reinterpret_cast<const InternedV8Isolate*>(
               &_InternedV8Isolate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(InternedV8Isolate& a, InternedV8Isolate& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(InternedV8Isolate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InternedV8Isolate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InternedV8Isolate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InternedV8Isolate>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const InternedV8Isolate& from);
  void MergeFrom(const InternedV8Isolate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InternedV8Isolate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.InternedV8Isolate";
  }
  protected:
  explicit InternedV8Isolate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef InternedV8Isolate_CodeRange CodeRange;

  // accessors -------------------------------------------------------

  enum : int {
    kCodeRangeFieldNumber = 4,
    kIidFieldNumber = 1,
    kPidFieldNumber = 2,
    kIsolateIdFieldNumber = 3,
    kEmbeddedBlobCodeStartAddressFieldNumber = 5,
    kEmbeddedBlobCodeSizeFieldNumber = 6,
  };
  // optional .perfetto.protos.InternedV8Isolate.CodeRange code_range = 4;
  bool has_code_range() const;
  private:
  bool _internal_has_code_range() const;
  public:
  void clear_code_range();
  const ::perfetto::protos::InternedV8Isolate_CodeRange& code_range() const;
  PROTOBUF_NODISCARD ::perfetto::protos::InternedV8Isolate_CodeRange* release_code_range();
  ::perfetto::protos::InternedV8Isolate_CodeRange* mutable_code_range();
  void set_allocated_code_range(::perfetto::protos::InternedV8Isolate_CodeRange* code_range);
  private:
  const ::perfetto::protos::InternedV8Isolate_CodeRange& _internal_code_range() const;
  ::perfetto::protos::InternedV8Isolate_CodeRange* _internal_mutable_code_range();
  public:
  void unsafe_arena_set_allocated_code_range(
      ::perfetto::protos::InternedV8Isolate_CodeRange* code_range);
  ::perfetto::protos::InternedV8Isolate_CodeRange* unsafe_arena_release_code_range();

  // optional uint64 iid = 1;
  bool has_iid() const;
  private:
  bool _internal_has_iid() const;
  public:
  void clear_iid();
  uint64_t iid() const;
  void set_iid(uint64_t value);
  private:
  uint64_t _internal_iid() const;
  void _internal_set_iid(uint64_t value);
  public:

  // optional uint32 pid = 2;
  bool has_pid() const;
  private:
  bool _internal_has_pid() const;
  public:
  void clear_pid();
  uint32_t pid() const;
  void set_pid(uint32_t value);
  private:
  uint32_t _internal_pid() const;
  void _internal_set_pid(uint32_t value);
  public:

  // optional int32 isolate_id = 3;
  bool has_isolate_id() const;
  private:
  bool _internal_has_isolate_id() const;
  public:
  void clear_isolate_id();
  int32_t isolate_id() const;
  void set_isolate_id(int32_t value);
  private:
  int32_t _internal_isolate_id() const;
  void _internal_set_isolate_id(int32_t value);
  public:

  // optional uint64 embedded_blob_code_start_address = 5;
  bool has_embedded_blob_code_start_address() const;
  private:
  bool _internal_has_embedded_blob_code_start_address() const;
  public:
  void clear_embedded_blob_code_start_address();
  uint64_t embedded_blob_code_start_address() const;
  void set_embedded_blob_code_start_address(uint64_t value);
  private:
  uint64_t _internal_embedded_blob_code_start_address() const;
  void _internal_set_embedded_blob_code_start_address(uint64_t value);
  public:

  // optional uint64 embedded_blob_code_size = 6;
  bool has_embedded_blob_code_size() const;
  private:
  bool _internal_has_embedded_blob_code_size() const;
  public:
  void clear_embedded_blob_code_size();
  uint64_t embedded_blob_code_size() const;
  void set_embedded_blob_code_size(uint64_t value);
  private:
  uint64_t _internal_embedded_blob_code_size() const;
  void _internal_set_embedded_blob_code_size(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:perfetto.protos.InternedV8Isolate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::perfetto::protos::InternedV8Isolate_CodeRange* code_range_;
    uint64_t iid_;
    uint32_t pid_;
    int32_t isolate_id_;
    uint64_t embedded_blob_code_start_address_;
    uint64_t embedded_blob_code_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fchrome_2fv8_2eproto;
};
// -------------------------------------------------------------------

class V8JsCode final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.V8JsCode) */ {
 public:
  inline V8JsCode() : V8JsCode(nullptr) {}
  ~V8JsCode() override;
  explicit PROTOBUF_CONSTEXPR V8JsCode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  V8JsCode(const V8JsCode& from);
  V8JsCode(V8JsCode&& from) noexcept
    : V8JsCode() {
    *this = ::std::move(from);
  }

  inline V8JsCode& operator=(const V8JsCode& from) {
    CopyFrom(from);
    return *this;
  }
  inline V8JsCode& operator=(V8JsCode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const V8JsCode& default_instance() {
    return *internal_default_instance();
  }
  enum InstructionsCase {
    kMachineCode = 7,
    kBytecode = 8,
    INSTRUCTIONS_NOT_SET = 0,
  };

  static inline const V8JsCode* internal_default_instance() {
    return reinterpret_cast<const V8JsCode*>(
               &_V8JsCode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(V8JsCode& a, V8JsCode& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(V8JsCode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(V8JsCode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  V8JsCode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<V8JsCode>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const V8JsCode& from);
  void MergeFrom(const V8JsCode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(V8JsCode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.V8JsCode";
  }
  protected:
  explicit V8JsCode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef V8JsCode_Tier Tier;
  static constexpr Tier TIER_UNKNOWN =
    V8JsCode_Tier_TIER_UNKNOWN;
  static constexpr Tier TIER_IGNITION =
    V8JsCode_Tier_TIER_IGNITION;
  static constexpr Tier TIER_SPARKPLUG =
    V8JsCode_Tier_TIER_SPARKPLUG;
  static constexpr Tier TIER_MAGLEV =
    V8JsCode_Tier_TIER_MAGLEV;
  static constexpr Tier TIER_TURBOSHAFT =
    V8JsCode_Tier_TIER_TURBOSHAFT;
  static constexpr Tier TIER_TURBOFAN =
    V8JsCode_Tier_TIER_TURBOFAN;
  static inline bool Tier_IsValid(int value) {
    return V8JsCode_Tier_IsValid(value);
  }
  static constexpr Tier Tier_MIN =
    V8JsCode_Tier_Tier_MIN;
  static constexpr Tier Tier_MAX =
    V8JsCode_Tier_Tier_MAX;
  static constexpr int Tier_ARRAYSIZE =
    V8JsCode_Tier_Tier_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Tier_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Tier>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Tier_Name.");
    return V8JsCode_Tier_Name(enum_t_value);
  }
  static inline bool Tier_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Tier* value) {
    return V8JsCode_Tier_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kV8IsolateIidFieldNumber = 1,
    kV8JsFunctionIidFieldNumber = 3,
    kTidFieldNumber = 2,
    kTierFieldNumber = 4,
    kInstructionStartFieldNumber = 5,
    kInstructionSizeBytesFieldNumber = 6,
    kMachineCodeFieldNumber = 7,
    kBytecodeFieldNumber = 8,
  };
  // optional uint64 v8_isolate_iid = 1;
  bool has_v8_isolate_iid() const;
  private:
  bool _internal_has_v8_isolate_iid() const;
  public:
  void clear_v8_isolate_iid();
  uint64_t v8_isolate_iid() const;
  void set_v8_isolate_iid(uint64_t value);
  private:
  uint64_t _internal_v8_isolate_iid() const;
  void _internal_set_v8_isolate_iid(uint64_t value);
  public:

  // optional uint64 v8_js_function_iid = 3;
  bool has_v8_js_function_iid() const;
  private:
  bool _internal_has_v8_js_function_iid() const;
  public:
  void clear_v8_js_function_iid();
  uint64_t v8_js_function_iid() const;
  void set_v8_js_function_iid(uint64_t value);
  private:
  uint64_t _internal_v8_js_function_iid() const;
  void _internal_set_v8_js_function_iid(uint64_t value);
  public:

  // optional uint32 tid = 2;
  bool has_tid() const;
  private:
  bool _internal_has_tid() const;
  public:
  void clear_tid();
  uint32_t tid() const;
  void set_tid(uint32_t value);
  private:
  uint32_t _internal_tid() const;
  void _internal_set_tid(uint32_t value);
  public:

  // optional .perfetto.protos.V8JsCode.Tier tier = 4;
  bool has_tier() const;
  private:
  bool _internal_has_tier() const;
  public:
  void clear_tier();
  ::perfetto::protos::V8JsCode_Tier tier() const;
  void set_tier(::perfetto::protos::V8JsCode_Tier value);
  private:
  ::perfetto::protos::V8JsCode_Tier _internal_tier() const;
  void _internal_set_tier(::perfetto::protos::V8JsCode_Tier value);
  public:

  // optional uint64 instruction_start = 5;
  bool has_instruction_start() const;
  private:
  bool _internal_has_instruction_start() const;
  public:
  void clear_instruction_start();
  uint64_t instruction_start() const;
  void set_instruction_start(uint64_t value);
  private:
  uint64_t _internal_instruction_start() const;
  void _internal_set_instruction_start(uint64_t value);
  public:

  // optional uint64 instruction_size_bytes = 6;
  bool has_instruction_size_bytes() const;
  private:
  bool _internal_has_instruction_size_bytes() const;
  public:
  void clear_instruction_size_bytes();
  uint64_t instruction_size_bytes() const;
  void set_instruction_size_bytes(uint64_t value);
  private:
  uint64_t _internal_instruction_size_bytes() const;
  void _internal_set_instruction_size_bytes(uint64_t value);
  public:

  // bytes machine_code = 7;
  bool has_machine_code() const;
  private:
  bool _internal_has_machine_code() const;
  public:
  void clear_machine_code();
  const std::string& machine_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_machine_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_machine_code();
  PROTOBUF_NODISCARD std::string* release_machine_code();
  void set_allocated_machine_code(std::string* machine_code);
  private:
  const std::string& _internal_machine_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_machine_code(const std::string& value);
  std::string* _internal_mutable_machine_code();
  public:

  // bytes bytecode = 8;
  bool has_bytecode() const;
  private:
  bool _internal_has_bytecode() const;
  public:
  void clear_bytecode();
  const std::string& bytecode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bytecode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bytecode();
  PROTOBUF_NODISCARD std::string* release_bytecode();
  void set_allocated_bytecode(std::string* bytecode);
  private:
  const std::string& _internal_bytecode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bytecode(const std::string& value);
  std::string* _internal_mutable_bytecode();
  public:

  void clear_instructions();
  InstructionsCase instructions_case() const;
  // @@protoc_insertion_point(class_scope:perfetto.protos.V8JsCode)
 private:
  class _Internal;
  void set_has_machine_code();
  void set_has_bytecode();

  inline bool has_instructions() const;
  inline void clear_has_instructions();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t v8_isolate_iid_;
    uint64_t v8_js_function_iid_;
    uint32_t tid_;
    int tier_;
    uint64_t instruction_start_;
    uint64_t instruction_size_bytes_;
    union InstructionsUnion {
      constexpr InstructionsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr machine_code_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bytecode_;
    } instructions_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fchrome_2fv8_2eproto;
};
// -------------------------------------------------------------------

class V8InternalCode final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.V8InternalCode) */ {
 public:
  inline V8InternalCode() : V8InternalCode(nullptr) {}
  ~V8InternalCode() override;
  explicit PROTOBUF_CONSTEXPR V8InternalCode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  V8InternalCode(const V8InternalCode& from);
  V8InternalCode(V8InternalCode&& from) noexcept
    : V8InternalCode() {
    *this = ::std::move(from);
  }

  inline V8InternalCode& operator=(const V8InternalCode& from) {
    CopyFrom(from);
    return *this;
  }
  inline V8InternalCode& operator=(V8InternalCode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const V8InternalCode& default_instance() {
    return *internal_default_instance();
  }
  static inline const V8InternalCode* internal_default_instance() {
    return reinterpret_cast<const V8InternalCode*>(
               &_V8InternalCode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(V8InternalCode& a, V8InternalCode& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(V8InternalCode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(V8InternalCode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  V8InternalCode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<V8InternalCode>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const V8InternalCode& from);
  void MergeFrom(const V8InternalCode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(V8InternalCode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.V8InternalCode";
  }
  protected:
  explicit V8InternalCode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef V8InternalCode_Type Type;
  static constexpr Type TYPE_UNKNOWN =
    V8InternalCode_Type_TYPE_UNKNOWN;
  static constexpr Type TYPE_BYTECODE_HANDLER =
    V8InternalCode_Type_TYPE_BYTECODE_HANDLER;
  static constexpr Type TYPE_FOR_TESTING =
    V8InternalCode_Type_TYPE_FOR_TESTING;
  static constexpr Type TYPE_BUILTIN =
    V8InternalCode_Type_TYPE_BUILTIN;
  static constexpr Type TYPE_WASM_FUNCTION =
    V8InternalCode_Type_TYPE_WASM_FUNCTION;
  static constexpr Type TYPE_WASM_TO_CAPI_FUNCTION =
    V8InternalCode_Type_TYPE_WASM_TO_CAPI_FUNCTION;
  static constexpr Type TYPE_WASM_TO_JS_FUNCTION =
    V8InternalCode_Type_TYPE_WASM_TO_JS_FUNCTION;
  static constexpr Type TYPE_JS_TO_WASM_FUNCTION =
    V8InternalCode_Type_TYPE_JS_TO_WASM_FUNCTION;
  static constexpr Type TYPE_JS_TO_JS_FUNCTION =
    V8InternalCode_Type_TYPE_JS_TO_JS_FUNCTION;
  static constexpr Type TYPE_C_WASM_ENTRY =
    V8InternalCode_Type_TYPE_C_WASM_ENTRY;
  static inline bool Type_IsValid(int value) {
    return V8InternalCode_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    V8InternalCode_Type_Type_MIN;
  static constexpr Type Type_MAX =
    V8InternalCode_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    V8InternalCode_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return V8InternalCode_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return V8InternalCode_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 3,
    kMachineCodeFieldNumber = 8,
    kV8IsolateIidFieldNumber = 1,
    kTidFieldNumber = 2,
    kTypeFieldNumber = 4,
    kInstructionStartFieldNumber = 6,
    kInstructionSizeBytesFieldNumber = 7,
    kBuiltinIdFieldNumber = 5,
  };
  // optional string name = 3;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional bytes machine_code = 8;
  bool has_machine_code() const;
  private:
  bool _internal_has_machine_code() const;
  public:
  void clear_machine_code();
  const std::string& machine_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_machine_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_machine_code();
  PROTOBUF_NODISCARD std::string* release_machine_code();
  void set_allocated_machine_code(std::string* machine_code);
  private:
  const std::string& _internal_machine_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_machine_code(const std::string& value);
  std::string* _internal_mutable_machine_code();
  public:

  // optional uint64 v8_isolate_iid = 1;
  bool has_v8_isolate_iid() const;
  private:
  bool _internal_has_v8_isolate_iid() const;
  public:
  void clear_v8_isolate_iid();
  uint64_t v8_isolate_iid() const;
  void set_v8_isolate_iid(uint64_t value);
  private:
  uint64_t _internal_v8_isolate_iid() const;
  void _internal_set_v8_isolate_iid(uint64_t value);
  public:

  // optional uint32 tid = 2;
  bool has_tid() const;
  private:
  bool _internal_has_tid() const;
  public:
  void clear_tid();
  uint32_t tid() const;
  void set_tid(uint32_t value);
  private:
  uint32_t _internal_tid() const;
  void _internal_set_tid(uint32_t value);
  public:

  // optional .perfetto.protos.V8InternalCode.Type type = 4;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::perfetto::protos::V8InternalCode_Type type() const;
  void set_type(::perfetto::protos::V8InternalCode_Type value);
  private:
  ::perfetto::protos::V8InternalCode_Type _internal_type() const;
  void _internal_set_type(::perfetto::protos::V8InternalCode_Type value);
  public:

  // optional uint64 instruction_start = 6;
  bool has_instruction_start() const;
  private:
  bool _internal_has_instruction_start() const;
  public:
  void clear_instruction_start();
  uint64_t instruction_start() const;
  void set_instruction_start(uint64_t value);
  private:
  uint64_t _internal_instruction_start() const;
  void _internal_set_instruction_start(uint64_t value);
  public:

  // optional uint64 instruction_size_bytes = 7;
  bool has_instruction_size_bytes() const;
  private:
  bool _internal_has_instruction_size_bytes() const;
  public:
  void clear_instruction_size_bytes();
  uint64_t instruction_size_bytes() const;
  void set_instruction_size_bytes(uint64_t value);
  private:
  uint64_t _internal_instruction_size_bytes() const;
  void _internal_set_instruction_size_bytes(uint64_t value);
  public:

  // optional int32 builtin_id = 5;
  bool has_builtin_id() const;
  private:
  bool _internal_has_builtin_id() const;
  public:
  void clear_builtin_id();
  int32_t builtin_id() const;
  void set_builtin_id(int32_t value);
  private:
  int32_t _internal_builtin_id() const;
  void _internal_set_builtin_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:perfetto.protos.V8InternalCode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr machine_code_;
    uint64_t v8_isolate_iid_;
    uint32_t tid_;
    int type_;
    uint64_t instruction_start_;
    uint64_t instruction_size_bytes_;
    int32_t builtin_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fchrome_2fv8_2eproto;
};
// -------------------------------------------------------------------

class V8WasmCode final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.V8WasmCode) */ {
 public:
  inline V8WasmCode() : V8WasmCode(nullptr) {}
  ~V8WasmCode() override;
  explicit PROTOBUF_CONSTEXPR V8WasmCode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  V8WasmCode(const V8WasmCode& from);
  V8WasmCode(V8WasmCode&& from) noexcept
    : V8WasmCode() {
    *this = ::std::move(from);
  }

  inline V8WasmCode& operator=(const V8WasmCode& from) {
    CopyFrom(from);
    return *this;
  }
  inline V8WasmCode& operator=(V8WasmCode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const V8WasmCode& default_instance() {
    return *internal_default_instance();
  }
  static inline const V8WasmCode* internal_default_instance() {
    return reinterpret_cast<const V8WasmCode*>(
               &_V8WasmCode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(V8WasmCode& a, V8WasmCode& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(V8WasmCode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(V8WasmCode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  V8WasmCode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<V8WasmCode>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const V8WasmCode& from);
  void MergeFrom(const V8WasmCode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(V8WasmCode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.V8WasmCode";
  }
  protected:
  explicit V8WasmCode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef V8WasmCode_Tier Tier;
  static constexpr Tier TIER_UNKNOWN =
    V8WasmCode_Tier_TIER_UNKNOWN;
  static constexpr Tier TIER_LIFTOFF =
    V8WasmCode_Tier_TIER_LIFTOFF;
  static constexpr Tier TIER_TURBOFAN =
    V8WasmCode_Tier_TIER_TURBOFAN;
  static inline bool Tier_IsValid(int value) {
    return V8WasmCode_Tier_IsValid(value);
  }
  static constexpr Tier Tier_MIN =
    V8WasmCode_Tier_Tier_MIN;
  static constexpr Tier Tier_MAX =
    V8WasmCode_Tier_Tier_MAX;
  static constexpr int Tier_ARRAYSIZE =
    V8WasmCode_Tier_Tier_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Tier_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Tier>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Tier_Name.");
    return V8WasmCode_Tier_Name(enum_t_value);
  }
  static inline bool Tier_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Tier* value) {
    return V8WasmCode_Tier_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFunctionNameFieldNumber = 4,
    kMachineCodeFieldNumber = 9,
    kV8IsolateIidFieldNumber = 1,
    kV8WasmScriptIidFieldNumber = 3,
    kTidFieldNumber = 2,
    kTierFieldNumber = 5,
    kInstructionStartFieldNumber = 7,
    kInstructionSizeBytesFieldNumber = 8,
    kCodeOffsetInModuleFieldNumber = 6,
  };
  // optional string function_name = 4;
  bool has_function_name() const;
  private:
  bool _internal_has_function_name() const;
  public:
  void clear_function_name();
  const std::string& function_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_function_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_function_name();
  PROTOBUF_NODISCARD std::string* release_function_name();
  void set_allocated_function_name(std::string* function_name);
  private:
  const std::string& _internal_function_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_function_name(const std::string& value);
  std::string* _internal_mutable_function_name();
  public:

  // optional bytes machine_code = 9;
  bool has_machine_code() const;
  private:
  bool _internal_has_machine_code() const;
  public:
  void clear_machine_code();
  const std::string& machine_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_machine_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_machine_code();
  PROTOBUF_NODISCARD std::string* release_machine_code();
  void set_allocated_machine_code(std::string* machine_code);
  private:
  const std::string& _internal_machine_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_machine_code(const std::string& value);
  std::string* _internal_mutable_machine_code();
  public:

  // optional uint64 v8_isolate_iid = 1;
  bool has_v8_isolate_iid() const;
  private:
  bool _internal_has_v8_isolate_iid() const;
  public:
  void clear_v8_isolate_iid();
  uint64_t v8_isolate_iid() const;
  void set_v8_isolate_iid(uint64_t value);
  private:
  uint64_t _internal_v8_isolate_iid() const;
  void _internal_set_v8_isolate_iid(uint64_t value);
  public:

  // optional uint64 v8_wasm_script_iid = 3;
  bool has_v8_wasm_script_iid() const;
  private:
  bool _internal_has_v8_wasm_script_iid() const;
  public:
  void clear_v8_wasm_script_iid();
  uint64_t v8_wasm_script_iid() const;
  void set_v8_wasm_script_iid(uint64_t value);
  private:
  uint64_t _internal_v8_wasm_script_iid() const;
  void _internal_set_v8_wasm_script_iid(uint64_t value);
  public:

  // optional uint32 tid = 2;
  bool has_tid() const;
  private:
  bool _internal_has_tid() const;
  public:
  void clear_tid();
  uint32_t tid() const;
  void set_tid(uint32_t value);
  private:
  uint32_t _internal_tid() const;
  void _internal_set_tid(uint32_t value);
  public:

  // optional .perfetto.protos.V8WasmCode.Tier tier = 5;
  bool has_tier() const;
  private:
  bool _internal_has_tier() const;
  public:
  void clear_tier();
  ::perfetto::protos::V8WasmCode_Tier tier() const;
  void set_tier(::perfetto::protos::V8WasmCode_Tier value);
  private:
  ::perfetto::protos::V8WasmCode_Tier _internal_tier() const;
  void _internal_set_tier(::perfetto::protos::V8WasmCode_Tier value);
  public:

  // optional uint64 instruction_start = 7;
  bool has_instruction_start() const;
  private:
  bool _internal_has_instruction_start() const;
  public:
  void clear_instruction_start();
  uint64_t instruction_start() const;
  void set_instruction_start(uint64_t value);
  private:
  uint64_t _internal_instruction_start() const;
  void _internal_set_instruction_start(uint64_t value);
  public:

  // optional uint64 instruction_size_bytes = 8;
  bool has_instruction_size_bytes() const;
  private:
  bool _internal_has_instruction_size_bytes() const;
  public:
  void clear_instruction_size_bytes();
  uint64_t instruction_size_bytes() const;
  void set_instruction_size_bytes(uint64_t value);
  private:
  uint64_t _internal_instruction_size_bytes() const;
  void _internal_set_instruction_size_bytes(uint64_t value);
  public:

  // optional int32 code_offset_in_module = 6;
  bool has_code_offset_in_module() const;
  private:
  bool _internal_has_code_offset_in_module() const;
  public:
  void clear_code_offset_in_module();
  int32_t code_offset_in_module() const;
  void set_code_offset_in_module(int32_t value);
  private:
  int32_t _internal_code_offset_in_module() const;
  void _internal_set_code_offset_in_module(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:perfetto.protos.V8WasmCode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr function_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr machine_code_;
    uint64_t v8_isolate_iid_;
    uint64_t v8_wasm_script_iid_;
    uint32_t tid_;
    int tier_;
    uint64_t instruction_start_;
    uint64_t instruction_size_bytes_;
    int32_t code_offset_in_module_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fchrome_2fv8_2eproto;
};
// -------------------------------------------------------------------

class V8RegExpCode final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.V8RegExpCode) */ {
 public:
  inline V8RegExpCode() : V8RegExpCode(nullptr) {}
  ~V8RegExpCode() override;
  explicit PROTOBUF_CONSTEXPR V8RegExpCode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  V8RegExpCode(const V8RegExpCode& from);
  V8RegExpCode(V8RegExpCode&& from) noexcept
    : V8RegExpCode() {
    *this = ::std::move(from);
  }

  inline V8RegExpCode& operator=(const V8RegExpCode& from) {
    CopyFrom(from);
    return *this;
  }
  inline V8RegExpCode& operator=(V8RegExpCode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const V8RegExpCode& default_instance() {
    return *internal_default_instance();
  }
  static inline const V8RegExpCode* internal_default_instance() {
    return reinterpret_cast<const V8RegExpCode*>(
               &_V8RegExpCode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(V8RegExpCode& a, V8RegExpCode& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(V8RegExpCode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(V8RegExpCode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  V8RegExpCode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<V8RegExpCode>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const V8RegExpCode& from);
  void MergeFrom(const V8RegExpCode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(V8RegExpCode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.V8RegExpCode";
  }
  protected:
  explicit V8RegExpCode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMachineCodeFieldNumber = 6,
    kPatternFieldNumber = 3,
    kV8IsolateIidFieldNumber = 1,
    kInstructionStartFieldNumber = 4,
    kInstructionSizeBytesFieldNumber = 5,
    kTidFieldNumber = 2,
  };
  // optional bytes machine_code = 6;
  bool has_machine_code() const;
  private:
  bool _internal_has_machine_code() const;
  public:
  void clear_machine_code();
  const std::string& machine_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_machine_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_machine_code();
  PROTOBUF_NODISCARD std::string* release_machine_code();
  void set_allocated_machine_code(std::string* machine_code);
  private:
  const std::string& _internal_machine_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_machine_code(const std::string& value);
  std::string* _internal_mutable_machine_code();
  public:

  // optional .perfetto.protos.V8String pattern = 3;
  bool has_pattern() const;
  private:
  bool _internal_has_pattern() const;
  public:
  void clear_pattern();
  const ::perfetto::protos::V8String& pattern() const;
  PROTOBUF_NODISCARD ::perfetto::protos::V8String* release_pattern();
  ::perfetto::protos::V8String* mutable_pattern();
  void set_allocated_pattern(::perfetto::protos::V8String* pattern);
  private:
  const ::perfetto::protos::V8String& _internal_pattern() const;
  ::perfetto::protos::V8String* _internal_mutable_pattern();
  public:
  void unsafe_arena_set_allocated_pattern(
      ::perfetto::protos::V8String* pattern);
  ::perfetto::protos::V8String* unsafe_arena_release_pattern();

  // optional uint64 v8_isolate_iid = 1;
  bool has_v8_isolate_iid() const;
  private:
  bool _internal_has_v8_isolate_iid() const;
  public:
  void clear_v8_isolate_iid();
  uint64_t v8_isolate_iid() const;
  void set_v8_isolate_iid(uint64_t value);
  private:
  uint64_t _internal_v8_isolate_iid() const;
  void _internal_set_v8_isolate_iid(uint64_t value);
  public:

  // optional uint64 instruction_start = 4;
  bool has_instruction_start() const;
  private:
  bool _internal_has_instruction_start() const;
  public:
  void clear_instruction_start();
  uint64_t instruction_start() const;
  void set_instruction_start(uint64_t value);
  private:
  uint64_t _internal_instruction_start() const;
  void _internal_set_instruction_start(uint64_t value);
  public:

  // optional uint64 instruction_size_bytes = 5;
  bool has_instruction_size_bytes() const;
  private:
  bool _internal_has_instruction_size_bytes() const;
  public:
  void clear_instruction_size_bytes();
  uint64_t instruction_size_bytes() const;
  void set_instruction_size_bytes(uint64_t value);
  private:
  uint64_t _internal_instruction_size_bytes() const;
  void _internal_set_instruction_size_bytes(uint64_t value);
  public:

  // optional uint32 tid = 2;
  bool has_tid() const;
  private:
  bool _internal_has_tid() const;
  public:
  void clear_tid();
  uint32_t tid() const;
  void set_tid(uint32_t value);
  private:
  uint32_t _internal_tid() const;
  void _internal_set_tid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:perfetto.protos.V8RegExpCode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr machine_code_;
    ::perfetto::protos::V8String* pattern_;
    uint64_t v8_isolate_iid_;
    uint64_t instruction_start_;
    uint64_t instruction_size_bytes_;
    uint32_t tid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fchrome_2fv8_2eproto;
};
// -------------------------------------------------------------------

class V8CodeMove final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.V8CodeMove) */ {
 public:
  inline V8CodeMove() : V8CodeMove(nullptr) {}
  ~V8CodeMove() override;
  explicit PROTOBUF_CONSTEXPR V8CodeMove(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  V8CodeMove(const V8CodeMove& from);
  V8CodeMove(V8CodeMove&& from) noexcept
    : V8CodeMove() {
    *this = ::std::move(from);
  }

  inline V8CodeMove& operator=(const V8CodeMove& from) {
    CopyFrom(from);
    return *this;
  }
  inline V8CodeMove& operator=(V8CodeMove&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const V8CodeMove& default_instance() {
    return *internal_default_instance();
  }
  enum ToInstructionsCase {
    kToMachineCode = 6,
    kToBytecode = 7,
    TO_INSTRUCTIONS_NOT_SET = 0,
  };

  static inline const V8CodeMove* internal_default_instance() {
    return reinterpret_cast<const V8CodeMove*>(
               &_V8CodeMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(V8CodeMove& a, V8CodeMove& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(V8CodeMove* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(V8CodeMove* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  V8CodeMove* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<V8CodeMove>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const V8CodeMove& from);
  void MergeFrom(const V8CodeMove& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(V8CodeMove* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.V8CodeMove";
  }
  protected:
  explicit V8CodeMove(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsolateIidFieldNumber = 1,
    kFromInstructionStartAddressFieldNumber = 3,
    kToInstructionStartAddressFieldNumber = 4,
    kInstructionSizeBytesFieldNumber = 5,
    kTidFieldNumber = 2,
    kToMachineCodeFieldNumber = 6,
    kToBytecodeFieldNumber = 7,
  };
  // optional uint64 isolate_iid = 1;
  bool has_isolate_iid() const;
  private:
  bool _internal_has_isolate_iid() const;
  public:
  void clear_isolate_iid();
  uint64_t isolate_iid() const;
  void set_isolate_iid(uint64_t value);
  private:
  uint64_t _internal_isolate_iid() const;
  void _internal_set_isolate_iid(uint64_t value);
  public:

  // optional uint64 from_instruction_start_address = 3;
  bool has_from_instruction_start_address() const;
  private:
  bool _internal_has_from_instruction_start_address() const;
  public:
  void clear_from_instruction_start_address();
  uint64_t from_instruction_start_address() const;
  void set_from_instruction_start_address(uint64_t value);
  private:
  uint64_t _internal_from_instruction_start_address() const;
  void _internal_set_from_instruction_start_address(uint64_t value);
  public:

  // optional uint64 to_instruction_start_address = 4;
  bool has_to_instruction_start_address() const;
  private:
  bool _internal_has_to_instruction_start_address() const;
  public:
  void clear_to_instruction_start_address();
  uint64_t to_instruction_start_address() const;
  void set_to_instruction_start_address(uint64_t value);
  private:
  uint64_t _internal_to_instruction_start_address() const;
  void _internal_set_to_instruction_start_address(uint64_t value);
  public:

  // optional uint64 instruction_size_bytes = 5;
  bool has_instruction_size_bytes() const;
  private:
  bool _internal_has_instruction_size_bytes() const;
  public:
  void clear_instruction_size_bytes();
  uint64_t instruction_size_bytes() const;
  void set_instruction_size_bytes(uint64_t value);
  private:
  uint64_t _internal_instruction_size_bytes() const;
  void _internal_set_instruction_size_bytes(uint64_t value);
  public:

  // optional uint32 tid = 2;
  bool has_tid() const;
  private:
  bool _internal_has_tid() const;
  public:
  void clear_tid();
  uint32_t tid() const;
  void set_tid(uint32_t value);
  private:
  uint32_t _internal_tid() const;
  void _internal_set_tid(uint32_t value);
  public:

  // bytes to_machine_code = 6;
  bool has_to_machine_code() const;
  private:
  bool _internal_has_to_machine_code() const;
  public:
  void clear_to_machine_code();
  const std::string& to_machine_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_machine_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_machine_code();
  PROTOBUF_NODISCARD std::string* release_to_machine_code();
  void set_allocated_to_machine_code(std::string* to_machine_code);
  private:
  const std::string& _internal_to_machine_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_machine_code(const std::string& value);
  std::string* _internal_mutable_to_machine_code();
  public:

  // bytes to_bytecode = 7;
  bool has_to_bytecode() const;
  private:
  bool _internal_has_to_bytecode() const;
  public:
  void clear_to_bytecode();
  const std::string& to_bytecode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_bytecode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_bytecode();
  PROTOBUF_NODISCARD std::string* release_to_bytecode();
  void set_allocated_to_bytecode(std::string* to_bytecode);
  private:
  const std::string& _internal_to_bytecode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_bytecode(const std::string& value);
  std::string* _internal_mutable_to_bytecode();
  public:

  void clear_to_instructions();
  ToInstructionsCase to_instructions_case() const;
  // @@protoc_insertion_point(class_scope:perfetto.protos.V8CodeMove)
 private:
  class _Internal;
  void set_has_to_machine_code();
  void set_has_to_bytecode();

  inline bool has_to_instructions() const;
  inline void clear_has_to_instructions();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t isolate_iid_;
    uint64_t from_instruction_start_address_;
    uint64_t to_instruction_start_address_;
    uint64_t instruction_size_bytes_;
    uint32_t tid_;
    union ToInstructionsUnion {
      constexpr ToInstructionsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_machine_code_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_bytecode_;
    } to_instructions_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fchrome_2fv8_2eproto;
};
// -------------------------------------------------------------------

class V8CodeDefaults final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.V8CodeDefaults) */ {
 public:
  inline V8CodeDefaults() : V8CodeDefaults(nullptr) {}
  ~V8CodeDefaults() override;
  explicit PROTOBUF_CONSTEXPR V8CodeDefaults(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  V8CodeDefaults(const V8CodeDefaults& from);
  V8CodeDefaults(V8CodeDefaults&& from) noexcept
    : V8CodeDefaults() {
    *this = ::std::move(from);
  }

  inline V8CodeDefaults& operator=(const V8CodeDefaults& from) {
    CopyFrom(from);
    return *this;
  }
  inline V8CodeDefaults& operator=(V8CodeDefaults&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const V8CodeDefaults& default_instance() {
    return *internal_default_instance();
  }
  static inline const V8CodeDefaults* internal_default_instance() {
    return reinterpret_cast<const V8CodeDefaults*>(
               &_V8CodeDefaults_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(V8CodeDefaults& a, V8CodeDefaults& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(V8CodeDefaults* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(V8CodeDefaults* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  V8CodeDefaults* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<V8CodeDefaults>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const V8CodeDefaults& from);
  void MergeFrom(const V8CodeDefaults& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(V8CodeDefaults* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.V8CodeDefaults";
  }
  protected:
  explicit V8CodeDefaults(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTidFieldNumber = 1,
  };
  // optional uint32 tid = 1;
  bool has_tid() const;
  private:
  bool _internal_has_tid() const;
  public:
  void clear_tid();
  uint32_t tid() const;
  void set_tid(uint32_t value);
  private:
  uint32_t _internal_tid() const;
  void _internal_set_tid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:perfetto.protos.V8CodeDefaults)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t tid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fchrome_2fv8_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// V8String

// bytes latin1 = 1;
inline bool V8String::_internal_has_latin1() const {
  return encoded_string_case() == kLatin1;
}
inline bool V8String::has_latin1() const {
  return _internal_has_latin1();
}
inline void V8String::set_has_latin1() {
  _impl_._oneof_case_[0] = kLatin1;
}
inline void V8String::clear_latin1() {
  if (_internal_has_latin1()) {
    _impl_.encoded_string_.latin1_.Destroy();
    clear_has_encoded_string();
  }
}
inline const std::string& V8String::latin1() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8String.latin1)
  return _internal_latin1();
}
template <typename ArgT0, typename... ArgT>
inline void V8String::set_latin1(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_latin1()) {
    clear_encoded_string();
    set_has_latin1();
    _impl_.encoded_string_.latin1_.InitDefault();
  }
  _impl_.encoded_string_.latin1_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.V8String.latin1)
}
inline std::string* V8String::mutable_latin1() {
  std::string* _s = _internal_mutable_latin1();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.V8String.latin1)
  return _s;
}
inline const std::string& V8String::_internal_latin1() const {
  if (_internal_has_latin1()) {
    return _impl_.encoded_string_.latin1_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void V8String::_internal_set_latin1(const std::string& value) {
  if (!_internal_has_latin1()) {
    clear_encoded_string();
    set_has_latin1();
    _impl_.encoded_string_.latin1_.InitDefault();
  }
  _impl_.encoded_string_.latin1_.Set(value, GetArenaForAllocation());
}
inline std::string* V8String::_internal_mutable_latin1() {
  if (!_internal_has_latin1()) {
    clear_encoded_string();
    set_has_latin1();
    _impl_.encoded_string_.latin1_.InitDefault();
  }
  return _impl_.encoded_string_.latin1_.Mutable(      GetArenaForAllocation());
}
inline std::string* V8String::release_latin1() {
  // @@protoc_insertion_point(field_release:perfetto.protos.V8String.latin1)
  if (_internal_has_latin1()) {
    clear_has_encoded_string();
    return _impl_.encoded_string_.latin1_.Release();
  } else {
    return nullptr;
  }
}
inline void V8String::set_allocated_latin1(std::string* latin1) {
  if (has_encoded_string()) {
    clear_encoded_string();
  }
  if (latin1 != nullptr) {
    set_has_latin1();
    _impl_.encoded_string_.latin1_.InitAllocated(latin1, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.V8String.latin1)
}

// bytes utf16_le = 2;
inline bool V8String::_internal_has_utf16_le() const {
  return encoded_string_case() == kUtf16Le;
}
inline bool V8String::has_utf16_le() const {
  return _internal_has_utf16_le();
}
inline void V8String::set_has_utf16_le() {
  _impl_._oneof_case_[0] = kUtf16Le;
}
inline void V8String::clear_utf16_le() {
  if (_internal_has_utf16_le()) {
    _impl_.encoded_string_.utf16_le_.Destroy();
    clear_has_encoded_string();
  }
}
inline const std::string& V8String::utf16_le() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8String.utf16_le)
  return _internal_utf16_le();
}
template <typename ArgT0, typename... ArgT>
inline void V8String::set_utf16_le(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_utf16_le()) {
    clear_encoded_string();
    set_has_utf16_le();
    _impl_.encoded_string_.utf16_le_.InitDefault();
  }
  _impl_.encoded_string_.utf16_le_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.V8String.utf16_le)
}
inline std::string* V8String::mutable_utf16_le() {
  std::string* _s = _internal_mutable_utf16_le();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.V8String.utf16_le)
  return _s;
}
inline const std::string& V8String::_internal_utf16_le() const {
  if (_internal_has_utf16_le()) {
    return _impl_.encoded_string_.utf16_le_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void V8String::_internal_set_utf16_le(const std::string& value) {
  if (!_internal_has_utf16_le()) {
    clear_encoded_string();
    set_has_utf16_le();
    _impl_.encoded_string_.utf16_le_.InitDefault();
  }
  _impl_.encoded_string_.utf16_le_.Set(value, GetArenaForAllocation());
}
inline std::string* V8String::_internal_mutable_utf16_le() {
  if (!_internal_has_utf16_le()) {
    clear_encoded_string();
    set_has_utf16_le();
    _impl_.encoded_string_.utf16_le_.InitDefault();
  }
  return _impl_.encoded_string_.utf16_le_.Mutable(      GetArenaForAllocation());
}
inline std::string* V8String::release_utf16_le() {
  // @@protoc_insertion_point(field_release:perfetto.protos.V8String.utf16_le)
  if (_internal_has_utf16_le()) {
    clear_has_encoded_string();
    return _impl_.encoded_string_.utf16_le_.Release();
  } else {
    return nullptr;
  }
}
inline void V8String::set_allocated_utf16_le(std::string* utf16_le) {
  if (has_encoded_string()) {
    clear_encoded_string();
  }
  if (utf16_le != nullptr) {
    set_has_utf16_le();
    _impl_.encoded_string_.utf16_le_.InitAllocated(utf16_le, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.V8String.utf16_le)
}

// bytes utf16_be = 3;
inline bool V8String::_internal_has_utf16_be() const {
  return encoded_string_case() == kUtf16Be;
}
inline bool V8String::has_utf16_be() const {
  return _internal_has_utf16_be();
}
inline void V8String::set_has_utf16_be() {
  _impl_._oneof_case_[0] = kUtf16Be;
}
inline void V8String::clear_utf16_be() {
  if (_internal_has_utf16_be()) {
    _impl_.encoded_string_.utf16_be_.Destroy();
    clear_has_encoded_string();
  }
}
inline const std::string& V8String::utf16_be() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8String.utf16_be)
  return _internal_utf16_be();
}
template <typename ArgT0, typename... ArgT>
inline void V8String::set_utf16_be(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_utf16_be()) {
    clear_encoded_string();
    set_has_utf16_be();
    _impl_.encoded_string_.utf16_be_.InitDefault();
  }
  _impl_.encoded_string_.utf16_be_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.V8String.utf16_be)
}
inline std::string* V8String::mutable_utf16_be() {
  std::string* _s = _internal_mutable_utf16_be();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.V8String.utf16_be)
  return _s;
}
inline const std::string& V8String::_internal_utf16_be() const {
  if (_internal_has_utf16_be()) {
    return _impl_.encoded_string_.utf16_be_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void V8String::_internal_set_utf16_be(const std::string& value) {
  if (!_internal_has_utf16_be()) {
    clear_encoded_string();
    set_has_utf16_be();
    _impl_.encoded_string_.utf16_be_.InitDefault();
  }
  _impl_.encoded_string_.utf16_be_.Set(value, GetArenaForAllocation());
}
inline std::string* V8String::_internal_mutable_utf16_be() {
  if (!_internal_has_utf16_be()) {
    clear_encoded_string();
    set_has_utf16_be();
    _impl_.encoded_string_.utf16_be_.InitDefault();
  }
  return _impl_.encoded_string_.utf16_be_.Mutable(      GetArenaForAllocation());
}
inline std::string* V8String::release_utf16_be() {
  // @@protoc_insertion_point(field_release:perfetto.protos.V8String.utf16_be)
  if (_internal_has_utf16_be()) {
    clear_has_encoded_string();
    return _impl_.encoded_string_.utf16_be_.Release();
  } else {
    return nullptr;
  }
}
inline void V8String::set_allocated_utf16_be(std::string* utf16_be) {
  if (has_encoded_string()) {
    clear_encoded_string();
  }
  if (utf16_be != nullptr) {
    set_has_utf16_be();
    _impl_.encoded_string_.utf16_be_.InitAllocated(utf16_be, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.V8String.utf16_be)
}

inline bool V8String::has_encoded_string() const {
  return encoded_string_case() != ENCODED_STRING_NOT_SET;
}
inline void V8String::clear_has_encoded_string() {
  _impl_._oneof_case_[0] = ENCODED_STRING_NOT_SET;
}
inline V8String::EncodedStringCase V8String::encoded_string_case() const {
  return V8String::EncodedStringCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// InternedV8String

// optional uint64 iid = 1;
inline bool InternedV8String::_internal_has_iid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InternedV8String::has_iid() const {
  return _internal_has_iid();
}
inline void InternedV8String::clear_iid() {
  _impl_.iid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t InternedV8String::_internal_iid() const {
  return _impl_.iid_;
}
inline uint64_t InternedV8String::iid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InternedV8String.iid)
  return _internal_iid();
}
inline void InternedV8String::_internal_set_iid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.iid_ = value;
}
inline void InternedV8String::set_iid(uint64_t value) {
  _internal_set_iid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.InternedV8String.iid)
}

// bytes latin1 = 2;
inline bool InternedV8String::_internal_has_latin1() const {
  return encoded_string_case() == kLatin1;
}
inline bool InternedV8String::has_latin1() const {
  return _internal_has_latin1();
}
inline void InternedV8String::set_has_latin1() {
  _impl_._oneof_case_[0] = kLatin1;
}
inline void InternedV8String::clear_latin1() {
  if (_internal_has_latin1()) {
    _impl_.encoded_string_.latin1_.Destroy();
    clear_has_encoded_string();
  }
}
inline const std::string& InternedV8String::latin1() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InternedV8String.latin1)
  return _internal_latin1();
}
template <typename ArgT0, typename... ArgT>
inline void InternedV8String::set_latin1(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_latin1()) {
    clear_encoded_string();
    set_has_latin1();
    _impl_.encoded_string_.latin1_.InitDefault();
  }
  _impl_.encoded_string_.latin1_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.InternedV8String.latin1)
}
inline std::string* InternedV8String::mutable_latin1() {
  std::string* _s = _internal_mutable_latin1();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.InternedV8String.latin1)
  return _s;
}
inline const std::string& InternedV8String::_internal_latin1() const {
  if (_internal_has_latin1()) {
    return _impl_.encoded_string_.latin1_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void InternedV8String::_internal_set_latin1(const std::string& value) {
  if (!_internal_has_latin1()) {
    clear_encoded_string();
    set_has_latin1();
    _impl_.encoded_string_.latin1_.InitDefault();
  }
  _impl_.encoded_string_.latin1_.Set(value, GetArenaForAllocation());
}
inline std::string* InternedV8String::_internal_mutable_latin1() {
  if (!_internal_has_latin1()) {
    clear_encoded_string();
    set_has_latin1();
    _impl_.encoded_string_.latin1_.InitDefault();
  }
  return _impl_.encoded_string_.latin1_.Mutable(      GetArenaForAllocation());
}
inline std::string* InternedV8String::release_latin1() {
  // @@protoc_insertion_point(field_release:perfetto.protos.InternedV8String.latin1)
  if (_internal_has_latin1()) {
    clear_has_encoded_string();
    return _impl_.encoded_string_.latin1_.Release();
  } else {
    return nullptr;
  }
}
inline void InternedV8String::set_allocated_latin1(std::string* latin1) {
  if (has_encoded_string()) {
    clear_encoded_string();
  }
  if (latin1 != nullptr) {
    set_has_latin1();
    _impl_.encoded_string_.latin1_.InitAllocated(latin1, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.InternedV8String.latin1)
}

// bytes utf16_le = 3;
inline bool InternedV8String::_internal_has_utf16_le() const {
  return encoded_string_case() == kUtf16Le;
}
inline bool InternedV8String::has_utf16_le() const {
  return _internal_has_utf16_le();
}
inline void InternedV8String::set_has_utf16_le() {
  _impl_._oneof_case_[0] = kUtf16Le;
}
inline void InternedV8String::clear_utf16_le() {
  if (_internal_has_utf16_le()) {
    _impl_.encoded_string_.utf16_le_.Destroy();
    clear_has_encoded_string();
  }
}
inline const std::string& InternedV8String::utf16_le() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InternedV8String.utf16_le)
  return _internal_utf16_le();
}
template <typename ArgT0, typename... ArgT>
inline void InternedV8String::set_utf16_le(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_utf16_le()) {
    clear_encoded_string();
    set_has_utf16_le();
    _impl_.encoded_string_.utf16_le_.InitDefault();
  }
  _impl_.encoded_string_.utf16_le_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.InternedV8String.utf16_le)
}
inline std::string* InternedV8String::mutable_utf16_le() {
  std::string* _s = _internal_mutable_utf16_le();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.InternedV8String.utf16_le)
  return _s;
}
inline const std::string& InternedV8String::_internal_utf16_le() const {
  if (_internal_has_utf16_le()) {
    return _impl_.encoded_string_.utf16_le_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void InternedV8String::_internal_set_utf16_le(const std::string& value) {
  if (!_internal_has_utf16_le()) {
    clear_encoded_string();
    set_has_utf16_le();
    _impl_.encoded_string_.utf16_le_.InitDefault();
  }
  _impl_.encoded_string_.utf16_le_.Set(value, GetArenaForAllocation());
}
inline std::string* InternedV8String::_internal_mutable_utf16_le() {
  if (!_internal_has_utf16_le()) {
    clear_encoded_string();
    set_has_utf16_le();
    _impl_.encoded_string_.utf16_le_.InitDefault();
  }
  return _impl_.encoded_string_.utf16_le_.Mutable(      GetArenaForAllocation());
}
inline std::string* InternedV8String::release_utf16_le() {
  // @@protoc_insertion_point(field_release:perfetto.protos.InternedV8String.utf16_le)
  if (_internal_has_utf16_le()) {
    clear_has_encoded_string();
    return _impl_.encoded_string_.utf16_le_.Release();
  } else {
    return nullptr;
  }
}
inline void InternedV8String::set_allocated_utf16_le(std::string* utf16_le) {
  if (has_encoded_string()) {
    clear_encoded_string();
  }
  if (utf16_le != nullptr) {
    set_has_utf16_le();
    _impl_.encoded_string_.utf16_le_.InitAllocated(utf16_le, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.InternedV8String.utf16_le)
}

// bytes utf16_be = 4;
inline bool InternedV8String::_internal_has_utf16_be() const {
  return encoded_string_case() == kUtf16Be;
}
inline bool InternedV8String::has_utf16_be() const {
  return _internal_has_utf16_be();
}
inline void InternedV8String::set_has_utf16_be() {
  _impl_._oneof_case_[0] = kUtf16Be;
}
inline void InternedV8String::clear_utf16_be() {
  if (_internal_has_utf16_be()) {
    _impl_.encoded_string_.utf16_be_.Destroy();
    clear_has_encoded_string();
  }
}
inline const std::string& InternedV8String::utf16_be() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InternedV8String.utf16_be)
  return _internal_utf16_be();
}
template <typename ArgT0, typename... ArgT>
inline void InternedV8String::set_utf16_be(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_utf16_be()) {
    clear_encoded_string();
    set_has_utf16_be();
    _impl_.encoded_string_.utf16_be_.InitDefault();
  }
  _impl_.encoded_string_.utf16_be_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.InternedV8String.utf16_be)
}
inline std::string* InternedV8String::mutable_utf16_be() {
  std::string* _s = _internal_mutable_utf16_be();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.InternedV8String.utf16_be)
  return _s;
}
inline const std::string& InternedV8String::_internal_utf16_be() const {
  if (_internal_has_utf16_be()) {
    return _impl_.encoded_string_.utf16_be_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void InternedV8String::_internal_set_utf16_be(const std::string& value) {
  if (!_internal_has_utf16_be()) {
    clear_encoded_string();
    set_has_utf16_be();
    _impl_.encoded_string_.utf16_be_.InitDefault();
  }
  _impl_.encoded_string_.utf16_be_.Set(value, GetArenaForAllocation());
}
inline std::string* InternedV8String::_internal_mutable_utf16_be() {
  if (!_internal_has_utf16_be()) {
    clear_encoded_string();
    set_has_utf16_be();
    _impl_.encoded_string_.utf16_be_.InitDefault();
  }
  return _impl_.encoded_string_.utf16_be_.Mutable(      GetArenaForAllocation());
}
inline std::string* InternedV8String::release_utf16_be() {
  // @@protoc_insertion_point(field_release:perfetto.protos.InternedV8String.utf16_be)
  if (_internal_has_utf16_be()) {
    clear_has_encoded_string();
    return _impl_.encoded_string_.utf16_be_.Release();
  } else {
    return nullptr;
  }
}
inline void InternedV8String::set_allocated_utf16_be(std::string* utf16_be) {
  if (has_encoded_string()) {
    clear_encoded_string();
  }
  if (utf16_be != nullptr) {
    set_has_utf16_be();
    _impl_.encoded_string_.utf16_be_.InitAllocated(utf16_be, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.InternedV8String.utf16_be)
}

inline bool InternedV8String::has_encoded_string() const {
  return encoded_string_case() != ENCODED_STRING_NOT_SET;
}
inline void InternedV8String::clear_has_encoded_string() {
  _impl_._oneof_case_[0] = ENCODED_STRING_NOT_SET;
}
inline InternedV8String::EncodedStringCase InternedV8String::encoded_string_case() const {
  return InternedV8String::EncodedStringCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// InternedV8JsScript

// optional uint64 iid = 1;
inline bool InternedV8JsScript::_internal_has_iid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool InternedV8JsScript::has_iid() const {
  return _internal_has_iid();
}
inline void InternedV8JsScript::clear_iid() {
  _impl_.iid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t InternedV8JsScript::_internal_iid() const {
  return _impl_.iid_;
}
inline uint64_t InternedV8JsScript::iid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InternedV8JsScript.iid)
  return _internal_iid();
}
inline void InternedV8JsScript::_internal_set_iid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.iid_ = value;
}
inline void InternedV8JsScript::set_iid(uint64_t value) {
  _internal_set_iid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.InternedV8JsScript.iid)
}

// optional int32 script_id = 2;
inline bool InternedV8JsScript::_internal_has_script_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool InternedV8JsScript::has_script_id() const {
  return _internal_has_script_id();
}
inline void InternedV8JsScript::clear_script_id() {
  _impl_.script_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t InternedV8JsScript::_internal_script_id() const {
  return _impl_.script_id_;
}
inline int32_t InternedV8JsScript::script_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InternedV8JsScript.script_id)
  return _internal_script_id();
}
inline void InternedV8JsScript::_internal_set_script_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.script_id_ = value;
}
inline void InternedV8JsScript::set_script_id(int32_t value) {
  _internal_set_script_id(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.InternedV8JsScript.script_id)
}

// optional .perfetto.protos.InternedV8JsScript.Type type = 3;
inline bool InternedV8JsScript::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool InternedV8JsScript::has_type() const {
  return _internal_has_type();
}
inline void InternedV8JsScript::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::perfetto::protos::InternedV8JsScript_Type InternedV8JsScript::_internal_type() const {
  return static_cast< ::perfetto::protos::InternedV8JsScript_Type >(_impl_.type_);
}
inline ::perfetto::protos::InternedV8JsScript_Type InternedV8JsScript::type() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InternedV8JsScript.type)
  return _internal_type();
}
inline void InternedV8JsScript::_internal_set_type(::perfetto::protos::InternedV8JsScript_Type value) {
  assert(::perfetto::protos::InternedV8JsScript_Type_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.type_ = value;
}
inline void InternedV8JsScript::set_type(::perfetto::protos::InternedV8JsScript_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.InternedV8JsScript.type)
}

// optional .perfetto.protos.V8String name = 4;
inline bool InternedV8JsScript::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.name_ != nullptr);
  return value;
}
inline bool InternedV8JsScript::has_name() const {
  return _internal_has_name();
}
inline void InternedV8JsScript::clear_name() {
  if (_impl_.name_ != nullptr) _impl_.name_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::perfetto::protos::V8String& InternedV8JsScript::_internal_name() const {
  const ::perfetto::protos::V8String* p = _impl_.name_;
  return p != nullptr ? *p : reinterpret_cast<const ::perfetto::protos::V8String&>(
      ::perfetto::protos::_V8String_default_instance_);
}
inline const ::perfetto::protos::V8String& InternedV8JsScript::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InternedV8JsScript.name)
  return _internal_name();
}
inline void InternedV8JsScript::unsafe_arena_set_allocated_name(
    ::perfetto::protos::V8String* name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.name_);
  }
  _impl_.name_ = name;
  if (name) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perfetto.protos.InternedV8JsScript.name)
}
inline ::perfetto::protos::V8String* InternedV8JsScript::release_name() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::perfetto::protos::V8String* temp = _impl_.name_;
  _impl_.name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::perfetto::protos::V8String* InternedV8JsScript::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.InternedV8JsScript.name)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::perfetto::protos::V8String* temp = _impl_.name_;
  _impl_.name_ = nullptr;
  return temp;
}
inline ::perfetto::protos::V8String* InternedV8JsScript::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.name_ == nullptr) {
    auto* p = CreateMaybeMessage<::perfetto::protos::V8String>(GetArenaForAllocation());
    _impl_.name_ = p;
  }
  return _impl_.name_;
}
inline ::perfetto::protos::V8String* InternedV8JsScript::mutable_name() {
  ::perfetto::protos::V8String* _msg = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.InternedV8JsScript.name)
  return _msg;
}
inline void InternedV8JsScript::set_allocated_name(::perfetto::protos::V8String* name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.name_;
  }
  if (name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(name);
    if (message_arena != submessage_arena) {
      name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_ = name;
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.InternedV8JsScript.name)
}

// optional .perfetto.protos.V8String source = 5;
inline bool InternedV8JsScript::_internal_has_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_ != nullptr);
  return value;
}
inline bool InternedV8JsScript::has_source() const {
  return _internal_has_source();
}
inline void InternedV8JsScript::clear_source() {
  if (_impl_.source_ != nullptr) _impl_.source_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::perfetto::protos::V8String& InternedV8JsScript::_internal_source() const {
  const ::perfetto::protos::V8String* p = _impl_.source_;
  return p != nullptr ? *p : reinterpret_cast<const ::perfetto::protos::V8String&>(
      ::perfetto::protos::_V8String_default_instance_);
}
inline const ::perfetto::protos::V8String& InternedV8JsScript::source() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InternedV8JsScript.source)
  return _internal_source();
}
inline void InternedV8JsScript::unsafe_arena_set_allocated_source(
    ::perfetto::protos::V8String* source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
  }
  _impl_.source_ = source;
  if (source) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perfetto.protos.InternedV8JsScript.source)
}
inline ::perfetto::protos::V8String* InternedV8JsScript::release_source() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::perfetto::protos::V8String* temp = _impl_.source_;
  _impl_.source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::perfetto::protos::V8String* InternedV8JsScript::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_release:perfetto.protos.InternedV8JsScript.source)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::perfetto::protos::V8String* temp = _impl_.source_;
  _impl_.source_ = nullptr;
  return temp;
}
inline ::perfetto::protos::V8String* InternedV8JsScript::_internal_mutable_source() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.source_ == nullptr) {
    auto* p = CreateMaybeMessage<::perfetto::protos::V8String>(GetArenaForAllocation());
    _impl_.source_ = p;
  }
  return _impl_.source_;
}
inline ::perfetto::protos::V8String* InternedV8JsScript::mutable_source() {
  ::perfetto::protos::V8String* _msg = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.InternedV8JsScript.source)
  return _msg;
}
inline void InternedV8JsScript::set_allocated_source(::perfetto::protos::V8String* source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.source_;
  }
  if (source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
    if (message_arena != submessage_arena) {
      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.source_ = source;
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.InternedV8JsScript.source)
}

// -------------------------------------------------------------------

// InternedV8WasmScript

// optional uint64 iid = 1;
inline bool InternedV8WasmScript::_internal_has_iid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InternedV8WasmScript::has_iid() const {
  return _internal_has_iid();
}
inline void InternedV8WasmScript::clear_iid() {
  _impl_.iid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t InternedV8WasmScript::_internal_iid() const {
  return _impl_.iid_;
}
inline uint64_t InternedV8WasmScript::iid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InternedV8WasmScript.iid)
  return _internal_iid();
}
inline void InternedV8WasmScript::_internal_set_iid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.iid_ = value;
}
inline void InternedV8WasmScript::set_iid(uint64_t value) {
  _internal_set_iid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.InternedV8WasmScript.iid)
}

// optional int32 script_id = 2;
inline bool InternedV8WasmScript::_internal_has_script_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool InternedV8WasmScript::has_script_id() const {
  return _internal_has_script_id();
}
inline void InternedV8WasmScript::clear_script_id() {
  _impl_.script_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t InternedV8WasmScript::_internal_script_id() const {
  return _impl_.script_id_;
}
inline int32_t InternedV8WasmScript::script_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InternedV8WasmScript.script_id)
  return _internal_script_id();
}
inline void InternedV8WasmScript::_internal_set_script_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.script_id_ = value;
}
inline void InternedV8WasmScript::set_script_id(int32_t value) {
  _internal_set_script_id(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.InternedV8WasmScript.script_id)
}

// optional string url = 3;
inline bool InternedV8WasmScript::_internal_has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InternedV8WasmScript::has_url() const {
  return _internal_has_url();
}
inline void InternedV8WasmScript::clear_url() {
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InternedV8WasmScript::url() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InternedV8WasmScript.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InternedV8WasmScript::set_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.InternedV8WasmScript.url)
}
inline std::string* InternedV8WasmScript::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.InternedV8WasmScript.url)
  return _s;
}
inline const std::string& InternedV8WasmScript::_internal_url() const {
  return _impl_.url_.Get();
}
inline void InternedV8WasmScript::_internal_set_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* InternedV8WasmScript::_internal_mutable_url() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* InternedV8WasmScript::release_url() {
  // @@protoc_insertion_point(field_release:perfetto.protos.InternedV8WasmScript.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InternedV8WasmScript::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.InternedV8WasmScript.url)
}

// -------------------------------------------------------------------

// InternedV8JsFunction

// optional uint64 iid = 1;
inline bool InternedV8JsFunction::_internal_has_iid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InternedV8JsFunction::has_iid() const {
  return _internal_has_iid();
}
inline void InternedV8JsFunction::clear_iid() {
  _impl_.iid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t InternedV8JsFunction::_internal_iid() const {
  return _impl_.iid_;
}
inline uint64_t InternedV8JsFunction::iid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InternedV8JsFunction.iid)
  return _internal_iid();
}
inline void InternedV8JsFunction::_internal_set_iid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.iid_ = value;
}
inline void InternedV8JsFunction::set_iid(uint64_t value) {
  _internal_set_iid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.InternedV8JsFunction.iid)
}

// optional uint64 v8_js_function_name_iid = 2;
inline bool InternedV8JsFunction::_internal_has_v8_js_function_name_iid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InternedV8JsFunction::has_v8_js_function_name_iid() const {
  return _internal_has_v8_js_function_name_iid();
}
inline void InternedV8JsFunction::clear_v8_js_function_name_iid() {
  _impl_.v8_js_function_name_iid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t InternedV8JsFunction::_internal_v8_js_function_name_iid() const {
  return _impl_.v8_js_function_name_iid_;
}
inline uint64_t InternedV8JsFunction::v8_js_function_name_iid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InternedV8JsFunction.v8_js_function_name_iid)
  return _internal_v8_js_function_name_iid();
}
inline void InternedV8JsFunction::_internal_set_v8_js_function_name_iid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.v8_js_function_name_iid_ = value;
}
inline void InternedV8JsFunction::set_v8_js_function_name_iid(uint64_t value) {
  _internal_set_v8_js_function_name_iid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.InternedV8JsFunction.v8_js_function_name_iid)
}

// optional uint64 v8_js_script_iid = 3;
inline bool InternedV8JsFunction::_internal_has_v8_js_script_iid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool InternedV8JsFunction::has_v8_js_script_iid() const {
  return _internal_has_v8_js_script_iid();
}
inline void InternedV8JsFunction::clear_v8_js_script_iid() {
  _impl_.v8_js_script_iid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t InternedV8JsFunction::_internal_v8_js_script_iid() const {
  return _impl_.v8_js_script_iid_;
}
inline uint64_t InternedV8JsFunction::v8_js_script_iid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InternedV8JsFunction.v8_js_script_iid)
  return _internal_v8_js_script_iid();
}
inline void InternedV8JsFunction::_internal_set_v8_js_script_iid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.v8_js_script_iid_ = value;
}
inline void InternedV8JsFunction::set_v8_js_script_iid(uint64_t value) {
  _internal_set_v8_js_script_iid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.InternedV8JsFunction.v8_js_script_iid)
}

// optional bool is_toplevel = 4;
inline bool InternedV8JsFunction::_internal_has_is_toplevel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool InternedV8JsFunction::has_is_toplevel() const {
  return _internal_has_is_toplevel();
}
inline void InternedV8JsFunction::clear_is_toplevel() {
  _impl_.is_toplevel_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool InternedV8JsFunction::_internal_is_toplevel() const {
  return _impl_.is_toplevel_;
}
inline bool InternedV8JsFunction::is_toplevel() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InternedV8JsFunction.is_toplevel)
  return _internal_is_toplevel();
}
inline void InternedV8JsFunction::_internal_set_is_toplevel(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.is_toplevel_ = value;
}
inline void InternedV8JsFunction::set_is_toplevel(bool value) {
  _internal_set_is_toplevel(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.InternedV8JsFunction.is_toplevel)
}

// optional .perfetto.protos.InternedV8JsFunction.Kind kind = 5;
inline bool InternedV8JsFunction::_internal_has_kind() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool InternedV8JsFunction::has_kind() const {
  return _internal_has_kind();
}
inline void InternedV8JsFunction::clear_kind() {
  _impl_.kind_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::perfetto::protos::InternedV8JsFunction_Kind InternedV8JsFunction::_internal_kind() const {
  return static_cast< ::perfetto::protos::InternedV8JsFunction_Kind >(_impl_.kind_);
}
inline ::perfetto::protos::InternedV8JsFunction_Kind InternedV8JsFunction::kind() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InternedV8JsFunction.kind)
  return _internal_kind();
}
inline void InternedV8JsFunction::_internal_set_kind(::perfetto::protos::InternedV8JsFunction_Kind value) {
  assert(::perfetto::protos::InternedV8JsFunction_Kind_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.kind_ = value;
}
inline void InternedV8JsFunction::set_kind(::perfetto::protos::InternedV8JsFunction_Kind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.InternedV8JsFunction.kind)
}

// optional uint32 byte_offset = 6;
inline bool InternedV8JsFunction::_internal_has_byte_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool InternedV8JsFunction::has_byte_offset() const {
  return _internal_has_byte_offset();
}
inline void InternedV8JsFunction::clear_byte_offset() {
  _impl_.byte_offset_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t InternedV8JsFunction::_internal_byte_offset() const {
  return _impl_.byte_offset_;
}
inline uint32_t InternedV8JsFunction::byte_offset() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InternedV8JsFunction.byte_offset)
  return _internal_byte_offset();
}
inline void InternedV8JsFunction::_internal_set_byte_offset(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.byte_offset_ = value;
}
inline void InternedV8JsFunction::set_byte_offset(uint32_t value) {
  _internal_set_byte_offset(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.InternedV8JsFunction.byte_offset)
}

// -------------------------------------------------------------------

// InternedV8Isolate_CodeRange

// optional uint64 base_address = 1;
inline bool InternedV8Isolate_CodeRange::_internal_has_base_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InternedV8Isolate_CodeRange::has_base_address() const {
  return _internal_has_base_address();
}
inline void InternedV8Isolate_CodeRange::clear_base_address() {
  _impl_.base_address_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t InternedV8Isolate_CodeRange::_internal_base_address() const {
  return _impl_.base_address_;
}
inline uint64_t InternedV8Isolate_CodeRange::base_address() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InternedV8Isolate.CodeRange.base_address)
  return _internal_base_address();
}
inline void InternedV8Isolate_CodeRange::_internal_set_base_address(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.base_address_ = value;
}
inline void InternedV8Isolate_CodeRange::set_base_address(uint64_t value) {
  _internal_set_base_address(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.InternedV8Isolate.CodeRange.base_address)
}

// optional uint64 size = 2;
inline bool InternedV8Isolate_CodeRange::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InternedV8Isolate_CodeRange::has_size() const {
  return _internal_has_size();
}
inline void InternedV8Isolate_CodeRange::clear_size() {
  _impl_.size_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t InternedV8Isolate_CodeRange::_internal_size() const {
  return _impl_.size_;
}
inline uint64_t InternedV8Isolate_CodeRange::size() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InternedV8Isolate.CodeRange.size)
  return _internal_size();
}
inline void InternedV8Isolate_CodeRange::_internal_set_size(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.size_ = value;
}
inline void InternedV8Isolate_CodeRange::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.InternedV8Isolate.CodeRange.size)
}

// optional uint64 embedded_blob_code_copy_start_address = 3;
inline bool InternedV8Isolate_CodeRange::_internal_has_embedded_blob_code_copy_start_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool InternedV8Isolate_CodeRange::has_embedded_blob_code_copy_start_address() const {
  return _internal_has_embedded_blob_code_copy_start_address();
}
inline void InternedV8Isolate_CodeRange::clear_embedded_blob_code_copy_start_address() {
  _impl_.embedded_blob_code_copy_start_address_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t InternedV8Isolate_CodeRange::_internal_embedded_blob_code_copy_start_address() const {
  return _impl_.embedded_blob_code_copy_start_address_;
}
inline uint64_t InternedV8Isolate_CodeRange::embedded_blob_code_copy_start_address() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InternedV8Isolate.CodeRange.embedded_blob_code_copy_start_address)
  return _internal_embedded_blob_code_copy_start_address();
}
inline void InternedV8Isolate_CodeRange::_internal_set_embedded_blob_code_copy_start_address(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.embedded_blob_code_copy_start_address_ = value;
}
inline void InternedV8Isolate_CodeRange::set_embedded_blob_code_copy_start_address(uint64_t value) {
  _internal_set_embedded_blob_code_copy_start_address(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.InternedV8Isolate.CodeRange.embedded_blob_code_copy_start_address)
}

// optional bool is_process_wide = 4;
inline bool InternedV8Isolate_CodeRange::_internal_has_is_process_wide() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool InternedV8Isolate_CodeRange::has_is_process_wide() const {
  return _internal_has_is_process_wide();
}
inline void InternedV8Isolate_CodeRange::clear_is_process_wide() {
  _impl_.is_process_wide_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool InternedV8Isolate_CodeRange::_internal_is_process_wide() const {
  return _impl_.is_process_wide_;
}
inline bool InternedV8Isolate_CodeRange::is_process_wide() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InternedV8Isolate.CodeRange.is_process_wide)
  return _internal_is_process_wide();
}
inline void InternedV8Isolate_CodeRange::_internal_set_is_process_wide(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.is_process_wide_ = value;
}
inline void InternedV8Isolate_CodeRange::set_is_process_wide(bool value) {
  _internal_set_is_process_wide(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.InternedV8Isolate.CodeRange.is_process_wide)
}

// -------------------------------------------------------------------

// InternedV8Isolate

// optional uint64 iid = 1;
inline bool InternedV8Isolate::_internal_has_iid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InternedV8Isolate::has_iid() const {
  return _internal_has_iid();
}
inline void InternedV8Isolate::clear_iid() {
  _impl_.iid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t InternedV8Isolate::_internal_iid() const {
  return _impl_.iid_;
}
inline uint64_t InternedV8Isolate::iid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InternedV8Isolate.iid)
  return _internal_iid();
}
inline void InternedV8Isolate::_internal_set_iid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.iid_ = value;
}
inline void InternedV8Isolate::set_iid(uint64_t value) {
  _internal_set_iid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.InternedV8Isolate.iid)
}

// optional uint32 pid = 2;
inline bool InternedV8Isolate::_internal_has_pid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool InternedV8Isolate::has_pid() const {
  return _internal_has_pid();
}
inline void InternedV8Isolate::clear_pid() {
  _impl_.pid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t InternedV8Isolate::_internal_pid() const {
  return _impl_.pid_;
}
inline uint32_t InternedV8Isolate::pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InternedV8Isolate.pid)
  return _internal_pid();
}
inline void InternedV8Isolate::_internal_set_pid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.pid_ = value;
}
inline void InternedV8Isolate::set_pid(uint32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.InternedV8Isolate.pid)
}

// optional int32 isolate_id = 3;
inline bool InternedV8Isolate::_internal_has_isolate_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool InternedV8Isolate::has_isolate_id() const {
  return _internal_has_isolate_id();
}
inline void InternedV8Isolate::clear_isolate_id() {
  _impl_.isolate_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t InternedV8Isolate::_internal_isolate_id() const {
  return _impl_.isolate_id_;
}
inline int32_t InternedV8Isolate::isolate_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InternedV8Isolate.isolate_id)
  return _internal_isolate_id();
}
inline void InternedV8Isolate::_internal_set_isolate_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.isolate_id_ = value;
}
inline void InternedV8Isolate::set_isolate_id(int32_t value) {
  _internal_set_isolate_id(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.InternedV8Isolate.isolate_id)
}

// optional .perfetto.protos.InternedV8Isolate.CodeRange code_range = 4;
inline bool InternedV8Isolate::_internal_has_code_range() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.code_range_ != nullptr);
  return value;
}
inline bool InternedV8Isolate::has_code_range() const {
  return _internal_has_code_range();
}
inline void InternedV8Isolate::clear_code_range() {
  if (_impl_.code_range_ != nullptr) _impl_.code_range_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::perfetto::protos::InternedV8Isolate_CodeRange& InternedV8Isolate::_internal_code_range() const {
  const ::perfetto::protos::InternedV8Isolate_CodeRange* p = _impl_.code_range_;
  return p != nullptr ? *p : reinterpret_cast<const ::perfetto::protos::InternedV8Isolate_CodeRange&>(
      ::perfetto::protos::_InternedV8Isolate_CodeRange_default_instance_);
}
inline const ::perfetto::protos::InternedV8Isolate_CodeRange& InternedV8Isolate::code_range() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InternedV8Isolate.code_range)
  return _internal_code_range();
}
inline void InternedV8Isolate::unsafe_arena_set_allocated_code_range(
    ::perfetto::protos::InternedV8Isolate_CodeRange* code_range) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.code_range_);
  }
  _impl_.code_range_ = code_range;
  if (code_range) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perfetto.protos.InternedV8Isolate.code_range)
}
inline ::perfetto::protos::InternedV8Isolate_CodeRange* InternedV8Isolate::release_code_range() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::perfetto::protos::InternedV8Isolate_CodeRange* temp = _impl_.code_range_;
  _impl_.code_range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::perfetto::protos::InternedV8Isolate_CodeRange* InternedV8Isolate::unsafe_arena_release_code_range() {
  // @@protoc_insertion_point(field_release:perfetto.protos.InternedV8Isolate.code_range)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::perfetto::protos::InternedV8Isolate_CodeRange* temp = _impl_.code_range_;
  _impl_.code_range_ = nullptr;
  return temp;
}
inline ::perfetto::protos::InternedV8Isolate_CodeRange* InternedV8Isolate::_internal_mutable_code_range() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.code_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::perfetto::protos::InternedV8Isolate_CodeRange>(GetArenaForAllocation());
    _impl_.code_range_ = p;
  }
  return _impl_.code_range_;
}
inline ::perfetto::protos::InternedV8Isolate_CodeRange* InternedV8Isolate::mutable_code_range() {
  ::perfetto::protos::InternedV8Isolate_CodeRange* _msg = _internal_mutable_code_range();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.InternedV8Isolate.code_range)
  return _msg;
}
inline void InternedV8Isolate::set_allocated_code_range(::perfetto::protos::InternedV8Isolate_CodeRange* code_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.code_range_;
  }
  if (code_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(code_range);
    if (message_arena != submessage_arena) {
      code_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, code_range, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.code_range_ = code_range;
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.InternedV8Isolate.code_range)
}

// optional uint64 embedded_blob_code_start_address = 5;
inline bool InternedV8Isolate::_internal_has_embedded_blob_code_start_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool InternedV8Isolate::has_embedded_blob_code_start_address() const {
  return _internal_has_embedded_blob_code_start_address();
}
inline void InternedV8Isolate::clear_embedded_blob_code_start_address() {
  _impl_.embedded_blob_code_start_address_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t InternedV8Isolate::_internal_embedded_blob_code_start_address() const {
  return _impl_.embedded_blob_code_start_address_;
}
inline uint64_t InternedV8Isolate::embedded_blob_code_start_address() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InternedV8Isolate.embedded_blob_code_start_address)
  return _internal_embedded_blob_code_start_address();
}
inline void InternedV8Isolate::_internal_set_embedded_blob_code_start_address(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.embedded_blob_code_start_address_ = value;
}
inline void InternedV8Isolate::set_embedded_blob_code_start_address(uint64_t value) {
  _internal_set_embedded_blob_code_start_address(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.InternedV8Isolate.embedded_blob_code_start_address)
}

// optional uint64 embedded_blob_code_size = 6;
inline bool InternedV8Isolate::_internal_has_embedded_blob_code_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool InternedV8Isolate::has_embedded_blob_code_size() const {
  return _internal_has_embedded_blob_code_size();
}
inline void InternedV8Isolate::clear_embedded_blob_code_size() {
  _impl_.embedded_blob_code_size_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint64_t InternedV8Isolate::_internal_embedded_blob_code_size() const {
  return _impl_.embedded_blob_code_size_;
}
inline uint64_t InternedV8Isolate::embedded_blob_code_size() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InternedV8Isolate.embedded_blob_code_size)
  return _internal_embedded_blob_code_size();
}
inline void InternedV8Isolate::_internal_set_embedded_blob_code_size(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.embedded_blob_code_size_ = value;
}
inline void InternedV8Isolate::set_embedded_blob_code_size(uint64_t value) {
  _internal_set_embedded_blob_code_size(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.InternedV8Isolate.embedded_blob_code_size)
}

// -------------------------------------------------------------------

// V8JsCode

// optional uint64 v8_isolate_iid = 1;
inline bool V8JsCode::_internal_has_v8_isolate_iid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool V8JsCode::has_v8_isolate_iid() const {
  return _internal_has_v8_isolate_iid();
}
inline void V8JsCode::clear_v8_isolate_iid() {
  _impl_.v8_isolate_iid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t V8JsCode::_internal_v8_isolate_iid() const {
  return _impl_.v8_isolate_iid_;
}
inline uint64_t V8JsCode::v8_isolate_iid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8JsCode.v8_isolate_iid)
  return _internal_v8_isolate_iid();
}
inline void V8JsCode::_internal_set_v8_isolate_iid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.v8_isolate_iid_ = value;
}
inline void V8JsCode::set_v8_isolate_iid(uint64_t value) {
  _internal_set_v8_isolate_iid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.V8JsCode.v8_isolate_iid)
}

// optional uint32 tid = 2;
inline bool V8JsCode::_internal_has_tid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool V8JsCode::has_tid() const {
  return _internal_has_tid();
}
inline void V8JsCode::clear_tid() {
  _impl_.tid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t V8JsCode::_internal_tid() const {
  return _impl_.tid_;
}
inline uint32_t V8JsCode::tid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8JsCode.tid)
  return _internal_tid();
}
inline void V8JsCode::_internal_set_tid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.tid_ = value;
}
inline void V8JsCode::set_tid(uint32_t value) {
  _internal_set_tid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.V8JsCode.tid)
}

// optional uint64 v8_js_function_iid = 3;
inline bool V8JsCode::_internal_has_v8_js_function_iid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool V8JsCode::has_v8_js_function_iid() const {
  return _internal_has_v8_js_function_iid();
}
inline void V8JsCode::clear_v8_js_function_iid() {
  _impl_.v8_js_function_iid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t V8JsCode::_internal_v8_js_function_iid() const {
  return _impl_.v8_js_function_iid_;
}
inline uint64_t V8JsCode::v8_js_function_iid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8JsCode.v8_js_function_iid)
  return _internal_v8_js_function_iid();
}
inline void V8JsCode::_internal_set_v8_js_function_iid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.v8_js_function_iid_ = value;
}
inline void V8JsCode::set_v8_js_function_iid(uint64_t value) {
  _internal_set_v8_js_function_iid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.V8JsCode.v8_js_function_iid)
}

// optional .perfetto.protos.V8JsCode.Tier tier = 4;
inline bool V8JsCode::_internal_has_tier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool V8JsCode::has_tier() const {
  return _internal_has_tier();
}
inline void V8JsCode::clear_tier() {
  _impl_.tier_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::perfetto::protos::V8JsCode_Tier V8JsCode::_internal_tier() const {
  return static_cast< ::perfetto::protos::V8JsCode_Tier >(_impl_.tier_);
}
inline ::perfetto::protos::V8JsCode_Tier V8JsCode::tier() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8JsCode.tier)
  return _internal_tier();
}
inline void V8JsCode::_internal_set_tier(::perfetto::protos::V8JsCode_Tier value) {
  assert(::perfetto::protos::V8JsCode_Tier_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.tier_ = value;
}
inline void V8JsCode::set_tier(::perfetto::protos::V8JsCode_Tier value) {
  _internal_set_tier(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.V8JsCode.tier)
}

// optional uint64 instruction_start = 5;
inline bool V8JsCode::_internal_has_instruction_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool V8JsCode::has_instruction_start() const {
  return _internal_has_instruction_start();
}
inline void V8JsCode::clear_instruction_start() {
  _impl_.instruction_start_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t V8JsCode::_internal_instruction_start() const {
  return _impl_.instruction_start_;
}
inline uint64_t V8JsCode::instruction_start() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8JsCode.instruction_start)
  return _internal_instruction_start();
}
inline void V8JsCode::_internal_set_instruction_start(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.instruction_start_ = value;
}
inline void V8JsCode::set_instruction_start(uint64_t value) {
  _internal_set_instruction_start(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.V8JsCode.instruction_start)
}

// optional uint64 instruction_size_bytes = 6;
inline bool V8JsCode::_internal_has_instruction_size_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool V8JsCode::has_instruction_size_bytes() const {
  return _internal_has_instruction_size_bytes();
}
inline void V8JsCode::clear_instruction_size_bytes() {
  _impl_.instruction_size_bytes_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint64_t V8JsCode::_internal_instruction_size_bytes() const {
  return _impl_.instruction_size_bytes_;
}
inline uint64_t V8JsCode::instruction_size_bytes() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8JsCode.instruction_size_bytes)
  return _internal_instruction_size_bytes();
}
inline void V8JsCode::_internal_set_instruction_size_bytes(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.instruction_size_bytes_ = value;
}
inline void V8JsCode::set_instruction_size_bytes(uint64_t value) {
  _internal_set_instruction_size_bytes(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.V8JsCode.instruction_size_bytes)
}

// bytes machine_code = 7;
inline bool V8JsCode::_internal_has_machine_code() const {
  return instructions_case() == kMachineCode;
}
inline bool V8JsCode::has_machine_code() const {
  return _internal_has_machine_code();
}
inline void V8JsCode::set_has_machine_code() {
  _impl_._oneof_case_[0] = kMachineCode;
}
inline void V8JsCode::clear_machine_code() {
  if (_internal_has_machine_code()) {
    _impl_.instructions_.machine_code_.Destroy();
    clear_has_instructions();
  }
}
inline const std::string& V8JsCode::machine_code() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8JsCode.machine_code)
  return _internal_machine_code();
}
template <typename ArgT0, typename... ArgT>
inline void V8JsCode::set_machine_code(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_machine_code()) {
    clear_instructions();
    set_has_machine_code();
    _impl_.instructions_.machine_code_.InitDefault();
  }
  _impl_.instructions_.machine_code_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.V8JsCode.machine_code)
}
inline std::string* V8JsCode::mutable_machine_code() {
  std::string* _s = _internal_mutable_machine_code();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.V8JsCode.machine_code)
  return _s;
}
inline const std::string& V8JsCode::_internal_machine_code() const {
  if (_internal_has_machine_code()) {
    return _impl_.instructions_.machine_code_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void V8JsCode::_internal_set_machine_code(const std::string& value) {
  if (!_internal_has_machine_code()) {
    clear_instructions();
    set_has_machine_code();
    _impl_.instructions_.machine_code_.InitDefault();
  }
  _impl_.instructions_.machine_code_.Set(value, GetArenaForAllocation());
}
inline std::string* V8JsCode::_internal_mutable_machine_code() {
  if (!_internal_has_machine_code()) {
    clear_instructions();
    set_has_machine_code();
    _impl_.instructions_.machine_code_.InitDefault();
  }
  return _impl_.instructions_.machine_code_.Mutable(      GetArenaForAllocation());
}
inline std::string* V8JsCode::release_machine_code() {
  // @@protoc_insertion_point(field_release:perfetto.protos.V8JsCode.machine_code)
  if (_internal_has_machine_code()) {
    clear_has_instructions();
    return _impl_.instructions_.machine_code_.Release();
  } else {
    return nullptr;
  }
}
inline void V8JsCode::set_allocated_machine_code(std::string* machine_code) {
  if (has_instructions()) {
    clear_instructions();
  }
  if (machine_code != nullptr) {
    set_has_machine_code();
    _impl_.instructions_.machine_code_.InitAllocated(machine_code, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.V8JsCode.machine_code)
}

// bytes bytecode = 8;
inline bool V8JsCode::_internal_has_bytecode() const {
  return instructions_case() == kBytecode;
}
inline bool V8JsCode::has_bytecode() const {
  return _internal_has_bytecode();
}
inline void V8JsCode::set_has_bytecode() {
  _impl_._oneof_case_[0] = kBytecode;
}
inline void V8JsCode::clear_bytecode() {
  if (_internal_has_bytecode()) {
    _impl_.instructions_.bytecode_.Destroy();
    clear_has_instructions();
  }
}
inline const std::string& V8JsCode::bytecode() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8JsCode.bytecode)
  return _internal_bytecode();
}
template <typename ArgT0, typename... ArgT>
inline void V8JsCode::set_bytecode(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_bytecode()) {
    clear_instructions();
    set_has_bytecode();
    _impl_.instructions_.bytecode_.InitDefault();
  }
  _impl_.instructions_.bytecode_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.V8JsCode.bytecode)
}
inline std::string* V8JsCode::mutable_bytecode() {
  std::string* _s = _internal_mutable_bytecode();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.V8JsCode.bytecode)
  return _s;
}
inline const std::string& V8JsCode::_internal_bytecode() const {
  if (_internal_has_bytecode()) {
    return _impl_.instructions_.bytecode_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void V8JsCode::_internal_set_bytecode(const std::string& value) {
  if (!_internal_has_bytecode()) {
    clear_instructions();
    set_has_bytecode();
    _impl_.instructions_.bytecode_.InitDefault();
  }
  _impl_.instructions_.bytecode_.Set(value, GetArenaForAllocation());
}
inline std::string* V8JsCode::_internal_mutable_bytecode() {
  if (!_internal_has_bytecode()) {
    clear_instructions();
    set_has_bytecode();
    _impl_.instructions_.bytecode_.InitDefault();
  }
  return _impl_.instructions_.bytecode_.Mutable(      GetArenaForAllocation());
}
inline std::string* V8JsCode::release_bytecode() {
  // @@protoc_insertion_point(field_release:perfetto.protos.V8JsCode.bytecode)
  if (_internal_has_bytecode()) {
    clear_has_instructions();
    return _impl_.instructions_.bytecode_.Release();
  } else {
    return nullptr;
  }
}
inline void V8JsCode::set_allocated_bytecode(std::string* bytecode) {
  if (has_instructions()) {
    clear_instructions();
  }
  if (bytecode != nullptr) {
    set_has_bytecode();
    _impl_.instructions_.bytecode_.InitAllocated(bytecode, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.V8JsCode.bytecode)
}

inline bool V8JsCode::has_instructions() const {
  return instructions_case() != INSTRUCTIONS_NOT_SET;
}
inline void V8JsCode::clear_has_instructions() {
  _impl_._oneof_case_[0] = INSTRUCTIONS_NOT_SET;
}
inline V8JsCode::InstructionsCase V8JsCode::instructions_case() const {
  return V8JsCode::InstructionsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// V8InternalCode

// optional uint64 v8_isolate_iid = 1;
inline bool V8InternalCode::_internal_has_v8_isolate_iid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool V8InternalCode::has_v8_isolate_iid() const {
  return _internal_has_v8_isolate_iid();
}
inline void V8InternalCode::clear_v8_isolate_iid() {
  _impl_.v8_isolate_iid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t V8InternalCode::_internal_v8_isolate_iid() const {
  return _impl_.v8_isolate_iid_;
}
inline uint64_t V8InternalCode::v8_isolate_iid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8InternalCode.v8_isolate_iid)
  return _internal_v8_isolate_iid();
}
inline void V8InternalCode::_internal_set_v8_isolate_iid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.v8_isolate_iid_ = value;
}
inline void V8InternalCode::set_v8_isolate_iid(uint64_t value) {
  _internal_set_v8_isolate_iid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.V8InternalCode.v8_isolate_iid)
}

// optional uint32 tid = 2;
inline bool V8InternalCode::_internal_has_tid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool V8InternalCode::has_tid() const {
  return _internal_has_tid();
}
inline void V8InternalCode::clear_tid() {
  _impl_.tid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t V8InternalCode::_internal_tid() const {
  return _impl_.tid_;
}
inline uint32_t V8InternalCode::tid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8InternalCode.tid)
  return _internal_tid();
}
inline void V8InternalCode::_internal_set_tid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.tid_ = value;
}
inline void V8InternalCode::set_tid(uint32_t value) {
  _internal_set_tid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.V8InternalCode.tid)
}

// optional string name = 3;
inline bool V8InternalCode::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool V8InternalCode::has_name() const {
  return _internal_has_name();
}
inline void V8InternalCode::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& V8InternalCode::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8InternalCode.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void V8InternalCode::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.V8InternalCode.name)
}
inline std::string* V8InternalCode::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.V8InternalCode.name)
  return _s;
}
inline const std::string& V8InternalCode::_internal_name() const {
  return _impl_.name_.Get();
}
inline void V8InternalCode::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* V8InternalCode::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* V8InternalCode::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.V8InternalCode.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void V8InternalCode::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.V8InternalCode.name)
}

// optional .perfetto.protos.V8InternalCode.Type type = 4;
inline bool V8InternalCode::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool V8InternalCode::has_type() const {
  return _internal_has_type();
}
inline void V8InternalCode::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::perfetto::protos::V8InternalCode_Type V8InternalCode::_internal_type() const {
  return static_cast< ::perfetto::protos::V8InternalCode_Type >(_impl_.type_);
}
inline ::perfetto::protos::V8InternalCode_Type V8InternalCode::type() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8InternalCode.type)
  return _internal_type();
}
inline void V8InternalCode::_internal_set_type(::perfetto::protos::V8InternalCode_Type value) {
  assert(::perfetto::protos::V8InternalCode_Type_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.type_ = value;
}
inline void V8InternalCode::set_type(::perfetto::protos::V8InternalCode_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.V8InternalCode.type)
}

// optional int32 builtin_id = 5;
inline bool V8InternalCode::_internal_has_builtin_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool V8InternalCode::has_builtin_id() const {
  return _internal_has_builtin_id();
}
inline void V8InternalCode::clear_builtin_id() {
  _impl_.builtin_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int32_t V8InternalCode::_internal_builtin_id() const {
  return _impl_.builtin_id_;
}
inline int32_t V8InternalCode::builtin_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8InternalCode.builtin_id)
  return _internal_builtin_id();
}
inline void V8InternalCode::_internal_set_builtin_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.builtin_id_ = value;
}
inline void V8InternalCode::set_builtin_id(int32_t value) {
  _internal_set_builtin_id(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.V8InternalCode.builtin_id)
}

// optional uint64 instruction_start = 6;
inline bool V8InternalCode::_internal_has_instruction_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool V8InternalCode::has_instruction_start() const {
  return _internal_has_instruction_start();
}
inline void V8InternalCode::clear_instruction_start() {
  _impl_.instruction_start_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint64_t V8InternalCode::_internal_instruction_start() const {
  return _impl_.instruction_start_;
}
inline uint64_t V8InternalCode::instruction_start() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8InternalCode.instruction_start)
  return _internal_instruction_start();
}
inline void V8InternalCode::_internal_set_instruction_start(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.instruction_start_ = value;
}
inline void V8InternalCode::set_instruction_start(uint64_t value) {
  _internal_set_instruction_start(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.V8InternalCode.instruction_start)
}

// optional uint64 instruction_size_bytes = 7;
inline bool V8InternalCode::_internal_has_instruction_size_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool V8InternalCode::has_instruction_size_bytes() const {
  return _internal_has_instruction_size_bytes();
}
inline void V8InternalCode::clear_instruction_size_bytes() {
  _impl_.instruction_size_bytes_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint64_t V8InternalCode::_internal_instruction_size_bytes() const {
  return _impl_.instruction_size_bytes_;
}
inline uint64_t V8InternalCode::instruction_size_bytes() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8InternalCode.instruction_size_bytes)
  return _internal_instruction_size_bytes();
}
inline void V8InternalCode::_internal_set_instruction_size_bytes(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.instruction_size_bytes_ = value;
}
inline void V8InternalCode::set_instruction_size_bytes(uint64_t value) {
  _internal_set_instruction_size_bytes(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.V8InternalCode.instruction_size_bytes)
}

// optional bytes machine_code = 8;
inline bool V8InternalCode::_internal_has_machine_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool V8InternalCode::has_machine_code() const {
  return _internal_has_machine_code();
}
inline void V8InternalCode::clear_machine_code() {
  _impl_.machine_code_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& V8InternalCode::machine_code() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8InternalCode.machine_code)
  return _internal_machine_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void V8InternalCode::set_machine_code(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.machine_code_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.V8InternalCode.machine_code)
}
inline std::string* V8InternalCode::mutable_machine_code() {
  std::string* _s = _internal_mutable_machine_code();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.V8InternalCode.machine_code)
  return _s;
}
inline const std::string& V8InternalCode::_internal_machine_code() const {
  return _impl_.machine_code_.Get();
}
inline void V8InternalCode::_internal_set_machine_code(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.machine_code_.Set(value, GetArenaForAllocation());
}
inline std::string* V8InternalCode::_internal_mutable_machine_code() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.machine_code_.Mutable(GetArenaForAllocation());
}
inline std::string* V8InternalCode::release_machine_code() {
  // @@protoc_insertion_point(field_release:perfetto.protos.V8InternalCode.machine_code)
  if (!_internal_has_machine_code()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.machine_code_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.machine_code_.IsDefault()) {
    _impl_.machine_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void V8InternalCode::set_allocated_machine_code(std::string* machine_code) {
  if (machine_code != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.machine_code_.SetAllocated(machine_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.machine_code_.IsDefault()) {
    _impl_.machine_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.V8InternalCode.machine_code)
}

// -------------------------------------------------------------------

// V8WasmCode

// optional uint64 v8_isolate_iid = 1;
inline bool V8WasmCode::_internal_has_v8_isolate_iid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool V8WasmCode::has_v8_isolate_iid() const {
  return _internal_has_v8_isolate_iid();
}
inline void V8WasmCode::clear_v8_isolate_iid() {
  _impl_.v8_isolate_iid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t V8WasmCode::_internal_v8_isolate_iid() const {
  return _impl_.v8_isolate_iid_;
}
inline uint64_t V8WasmCode::v8_isolate_iid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8WasmCode.v8_isolate_iid)
  return _internal_v8_isolate_iid();
}
inline void V8WasmCode::_internal_set_v8_isolate_iid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.v8_isolate_iid_ = value;
}
inline void V8WasmCode::set_v8_isolate_iid(uint64_t value) {
  _internal_set_v8_isolate_iid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.V8WasmCode.v8_isolate_iid)
}

// optional uint32 tid = 2;
inline bool V8WasmCode::_internal_has_tid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool V8WasmCode::has_tid() const {
  return _internal_has_tid();
}
inline void V8WasmCode::clear_tid() {
  _impl_.tid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t V8WasmCode::_internal_tid() const {
  return _impl_.tid_;
}
inline uint32_t V8WasmCode::tid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8WasmCode.tid)
  return _internal_tid();
}
inline void V8WasmCode::_internal_set_tid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.tid_ = value;
}
inline void V8WasmCode::set_tid(uint32_t value) {
  _internal_set_tid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.V8WasmCode.tid)
}

// optional uint64 v8_wasm_script_iid = 3;
inline bool V8WasmCode::_internal_has_v8_wasm_script_iid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool V8WasmCode::has_v8_wasm_script_iid() const {
  return _internal_has_v8_wasm_script_iid();
}
inline void V8WasmCode::clear_v8_wasm_script_iid() {
  _impl_.v8_wasm_script_iid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t V8WasmCode::_internal_v8_wasm_script_iid() const {
  return _impl_.v8_wasm_script_iid_;
}
inline uint64_t V8WasmCode::v8_wasm_script_iid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8WasmCode.v8_wasm_script_iid)
  return _internal_v8_wasm_script_iid();
}
inline void V8WasmCode::_internal_set_v8_wasm_script_iid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.v8_wasm_script_iid_ = value;
}
inline void V8WasmCode::set_v8_wasm_script_iid(uint64_t value) {
  _internal_set_v8_wasm_script_iid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.V8WasmCode.v8_wasm_script_iid)
}

// optional string function_name = 4;
inline bool V8WasmCode::_internal_has_function_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool V8WasmCode::has_function_name() const {
  return _internal_has_function_name();
}
inline void V8WasmCode::clear_function_name() {
  _impl_.function_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& V8WasmCode::function_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8WasmCode.function_name)
  return _internal_function_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void V8WasmCode::set_function_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.function_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.V8WasmCode.function_name)
}
inline std::string* V8WasmCode::mutable_function_name() {
  std::string* _s = _internal_mutable_function_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.V8WasmCode.function_name)
  return _s;
}
inline const std::string& V8WasmCode::_internal_function_name() const {
  return _impl_.function_name_.Get();
}
inline void V8WasmCode::_internal_set_function_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.function_name_.Set(value, GetArenaForAllocation());
}
inline std::string* V8WasmCode::_internal_mutable_function_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.function_name_.Mutable(GetArenaForAllocation());
}
inline std::string* V8WasmCode::release_function_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.V8WasmCode.function_name)
  if (!_internal_has_function_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.function_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.function_name_.IsDefault()) {
    _impl_.function_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void V8WasmCode::set_allocated_function_name(std::string* function_name) {
  if (function_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.function_name_.SetAllocated(function_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.function_name_.IsDefault()) {
    _impl_.function_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.V8WasmCode.function_name)
}

// optional .perfetto.protos.V8WasmCode.Tier tier = 5;
inline bool V8WasmCode::_internal_has_tier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool V8WasmCode::has_tier() const {
  return _internal_has_tier();
}
inline void V8WasmCode::clear_tier() {
  _impl_.tier_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::perfetto::protos::V8WasmCode_Tier V8WasmCode::_internal_tier() const {
  return static_cast< ::perfetto::protos::V8WasmCode_Tier >(_impl_.tier_);
}
inline ::perfetto::protos::V8WasmCode_Tier V8WasmCode::tier() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8WasmCode.tier)
  return _internal_tier();
}
inline void V8WasmCode::_internal_set_tier(::perfetto::protos::V8WasmCode_Tier value) {
  assert(::perfetto::protos::V8WasmCode_Tier_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.tier_ = value;
}
inline void V8WasmCode::set_tier(::perfetto::protos::V8WasmCode_Tier value) {
  _internal_set_tier(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.V8WasmCode.tier)
}

// optional int32 code_offset_in_module = 6;
inline bool V8WasmCode::_internal_has_code_offset_in_module() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool V8WasmCode::has_code_offset_in_module() const {
  return _internal_has_code_offset_in_module();
}
inline void V8WasmCode::clear_code_offset_in_module() {
  _impl_.code_offset_in_module_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int32_t V8WasmCode::_internal_code_offset_in_module() const {
  return _impl_.code_offset_in_module_;
}
inline int32_t V8WasmCode::code_offset_in_module() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8WasmCode.code_offset_in_module)
  return _internal_code_offset_in_module();
}
inline void V8WasmCode::_internal_set_code_offset_in_module(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.code_offset_in_module_ = value;
}
inline void V8WasmCode::set_code_offset_in_module(int32_t value) {
  _internal_set_code_offset_in_module(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.V8WasmCode.code_offset_in_module)
}

// optional uint64 instruction_start = 7;
inline bool V8WasmCode::_internal_has_instruction_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool V8WasmCode::has_instruction_start() const {
  return _internal_has_instruction_start();
}
inline void V8WasmCode::clear_instruction_start() {
  _impl_.instruction_start_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint64_t V8WasmCode::_internal_instruction_start() const {
  return _impl_.instruction_start_;
}
inline uint64_t V8WasmCode::instruction_start() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8WasmCode.instruction_start)
  return _internal_instruction_start();
}
inline void V8WasmCode::_internal_set_instruction_start(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.instruction_start_ = value;
}
inline void V8WasmCode::set_instruction_start(uint64_t value) {
  _internal_set_instruction_start(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.V8WasmCode.instruction_start)
}

// optional uint64 instruction_size_bytes = 8;
inline bool V8WasmCode::_internal_has_instruction_size_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool V8WasmCode::has_instruction_size_bytes() const {
  return _internal_has_instruction_size_bytes();
}
inline void V8WasmCode::clear_instruction_size_bytes() {
  _impl_.instruction_size_bytes_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint64_t V8WasmCode::_internal_instruction_size_bytes() const {
  return _impl_.instruction_size_bytes_;
}
inline uint64_t V8WasmCode::instruction_size_bytes() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8WasmCode.instruction_size_bytes)
  return _internal_instruction_size_bytes();
}
inline void V8WasmCode::_internal_set_instruction_size_bytes(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.instruction_size_bytes_ = value;
}
inline void V8WasmCode::set_instruction_size_bytes(uint64_t value) {
  _internal_set_instruction_size_bytes(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.V8WasmCode.instruction_size_bytes)
}

// optional bytes machine_code = 9;
inline bool V8WasmCode::_internal_has_machine_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool V8WasmCode::has_machine_code() const {
  return _internal_has_machine_code();
}
inline void V8WasmCode::clear_machine_code() {
  _impl_.machine_code_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& V8WasmCode::machine_code() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8WasmCode.machine_code)
  return _internal_machine_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void V8WasmCode::set_machine_code(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.machine_code_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.V8WasmCode.machine_code)
}
inline std::string* V8WasmCode::mutable_machine_code() {
  std::string* _s = _internal_mutable_machine_code();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.V8WasmCode.machine_code)
  return _s;
}
inline const std::string& V8WasmCode::_internal_machine_code() const {
  return _impl_.machine_code_.Get();
}
inline void V8WasmCode::_internal_set_machine_code(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.machine_code_.Set(value, GetArenaForAllocation());
}
inline std::string* V8WasmCode::_internal_mutable_machine_code() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.machine_code_.Mutable(GetArenaForAllocation());
}
inline std::string* V8WasmCode::release_machine_code() {
  // @@protoc_insertion_point(field_release:perfetto.protos.V8WasmCode.machine_code)
  if (!_internal_has_machine_code()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.machine_code_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.machine_code_.IsDefault()) {
    _impl_.machine_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void V8WasmCode::set_allocated_machine_code(std::string* machine_code) {
  if (machine_code != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.machine_code_.SetAllocated(machine_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.machine_code_.IsDefault()) {
    _impl_.machine_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.V8WasmCode.machine_code)
}

// -------------------------------------------------------------------

// V8RegExpCode

// optional uint64 v8_isolate_iid = 1;
inline bool V8RegExpCode::_internal_has_v8_isolate_iid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool V8RegExpCode::has_v8_isolate_iid() const {
  return _internal_has_v8_isolate_iid();
}
inline void V8RegExpCode::clear_v8_isolate_iid() {
  _impl_.v8_isolate_iid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t V8RegExpCode::_internal_v8_isolate_iid() const {
  return _impl_.v8_isolate_iid_;
}
inline uint64_t V8RegExpCode::v8_isolate_iid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8RegExpCode.v8_isolate_iid)
  return _internal_v8_isolate_iid();
}
inline void V8RegExpCode::_internal_set_v8_isolate_iid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.v8_isolate_iid_ = value;
}
inline void V8RegExpCode::set_v8_isolate_iid(uint64_t value) {
  _internal_set_v8_isolate_iid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.V8RegExpCode.v8_isolate_iid)
}

// optional uint32 tid = 2;
inline bool V8RegExpCode::_internal_has_tid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool V8RegExpCode::has_tid() const {
  return _internal_has_tid();
}
inline void V8RegExpCode::clear_tid() {
  _impl_.tid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t V8RegExpCode::_internal_tid() const {
  return _impl_.tid_;
}
inline uint32_t V8RegExpCode::tid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8RegExpCode.tid)
  return _internal_tid();
}
inline void V8RegExpCode::_internal_set_tid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.tid_ = value;
}
inline void V8RegExpCode::set_tid(uint32_t value) {
  _internal_set_tid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.V8RegExpCode.tid)
}

// optional .perfetto.protos.V8String pattern = 3;
inline bool V8RegExpCode::_internal_has_pattern() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pattern_ != nullptr);
  return value;
}
inline bool V8RegExpCode::has_pattern() const {
  return _internal_has_pattern();
}
inline void V8RegExpCode::clear_pattern() {
  if (_impl_.pattern_ != nullptr) _impl_.pattern_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::perfetto::protos::V8String& V8RegExpCode::_internal_pattern() const {
  const ::perfetto::protos::V8String* p = _impl_.pattern_;
  return p != nullptr ? *p : reinterpret_cast<const ::perfetto::protos::V8String&>(
      ::perfetto::protos::_V8String_default_instance_);
}
inline const ::perfetto::protos::V8String& V8RegExpCode::pattern() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8RegExpCode.pattern)
  return _internal_pattern();
}
inline void V8RegExpCode::unsafe_arena_set_allocated_pattern(
    ::perfetto::protos::V8String* pattern) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pattern_);
  }
  _impl_.pattern_ = pattern;
  if (pattern) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perfetto.protos.V8RegExpCode.pattern)
}
inline ::perfetto::protos::V8String* V8RegExpCode::release_pattern() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::perfetto::protos::V8String* temp = _impl_.pattern_;
  _impl_.pattern_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::perfetto::protos::V8String* V8RegExpCode::unsafe_arena_release_pattern() {
  // @@protoc_insertion_point(field_release:perfetto.protos.V8RegExpCode.pattern)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::perfetto::protos::V8String* temp = _impl_.pattern_;
  _impl_.pattern_ = nullptr;
  return temp;
}
inline ::perfetto::protos::V8String* V8RegExpCode::_internal_mutable_pattern() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.pattern_ == nullptr) {
    auto* p = CreateMaybeMessage<::perfetto::protos::V8String>(GetArenaForAllocation());
    _impl_.pattern_ = p;
  }
  return _impl_.pattern_;
}
inline ::perfetto::protos::V8String* V8RegExpCode::mutable_pattern() {
  ::perfetto::protos::V8String* _msg = _internal_mutable_pattern();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.V8RegExpCode.pattern)
  return _msg;
}
inline void V8RegExpCode::set_allocated_pattern(::perfetto::protos::V8String* pattern) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pattern_;
  }
  if (pattern) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pattern);
    if (message_arena != submessage_arena) {
      pattern = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pattern, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.pattern_ = pattern;
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.V8RegExpCode.pattern)
}

// optional uint64 instruction_start = 4;
inline bool V8RegExpCode::_internal_has_instruction_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool V8RegExpCode::has_instruction_start() const {
  return _internal_has_instruction_start();
}
inline void V8RegExpCode::clear_instruction_start() {
  _impl_.instruction_start_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t V8RegExpCode::_internal_instruction_start() const {
  return _impl_.instruction_start_;
}
inline uint64_t V8RegExpCode::instruction_start() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8RegExpCode.instruction_start)
  return _internal_instruction_start();
}
inline void V8RegExpCode::_internal_set_instruction_start(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.instruction_start_ = value;
}
inline void V8RegExpCode::set_instruction_start(uint64_t value) {
  _internal_set_instruction_start(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.V8RegExpCode.instruction_start)
}

// optional uint64 instruction_size_bytes = 5;
inline bool V8RegExpCode::_internal_has_instruction_size_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool V8RegExpCode::has_instruction_size_bytes() const {
  return _internal_has_instruction_size_bytes();
}
inline void V8RegExpCode::clear_instruction_size_bytes() {
  _impl_.instruction_size_bytes_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t V8RegExpCode::_internal_instruction_size_bytes() const {
  return _impl_.instruction_size_bytes_;
}
inline uint64_t V8RegExpCode::instruction_size_bytes() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8RegExpCode.instruction_size_bytes)
  return _internal_instruction_size_bytes();
}
inline void V8RegExpCode::_internal_set_instruction_size_bytes(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.instruction_size_bytes_ = value;
}
inline void V8RegExpCode::set_instruction_size_bytes(uint64_t value) {
  _internal_set_instruction_size_bytes(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.V8RegExpCode.instruction_size_bytes)
}

// optional bytes machine_code = 6;
inline bool V8RegExpCode::_internal_has_machine_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool V8RegExpCode::has_machine_code() const {
  return _internal_has_machine_code();
}
inline void V8RegExpCode::clear_machine_code() {
  _impl_.machine_code_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& V8RegExpCode::machine_code() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8RegExpCode.machine_code)
  return _internal_machine_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void V8RegExpCode::set_machine_code(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.machine_code_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.V8RegExpCode.machine_code)
}
inline std::string* V8RegExpCode::mutable_machine_code() {
  std::string* _s = _internal_mutable_machine_code();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.V8RegExpCode.machine_code)
  return _s;
}
inline const std::string& V8RegExpCode::_internal_machine_code() const {
  return _impl_.machine_code_.Get();
}
inline void V8RegExpCode::_internal_set_machine_code(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.machine_code_.Set(value, GetArenaForAllocation());
}
inline std::string* V8RegExpCode::_internal_mutable_machine_code() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.machine_code_.Mutable(GetArenaForAllocation());
}
inline std::string* V8RegExpCode::release_machine_code() {
  // @@protoc_insertion_point(field_release:perfetto.protos.V8RegExpCode.machine_code)
  if (!_internal_has_machine_code()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.machine_code_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.machine_code_.IsDefault()) {
    _impl_.machine_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void V8RegExpCode::set_allocated_machine_code(std::string* machine_code) {
  if (machine_code != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.machine_code_.SetAllocated(machine_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.machine_code_.IsDefault()) {
    _impl_.machine_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.V8RegExpCode.machine_code)
}

// -------------------------------------------------------------------

// V8CodeMove

// optional uint64 isolate_iid = 1;
inline bool V8CodeMove::_internal_has_isolate_iid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool V8CodeMove::has_isolate_iid() const {
  return _internal_has_isolate_iid();
}
inline void V8CodeMove::clear_isolate_iid() {
  _impl_.isolate_iid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t V8CodeMove::_internal_isolate_iid() const {
  return _impl_.isolate_iid_;
}
inline uint64_t V8CodeMove::isolate_iid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8CodeMove.isolate_iid)
  return _internal_isolate_iid();
}
inline void V8CodeMove::_internal_set_isolate_iid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.isolate_iid_ = value;
}
inline void V8CodeMove::set_isolate_iid(uint64_t value) {
  _internal_set_isolate_iid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.V8CodeMove.isolate_iid)
}

// optional uint32 tid = 2;
inline bool V8CodeMove::_internal_has_tid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool V8CodeMove::has_tid() const {
  return _internal_has_tid();
}
inline void V8CodeMove::clear_tid() {
  _impl_.tid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t V8CodeMove::_internal_tid() const {
  return _impl_.tid_;
}
inline uint32_t V8CodeMove::tid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8CodeMove.tid)
  return _internal_tid();
}
inline void V8CodeMove::_internal_set_tid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.tid_ = value;
}
inline void V8CodeMove::set_tid(uint32_t value) {
  _internal_set_tid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.V8CodeMove.tid)
}

// optional uint64 from_instruction_start_address = 3;
inline bool V8CodeMove::_internal_has_from_instruction_start_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool V8CodeMove::has_from_instruction_start_address() const {
  return _internal_has_from_instruction_start_address();
}
inline void V8CodeMove::clear_from_instruction_start_address() {
  _impl_.from_instruction_start_address_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t V8CodeMove::_internal_from_instruction_start_address() const {
  return _impl_.from_instruction_start_address_;
}
inline uint64_t V8CodeMove::from_instruction_start_address() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8CodeMove.from_instruction_start_address)
  return _internal_from_instruction_start_address();
}
inline void V8CodeMove::_internal_set_from_instruction_start_address(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.from_instruction_start_address_ = value;
}
inline void V8CodeMove::set_from_instruction_start_address(uint64_t value) {
  _internal_set_from_instruction_start_address(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.V8CodeMove.from_instruction_start_address)
}

// optional uint64 to_instruction_start_address = 4;
inline bool V8CodeMove::_internal_has_to_instruction_start_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool V8CodeMove::has_to_instruction_start_address() const {
  return _internal_has_to_instruction_start_address();
}
inline void V8CodeMove::clear_to_instruction_start_address() {
  _impl_.to_instruction_start_address_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t V8CodeMove::_internal_to_instruction_start_address() const {
  return _impl_.to_instruction_start_address_;
}
inline uint64_t V8CodeMove::to_instruction_start_address() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8CodeMove.to_instruction_start_address)
  return _internal_to_instruction_start_address();
}
inline void V8CodeMove::_internal_set_to_instruction_start_address(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.to_instruction_start_address_ = value;
}
inline void V8CodeMove::set_to_instruction_start_address(uint64_t value) {
  _internal_set_to_instruction_start_address(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.V8CodeMove.to_instruction_start_address)
}

// optional uint64 instruction_size_bytes = 5;
inline bool V8CodeMove::_internal_has_instruction_size_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool V8CodeMove::has_instruction_size_bytes() const {
  return _internal_has_instruction_size_bytes();
}
inline void V8CodeMove::clear_instruction_size_bytes() {
  _impl_.instruction_size_bytes_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t V8CodeMove::_internal_instruction_size_bytes() const {
  return _impl_.instruction_size_bytes_;
}
inline uint64_t V8CodeMove::instruction_size_bytes() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8CodeMove.instruction_size_bytes)
  return _internal_instruction_size_bytes();
}
inline void V8CodeMove::_internal_set_instruction_size_bytes(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.instruction_size_bytes_ = value;
}
inline void V8CodeMove::set_instruction_size_bytes(uint64_t value) {
  _internal_set_instruction_size_bytes(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.V8CodeMove.instruction_size_bytes)
}

// bytes to_machine_code = 6;
inline bool V8CodeMove::_internal_has_to_machine_code() const {
  return to_instructions_case() == kToMachineCode;
}
inline bool V8CodeMove::has_to_machine_code() const {
  return _internal_has_to_machine_code();
}
inline void V8CodeMove::set_has_to_machine_code() {
  _impl_._oneof_case_[0] = kToMachineCode;
}
inline void V8CodeMove::clear_to_machine_code() {
  if (_internal_has_to_machine_code()) {
    _impl_.to_instructions_.to_machine_code_.Destroy();
    clear_has_to_instructions();
  }
}
inline const std::string& V8CodeMove::to_machine_code() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8CodeMove.to_machine_code)
  return _internal_to_machine_code();
}
template <typename ArgT0, typename... ArgT>
inline void V8CodeMove::set_to_machine_code(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_to_machine_code()) {
    clear_to_instructions();
    set_has_to_machine_code();
    _impl_.to_instructions_.to_machine_code_.InitDefault();
  }
  _impl_.to_instructions_.to_machine_code_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.V8CodeMove.to_machine_code)
}
inline std::string* V8CodeMove::mutable_to_machine_code() {
  std::string* _s = _internal_mutable_to_machine_code();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.V8CodeMove.to_machine_code)
  return _s;
}
inline const std::string& V8CodeMove::_internal_to_machine_code() const {
  if (_internal_has_to_machine_code()) {
    return _impl_.to_instructions_.to_machine_code_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void V8CodeMove::_internal_set_to_machine_code(const std::string& value) {
  if (!_internal_has_to_machine_code()) {
    clear_to_instructions();
    set_has_to_machine_code();
    _impl_.to_instructions_.to_machine_code_.InitDefault();
  }
  _impl_.to_instructions_.to_machine_code_.Set(value, GetArenaForAllocation());
}
inline std::string* V8CodeMove::_internal_mutable_to_machine_code() {
  if (!_internal_has_to_machine_code()) {
    clear_to_instructions();
    set_has_to_machine_code();
    _impl_.to_instructions_.to_machine_code_.InitDefault();
  }
  return _impl_.to_instructions_.to_machine_code_.Mutable(      GetArenaForAllocation());
}
inline std::string* V8CodeMove::release_to_machine_code() {
  // @@protoc_insertion_point(field_release:perfetto.protos.V8CodeMove.to_machine_code)
  if (_internal_has_to_machine_code()) {
    clear_has_to_instructions();
    return _impl_.to_instructions_.to_machine_code_.Release();
  } else {
    return nullptr;
  }
}
inline void V8CodeMove::set_allocated_to_machine_code(std::string* to_machine_code) {
  if (has_to_instructions()) {
    clear_to_instructions();
  }
  if (to_machine_code != nullptr) {
    set_has_to_machine_code();
    _impl_.to_instructions_.to_machine_code_.InitAllocated(to_machine_code, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.V8CodeMove.to_machine_code)
}

// bytes to_bytecode = 7;
inline bool V8CodeMove::_internal_has_to_bytecode() const {
  return to_instructions_case() == kToBytecode;
}
inline bool V8CodeMove::has_to_bytecode() const {
  return _internal_has_to_bytecode();
}
inline void V8CodeMove::set_has_to_bytecode() {
  _impl_._oneof_case_[0] = kToBytecode;
}
inline void V8CodeMove::clear_to_bytecode() {
  if (_internal_has_to_bytecode()) {
    _impl_.to_instructions_.to_bytecode_.Destroy();
    clear_has_to_instructions();
  }
}
inline const std::string& V8CodeMove::to_bytecode() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8CodeMove.to_bytecode)
  return _internal_to_bytecode();
}
template <typename ArgT0, typename... ArgT>
inline void V8CodeMove::set_to_bytecode(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_to_bytecode()) {
    clear_to_instructions();
    set_has_to_bytecode();
    _impl_.to_instructions_.to_bytecode_.InitDefault();
  }
  _impl_.to_instructions_.to_bytecode_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.V8CodeMove.to_bytecode)
}
inline std::string* V8CodeMove::mutable_to_bytecode() {
  std::string* _s = _internal_mutable_to_bytecode();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.V8CodeMove.to_bytecode)
  return _s;
}
inline const std::string& V8CodeMove::_internal_to_bytecode() const {
  if (_internal_has_to_bytecode()) {
    return _impl_.to_instructions_.to_bytecode_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void V8CodeMove::_internal_set_to_bytecode(const std::string& value) {
  if (!_internal_has_to_bytecode()) {
    clear_to_instructions();
    set_has_to_bytecode();
    _impl_.to_instructions_.to_bytecode_.InitDefault();
  }
  _impl_.to_instructions_.to_bytecode_.Set(value, GetArenaForAllocation());
}
inline std::string* V8CodeMove::_internal_mutable_to_bytecode() {
  if (!_internal_has_to_bytecode()) {
    clear_to_instructions();
    set_has_to_bytecode();
    _impl_.to_instructions_.to_bytecode_.InitDefault();
  }
  return _impl_.to_instructions_.to_bytecode_.Mutable(      GetArenaForAllocation());
}
inline std::string* V8CodeMove::release_to_bytecode() {
  // @@protoc_insertion_point(field_release:perfetto.protos.V8CodeMove.to_bytecode)
  if (_internal_has_to_bytecode()) {
    clear_has_to_instructions();
    return _impl_.to_instructions_.to_bytecode_.Release();
  } else {
    return nullptr;
  }
}
inline void V8CodeMove::set_allocated_to_bytecode(std::string* to_bytecode) {
  if (has_to_instructions()) {
    clear_to_instructions();
  }
  if (to_bytecode != nullptr) {
    set_has_to_bytecode();
    _impl_.to_instructions_.to_bytecode_.InitAllocated(to_bytecode, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.V8CodeMove.to_bytecode)
}

inline bool V8CodeMove::has_to_instructions() const {
  return to_instructions_case() != TO_INSTRUCTIONS_NOT_SET;
}
inline void V8CodeMove::clear_has_to_instructions() {
  _impl_._oneof_case_[0] = TO_INSTRUCTIONS_NOT_SET;
}
inline V8CodeMove::ToInstructionsCase V8CodeMove::to_instructions_case() const {
  return V8CodeMove::ToInstructionsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// V8CodeDefaults

// optional uint32 tid = 1;
inline bool V8CodeDefaults::_internal_has_tid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool V8CodeDefaults::has_tid() const {
  return _internal_has_tid();
}
inline void V8CodeDefaults::clear_tid() {
  _impl_.tid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t V8CodeDefaults::_internal_tid() const {
  return _impl_.tid_;
}
inline uint32_t V8CodeDefaults::tid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.V8CodeDefaults.tid)
  return _internal_tid();
}
inline void V8CodeDefaults::_internal_set_tid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.tid_ = value;
}
inline void V8CodeDefaults::set_tid(uint32_t value) {
  _internal_set_tid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.V8CodeDefaults.tid)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::perfetto::protos::InternedV8JsScript_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::perfetto::protos::InternedV8JsFunction_Kind> : ::std::true_type {};
template <> struct is_proto_enum< ::perfetto::protos::V8JsCode_Tier> : ::std::true_type {};
template <> struct is_proto_enum< ::perfetto::protos::V8InternalCode_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::perfetto::protos::V8WasmCode_Tier> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_protos_2fperfetto_2ftrace_2fchrome_2fv8_2eproto
