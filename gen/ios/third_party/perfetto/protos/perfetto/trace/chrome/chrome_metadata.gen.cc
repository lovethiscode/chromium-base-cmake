#include "perfetto/protozero/gen_field_helpers.h"
#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/scattered_heap_buffer.h"
// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
#endif
#include "protos/perfetto/trace/chrome/chrome_metadata.gen.h"

namespace perfetto {
namespace protos {
namespace gen {

BackgroundTracingMetadata::BackgroundTracingMetadata() = default;
BackgroundTracingMetadata::~BackgroundTracingMetadata() = default;
BackgroundTracingMetadata::BackgroundTracingMetadata(const BackgroundTracingMetadata&) = default;
BackgroundTracingMetadata& BackgroundTracingMetadata::operator=(const BackgroundTracingMetadata&) = default;
BackgroundTracingMetadata::BackgroundTracingMetadata(BackgroundTracingMetadata&&) noexcept = default;
BackgroundTracingMetadata& BackgroundTracingMetadata::operator=(BackgroundTracingMetadata&&) = default;

bool BackgroundTracingMetadata::operator==(const BackgroundTracingMetadata& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(triggered_rule_, other.triggered_rule_)
   && ::protozero::internal::gen_helpers::EqualsField(active_rules_, other.active_rules_)
   && ::protozero::internal::gen_helpers::EqualsField(scenario_name_hash_, other.scenario_name_hash_);
}

int BackgroundTracingMetadata::active_rules_size() const { return static_cast<int>(active_rules_.size()); }
void BackgroundTracingMetadata::clear_active_rules() { active_rules_.clear(); }
BackgroundTracingMetadata_TriggerRule* BackgroundTracingMetadata::add_active_rules() { active_rules_.emplace_back(); return &active_rules_.back(); }
bool BackgroundTracingMetadata::ParseFromArray(const void* raw, size_t size) {
  active_rules_.clear();
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* triggered_rule */:
        (*triggered_rule_).ParseFromArray(field.data(), field.size());
        break;
      case 2 /* active_rules */:
        active_rules_.emplace_back();
        active_rules_.back().ParseFromArray(field.data(), field.size());
        break;
      case 3 /* scenario_name_hash */:
        field.get(&scenario_name_hash_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string BackgroundTracingMetadata::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> BackgroundTracingMetadata::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void BackgroundTracingMetadata::Serialize(::protozero::Message* msg) const {
  // Field 1: triggered_rule
  if (_has_field_[1]) {
    (*triggered_rule_).Serialize(msg->BeginNestedMessage<::protozero::Message>(1));
  }

  // Field 2: active_rules
  for (auto& it : active_rules_) {
    it.Serialize(msg->BeginNestedMessage<::protozero::Message>(2));
  }

  // Field 3: scenario_name_hash
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeFixed(3, scenario_name_hash_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


BackgroundTracingMetadata_TriggerRule::BackgroundTracingMetadata_TriggerRule() = default;
BackgroundTracingMetadata_TriggerRule::~BackgroundTracingMetadata_TriggerRule() = default;
BackgroundTracingMetadata_TriggerRule::BackgroundTracingMetadata_TriggerRule(const BackgroundTracingMetadata_TriggerRule&) = default;
BackgroundTracingMetadata_TriggerRule& BackgroundTracingMetadata_TriggerRule::operator=(const BackgroundTracingMetadata_TriggerRule&) = default;
BackgroundTracingMetadata_TriggerRule::BackgroundTracingMetadata_TriggerRule(BackgroundTracingMetadata_TriggerRule&&) noexcept = default;
BackgroundTracingMetadata_TriggerRule& BackgroundTracingMetadata_TriggerRule::operator=(BackgroundTracingMetadata_TriggerRule&&) = default;

bool BackgroundTracingMetadata_TriggerRule::operator==(const BackgroundTracingMetadata_TriggerRule& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(trigger_type_, other.trigger_type_)
   && ::protozero::internal::gen_helpers::EqualsField(histogram_rule_, other.histogram_rule_)
   && ::protozero::internal::gen_helpers::EqualsField(named_rule_, other.named_rule_)
   && ::protozero::internal::gen_helpers::EqualsField(name_hash_, other.name_hash_);
}

bool BackgroundTracingMetadata_TriggerRule::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* trigger_type */:
        field.get(&trigger_type_);
        break;
      case 2 /* histogram_rule */:
        (*histogram_rule_).ParseFromArray(field.data(), field.size());
        break;
      case 3 /* named_rule */:
        (*named_rule_).ParseFromArray(field.data(), field.size());
        break;
      case 4 /* name_hash */:
        field.get(&name_hash_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string BackgroundTracingMetadata_TriggerRule::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> BackgroundTracingMetadata_TriggerRule::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void BackgroundTracingMetadata_TriggerRule::Serialize(::protozero::Message* msg) const {
  // Field 1: trigger_type
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, trigger_type_, msg);
  }

  // Field 2: histogram_rule
  if (_has_field_[2]) {
    (*histogram_rule_).Serialize(msg->BeginNestedMessage<::protozero::Message>(2));
  }

  // Field 3: named_rule
  if (_has_field_[3]) {
    (*named_rule_).Serialize(msg->BeginNestedMessage<::protozero::Message>(3));
  }

  // Field 4: name_hash
  if (_has_field_[4]) {
    ::protozero::internal::gen_helpers::SerializeFixed(4, name_hash_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


BackgroundTracingMetadata_TriggerRule_NamedRule::BackgroundTracingMetadata_TriggerRule_NamedRule() = default;
BackgroundTracingMetadata_TriggerRule_NamedRule::~BackgroundTracingMetadata_TriggerRule_NamedRule() = default;
BackgroundTracingMetadata_TriggerRule_NamedRule::BackgroundTracingMetadata_TriggerRule_NamedRule(const BackgroundTracingMetadata_TriggerRule_NamedRule&) = default;
BackgroundTracingMetadata_TriggerRule_NamedRule& BackgroundTracingMetadata_TriggerRule_NamedRule::operator=(const BackgroundTracingMetadata_TriggerRule_NamedRule&) = default;
BackgroundTracingMetadata_TriggerRule_NamedRule::BackgroundTracingMetadata_TriggerRule_NamedRule(BackgroundTracingMetadata_TriggerRule_NamedRule&&) noexcept = default;
BackgroundTracingMetadata_TriggerRule_NamedRule& BackgroundTracingMetadata_TriggerRule_NamedRule::operator=(BackgroundTracingMetadata_TriggerRule_NamedRule&&) = default;

bool BackgroundTracingMetadata_TriggerRule_NamedRule::operator==(const BackgroundTracingMetadata_TriggerRule_NamedRule& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(event_type_, other.event_type_)
   && ::protozero::internal::gen_helpers::EqualsField(content_trigger_name_hash_, other.content_trigger_name_hash_);
}

bool BackgroundTracingMetadata_TriggerRule_NamedRule::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* event_type */:
        field.get(&event_type_);
        break;
      case 2 /* content_trigger_name_hash */:
        field.get(&content_trigger_name_hash_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string BackgroundTracingMetadata_TriggerRule_NamedRule::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> BackgroundTracingMetadata_TriggerRule_NamedRule::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void BackgroundTracingMetadata_TriggerRule_NamedRule::Serialize(::protozero::Message* msg) const {
  // Field 1: event_type
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, event_type_, msg);
  }

  // Field 2: content_trigger_name_hash
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeFixed(2, content_trigger_name_hash_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


BackgroundTracingMetadata_TriggerRule_HistogramRule::BackgroundTracingMetadata_TriggerRule_HistogramRule() = default;
BackgroundTracingMetadata_TriggerRule_HistogramRule::~BackgroundTracingMetadata_TriggerRule_HistogramRule() = default;
BackgroundTracingMetadata_TriggerRule_HistogramRule::BackgroundTracingMetadata_TriggerRule_HistogramRule(const BackgroundTracingMetadata_TriggerRule_HistogramRule&) = default;
BackgroundTracingMetadata_TriggerRule_HistogramRule& BackgroundTracingMetadata_TriggerRule_HistogramRule::operator=(const BackgroundTracingMetadata_TriggerRule_HistogramRule&) = default;
BackgroundTracingMetadata_TriggerRule_HistogramRule::BackgroundTracingMetadata_TriggerRule_HistogramRule(BackgroundTracingMetadata_TriggerRule_HistogramRule&&) noexcept = default;
BackgroundTracingMetadata_TriggerRule_HistogramRule& BackgroundTracingMetadata_TriggerRule_HistogramRule::operator=(BackgroundTracingMetadata_TriggerRule_HistogramRule&&) = default;

bool BackgroundTracingMetadata_TriggerRule_HistogramRule::operator==(const BackgroundTracingMetadata_TriggerRule_HistogramRule& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(histogram_name_hash_, other.histogram_name_hash_)
   && ::protozero::internal::gen_helpers::EqualsField(histogram_min_trigger_, other.histogram_min_trigger_)
   && ::protozero::internal::gen_helpers::EqualsField(histogram_max_trigger_, other.histogram_max_trigger_);
}

bool BackgroundTracingMetadata_TriggerRule_HistogramRule::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* histogram_name_hash */:
        field.get(&histogram_name_hash_);
        break;
      case 2 /* histogram_min_trigger */:
        field.get(&histogram_min_trigger_);
        break;
      case 3 /* histogram_max_trigger */:
        field.get(&histogram_max_trigger_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string BackgroundTracingMetadata_TriggerRule_HistogramRule::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> BackgroundTracingMetadata_TriggerRule_HistogramRule::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void BackgroundTracingMetadata_TriggerRule_HistogramRule::Serialize(::protozero::Message* msg) const {
  // Field 1: histogram_name_hash
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeFixed(1, histogram_name_hash_, msg);
  }

  // Field 2: histogram_min_trigger
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, histogram_min_trigger_, msg);
  }

  // Field 3: histogram_max_trigger
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, histogram_max_trigger_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


ChromeMetadataPacket::ChromeMetadataPacket() = default;
ChromeMetadataPacket::~ChromeMetadataPacket() = default;
ChromeMetadataPacket::ChromeMetadataPacket(const ChromeMetadataPacket&) = default;
ChromeMetadataPacket& ChromeMetadataPacket::operator=(const ChromeMetadataPacket&) = default;
ChromeMetadataPacket::ChromeMetadataPacket(ChromeMetadataPacket&&) noexcept = default;
ChromeMetadataPacket& ChromeMetadataPacket::operator=(ChromeMetadataPacket&&) = default;

bool ChromeMetadataPacket::operator==(const ChromeMetadataPacket& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(background_tracing_metadata_, other.background_tracing_metadata_)
   && ::protozero::internal::gen_helpers::EqualsField(chrome_version_code_, other.chrome_version_code_)
   && ::protozero::internal::gen_helpers::EqualsField(enabled_categories_, other.enabled_categories_)
   && ::protozero::internal::gen_helpers::EqualsField(field_trial_hashes_, other.field_trial_hashes_);
}

int ChromeMetadataPacket::field_trial_hashes_size() const { return static_cast<int>(field_trial_hashes_.size()); }
void ChromeMetadataPacket::clear_field_trial_hashes() { field_trial_hashes_.clear(); }
ChromeMetadataPacket_FinchHash* ChromeMetadataPacket::add_field_trial_hashes() { field_trial_hashes_.emplace_back(); return &field_trial_hashes_.back(); }
bool ChromeMetadataPacket::ParseFromArray(const void* raw, size_t size) {
  field_trial_hashes_.clear();
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* background_tracing_metadata */:
        (*background_tracing_metadata_).ParseFromArray(field.data(), field.size());
        break;
      case 2 /* chrome_version_code */:
        field.get(&chrome_version_code_);
        break;
      case 3 /* enabled_categories */:
        ::protozero::internal::gen_helpers::DeserializeString(field, &enabled_categories_);
        break;
      case 4 /* field_trial_hashes */:
        field_trial_hashes_.emplace_back();
        field_trial_hashes_.back().ParseFromArray(field.data(), field.size());
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string ChromeMetadataPacket::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> ChromeMetadataPacket::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void ChromeMetadataPacket::Serialize(::protozero::Message* msg) const {
  // Field 1: background_tracing_metadata
  if (_has_field_[1]) {
    (*background_tracing_metadata_).Serialize(msg->BeginNestedMessage<::protozero::Message>(1));
  }

  // Field 2: chrome_version_code
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, chrome_version_code_, msg);
  }

  // Field 3: enabled_categories
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeString(3, enabled_categories_, msg);
  }

  // Field 4: field_trial_hashes
  for (auto& it : field_trial_hashes_) {
    it.Serialize(msg->BeginNestedMessage<::protozero::Message>(4));
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


ChromeMetadataPacket_FinchHash::ChromeMetadataPacket_FinchHash() = default;
ChromeMetadataPacket_FinchHash::~ChromeMetadataPacket_FinchHash() = default;
ChromeMetadataPacket_FinchHash::ChromeMetadataPacket_FinchHash(const ChromeMetadataPacket_FinchHash&) = default;
ChromeMetadataPacket_FinchHash& ChromeMetadataPacket_FinchHash::operator=(const ChromeMetadataPacket_FinchHash&) = default;
ChromeMetadataPacket_FinchHash::ChromeMetadataPacket_FinchHash(ChromeMetadataPacket_FinchHash&&) noexcept = default;
ChromeMetadataPacket_FinchHash& ChromeMetadataPacket_FinchHash::operator=(ChromeMetadataPacket_FinchHash&&) = default;

bool ChromeMetadataPacket_FinchHash::operator==(const ChromeMetadataPacket_FinchHash& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(name_, other.name_)
   && ::protozero::internal::gen_helpers::EqualsField(group_, other.group_);
}

bool ChromeMetadataPacket_FinchHash::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* name */:
        field.get(&name_);
        break;
      case 2 /* group */:
        field.get(&group_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string ChromeMetadataPacket_FinchHash::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> ChromeMetadataPacket_FinchHash::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void ChromeMetadataPacket_FinchHash::Serialize(::protozero::Message* msg) const {
  // Field 1: name
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, name_, msg);
  }

  // Field 2: group
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, group_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}

}  // namespace perfetto
}  // namespace protos
}  // namespace gen
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif
