// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ANDROID_VIEW_INPUTMETHOD_INPUTCONNECTION_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ANDROID_VIEW_INPUTMETHOD_INPUTCONNECTION_PROTO_H_

#include <stddef.h>
#include <stdint.h>

#include "perfetto/protozero/field_writer.h"
#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {
class InputConnectionCallProto_GetCursorCapsMode;
class InputConnectionCallProto_GetExtractedText;
class InputConnectionCallProto_GetExtractedText_ExtractedTextRequest;
class InputConnectionCallProto_GetSelectedText;
class InputConnectionCallProto_GetSurroundingText;
class InputConnectionCallProto_GetSurroundingText_SurroundingText;
class InputConnectionCallProto_GetTextAfterCursor;
class InputConnectionCallProto_GetTextBeforeCursor;
} // Namespace pbzero.
} // Namespace protos.
} // Namespace perfetto.

namespace perfetto {
namespace protos {
namespace pbzero {

class InputConnectionCallProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  InputConnectionCallProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit InputConnectionCallProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit InputConnectionCallProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_get_text_before_cursor() const { return at<1>().valid(); }
  ::protozero::ConstBytes get_text_before_cursor() const { return at<1>().as_bytes(); }
  bool has_get_text_after_cursor() const { return at<2>().valid(); }
  ::protozero::ConstBytes get_text_after_cursor() const { return at<2>().as_bytes(); }
  bool has_get_selected_text() const { return at<3>().valid(); }
  ::protozero::ConstBytes get_selected_text() const { return at<3>().as_bytes(); }
  bool has_get_surrounding_text() const { return at<4>().valid(); }
  ::protozero::ConstBytes get_surrounding_text() const { return at<4>().as_bytes(); }
  bool has_get_cursor_caps_mode() const { return at<5>().valid(); }
  ::protozero::ConstBytes get_cursor_caps_mode() const { return at<5>().as_bytes(); }
  bool has_get_extracted_text() const { return at<6>().valid(); }
  ::protozero::ConstBytes get_extracted_text() const { return at<6>().as_bytes(); }
};

class InputConnectionCallProto : public ::protozero::Message {
 public:
  using Decoder = InputConnectionCallProto_Decoder;
  enum : int32_t {
    kGetTextBeforeCursorFieldNumber = 1,
    kGetTextAfterCursorFieldNumber = 2,
    kGetSelectedTextFieldNumber = 3,
    kGetSurroundingTextFieldNumber = 4,
    kGetCursorCapsModeFieldNumber = 5,
    kGetExtractedTextFieldNumber = 6,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.InputConnectionCallProto"; }

  using GetTextBeforeCursor = ::perfetto::protos::pbzero::InputConnectionCallProto_GetTextBeforeCursor;
  using GetTextAfterCursor = ::perfetto::protos::pbzero::InputConnectionCallProto_GetTextAfterCursor;
  using GetSelectedText = ::perfetto::protos::pbzero::InputConnectionCallProto_GetSelectedText;
  using GetSurroundingText = ::perfetto::protos::pbzero::InputConnectionCallProto_GetSurroundingText;
  using GetCursorCapsMode = ::perfetto::protos::pbzero::InputConnectionCallProto_GetCursorCapsMode;
  using GetExtractedText = ::perfetto::protos::pbzero::InputConnectionCallProto_GetExtractedText;

  using FieldMetadata_GetTextBeforeCursor =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      InputConnectionCallProto_GetTextBeforeCursor,
      InputConnectionCallProto>;

  static constexpr FieldMetadata_GetTextBeforeCursor kGetTextBeforeCursor{};
  template <typename T = InputConnectionCallProto_GetTextBeforeCursor> T* set_get_text_before_cursor() {
    return BeginNestedMessage<T>(1);
  }


  using FieldMetadata_GetTextAfterCursor =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      InputConnectionCallProto_GetTextAfterCursor,
      InputConnectionCallProto>;

  static constexpr FieldMetadata_GetTextAfterCursor kGetTextAfterCursor{};
  template <typename T = InputConnectionCallProto_GetTextAfterCursor> T* set_get_text_after_cursor() {
    return BeginNestedMessage<T>(2);
  }


  using FieldMetadata_GetSelectedText =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      InputConnectionCallProto_GetSelectedText,
      InputConnectionCallProto>;

  static constexpr FieldMetadata_GetSelectedText kGetSelectedText{};
  template <typename T = InputConnectionCallProto_GetSelectedText> T* set_get_selected_text() {
    return BeginNestedMessage<T>(3);
  }


  using FieldMetadata_GetSurroundingText =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      InputConnectionCallProto_GetSurroundingText,
      InputConnectionCallProto>;

  static constexpr FieldMetadata_GetSurroundingText kGetSurroundingText{};
  template <typename T = InputConnectionCallProto_GetSurroundingText> T* set_get_surrounding_text() {
    return BeginNestedMessage<T>(4);
  }


  using FieldMetadata_GetCursorCapsMode =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      InputConnectionCallProto_GetCursorCapsMode,
      InputConnectionCallProto>;

  static constexpr FieldMetadata_GetCursorCapsMode kGetCursorCapsMode{};
  template <typename T = InputConnectionCallProto_GetCursorCapsMode> T* set_get_cursor_caps_mode() {
    return BeginNestedMessage<T>(5);
  }


  using FieldMetadata_GetExtractedText =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      InputConnectionCallProto_GetExtractedText,
      InputConnectionCallProto>;

  static constexpr FieldMetadata_GetExtractedText kGetExtractedText{};
  template <typename T = InputConnectionCallProto_GetExtractedText> T* set_get_extracted_text() {
    return BeginNestedMessage<T>(6);
  }

};

class InputConnectionCallProto_GetExtractedText_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  InputConnectionCallProto_GetExtractedText_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit InputConnectionCallProto_GetExtractedText_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit InputConnectionCallProto_GetExtractedText_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_request() const { return at<1>().valid(); }
  ::protozero::ConstBytes request() const { return at<1>().as_bytes(); }
  bool has_flags() const { return at<2>().valid(); }
  int32_t flags() const { return at<2>().as_int32(); }
};

class InputConnectionCallProto_GetExtractedText : public ::protozero::Message {
 public:
  using Decoder = InputConnectionCallProto_GetExtractedText_Decoder;
  enum : int32_t {
    kRequestFieldNumber = 1,
    kFlagsFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.InputConnectionCallProto.GetExtractedText"; }

  using ExtractedTextRequest = ::perfetto::protos::pbzero::InputConnectionCallProto_GetExtractedText_ExtractedTextRequest;

  using FieldMetadata_Request =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      InputConnectionCallProto_GetExtractedText_ExtractedTextRequest,
      InputConnectionCallProto_GetExtractedText>;

  static constexpr FieldMetadata_Request kRequest{};
  template <typename T = InputConnectionCallProto_GetExtractedText_ExtractedTextRequest> T* set_request() {
    return BeginNestedMessage<T>(1);
  }


  using FieldMetadata_Flags =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      InputConnectionCallProto_GetExtractedText>;

  static constexpr FieldMetadata_Flags kFlags{};
  void set_flags(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Flags::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

class InputConnectionCallProto_GetExtractedText_ExtractedTextRequest_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  InputConnectionCallProto_GetExtractedText_ExtractedTextRequest_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit InputConnectionCallProto_GetExtractedText_ExtractedTextRequest_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit InputConnectionCallProto_GetExtractedText_ExtractedTextRequest_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_token() const { return at<1>().valid(); }
  int32_t token() const { return at<1>().as_int32(); }
  bool has_flags() const { return at<2>().valid(); }
  int32_t flags() const { return at<2>().as_int32(); }
  bool has_hint_max_lines() const { return at<3>().valid(); }
  int32_t hint_max_lines() const { return at<3>().as_int32(); }
  bool has_hint_max_chars() const { return at<4>().valid(); }
  int32_t hint_max_chars() const { return at<4>().as_int32(); }
};

class InputConnectionCallProto_GetExtractedText_ExtractedTextRequest : public ::protozero::Message {
 public:
  using Decoder = InputConnectionCallProto_GetExtractedText_ExtractedTextRequest_Decoder;
  enum : int32_t {
    kTokenFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kHintMaxLinesFieldNumber = 3,
    kHintMaxCharsFieldNumber = 4,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.InputConnectionCallProto.GetExtractedText.ExtractedTextRequest"; }


  using FieldMetadata_Token =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      InputConnectionCallProto_GetExtractedText_ExtractedTextRequest>;

  static constexpr FieldMetadata_Token kToken{};
  void set_token(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Token::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Flags =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      InputConnectionCallProto_GetExtractedText_ExtractedTextRequest>;

  static constexpr FieldMetadata_Flags kFlags{};
  void set_flags(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Flags::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_HintMaxLines =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      InputConnectionCallProto_GetExtractedText_ExtractedTextRequest>;

  static constexpr FieldMetadata_HintMaxLines kHintMaxLines{};
  void set_hint_max_lines(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_HintMaxLines::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_HintMaxChars =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      InputConnectionCallProto_GetExtractedText_ExtractedTextRequest>;

  static constexpr FieldMetadata_HintMaxChars kHintMaxChars{};
  void set_hint_max_chars(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_HintMaxChars::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

class InputConnectionCallProto_GetCursorCapsMode_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  InputConnectionCallProto_GetCursorCapsMode_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit InputConnectionCallProto_GetCursorCapsMode_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit InputConnectionCallProto_GetCursorCapsMode_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_req_modes() const { return at<1>().valid(); }
  int32_t req_modes() const { return at<1>().as_int32(); }
  bool has_result() const { return at<2>().valid(); }
  int32_t result() const { return at<2>().as_int32(); }
};

class InputConnectionCallProto_GetCursorCapsMode : public ::protozero::Message {
 public:
  using Decoder = InputConnectionCallProto_GetCursorCapsMode_Decoder;
  enum : int32_t {
    kReqModesFieldNumber = 1,
    kResultFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.InputConnectionCallProto.GetCursorCapsMode"; }


  using FieldMetadata_ReqModes =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      InputConnectionCallProto_GetCursorCapsMode>;

  static constexpr FieldMetadata_ReqModes kReqModes{};
  void set_req_modes(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ReqModes::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Result =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      InputConnectionCallProto_GetCursorCapsMode>;

  static constexpr FieldMetadata_Result kResult{};
  void set_result(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Result::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

class InputConnectionCallProto_GetSurroundingText_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  InputConnectionCallProto_GetSurroundingText_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit InputConnectionCallProto_GetSurroundingText_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit InputConnectionCallProto_GetSurroundingText_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_before_length() const { return at<1>().valid(); }
  int32_t before_length() const { return at<1>().as_int32(); }
  bool has_after_length() const { return at<2>().valid(); }
  int32_t after_length() const { return at<2>().as_int32(); }
  bool has_flags() const { return at<3>().valid(); }
  int32_t flags() const { return at<3>().as_int32(); }
  bool has_result() const { return at<4>().valid(); }
  ::protozero::ConstBytes result() const { return at<4>().as_bytes(); }
};

class InputConnectionCallProto_GetSurroundingText : public ::protozero::Message {
 public:
  using Decoder = InputConnectionCallProto_GetSurroundingText_Decoder;
  enum : int32_t {
    kBeforeLengthFieldNumber = 1,
    kAfterLengthFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kResultFieldNumber = 4,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.InputConnectionCallProto.GetSurroundingText"; }

  using SurroundingText = ::perfetto::protos::pbzero::InputConnectionCallProto_GetSurroundingText_SurroundingText;

  using FieldMetadata_BeforeLength =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      InputConnectionCallProto_GetSurroundingText>;

  static constexpr FieldMetadata_BeforeLength kBeforeLength{};
  void set_before_length(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_BeforeLength::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_AfterLength =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      InputConnectionCallProto_GetSurroundingText>;

  static constexpr FieldMetadata_AfterLength kAfterLength{};
  void set_after_length(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_AfterLength::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Flags =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      InputConnectionCallProto_GetSurroundingText>;

  static constexpr FieldMetadata_Flags kFlags{};
  void set_flags(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Flags::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Result =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      InputConnectionCallProto_GetSurroundingText_SurroundingText,
      InputConnectionCallProto_GetSurroundingText>;

  static constexpr FieldMetadata_Result kResult{};
  template <typename T = InputConnectionCallProto_GetSurroundingText_SurroundingText> T* set_result() {
    return BeginNestedMessage<T>(4);
  }

};

class InputConnectionCallProto_GetSurroundingText_SurroundingText_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  InputConnectionCallProto_GetSurroundingText_SurroundingText_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit InputConnectionCallProto_GetSurroundingText_SurroundingText_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit InputConnectionCallProto_GetSurroundingText_SurroundingText_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_selection_start() const { return at<2>().valid(); }
  int32_t selection_start() const { return at<2>().as_int32(); }
  bool has_selection_end() const { return at<3>().valid(); }
  int32_t selection_end() const { return at<3>().as_int32(); }
  bool has_offset() const { return at<4>().valid(); }
  int32_t offset() const { return at<4>().as_int32(); }
};

class InputConnectionCallProto_GetSurroundingText_SurroundingText : public ::protozero::Message {
 public:
  using Decoder = InputConnectionCallProto_GetSurroundingText_SurroundingText_Decoder;
  enum : int32_t {
    kSelectionStartFieldNumber = 2,
    kSelectionEndFieldNumber = 3,
    kOffsetFieldNumber = 4,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.InputConnectionCallProto.GetSurroundingText.SurroundingText"; }


  using FieldMetadata_SelectionStart =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      InputConnectionCallProto_GetSurroundingText_SurroundingText>;

  static constexpr FieldMetadata_SelectionStart kSelectionStart{};
  void set_selection_start(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SelectionStart::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SelectionEnd =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      InputConnectionCallProto_GetSurroundingText_SurroundingText>;

  static constexpr FieldMetadata_SelectionEnd kSelectionEnd{};
  void set_selection_end(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SelectionEnd::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Offset =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      InputConnectionCallProto_GetSurroundingText_SurroundingText>;

  static constexpr FieldMetadata_Offset kOffset{};
  void set_offset(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Offset::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

class InputConnectionCallProto_GetSelectedText_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  InputConnectionCallProto_GetSelectedText_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit InputConnectionCallProto_GetSelectedText_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit InputConnectionCallProto_GetSelectedText_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_flags() const { return at<1>().valid(); }
  int32_t flags() const { return at<1>().as_int32(); }
};

class InputConnectionCallProto_GetSelectedText : public ::protozero::Message {
 public:
  using Decoder = InputConnectionCallProto_GetSelectedText_Decoder;
  enum : int32_t {
    kFlagsFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.InputConnectionCallProto.GetSelectedText"; }


  using FieldMetadata_Flags =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      InputConnectionCallProto_GetSelectedText>;

  static constexpr FieldMetadata_Flags kFlags{};
  void set_flags(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Flags::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

class InputConnectionCallProto_GetTextAfterCursor_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  InputConnectionCallProto_GetTextAfterCursor_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit InputConnectionCallProto_GetTextAfterCursor_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit InputConnectionCallProto_GetTextAfterCursor_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_length() const { return at<1>().valid(); }
  int32_t length() const { return at<1>().as_int32(); }
  bool has_flags() const { return at<2>().valid(); }
  int32_t flags() const { return at<2>().as_int32(); }
};

class InputConnectionCallProto_GetTextAfterCursor : public ::protozero::Message {
 public:
  using Decoder = InputConnectionCallProto_GetTextAfterCursor_Decoder;
  enum : int32_t {
    kLengthFieldNumber = 1,
    kFlagsFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.InputConnectionCallProto.GetTextAfterCursor"; }


  using FieldMetadata_Length =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      InputConnectionCallProto_GetTextAfterCursor>;

  static constexpr FieldMetadata_Length kLength{};
  void set_length(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Length::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Flags =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      InputConnectionCallProto_GetTextAfterCursor>;

  static constexpr FieldMetadata_Flags kFlags{};
  void set_flags(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Flags::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

class InputConnectionCallProto_GetTextBeforeCursor_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  InputConnectionCallProto_GetTextBeforeCursor_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit InputConnectionCallProto_GetTextBeforeCursor_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit InputConnectionCallProto_GetTextBeforeCursor_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_length() const { return at<1>().valid(); }
  int32_t length() const { return at<1>().as_int32(); }
  bool has_flags() const { return at<2>().valid(); }
  int32_t flags() const { return at<2>().as_int32(); }
};

class InputConnectionCallProto_GetTextBeforeCursor : public ::protozero::Message {
 public:
  using Decoder = InputConnectionCallProto_GetTextBeforeCursor_Decoder;
  enum : int32_t {
    kLengthFieldNumber = 1,
    kFlagsFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.InputConnectionCallProto.GetTextBeforeCursor"; }


  using FieldMetadata_Length =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      InputConnectionCallProto_GetTextBeforeCursor>;

  static constexpr FieldMetadata_Length kLength{};
  void set_length(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Length::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Flags =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      InputConnectionCallProto_GetTextBeforeCursor>;

  static constexpr FieldMetadata_Flags kFlags{};
  void set_flags(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Flags::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

class InputConnectionProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  InputConnectionProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit InputConnectionProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit InputConnectionProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_selected_text_start() const { return at<3>().valid(); }
  int32_t selected_text_start() const { return at<3>().as_int32(); }
  bool has_selected_text_end() const { return at<4>().valid(); }
  int32_t selected_text_end() const { return at<4>().as_int32(); }
  bool has_cursor_caps_mode() const { return at<5>().valid(); }
  int32_t cursor_caps_mode() const { return at<5>().as_int32(); }
};

class InputConnectionProto : public ::protozero::Message {
 public:
  using Decoder = InputConnectionProto_Decoder;
  enum : int32_t {
    kSelectedTextStartFieldNumber = 3,
    kSelectedTextEndFieldNumber = 4,
    kCursorCapsModeFieldNumber = 5,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.InputConnectionProto"; }


  using FieldMetadata_SelectedTextStart =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      InputConnectionProto>;

  static constexpr FieldMetadata_SelectedTextStart kSelectedTextStart{};
  void set_selected_text_start(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SelectedTextStart::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SelectedTextEnd =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      InputConnectionProto>;

  static constexpr FieldMetadata_SelectedTextEnd kSelectedTextEnd{};
  void set_selected_text_end(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SelectedTextEnd::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_CursorCapsMode =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      InputConnectionProto>;

  static constexpr FieldMetadata_CursorCapsMode kCursorCapsMode{};
  void set_cursor_caps_mode(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_CursorCapsMode::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
