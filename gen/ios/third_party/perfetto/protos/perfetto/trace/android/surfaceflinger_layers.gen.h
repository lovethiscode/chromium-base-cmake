// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ANDROID_SURFACEFLINGER_LAYERS_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ANDROID_SURFACEFLINGER_LAYERS_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class BarrierLayerProto;
class ActiveBufferProto;
class FloatRectProto;
class PositionProto;
class LayerProto;
class RectProto;
class BlurRegion;
class ColorTransformProto;
class InputWindowInfoProto;
class TransformProto;
class RegionProto;
class LayerProto_MetadataEntry;
class ColorProto;
class SizeProto;
class DisplayProto;
class LayersProto;
class LayersSnapshotProto;
class LayersTraceFileProto;
enum HwcCompositionType : int;
enum TrustedOverlay : int;
enum LayersTraceFileProto_MagicNumber : int;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {
enum HwcCompositionType : int {
  HWC_TYPE_UNSPECIFIED = 0,
  HWC_TYPE_CLIENT = 1,
  HWC_TYPE_DEVICE = 2,
  HWC_TYPE_SOLID_COLOR = 3,
  HWC_TYPE_CURSOR = 4,
  HWC_TYPE_SIDEBAND = 5,
  HWC_TYPE_DISPLAY_DECORATION = 6,
};
enum LayersTraceFileProto_MagicNumber : int {
  LayersTraceFileProto_MagicNumber_INVALID = 0,
  LayersTraceFileProto_MagicNumber_MAGIC_NUMBER_L = 1414682956,
  LayersTraceFileProto_MagicNumber_MAGIC_NUMBER_H = 1162035538,
};

class PERFETTO_EXPORT_COMPONENT BarrierLayerProto : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kIdFieldNumber = 1,
    kFrameNumberFieldNumber = 2,
  };

  BarrierLayerProto();
  ~BarrierLayerProto() override;
  BarrierLayerProto(BarrierLayerProto&&) noexcept;
  BarrierLayerProto& operator=(BarrierLayerProto&&);
  BarrierLayerProto(const BarrierLayerProto&);
  BarrierLayerProto& operator=(const BarrierLayerProto&);
  bool operator==(const BarrierLayerProto&) const;
  bool operator!=(const BarrierLayerProto& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_id() const { return _has_field_[1]; }
  int32_t id() const { return id_; }
  void set_id(int32_t value) { id_ = value; _has_field_.set(1); }

  bool has_frame_number() const { return _has_field_[2]; }
  uint64_t frame_number() const { return frame_number_; }
  void set_frame_number(uint64_t value) { frame_number_ = value; _has_field_.set(2); }

 private:
  int32_t id_{};
  uint64_t frame_number_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT ActiveBufferProto : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
    kStrideFieldNumber = 3,
    kFormatFieldNumber = 4,
    kUsageFieldNumber = 5,
  };

  ActiveBufferProto();
  ~ActiveBufferProto() override;
  ActiveBufferProto(ActiveBufferProto&&) noexcept;
  ActiveBufferProto& operator=(ActiveBufferProto&&);
  ActiveBufferProto(const ActiveBufferProto&);
  ActiveBufferProto& operator=(const ActiveBufferProto&);
  bool operator==(const ActiveBufferProto&) const;
  bool operator!=(const ActiveBufferProto& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_width() const { return _has_field_[1]; }
  uint32_t width() const { return width_; }
  void set_width(uint32_t value) { width_ = value; _has_field_.set(1); }

  bool has_height() const { return _has_field_[2]; }
  uint32_t height() const { return height_; }
  void set_height(uint32_t value) { height_ = value; _has_field_.set(2); }

  bool has_stride() const { return _has_field_[3]; }
  uint32_t stride() const { return stride_; }
  void set_stride(uint32_t value) { stride_ = value; _has_field_.set(3); }

  bool has_format() const { return _has_field_[4]; }
  int32_t format() const { return format_; }
  void set_format(int32_t value) { format_ = value; _has_field_.set(4); }

  bool has_usage() const { return _has_field_[5]; }
  uint64_t usage() const { return usage_; }
  void set_usage(uint64_t value) { usage_ = value; _has_field_.set(5); }

 private:
  uint32_t width_{};
  uint32_t height_{};
  uint32_t stride_{};
  int32_t format_{};
  uint64_t usage_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT FloatRectProto : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kLeftFieldNumber = 1,
    kTopFieldNumber = 2,
    kRightFieldNumber = 3,
    kBottomFieldNumber = 4,
  };

  FloatRectProto();
  ~FloatRectProto() override;
  FloatRectProto(FloatRectProto&&) noexcept;
  FloatRectProto& operator=(FloatRectProto&&);
  FloatRectProto(const FloatRectProto&);
  FloatRectProto& operator=(const FloatRectProto&);
  bool operator==(const FloatRectProto&) const;
  bool operator!=(const FloatRectProto& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_left() const { return _has_field_[1]; }
  float left() const { return left_; }
  void set_left(float value) { left_ = value; _has_field_.set(1); }

  bool has_top() const { return _has_field_[2]; }
  float top() const { return top_; }
  void set_top(float value) { top_ = value; _has_field_.set(2); }

  bool has_right() const { return _has_field_[3]; }
  float right() const { return right_; }
  void set_right(float value) { right_ = value; _has_field_.set(3); }

  bool has_bottom() const { return _has_field_[4]; }
  float bottom() const { return bottom_; }
  void set_bottom(float value) { bottom_ = value; _has_field_.set(4); }

 private:
  float left_{};
  float top_{};
  float right_{};
  float bottom_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT PositionProto : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };

  PositionProto();
  ~PositionProto() override;
  PositionProto(PositionProto&&) noexcept;
  PositionProto& operator=(PositionProto&&);
  PositionProto(const PositionProto&);
  PositionProto& operator=(const PositionProto&);
  bool operator==(const PositionProto&) const;
  bool operator!=(const PositionProto& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_x() const { return _has_field_[1]; }
  float x() const { return x_; }
  void set_x(float value) { x_ = value; _has_field_.set(1); }

  bool has_y() const { return _has_field_[2]; }
  float y() const { return y_; }
  void set_y(float value) { y_ = value; _has_field_.set(2); }

 private:
  float x_{};
  float y_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT LayerProto : public ::protozero::CppMessageObj {
 public:
  using MetadataEntry = LayerProto_MetadataEntry;
  enum FieldNumbers {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kChildrenFieldNumber = 3,
    kRelativesFieldNumber = 4,
    kTypeFieldNumber = 5,
    kTransparentRegionFieldNumber = 6,
    kVisibleRegionFieldNumber = 7,
    kDamageRegionFieldNumber = 8,
    kLayerStackFieldNumber = 9,
    kZFieldNumber = 10,
    kPositionFieldNumber = 11,
    kRequestedPositionFieldNumber = 12,
    kSizeFieldNumber = 13,
    kCropFieldNumber = 14,
    kFinalCropFieldNumber = 15,
    kIsOpaqueFieldNumber = 16,
    kInvalidateFieldNumber = 17,
    kDataspaceFieldNumber = 18,
    kPixelFormatFieldNumber = 19,
    kColorFieldNumber = 20,
    kRequestedColorFieldNumber = 21,
    kFlagsFieldNumber = 22,
    kTransformFieldNumber = 23,
    kRequestedTransformFieldNumber = 24,
    kParentFieldNumber = 25,
    kZOrderRelativeOfFieldNumber = 26,
    kActiveBufferFieldNumber = 27,
    kQueuedFramesFieldNumber = 28,
    kRefreshPendingFieldNumber = 29,
    kHwcFrameFieldNumber = 30,
    kHwcCropFieldNumber = 31,
    kHwcTransformFieldNumber = 32,
    kWindowTypeFieldNumber = 33,
    kAppIdFieldNumber = 34,
    kHwcCompositionTypeFieldNumber = 35,
    kIsProtectedFieldNumber = 36,
    kCurrFrameFieldNumber = 37,
    kBarrierLayerFieldNumber = 38,
    kBufferTransformFieldNumber = 39,
    kEffectiveScalingModeFieldNumber = 40,
    kCornerRadiusFieldNumber = 41,
    kMetadataFieldNumber = 42,
    kEffectiveTransformFieldNumber = 43,
    kSourceBoundsFieldNumber = 44,
    kBoundsFieldNumber = 45,
    kScreenBoundsFieldNumber = 46,
    kInputWindowInfoFieldNumber = 47,
    kCornerRadiusCropFieldNumber = 48,
    kShadowRadiusFieldNumber = 49,
    kColorTransformFieldNumber = 50,
    kIsRelativeOfFieldNumber = 51,
    kBackgroundBlurRadiusFieldNumber = 52,
    kOwnerUidFieldNumber = 53,
    kBlurRegionsFieldNumber = 54,
    kIsTrustedOverlayFieldNumber = 55,
    kRequestedCornerRadiusFieldNumber = 56,
    kDestinationFrameFieldNumber = 57,
    kOriginalIdFieldNumber = 58,
    kTrustedOverlayFieldNumber = 59,
  };

  LayerProto();
  ~LayerProto() override;
  LayerProto(LayerProto&&) noexcept;
  LayerProto& operator=(LayerProto&&);
  LayerProto(const LayerProto&);
  LayerProto& operator=(const LayerProto&);
  bool operator==(const LayerProto&) const;
  bool operator!=(const LayerProto& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_id() const { return _has_field_[1]; }
  int32_t id() const { return id_; }
  void set_id(int32_t value) { id_ = value; _has_field_.set(1); }

  bool has_name() const { return _has_field_[2]; }
  const std::string& name() const { return name_; }
  void set_name(const std::string& value) { name_ = value; _has_field_.set(2); }

  const std::vector<int32_t>& children() const { return children_; }
  std::vector<int32_t>* mutable_children() { return &children_; }
  int children_size() const { return static_cast<int>(children_.size()); }
  void clear_children() { children_.clear(); }
  void add_children(int32_t value) { children_.emplace_back(value); }
  int32_t* add_children() { children_.emplace_back(); return &children_.back(); }

  const std::vector<int32_t>& relatives() const { return relatives_; }
  std::vector<int32_t>* mutable_relatives() { return &relatives_; }
  int relatives_size() const { return static_cast<int>(relatives_.size()); }
  void clear_relatives() { relatives_.clear(); }
  void add_relatives(int32_t value) { relatives_.emplace_back(value); }
  int32_t* add_relatives() { relatives_.emplace_back(); return &relatives_.back(); }

  bool has_type() const { return _has_field_[5]; }
  const std::string& type() const { return type_; }
  void set_type(const std::string& value) { type_ = value; _has_field_.set(5); }

  bool has_transparent_region() const { return _has_field_[6]; }
  const RegionProto& transparent_region() const { return *transparent_region_; }
  RegionProto* mutable_transparent_region() { _has_field_.set(6); return transparent_region_.get(); }

  bool has_visible_region() const { return _has_field_[7]; }
  const RegionProto& visible_region() const { return *visible_region_; }
  RegionProto* mutable_visible_region() { _has_field_.set(7); return visible_region_.get(); }

  bool has_damage_region() const { return _has_field_[8]; }
  const RegionProto& damage_region() const { return *damage_region_; }
  RegionProto* mutable_damage_region() { _has_field_.set(8); return damage_region_.get(); }

  bool has_layer_stack() const { return _has_field_[9]; }
  uint32_t layer_stack() const { return layer_stack_; }
  void set_layer_stack(uint32_t value) { layer_stack_ = value; _has_field_.set(9); }

  bool has_z() const { return _has_field_[10]; }
  int32_t z() const { return z_; }
  void set_z(int32_t value) { z_ = value; _has_field_.set(10); }

  bool has_position() const { return _has_field_[11]; }
  const PositionProto& position() const { return *position_; }
  PositionProto* mutable_position() { _has_field_.set(11); return position_.get(); }

  bool has_requested_position() const { return _has_field_[12]; }
  const PositionProto& requested_position() const { return *requested_position_; }
  PositionProto* mutable_requested_position() { _has_field_.set(12); return requested_position_.get(); }

  bool has_size() const { return _has_field_[13]; }
  const SizeProto& size() const { return *size_; }
  SizeProto* mutable_size() { _has_field_.set(13); return size_.get(); }

  bool has_crop() const { return _has_field_[14]; }
  const RectProto& crop() const { return *crop_; }
  RectProto* mutable_crop() { _has_field_.set(14); return crop_.get(); }

  bool has_final_crop() const { return _has_field_[15]; }
  const RectProto& final_crop() const { return *final_crop_; }
  RectProto* mutable_final_crop() { _has_field_.set(15); return final_crop_.get(); }

  bool has_is_opaque() const { return _has_field_[16]; }
  bool is_opaque() const { return is_opaque_; }
  void set_is_opaque(bool value) { is_opaque_ = value; _has_field_.set(16); }

  bool has_invalidate() const { return _has_field_[17]; }
  bool invalidate() const { return invalidate_; }
  void set_invalidate(bool value) { invalidate_ = value; _has_field_.set(17); }

  bool has_dataspace() const { return _has_field_[18]; }
  const std::string& dataspace() const { return dataspace_; }
  void set_dataspace(const std::string& value) { dataspace_ = value; _has_field_.set(18); }

  bool has_pixel_format() const { return _has_field_[19]; }
  const std::string& pixel_format() const { return pixel_format_; }
  void set_pixel_format(const std::string& value) { pixel_format_ = value; _has_field_.set(19); }

  bool has_color() const { return _has_field_[20]; }
  const ColorProto& color() const { return *color_; }
  ColorProto* mutable_color() { _has_field_.set(20); return color_.get(); }

  bool has_requested_color() const { return _has_field_[21]; }
  const ColorProto& requested_color() const { return *requested_color_; }
  ColorProto* mutable_requested_color() { _has_field_.set(21); return requested_color_.get(); }

  bool has_flags() const { return _has_field_[22]; }
  uint32_t flags() const { return flags_; }
  void set_flags(uint32_t value) { flags_ = value; _has_field_.set(22); }

  bool has_transform() const { return _has_field_[23]; }
  const TransformProto& transform() const { return *transform_; }
  TransformProto* mutable_transform() { _has_field_.set(23); return transform_.get(); }

  bool has_requested_transform() const { return _has_field_[24]; }
  const TransformProto& requested_transform() const { return *requested_transform_; }
  TransformProto* mutable_requested_transform() { _has_field_.set(24); return requested_transform_.get(); }

  bool has_parent() const { return _has_field_[25]; }
  int32_t parent() const { return parent_; }
  void set_parent(int32_t value) { parent_ = value; _has_field_.set(25); }

  bool has_z_order_relative_of() const { return _has_field_[26]; }
  int32_t z_order_relative_of() const { return z_order_relative_of_; }
  void set_z_order_relative_of(int32_t value) { z_order_relative_of_ = value; _has_field_.set(26); }

  bool has_active_buffer() const { return _has_field_[27]; }
  const ActiveBufferProto& active_buffer() const { return *active_buffer_; }
  ActiveBufferProto* mutable_active_buffer() { _has_field_.set(27); return active_buffer_.get(); }

  bool has_queued_frames() const { return _has_field_[28]; }
  int32_t queued_frames() const { return queued_frames_; }
  void set_queued_frames(int32_t value) { queued_frames_ = value; _has_field_.set(28); }

  bool has_refresh_pending() const { return _has_field_[29]; }
  bool refresh_pending() const { return refresh_pending_; }
  void set_refresh_pending(bool value) { refresh_pending_ = value; _has_field_.set(29); }

  bool has_hwc_frame() const { return _has_field_[30]; }
  const RectProto& hwc_frame() const { return *hwc_frame_; }
  RectProto* mutable_hwc_frame() { _has_field_.set(30); return hwc_frame_.get(); }

  bool has_hwc_crop() const { return _has_field_[31]; }
  const FloatRectProto& hwc_crop() const { return *hwc_crop_; }
  FloatRectProto* mutable_hwc_crop() { _has_field_.set(31); return hwc_crop_.get(); }

  bool has_hwc_transform() const { return _has_field_[32]; }
  int32_t hwc_transform() const { return hwc_transform_; }
  void set_hwc_transform(int32_t value) { hwc_transform_ = value; _has_field_.set(32); }

  bool has_window_type() const { return _has_field_[33]; }
  int32_t window_type() const { return window_type_; }
  void set_window_type(int32_t value) { window_type_ = value; _has_field_.set(33); }

  bool has_app_id() const { return _has_field_[34]; }
  int32_t app_id() const { return app_id_; }
  void set_app_id(int32_t value) { app_id_ = value; _has_field_.set(34); }

  bool has_hwc_composition_type() const { return _has_field_[35]; }
  HwcCompositionType hwc_composition_type() const { return hwc_composition_type_; }
  void set_hwc_composition_type(HwcCompositionType value) { hwc_composition_type_ = value; _has_field_.set(35); }

  bool has_is_protected() const { return _has_field_[36]; }
  bool is_protected() const { return is_protected_; }
  void set_is_protected(bool value) { is_protected_ = value; _has_field_.set(36); }

  bool has_curr_frame() const { return _has_field_[37]; }
  uint64_t curr_frame() const { return curr_frame_; }
  void set_curr_frame(uint64_t value) { curr_frame_ = value; _has_field_.set(37); }

  const std::vector<BarrierLayerProto>& barrier_layer() const { return barrier_layer_; }
  std::vector<BarrierLayerProto>* mutable_barrier_layer() { return &barrier_layer_; }
  int barrier_layer_size() const;
  void clear_barrier_layer();
  BarrierLayerProto* add_barrier_layer();

  bool has_buffer_transform() const { return _has_field_[39]; }
  const TransformProto& buffer_transform() const { return *buffer_transform_; }
  TransformProto* mutable_buffer_transform() { _has_field_.set(39); return buffer_transform_.get(); }

  bool has_effective_scaling_mode() const { return _has_field_[40]; }
  int32_t effective_scaling_mode() const { return effective_scaling_mode_; }
  void set_effective_scaling_mode(int32_t value) { effective_scaling_mode_ = value; _has_field_.set(40); }

  bool has_corner_radius() const { return _has_field_[41]; }
  float corner_radius() const { return corner_radius_; }
  void set_corner_radius(float value) { corner_radius_ = value; _has_field_.set(41); }

  const std::vector<LayerProto_MetadataEntry>& metadata() const { return metadata_; }
  std::vector<LayerProto_MetadataEntry>* mutable_metadata() { return &metadata_; }
  int metadata_size() const;
  void clear_metadata();
  LayerProto_MetadataEntry* add_metadata();

  bool has_effective_transform() const { return _has_field_[43]; }
  const TransformProto& effective_transform() const { return *effective_transform_; }
  TransformProto* mutable_effective_transform() { _has_field_.set(43); return effective_transform_.get(); }

  bool has_source_bounds() const { return _has_field_[44]; }
  const FloatRectProto& source_bounds() const { return *source_bounds_; }
  FloatRectProto* mutable_source_bounds() { _has_field_.set(44); return source_bounds_.get(); }

  bool has_bounds() const { return _has_field_[45]; }
  const FloatRectProto& bounds() const { return *bounds_; }
  FloatRectProto* mutable_bounds() { _has_field_.set(45); return bounds_.get(); }

  bool has_screen_bounds() const { return _has_field_[46]; }
  const FloatRectProto& screen_bounds() const { return *screen_bounds_; }
  FloatRectProto* mutable_screen_bounds() { _has_field_.set(46); return screen_bounds_.get(); }

  bool has_input_window_info() const { return _has_field_[47]; }
  const InputWindowInfoProto& input_window_info() const { return *input_window_info_; }
  InputWindowInfoProto* mutable_input_window_info() { _has_field_.set(47); return input_window_info_.get(); }

  bool has_corner_radius_crop() const { return _has_field_[48]; }
  const FloatRectProto& corner_radius_crop() const { return *corner_radius_crop_; }
  FloatRectProto* mutable_corner_radius_crop() { _has_field_.set(48); return corner_radius_crop_.get(); }

  bool has_shadow_radius() const { return _has_field_[49]; }
  float shadow_radius() const { return shadow_radius_; }
  void set_shadow_radius(float value) { shadow_radius_ = value; _has_field_.set(49); }

  bool has_color_transform() const { return _has_field_[50]; }
  const ColorTransformProto& color_transform() const { return *color_transform_; }
  ColorTransformProto* mutable_color_transform() { _has_field_.set(50); return color_transform_.get(); }

  bool has_is_relative_of() const { return _has_field_[51]; }
  bool is_relative_of() const { return is_relative_of_; }
  void set_is_relative_of(bool value) { is_relative_of_ = value; _has_field_.set(51); }

  bool has_background_blur_radius() const { return _has_field_[52]; }
  int32_t background_blur_radius() const { return background_blur_radius_; }
  void set_background_blur_radius(int32_t value) { background_blur_radius_ = value; _has_field_.set(52); }

  bool has_owner_uid() const { return _has_field_[53]; }
  uint32_t owner_uid() const { return owner_uid_; }
  void set_owner_uid(uint32_t value) { owner_uid_ = value; _has_field_.set(53); }

  const std::vector<BlurRegion>& blur_regions() const { return blur_regions_; }
  std::vector<BlurRegion>* mutable_blur_regions() { return &blur_regions_; }
  int blur_regions_size() const;
  void clear_blur_regions();
  BlurRegion* add_blur_regions();

  bool has_is_trusted_overlay() const { return _has_field_[55]; }
  bool is_trusted_overlay() const { return is_trusted_overlay_; }
  void set_is_trusted_overlay(bool value) { is_trusted_overlay_ = value; _has_field_.set(55); }

  bool has_requested_corner_radius() const { return _has_field_[56]; }
  float requested_corner_radius() const { return requested_corner_radius_; }
  void set_requested_corner_radius(float value) { requested_corner_radius_ = value; _has_field_.set(56); }

  bool has_destination_frame() const { return _has_field_[57]; }
  const RectProto& destination_frame() const { return *destination_frame_; }
  RectProto* mutable_destination_frame() { _has_field_.set(57); return destination_frame_.get(); }

  bool has_original_id() const { return _has_field_[58]; }
  uint32_t original_id() const { return original_id_; }
  void set_original_id(uint32_t value) { original_id_ = value; _has_field_.set(58); }

  bool has_trusted_overlay() const { return _has_field_[59]; }
  TrustedOverlay trusted_overlay() const { return trusted_overlay_; }
  void set_trusted_overlay(TrustedOverlay value) { trusted_overlay_ = value; _has_field_.set(59); }

 private:
  int32_t id_{};
  std::string name_{};
  std::vector<int32_t> children_;
  std::vector<int32_t> relatives_;
  std::string type_{};
  ::protozero::CopyablePtr<RegionProto> transparent_region_;
  ::protozero::CopyablePtr<RegionProto> visible_region_;
  ::protozero::CopyablePtr<RegionProto> damage_region_;
  uint32_t layer_stack_{};
  int32_t z_{};
  ::protozero::CopyablePtr<PositionProto> position_;
  ::protozero::CopyablePtr<PositionProto> requested_position_;
  ::protozero::CopyablePtr<SizeProto> size_;
  ::protozero::CopyablePtr<RectProto> crop_;
  ::protozero::CopyablePtr<RectProto> final_crop_;
  bool is_opaque_{};
  bool invalidate_{};
  std::string dataspace_{};
  std::string pixel_format_{};
  ::protozero::CopyablePtr<ColorProto> color_;
  ::protozero::CopyablePtr<ColorProto> requested_color_;
  uint32_t flags_{};
  ::protozero::CopyablePtr<TransformProto> transform_;
  ::protozero::CopyablePtr<TransformProto> requested_transform_;
  int32_t parent_{};
  int32_t z_order_relative_of_{};
  ::protozero::CopyablePtr<ActiveBufferProto> active_buffer_;
  int32_t queued_frames_{};
  bool refresh_pending_{};
  ::protozero::CopyablePtr<RectProto> hwc_frame_;
  ::protozero::CopyablePtr<FloatRectProto> hwc_crop_;
  int32_t hwc_transform_{};
  int32_t window_type_{};
  int32_t app_id_{};
  HwcCompositionType hwc_composition_type_{};
  bool is_protected_{};
  uint64_t curr_frame_{};
  std::vector<BarrierLayerProto> barrier_layer_;
  ::protozero::CopyablePtr<TransformProto> buffer_transform_;
  int32_t effective_scaling_mode_{};
  float corner_radius_{};
  std::vector<LayerProto_MetadataEntry> metadata_;
  ::protozero::CopyablePtr<TransformProto> effective_transform_;
  ::protozero::CopyablePtr<FloatRectProto> source_bounds_;
  ::protozero::CopyablePtr<FloatRectProto> bounds_;
  ::protozero::CopyablePtr<FloatRectProto> screen_bounds_;
  ::protozero::CopyablePtr<InputWindowInfoProto> input_window_info_;
  ::protozero::CopyablePtr<FloatRectProto> corner_radius_crop_;
  float shadow_radius_{};
  ::protozero::CopyablePtr<ColorTransformProto> color_transform_;
  bool is_relative_of_{};
  int32_t background_blur_radius_{};
  uint32_t owner_uid_{};
  std::vector<BlurRegion> blur_regions_;
  bool is_trusted_overlay_{};
  float requested_corner_radius_{};
  ::protozero::CopyablePtr<RectProto> destination_frame_;
  uint32_t original_id_{};
  TrustedOverlay trusted_overlay_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<60> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT LayerProto_MetadataEntry : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };

  LayerProto_MetadataEntry();
  ~LayerProto_MetadataEntry() override;
  LayerProto_MetadataEntry(LayerProto_MetadataEntry&&) noexcept;
  LayerProto_MetadataEntry& operator=(LayerProto_MetadataEntry&&);
  LayerProto_MetadataEntry(const LayerProto_MetadataEntry&);
  LayerProto_MetadataEntry& operator=(const LayerProto_MetadataEntry&);
  bool operator==(const LayerProto_MetadataEntry&) const;
  bool operator!=(const LayerProto_MetadataEntry& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_key() const { return _has_field_[1]; }
  int32_t key() const { return key_; }
  void set_key(int32_t value) { key_ = value; _has_field_.set(1); }

  bool has_value() const { return _has_field_[2]; }
  const std::string& value() const { return value_; }
  void set_value(const std::string& value) { value_ = value; _has_field_.set(2); }

 private:
  int32_t key_{};
  std::string value_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT DisplayProto : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kLayerStackFieldNumber = 3,
    kSizeFieldNumber = 4,
    kLayerStackSpaceRectFieldNumber = 5,
    kTransformFieldNumber = 6,
    kIsVirtualFieldNumber = 7,
    kDpiXFieldNumber = 8,
    kDpiYFieldNumber = 9,
  };

  DisplayProto();
  ~DisplayProto() override;
  DisplayProto(DisplayProto&&) noexcept;
  DisplayProto& operator=(DisplayProto&&);
  DisplayProto(const DisplayProto&);
  DisplayProto& operator=(const DisplayProto&);
  bool operator==(const DisplayProto&) const;
  bool operator!=(const DisplayProto& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_id() const { return _has_field_[1]; }
  uint64_t id() const { return id_; }
  void set_id(uint64_t value) { id_ = value; _has_field_.set(1); }

  bool has_name() const { return _has_field_[2]; }
  const std::string& name() const { return name_; }
  void set_name(const std::string& value) { name_ = value; _has_field_.set(2); }

  bool has_layer_stack() const { return _has_field_[3]; }
  uint32_t layer_stack() const { return layer_stack_; }
  void set_layer_stack(uint32_t value) { layer_stack_ = value; _has_field_.set(3); }

  bool has_size() const { return _has_field_[4]; }
  const SizeProto& size() const { return *size_; }
  SizeProto* mutable_size() { _has_field_.set(4); return size_.get(); }

  bool has_layer_stack_space_rect() const { return _has_field_[5]; }
  const RectProto& layer_stack_space_rect() const { return *layer_stack_space_rect_; }
  RectProto* mutable_layer_stack_space_rect() { _has_field_.set(5); return layer_stack_space_rect_.get(); }

  bool has_transform() const { return _has_field_[6]; }
  const TransformProto& transform() const { return *transform_; }
  TransformProto* mutable_transform() { _has_field_.set(6); return transform_.get(); }

  bool has_is_virtual() const { return _has_field_[7]; }
  bool is_virtual() const { return is_virtual_; }
  void set_is_virtual(bool value) { is_virtual_ = value; _has_field_.set(7); }

  bool has_dpi_x() const { return _has_field_[8]; }
  double dpi_x() const { return dpi_x_; }
  void set_dpi_x(double value) { dpi_x_ = value; _has_field_.set(8); }

  bool has_dpi_y() const { return _has_field_[9]; }
  double dpi_y() const { return dpi_y_; }
  void set_dpi_y(double value) { dpi_y_ = value; _has_field_.set(9); }

 private:
  uint64_t id_{};
  std::string name_{};
  uint32_t layer_stack_{};
  ::protozero::CopyablePtr<SizeProto> size_;
  ::protozero::CopyablePtr<RectProto> layer_stack_space_rect_;
  ::protozero::CopyablePtr<TransformProto> transform_;
  bool is_virtual_{};
  double dpi_x_{};
  double dpi_y_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<10> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT LayersProto : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kLayersFieldNumber = 1,
  };

  LayersProto();
  ~LayersProto() override;
  LayersProto(LayersProto&&) noexcept;
  LayersProto& operator=(LayersProto&&);
  LayersProto(const LayersProto&);
  LayersProto& operator=(const LayersProto&);
  bool operator==(const LayersProto&) const;
  bool operator!=(const LayersProto& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  const std::vector<LayerProto>& layers() const { return layers_; }
  std::vector<LayerProto>* mutable_layers() { return &layers_; }
  int layers_size() const;
  void clear_layers();
  LayerProto* add_layers();

 private:
  std::vector<LayerProto> layers_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT LayersSnapshotProto : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kElapsedRealtimeNanosFieldNumber = 1,
    kWhereFieldNumber = 2,
    kLayersFieldNumber = 3,
    kHwcBlobFieldNumber = 4,
    kExcludesCompositionStateFieldNumber = 5,
    kMissedEntriesFieldNumber = 6,
    kDisplaysFieldNumber = 7,
    kVsyncIdFieldNumber = 8,
  };

  LayersSnapshotProto();
  ~LayersSnapshotProto() override;
  LayersSnapshotProto(LayersSnapshotProto&&) noexcept;
  LayersSnapshotProto& operator=(LayersSnapshotProto&&);
  LayersSnapshotProto(const LayersSnapshotProto&);
  LayersSnapshotProto& operator=(const LayersSnapshotProto&);
  bool operator==(const LayersSnapshotProto&) const;
  bool operator!=(const LayersSnapshotProto& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_elapsed_realtime_nanos() const { return _has_field_[1]; }
  int64_t elapsed_realtime_nanos() const { return elapsed_realtime_nanos_; }
  void set_elapsed_realtime_nanos(int64_t value) { elapsed_realtime_nanos_ = value; _has_field_.set(1); }

  bool has_where() const { return _has_field_[2]; }
  const std::string& where() const { return where_; }
  void set_where(const std::string& value) { where_ = value; _has_field_.set(2); }

  bool has_layers() const { return _has_field_[3]; }
  const LayersProto& layers() const { return *layers_; }
  LayersProto* mutable_layers() { _has_field_.set(3); return layers_.get(); }

  bool has_hwc_blob() const { return _has_field_[4]; }
  const std::string& hwc_blob() const { return hwc_blob_; }
  void set_hwc_blob(const std::string& value) { hwc_blob_ = value; _has_field_.set(4); }

  bool has_excludes_composition_state() const { return _has_field_[5]; }
  bool excludes_composition_state() const { return excludes_composition_state_; }
  void set_excludes_composition_state(bool value) { excludes_composition_state_ = value; _has_field_.set(5); }

  bool has_missed_entries() const { return _has_field_[6]; }
  uint32_t missed_entries() const { return missed_entries_; }
  void set_missed_entries(uint32_t value) { missed_entries_ = value; _has_field_.set(6); }

  const std::vector<DisplayProto>& displays() const { return displays_; }
  std::vector<DisplayProto>* mutable_displays() { return &displays_; }
  int displays_size() const;
  void clear_displays();
  DisplayProto* add_displays();

  bool has_vsync_id() const { return _has_field_[8]; }
  int64_t vsync_id() const { return vsync_id_; }
  void set_vsync_id(int64_t value) { vsync_id_ = value; _has_field_.set(8); }

 private:
  int64_t elapsed_realtime_nanos_{};
  std::string where_{};
  ::protozero::CopyablePtr<LayersProto> layers_;
  std::string hwc_blob_{};
  bool excludes_composition_state_{};
  uint32_t missed_entries_{};
  std::vector<DisplayProto> displays_;
  int64_t vsync_id_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<9> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT LayersTraceFileProto : public ::protozero::CppMessageObj {
 public:
  using MagicNumber = LayersTraceFileProto_MagicNumber;
  static constexpr auto INVALID = LayersTraceFileProto_MagicNumber_INVALID;
  static constexpr auto MAGIC_NUMBER_L = LayersTraceFileProto_MagicNumber_MAGIC_NUMBER_L;
  static constexpr auto MAGIC_NUMBER_H = LayersTraceFileProto_MagicNumber_MAGIC_NUMBER_H;
  static constexpr auto MagicNumber_MIN = LayersTraceFileProto_MagicNumber_INVALID;
  static constexpr auto MagicNumber_MAX = LayersTraceFileProto_MagicNumber_MAGIC_NUMBER_L;
  enum FieldNumbers {
    kMagicNumberFieldNumber = 1,
    kEntryFieldNumber = 2,
    kRealToElapsedTimeOffsetNanosFieldNumber = 3,
  };

  LayersTraceFileProto();
  ~LayersTraceFileProto() override;
  LayersTraceFileProto(LayersTraceFileProto&&) noexcept;
  LayersTraceFileProto& operator=(LayersTraceFileProto&&);
  LayersTraceFileProto(const LayersTraceFileProto&);
  LayersTraceFileProto& operator=(const LayersTraceFileProto&);
  bool operator==(const LayersTraceFileProto&) const;
  bool operator!=(const LayersTraceFileProto& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_magic_number() const { return _has_field_[1]; }
  uint64_t magic_number() const { return magic_number_; }
  void set_magic_number(uint64_t value) { magic_number_ = value; _has_field_.set(1); }

  const std::vector<LayersSnapshotProto>& entry() const { return entry_; }
  std::vector<LayersSnapshotProto>* mutable_entry() { return &entry_; }
  int entry_size() const;
  void clear_entry();
  LayersSnapshotProto* add_entry();

  bool has_real_to_elapsed_time_offset_nanos() const { return _has_field_[3]; }
  uint64_t real_to_elapsed_time_offset_nanos() const { return real_to_elapsed_time_offset_nanos_; }
  void set_real_to_elapsed_time_offset_nanos(uint64_t value) { real_to_elapsed_time_offset_nanos_ = value; _has_field_.set(3); }

 private:
  uint64_t magic_number_{};
  std::vector<LayersSnapshotProto> entry_;
  uint64_t real_to_elapsed_time_offset_nanos_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ANDROID_SURFACEFLINGER_LAYERS_PROTO_CPP_H_
