// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ANDROID_SHELL_TRANSITION_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ANDROID_SHELL_TRANSITION_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class ShellHandlerMapping;
class ShellHandlerMappings;
class ShellTransition;
class ShellTransition_Target;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {

class PERFETTO_EXPORT_COMPONENT ShellHandlerMapping : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
  };

  ShellHandlerMapping();
  ~ShellHandlerMapping() override;
  ShellHandlerMapping(ShellHandlerMapping&&) noexcept;
  ShellHandlerMapping& operator=(ShellHandlerMapping&&);
  ShellHandlerMapping(const ShellHandlerMapping&);
  ShellHandlerMapping& operator=(const ShellHandlerMapping&);
  bool operator==(const ShellHandlerMapping&) const;
  bool operator!=(const ShellHandlerMapping& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_id() const { return _has_field_[1]; }
  int32_t id() const { return id_; }
  void set_id(int32_t value) { id_ = value; _has_field_.set(1); }

  bool has_name() const { return _has_field_[2]; }
  const std::string& name() const { return name_; }
  void set_name(const std::string& value) { name_ = value; _has_field_.set(2); }

 private:
  int32_t id_{};
  std::string name_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT ShellHandlerMappings : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kMappingFieldNumber = 1,
  };

  ShellHandlerMappings();
  ~ShellHandlerMappings() override;
  ShellHandlerMappings(ShellHandlerMappings&&) noexcept;
  ShellHandlerMappings& operator=(ShellHandlerMappings&&);
  ShellHandlerMappings(const ShellHandlerMappings&);
  ShellHandlerMappings& operator=(const ShellHandlerMappings&);
  bool operator==(const ShellHandlerMappings&) const;
  bool operator!=(const ShellHandlerMappings& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  const std::vector<ShellHandlerMapping>& mapping() const { return mapping_; }
  std::vector<ShellHandlerMapping>* mutable_mapping() { return &mapping_; }
  int mapping_size() const;
  void clear_mapping();
  ShellHandlerMapping* add_mapping();

 private:
  std::vector<ShellHandlerMapping> mapping_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT ShellTransition : public ::protozero::CppMessageObj {
 public:
  using Target = ShellTransition_Target;
  enum FieldNumbers {
    kIdFieldNumber = 1,
    kCreateTimeNsFieldNumber = 2,
    kSendTimeNsFieldNumber = 3,
    kDispatchTimeNsFieldNumber = 4,
    kMergeTimeNsFieldNumber = 5,
    kMergeRequestTimeNsFieldNumber = 6,
    kShellAbortTimeNsFieldNumber = 7,
    kWmAbortTimeNsFieldNumber = 8,
    kFinishTimeNsFieldNumber = 9,
    kStartTransactionIdFieldNumber = 10,
    kFinishTransactionIdFieldNumber = 11,
    kHandlerFieldNumber = 12,
    kTypeFieldNumber = 13,
    kTargetsFieldNumber = 14,
    kMergeTargetFieldNumber = 15,
    kFlagsFieldNumber = 16,
    kStartingWindowRemoveTimeNsFieldNumber = 17,
  };

  ShellTransition();
  ~ShellTransition() override;
  ShellTransition(ShellTransition&&) noexcept;
  ShellTransition& operator=(ShellTransition&&);
  ShellTransition(const ShellTransition&);
  ShellTransition& operator=(const ShellTransition&);
  bool operator==(const ShellTransition&) const;
  bool operator!=(const ShellTransition& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_id() const { return _has_field_[1]; }
  int32_t id() const { return id_; }
  void set_id(int32_t value) { id_ = value; _has_field_.set(1); }

  bool has_create_time_ns() const { return _has_field_[2]; }
  int64_t create_time_ns() const { return create_time_ns_; }
  void set_create_time_ns(int64_t value) { create_time_ns_ = value; _has_field_.set(2); }

  bool has_send_time_ns() const { return _has_field_[3]; }
  int64_t send_time_ns() const { return send_time_ns_; }
  void set_send_time_ns(int64_t value) { send_time_ns_ = value; _has_field_.set(3); }

  bool has_dispatch_time_ns() const { return _has_field_[4]; }
  int64_t dispatch_time_ns() const { return dispatch_time_ns_; }
  void set_dispatch_time_ns(int64_t value) { dispatch_time_ns_ = value; _has_field_.set(4); }

  bool has_merge_time_ns() const { return _has_field_[5]; }
  int64_t merge_time_ns() const { return merge_time_ns_; }
  void set_merge_time_ns(int64_t value) { merge_time_ns_ = value; _has_field_.set(5); }

  bool has_merge_request_time_ns() const { return _has_field_[6]; }
  int64_t merge_request_time_ns() const { return merge_request_time_ns_; }
  void set_merge_request_time_ns(int64_t value) { merge_request_time_ns_ = value; _has_field_.set(6); }

  bool has_shell_abort_time_ns() const { return _has_field_[7]; }
  int64_t shell_abort_time_ns() const { return shell_abort_time_ns_; }
  void set_shell_abort_time_ns(int64_t value) { shell_abort_time_ns_ = value; _has_field_.set(7); }

  bool has_wm_abort_time_ns() const { return _has_field_[8]; }
  int64_t wm_abort_time_ns() const { return wm_abort_time_ns_; }
  void set_wm_abort_time_ns(int64_t value) { wm_abort_time_ns_ = value; _has_field_.set(8); }

  bool has_finish_time_ns() const { return _has_field_[9]; }
  int64_t finish_time_ns() const { return finish_time_ns_; }
  void set_finish_time_ns(int64_t value) { finish_time_ns_ = value; _has_field_.set(9); }

  bool has_start_transaction_id() const { return _has_field_[10]; }
  uint64_t start_transaction_id() const { return start_transaction_id_; }
  void set_start_transaction_id(uint64_t value) { start_transaction_id_ = value; _has_field_.set(10); }

  bool has_finish_transaction_id() const { return _has_field_[11]; }
  uint64_t finish_transaction_id() const { return finish_transaction_id_; }
  void set_finish_transaction_id(uint64_t value) { finish_transaction_id_ = value; _has_field_.set(11); }

  bool has_handler() const { return _has_field_[12]; }
  int32_t handler() const { return handler_; }
  void set_handler(int32_t value) { handler_ = value; _has_field_.set(12); }

  bool has_type() const { return _has_field_[13]; }
  int32_t type() const { return type_; }
  void set_type(int32_t value) { type_ = value; _has_field_.set(13); }

  const std::vector<ShellTransition_Target>& targets() const { return targets_; }
  std::vector<ShellTransition_Target>* mutable_targets() { return &targets_; }
  int targets_size() const;
  void clear_targets();
  ShellTransition_Target* add_targets();

  bool has_merge_target() const { return _has_field_[15]; }
  int32_t merge_target() const { return merge_target_; }
  void set_merge_target(int32_t value) { merge_target_ = value; _has_field_.set(15); }

  bool has_flags() const { return _has_field_[16]; }
  int32_t flags() const { return flags_; }
  void set_flags(int32_t value) { flags_ = value; _has_field_.set(16); }

  bool has_starting_window_remove_time_ns() const { return _has_field_[17]; }
  int64_t starting_window_remove_time_ns() const { return starting_window_remove_time_ns_; }
  void set_starting_window_remove_time_ns(int64_t value) { starting_window_remove_time_ns_ = value; _has_field_.set(17); }

 private:
  int32_t id_{};
  int64_t create_time_ns_{};
  int64_t send_time_ns_{};
  int64_t dispatch_time_ns_{};
  int64_t merge_time_ns_{};
  int64_t merge_request_time_ns_{};
  int64_t shell_abort_time_ns_{};
  int64_t wm_abort_time_ns_{};
  int64_t finish_time_ns_{};
  uint64_t start_transaction_id_{};
  uint64_t finish_transaction_id_{};
  int32_t handler_{};
  int32_t type_{};
  std::vector<ShellTransition_Target> targets_;
  int32_t merge_target_{};
  int32_t flags_{};
  int64_t starting_window_remove_time_ns_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<18> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT ShellTransition_Target : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kModeFieldNumber = 1,
    kLayerIdFieldNumber = 2,
    kWindowIdFieldNumber = 3,
    kFlagsFieldNumber = 4,
  };

  ShellTransition_Target();
  ~ShellTransition_Target() override;
  ShellTransition_Target(ShellTransition_Target&&) noexcept;
  ShellTransition_Target& operator=(ShellTransition_Target&&);
  ShellTransition_Target(const ShellTransition_Target&);
  ShellTransition_Target& operator=(const ShellTransition_Target&);
  bool operator==(const ShellTransition_Target&) const;
  bool operator!=(const ShellTransition_Target& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_mode() const { return _has_field_[1]; }
  int32_t mode() const { return mode_; }
  void set_mode(int32_t value) { mode_ = value; _has_field_.set(1); }

  bool has_layer_id() const { return _has_field_[2]; }
  int32_t layer_id() const { return layer_id_; }
  void set_layer_id(int32_t value) { layer_id_ = value; _has_field_.set(2); }

  bool has_window_id() const { return _has_field_[3]; }
  int32_t window_id() const { return window_id_; }
  void set_window_id(int32_t value) { window_id_ = value; _has_field_.set(3); }

  bool has_flags() const { return _has_field_[4]; }
  int32_t flags() const { return flags_; }
  void set_flags(int32_t value) { flags_ = value; _has_field_.set(4); }

 private:
  int32_t mode_{};
  int32_t layer_id_{};
  int32_t window_id_{};
  int32_t flags_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ANDROID_SHELL_TRANSITION_PROTO_CPP_H_
