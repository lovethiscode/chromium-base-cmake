#include "perfetto/protozero/gen_field_helpers.h"
#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/scattered_heap_buffer.h"
// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
#endif
#include "protos/perfetto/trace/profiling/profile_common.gen.h"

namespace perfetto {
namespace protos {
namespace gen {

Callstack::Callstack() = default;
Callstack::~Callstack() = default;
Callstack::Callstack(const Callstack&) = default;
Callstack& Callstack::operator=(const Callstack&) = default;
Callstack::Callstack(Callstack&&) noexcept = default;
Callstack& Callstack::operator=(Callstack&&) = default;

bool Callstack::operator==(const Callstack& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(iid_, other.iid_)
   && ::protozero::internal::gen_helpers::EqualsField(frame_ids_, other.frame_ids_);
}

bool Callstack::ParseFromArray(const void* raw, size_t size) {
  frame_ids_.clear();
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* iid */:
        field.get(&iid_);
        break;
      case 2 /* frame_ids */:
        frame_ids_.emplace_back();
        field.get(&frame_ids_.back());
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Callstack::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Callstack::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Callstack::Serialize(::protozero::Message* msg) const {
  // Field 1: iid
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, iid_, msg);
  }

  // Field 2: frame_ids
  for (auto& it : frame_ids_) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, it, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


Frame::Frame() = default;
Frame::~Frame() = default;
Frame::Frame(const Frame&) = default;
Frame& Frame::operator=(const Frame&) = default;
Frame::Frame(Frame&&) noexcept = default;
Frame& Frame::operator=(Frame&&) = default;

bool Frame::operator==(const Frame& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(iid_, other.iid_)
   && ::protozero::internal::gen_helpers::EqualsField(function_name_id_, other.function_name_id_)
   && ::protozero::internal::gen_helpers::EqualsField(mapping_id_, other.mapping_id_)
   && ::protozero::internal::gen_helpers::EqualsField(rel_pc_, other.rel_pc_);
}

bool Frame::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* iid */:
        field.get(&iid_);
        break;
      case 2 /* function_name_id */:
        field.get(&function_name_id_);
        break;
      case 3 /* mapping_id */:
        field.get(&mapping_id_);
        break;
      case 4 /* rel_pc */:
        field.get(&rel_pc_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Frame::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Frame::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Frame::Serialize(::protozero::Message* msg) const {
  // Field 1: iid
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, iid_, msg);
  }

  // Field 2: function_name_id
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, function_name_id_, msg);
  }

  // Field 3: mapping_id
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, mapping_id_, msg);
  }

  // Field 4: rel_pc
  if (_has_field_[4]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(4, rel_pc_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


Mapping::Mapping() = default;
Mapping::~Mapping() = default;
Mapping::Mapping(const Mapping&) = default;
Mapping& Mapping::operator=(const Mapping&) = default;
Mapping::Mapping(Mapping&&) noexcept = default;
Mapping& Mapping::operator=(Mapping&&) = default;

bool Mapping::operator==(const Mapping& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(iid_, other.iid_)
   && ::protozero::internal::gen_helpers::EqualsField(build_id_, other.build_id_)
   && ::protozero::internal::gen_helpers::EqualsField(exact_offset_, other.exact_offset_)
   && ::protozero::internal::gen_helpers::EqualsField(start_offset_, other.start_offset_)
   && ::protozero::internal::gen_helpers::EqualsField(start_, other.start_)
   && ::protozero::internal::gen_helpers::EqualsField(end_, other.end_)
   && ::protozero::internal::gen_helpers::EqualsField(load_bias_, other.load_bias_)
   && ::protozero::internal::gen_helpers::EqualsField(path_string_ids_, other.path_string_ids_);
}

bool Mapping::ParseFromArray(const void* raw, size_t size) {
  path_string_ids_.clear();
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* iid */:
        field.get(&iid_);
        break;
      case 2 /* build_id */:
        field.get(&build_id_);
        break;
      case 8 /* exact_offset */:
        field.get(&exact_offset_);
        break;
      case 3 /* start_offset */:
        field.get(&start_offset_);
        break;
      case 4 /* start */:
        field.get(&start_);
        break;
      case 5 /* end */:
        field.get(&end_);
        break;
      case 6 /* load_bias */:
        field.get(&load_bias_);
        break;
      case 7 /* path_string_ids */:
        path_string_ids_.emplace_back();
        field.get(&path_string_ids_.back());
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Mapping::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Mapping::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Mapping::Serialize(::protozero::Message* msg) const {
  // Field 1: iid
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, iid_, msg);
  }

  // Field 2: build_id
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, build_id_, msg);
  }

  // Field 8: exact_offset
  if (_has_field_[8]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(8, exact_offset_, msg);
  }

  // Field 3: start_offset
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, start_offset_, msg);
  }

  // Field 4: start
  if (_has_field_[4]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(4, start_, msg);
  }

  // Field 5: end
  if (_has_field_[5]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(5, end_, msg);
  }

  // Field 6: load_bias
  if (_has_field_[6]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(6, load_bias_, msg);
  }

  // Field 7: path_string_ids
  for (auto& it : path_string_ids_) {
    ::protozero::internal::gen_helpers::SerializeVarInt(7, it, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


ModuleSymbols::ModuleSymbols() = default;
ModuleSymbols::~ModuleSymbols() = default;
ModuleSymbols::ModuleSymbols(const ModuleSymbols&) = default;
ModuleSymbols& ModuleSymbols::operator=(const ModuleSymbols&) = default;
ModuleSymbols::ModuleSymbols(ModuleSymbols&&) noexcept = default;
ModuleSymbols& ModuleSymbols::operator=(ModuleSymbols&&) = default;

bool ModuleSymbols::operator==(const ModuleSymbols& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(path_, other.path_)
   && ::protozero::internal::gen_helpers::EqualsField(build_id_, other.build_id_)
   && ::protozero::internal::gen_helpers::EqualsField(address_symbols_, other.address_symbols_);
}

int ModuleSymbols::address_symbols_size() const { return static_cast<int>(address_symbols_.size()); }
void ModuleSymbols::clear_address_symbols() { address_symbols_.clear(); }
AddressSymbols* ModuleSymbols::add_address_symbols() { address_symbols_.emplace_back(); return &address_symbols_.back(); }
bool ModuleSymbols::ParseFromArray(const void* raw, size_t size) {
  address_symbols_.clear();
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* path */:
        ::protozero::internal::gen_helpers::DeserializeString(field, &path_);
        break;
      case 2 /* build_id */:
        ::protozero::internal::gen_helpers::DeserializeString(field, &build_id_);
        break;
      case 3 /* address_symbols */:
        address_symbols_.emplace_back();
        address_symbols_.back().ParseFromArray(field.data(), field.size());
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string ModuleSymbols::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> ModuleSymbols::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void ModuleSymbols::Serialize(::protozero::Message* msg) const {
  // Field 1: path
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeString(1, path_, msg);
  }

  // Field 2: build_id
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeString(2, build_id_, msg);
  }

  // Field 3: address_symbols
  for (auto& it : address_symbols_) {
    it.Serialize(msg->BeginNestedMessage<::protozero::Message>(3));
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


AddressSymbols::AddressSymbols() = default;
AddressSymbols::~AddressSymbols() = default;
AddressSymbols::AddressSymbols(const AddressSymbols&) = default;
AddressSymbols& AddressSymbols::operator=(const AddressSymbols&) = default;
AddressSymbols::AddressSymbols(AddressSymbols&&) noexcept = default;
AddressSymbols& AddressSymbols::operator=(AddressSymbols&&) = default;

bool AddressSymbols::operator==(const AddressSymbols& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(address_, other.address_)
   && ::protozero::internal::gen_helpers::EqualsField(lines_, other.lines_);
}

int AddressSymbols::lines_size() const { return static_cast<int>(lines_.size()); }
void AddressSymbols::clear_lines() { lines_.clear(); }
Line* AddressSymbols::add_lines() { lines_.emplace_back(); return &lines_.back(); }
bool AddressSymbols::ParseFromArray(const void* raw, size_t size) {
  lines_.clear();
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* address */:
        field.get(&address_);
        break;
      case 2 /* lines */:
        lines_.emplace_back();
        lines_.back().ParseFromArray(field.data(), field.size());
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string AddressSymbols::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> AddressSymbols::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void AddressSymbols::Serialize(::protozero::Message* msg) const {
  // Field 1: address
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, address_, msg);
  }

  // Field 2: lines
  for (auto& it : lines_) {
    it.Serialize(msg->BeginNestedMessage<::protozero::Message>(2));
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


Line::Line() = default;
Line::~Line() = default;
Line::Line(const Line&) = default;
Line& Line::operator=(const Line&) = default;
Line::Line(Line&&) noexcept = default;
Line& Line::operator=(Line&&) = default;

bool Line::operator==(const Line& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(function_name_, other.function_name_)
   && ::protozero::internal::gen_helpers::EqualsField(source_file_name_, other.source_file_name_)
   && ::protozero::internal::gen_helpers::EqualsField(line_number_, other.line_number_);
}

bool Line::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* function_name */:
        ::protozero::internal::gen_helpers::DeserializeString(field, &function_name_);
        break;
      case 2 /* source_file_name */:
        ::protozero::internal::gen_helpers::DeserializeString(field, &source_file_name_);
        break;
      case 3 /* line_number */:
        field.get(&line_number_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Line::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Line::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Line::Serialize(::protozero::Message* msg) const {
  // Field 1: function_name
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeString(1, function_name_, msg);
  }

  // Field 2: source_file_name
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeString(2, source_file_name_, msg);
  }

  // Field 3: line_number
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, line_number_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


ProfiledFrameSymbols::ProfiledFrameSymbols() = default;
ProfiledFrameSymbols::~ProfiledFrameSymbols() = default;
ProfiledFrameSymbols::ProfiledFrameSymbols(const ProfiledFrameSymbols&) = default;
ProfiledFrameSymbols& ProfiledFrameSymbols::operator=(const ProfiledFrameSymbols&) = default;
ProfiledFrameSymbols::ProfiledFrameSymbols(ProfiledFrameSymbols&&) noexcept = default;
ProfiledFrameSymbols& ProfiledFrameSymbols::operator=(ProfiledFrameSymbols&&) = default;

bool ProfiledFrameSymbols::operator==(const ProfiledFrameSymbols& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(frame_iid_, other.frame_iid_)
   && ::protozero::internal::gen_helpers::EqualsField(function_name_id_, other.function_name_id_)
   && ::protozero::internal::gen_helpers::EqualsField(file_name_id_, other.file_name_id_)
   && ::protozero::internal::gen_helpers::EqualsField(line_number_, other.line_number_);
}

bool ProfiledFrameSymbols::ParseFromArray(const void* raw, size_t size) {
  function_name_id_.clear();
  file_name_id_.clear();
  line_number_.clear();
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* frame_iid */:
        field.get(&frame_iid_);
        break;
      case 2 /* function_name_id */:
        function_name_id_.emplace_back();
        field.get(&function_name_id_.back());
        break;
      case 3 /* file_name_id */:
        file_name_id_.emplace_back();
        field.get(&file_name_id_.back());
        break;
      case 4 /* line_number */:
        line_number_.emplace_back();
        field.get(&line_number_.back());
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string ProfiledFrameSymbols::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> ProfiledFrameSymbols::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void ProfiledFrameSymbols::Serialize(::protozero::Message* msg) const {
  // Field 1: frame_iid
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, frame_iid_, msg);
  }

  // Field 2: function_name_id
  for (auto& it : function_name_id_) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, it, msg);
  }

  // Field 3: file_name_id
  for (auto& it : file_name_id_) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, it, msg);
  }

  // Field 4: line_number
  for (auto& it : line_number_) {
    ::protozero::internal::gen_helpers::SerializeVarInt(4, it, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


InternedString::InternedString() = default;
InternedString::~InternedString() = default;
InternedString::InternedString(const InternedString&) = default;
InternedString& InternedString::operator=(const InternedString&) = default;
InternedString::InternedString(InternedString&&) noexcept = default;
InternedString& InternedString::operator=(InternedString&&) = default;

bool InternedString::operator==(const InternedString& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(iid_, other.iid_)
   && ::protozero::internal::gen_helpers::EqualsField(str_, other.str_);
}

bool InternedString::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* iid */:
        field.get(&iid_);
        break;
      case 2 /* str */:
        field.get(&str_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string InternedString::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> InternedString::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void InternedString::Serialize(::protozero::Message* msg) const {
  // Field 1: iid
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, iid_, msg);
  }

  // Field 2: str
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeString(2, str_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}

}  // namespace perfetto
}  // namespace protos
}  // namespace gen
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif
