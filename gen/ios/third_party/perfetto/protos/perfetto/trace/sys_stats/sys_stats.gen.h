// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_SYS_STATS_SYS_STATS_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_SYS_STATS_SYS_STATS_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class SysStats;
class SysStats_PsiSample;
class SysStats_DiskStat;
class SysStats_BuddyInfo;
class SysStats_DevfreqValue;
class SysStats_InterruptCount;
class SysStats_CpuTimes;
class SysStats_VmstatValue;
class SysStats_MeminfoValue;
enum SysStats_PsiSample_PsiResource : int;
enum VmstatCounters : int;
enum MeminfoCounters : int;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {
enum SysStats_PsiSample_PsiResource : int {
  SysStats_PsiSample_PsiResource_PSI_RESOURCE_UNSPECIFIED = 0,
  SysStats_PsiSample_PsiResource_PSI_RESOURCE_CPU_SOME = 1,
  SysStats_PsiSample_PsiResource_PSI_RESOURCE_CPU_FULL = 2,
  SysStats_PsiSample_PsiResource_PSI_RESOURCE_IO_SOME = 3,
  SysStats_PsiSample_PsiResource_PSI_RESOURCE_IO_FULL = 4,
  SysStats_PsiSample_PsiResource_PSI_RESOURCE_MEMORY_SOME = 5,
  SysStats_PsiSample_PsiResource_PSI_RESOURCE_MEMORY_FULL = 6,
};

class PERFETTO_EXPORT_COMPONENT SysStats : public ::protozero::CppMessageObj {
 public:
  using MeminfoValue = SysStats_MeminfoValue;
  using VmstatValue = SysStats_VmstatValue;
  using CpuTimes = SysStats_CpuTimes;
  using InterruptCount = SysStats_InterruptCount;
  using DevfreqValue = SysStats_DevfreqValue;
  using BuddyInfo = SysStats_BuddyInfo;
  using DiskStat = SysStats_DiskStat;
  using PsiSample = SysStats_PsiSample;
  enum FieldNumbers {
    kMeminfoFieldNumber = 1,
    kVmstatFieldNumber = 2,
    kCpuStatFieldNumber = 3,
    kNumForksFieldNumber = 4,
    kNumIrqTotalFieldNumber = 5,
    kNumIrqFieldNumber = 6,
    kNumSoftirqTotalFieldNumber = 7,
    kNumSoftirqFieldNumber = 8,
    kCollectionEndTimestampFieldNumber = 9,
    kDevfreqFieldNumber = 10,
    kCpufreqKhzFieldNumber = 11,
    kBuddyInfoFieldNumber = 12,
    kDiskStatFieldNumber = 13,
    kPsiFieldNumber = 14,
  };

  SysStats();
  ~SysStats() override;
  SysStats(SysStats&&) noexcept;
  SysStats& operator=(SysStats&&);
  SysStats(const SysStats&);
  SysStats& operator=(const SysStats&);
  bool operator==(const SysStats&) const;
  bool operator!=(const SysStats& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  const std::vector<SysStats_MeminfoValue>& meminfo() const { return meminfo_; }
  std::vector<SysStats_MeminfoValue>* mutable_meminfo() { return &meminfo_; }
  int meminfo_size() const;
  void clear_meminfo();
  SysStats_MeminfoValue* add_meminfo();

  const std::vector<SysStats_VmstatValue>& vmstat() const { return vmstat_; }
  std::vector<SysStats_VmstatValue>* mutable_vmstat() { return &vmstat_; }
  int vmstat_size() const;
  void clear_vmstat();
  SysStats_VmstatValue* add_vmstat();

  const std::vector<SysStats_CpuTimes>& cpu_stat() const { return cpu_stat_; }
  std::vector<SysStats_CpuTimes>* mutable_cpu_stat() { return &cpu_stat_; }
  int cpu_stat_size() const;
  void clear_cpu_stat();
  SysStats_CpuTimes* add_cpu_stat();

  bool has_num_forks() const { return _has_field_[4]; }
  uint64_t num_forks() const { return num_forks_; }
  void set_num_forks(uint64_t value) { num_forks_ = value; _has_field_.set(4); }

  bool has_num_irq_total() const { return _has_field_[5]; }
  uint64_t num_irq_total() const { return num_irq_total_; }
  void set_num_irq_total(uint64_t value) { num_irq_total_ = value; _has_field_.set(5); }

  const std::vector<SysStats_InterruptCount>& num_irq() const { return num_irq_; }
  std::vector<SysStats_InterruptCount>* mutable_num_irq() { return &num_irq_; }
  int num_irq_size() const;
  void clear_num_irq();
  SysStats_InterruptCount* add_num_irq();

  bool has_num_softirq_total() const { return _has_field_[7]; }
  uint64_t num_softirq_total() const { return num_softirq_total_; }
  void set_num_softirq_total(uint64_t value) { num_softirq_total_ = value; _has_field_.set(7); }

  const std::vector<SysStats_InterruptCount>& num_softirq() const { return num_softirq_; }
  std::vector<SysStats_InterruptCount>* mutable_num_softirq() { return &num_softirq_; }
  int num_softirq_size() const;
  void clear_num_softirq();
  SysStats_InterruptCount* add_num_softirq();

  bool has_collection_end_timestamp() const { return _has_field_[9]; }
  uint64_t collection_end_timestamp() const { return collection_end_timestamp_; }
  void set_collection_end_timestamp(uint64_t value) { collection_end_timestamp_ = value; _has_field_.set(9); }

  const std::vector<SysStats_DevfreqValue>& devfreq() const { return devfreq_; }
  std::vector<SysStats_DevfreqValue>* mutable_devfreq() { return &devfreq_; }
  int devfreq_size() const;
  void clear_devfreq();
  SysStats_DevfreqValue* add_devfreq();

  const std::vector<uint32_t>& cpufreq_khz() const { return cpufreq_khz_; }
  std::vector<uint32_t>* mutable_cpufreq_khz() { return &cpufreq_khz_; }
  int cpufreq_khz_size() const { return static_cast<int>(cpufreq_khz_.size()); }
  void clear_cpufreq_khz() { cpufreq_khz_.clear(); }
  void add_cpufreq_khz(uint32_t value) { cpufreq_khz_.emplace_back(value); }
  uint32_t* add_cpufreq_khz() { cpufreq_khz_.emplace_back(); return &cpufreq_khz_.back(); }

  const std::vector<SysStats_BuddyInfo>& buddy_info() const { return buddy_info_; }
  std::vector<SysStats_BuddyInfo>* mutable_buddy_info() { return &buddy_info_; }
  int buddy_info_size() const;
  void clear_buddy_info();
  SysStats_BuddyInfo* add_buddy_info();

  const std::vector<SysStats_DiskStat>& disk_stat() const { return disk_stat_; }
  std::vector<SysStats_DiskStat>* mutable_disk_stat() { return &disk_stat_; }
  int disk_stat_size() const;
  void clear_disk_stat();
  SysStats_DiskStat* add_disk_stat();

  const std::vector<SysStats_PsiSample>& psi() const { return psi_; }
  std::vector<SysStats_PsiSample>* mutable_psi() { return &psi_; }
  int psi_size() const;
  void clear_psi();
  SysStats_PsiSample* add_psi();

 private:
  std::vector<SysStats_MeminfoValue> meminfo_;
  std::vector<SysStats_VmstatValue> vmstat_;
  std::vector<SysStats_CpuTimes> cpu_stat_;
  uint64_t num_forks_{};
  uint64_t num_irq_total_{};
  std::vector<SysStats_InterruptCount> num_irq_;
  uint64_t num_softirq_total_{};
  std::vector<SysStats_InterruptCount> num_softirq_;
  uint64_t collection_end_timestamp_{};
  std::vector<SysStats_DevfreqValue> devfreq_;
  std::vector<uint32_t> cpufreq_khz_;
  std::vector<SysStats_BuddyInfo> buddy_info_;
  std::vector<SysStats_DiskStat> disk_stat_;
  std::vector<SysStats_PsiSample> psi_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<15> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT SysStats_PsiSample : public ::protozero::CppMessageObj {
 public:
  using PsiResource = SysStats_PsiSample_PsiResource;
  static constexpr auto PSI_RESOURCE_UNSPECIFIED = SysStats_PsiSample_PsiResource_PSI_RESOURCE_UNSPECIFIED;
  static constexpr auto PSI_RESOURCE_CPU_SOME = SysStats_PsiSample_PsiResource_PSI_RESOURCE_CPU_SOME;
  static constexpr auto PSI_RESOURCE_CPU_FULL = SysStats_PsiSample_PsiResource_PSI_RESOURCE_CPU_FULL;
  static constexpr auto PSI_RESOURCE_IO_SOME = SysStats_PsiSample_PsiResource_PSI_RESOURCE_IO_SOME;
  static constexpr auto PSI_RESOURCE_IO_FULL = SysStats_PsiSample_PsiResource_PSI_RESOURCE_IO_FULL;
  static constexpr auto PSI_RESOURCE_MEMORY_SOME = SysStats_PsiSample_PsiResource_PSI_RESOURCE_MEMORY_SOME;
  static constexpr auto PSI_RESOURCE_MEMORY_FULL = SysStats_PsiSample_PsiResource_PSI_RESOURCE_MEMORY_FULL;
  static constexpr auto PsiResource_MIN = SysStats_PsiSample_PsiResource_PSI_RESOURCE_UNSPECIFIED;
  static constexpr auto PsiResource_MAX = SysStats_PsiSample_PsiResource_PSI_RESOURCE_MEMORY_FULL;
  enum FieldNumbers {
    kResourceFieldNumber = 1,
    kTotalNsFieldNumber = 2,
  };

  SysStats_PsiSample();
  ~SysStats_PsiSample() override;
  SysStats_PsiSample(SysStats_PsiSample&&) noexcept;
  SysStats_PsiSample& operator=(SysStats_PsiSample&&);
  SysStats_PsiSample(const SysStats_PsiSample&);
  SysStats_PsiSample& operator=(const SysStats_PsiSample&);
  bool operator==(const SysStats_PsiSample&) const;
  bool operator!=(const SysStats_PsiSample& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_resource() const { return _has_field_[1]; }
  SysStats_PsiSample_PsiResource resource() const { return resource_; }
  void set_resource(SysStats_PsiSample_PsiResource value) { resource_ = value; _has_field_.set(1); }

  bool has_total_ns() const { return _has_field_[2]; }
  uint64_t total_ns() const { return total_ns_; }
  void set_total_ns(uint64_t value) { total_ns_ = value; _has_field_.set(2); }

 private:
  SysStats_PsiSample_PsiResource resource_{};
  uint64_t total_ns_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT SysStats_DiskStat : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDeviceNameFieldNumber = 1,
    kReadSectorsFieldNumber = 2,
    kReadTimeMsFieldNumber = 3,
    kWriteSectorsFieldNumber = 4,
    kWriteTimeMsFieldNumber = 5,
    kDiscardSectorsFieldNumber = 6,
    kDiscardTimeMsFieldNumber = 7,
    kFlushCountFieldNumber = 8,
    kFlushTimeMsFieldNumber = 9,
  };

  SysStats_DiskStat();
  ~SysStats_DiskStat() override;
  SysStats_DiskStat(SysStats_DiskStat&&) noexcept;
  SysStats_DiskStat& operator=(SysStats_DiskStat&&);
  SysStats_DiskStat(const SysStats_DiskStat&);
  SysStats_DiskStat& operator=(const SysStats_DiskStat&);
  bool operator==(const SysStats_DiskStat&) const;
  bool operator!=(const SysStats_DiskStat& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_device_name() const { return _has_field_[1]; }
  const std::string& device_name() const { return device_name_; }
  void set_device_name(const std::string& value) { device_name_ = value; _has_field_.set(1); }

  bool has_read_sectors() const { return _has_field_[2]; }
  uint64_t read_sectors() const { return read_sectors_; }
  void set_read_sectors(uint64_t value) { read_sectors_ = value; _has_field_.set(2); }

  bool has_read_time_ms() const { return _has_field_[3]; }
  uint64_t read_time_ms() const { return read_time_ms_; }
  void set_read_time_ms(uint64_t value) { read_time_ms_ = value; _has_field_.set(3); }

  bool has_write_sectors() const { return _has_field_[4]; }
  uint64_t write_sectors() const { return write_sectors_; }
  void set_write_sectors(uint64_t value) { write_sectors_ = value; _has_field_.set(4); }

  bool has_write_time_ms() const { return _has_field_[5]; }
  uint64_t write_time_ms() const { return write_time_ms_; }
  void set_write_time_ms(uint64_t value) { write_time_ms_ = value; _has_field_.set(5); }

  bool has_discard_sectors() const { return _has_field_[6]; }
  uint64_t discard_sectors() const { return discard_sectors_; }
  void set_discard_sectors(uint64_t value) { discard_sectors_ = value; _has_field_.set(6); }

  bool has_discard_time_ms() const { return _has_field_[7]; }
  uint64_t discard_time_ms() const { return discard_time_ms_; }
  void set_discard_time_ms(uint64_t value) { discard_time_ms_ = value; _has_field_.set(7); }

  bool has_flush_count() const { return _has_field_[8]; }
  uint64_t flush_count() const { return flush_count_; }
  void set_flush_count(uint64_t value) { flush_count_ = value; _has_field_.set(8); }

  bool has_flush_time_ms() const { return _has_field_[9]; }
  uint64_t flush_time_ms() const { return flush_time_ms_; }
  void set_flush_time_ms(uint64_t value) { flush_time_ms_ = value; _has_field_.set(9); }

 private:
  std::string device_name_{};
  uint64_t read_sectors_{};
  uint64_t read_time_ms_{};
  uint64_t write_sectors_{};
  uint64_t write_time_ms_{};
  uint64_t discard_sectors_{};
  uint64_t discard_time_ms_{};
  uint64_t flush_count_{};
  uint64_t flush_time_ms_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<10> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT SysStats_BuddyInfo : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kNodeFieldNumber = 1,
    kZoneFieldNumber = 2,
    kOrderPagesFieldNumber = 3,
  };

  SysStats_BuddyInfo();
  ~SysStats_BuddyInfo() override;
  SysStats_BuddyInfo(SysStats_BuddyInfo&&) noexcept;
  SysStats_BuddyInfo& operator=(SysStats_BuddyInfo&&);
  SysStats_BuddyInfo(const SysStats_BuddyInfo&);
  SysStats_BuddyInfo& operator=(const SysStats_BuddyInfo&);
  bool operator==(const SysStats_BuddyInfo&) const;
  bool operator!=(const SysStats_BuddyInfo& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_node() const { return _has_field_[1]; }
  const std::string& node() const { return node_; }
  void set_node(const std::string& value) { node_ = value; _has_field_.set(1); }

  bool has_zone() const { return _has_field_[2]; }
  const std::string& zone() const { return zone_; }
  void set_zone(const std::string& value) { zone_ = value; _has_field_.set(2); }

  const std::vector<uint32_t>& order_pages() const { return order_pages_; }
  std::vector<uint32_t>* mutable_order_pages() { return &order_pages_; }
  int order_pages_size() const { return static_cast<int>(order_pages_.size()); }
  void clear_order_pages() { order_pages_.clear(); }
  void add_order_pages(uint32_t value) { order_pages_.emplace_back(value); }
  uint32_t* add_order_pages() { order_pages_.emplace_back(); return &order_pages_.back(); }

 private:
  std::string node_{};
  std::string zone_{};
  std::vector<uint32_t> order_pages_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT SysStats_DevfreqValue : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };

  SysStats_DevfreqValue();
  ~SysStats_DevfreqValue() override;
  SysStats_DevfreqValue(SysStats_DevfreqValue&&) noexcept;
  SysStats_DevfreqValue& operator=(SysStats_DevfreqValue&&);
  SysStats_DevfreqValue(const SysStats_DevfreqValue&);
  SysStats_DevfreqValue& operator=(const SysStats_DevfreqValue&);
  bool operator==(const SysStats_DevfreqValue&) const;
  bool operator!=(const SysStats_DevfreqValue& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_key() const { return _has_field_[1]; }
  const std::string& key() const { return key_; }
  void set_key(const std::string& value) { key_ = value; _has_field_.set(1); }

  bool has_value() const { return _has_field_[2]; }
  uint64_t value() const { return value_; }
  void set_value(uint64_t value) { value_ = value; _has_field_.set(2); }

 private:
  std::string key_{};
  uint64_t value_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT SysStats_InterruptCount : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kIrqFieldNumber = 1,
    kCountFieldNumber = 2,
  };

  SysStats_InterruptCount();
  ~SysStats_InterruptCount() override;
  SysStats_InterruptCount(SysStats_InterruptCount&&) noexcept;
  SysStats_InterruptCount& operator=(SysStats_InterruptCount&&);
  SysStats_InterruptCount(const SysStats_InterruptCount&);
  SysStats_InterruptCount& operator=(const SysStats_InterruptCount&);
  bool operator==(const SysStats_InterruptCount&) const;
  bool operator!=(const SysStats_InterruptCount& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_irq() const { return _has_field_[1]; }
  int32_t irq() const { return irq_; }
  void set_irq(int32_t value) { irq_ = value; _has_field_.set(1); }

  bool has_count() const { return _has_field_[2]; }
  uint64_t count() const { return count_; }
  void set_count(uint64_t value) { count_ = value; _has_field_.set(2); }

 private:
  int32_t irq_{};
  uint64_t count_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT SysStats_CpuTimes : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCpuIdFieldNumber = 1,
    kUserNsFieldNumber = 2,
    kUserNiceNsFieldNumber = 3,
    kSystemModeNsFieldNumber = 4,
    kIdleNsFieldNumber = 5,
    kIoWaitNsFieldNumber = 6,
    kIrqNsFieldNumber = 7,
    kSoftirqNsFieldNumber = 8,
  };

  SysStats_CpuTimes();
  ~SysStats_CpuTimes() override;
  SysStats_CpuTimes(SysStats_CpuTimes&&) noexcept;
  SysStats_CpuTimes& operator=(SysStats_CpuTimes&&);
  SysStats_CpuTimes(const SysStats_CpuTimes&);
  SysStats_CpuTimes& operator=(const SysStats_CpuTimes&);
  bool operator==(const SysStats_CpuTimes&) const;
  bool operator!=(const SysStats_CpuTimes& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_cpu_id() const { return _has_field_[1]; }
  uint32_t cpu_id() const { return cpu_id_; }
  void set_cpu_id(uint32_t value) { cpu_id_ = value; _has_field_.set(1); }

  bool has_user_ns() const { return _has_field_[2]; }
  uint64_t user_ns() const { return user_ns_; }
  void set_user_ns(uint64_t value) { user_ns_ = value; _has_field_.set(2); }

  bool has_user_nice_ns() const { return _has_field_[3]; }
  uint64_t user_nice_ns() const { return user_nice_ns_; }
  void set_user_nice_ns(uint64_t value) { user_nice_ns_ = value; _has_field_.set(3); }

  bool has_system_mode_ns() const { return _has_field_[4]; }
  uint64_t system_mode_ns() const { return system_mode_ns_; }
  void set_system_mode_ns(uint64_t value) { system_mode_ns_ = value; _has_field_.set(4); }

  bool has_idle_ns() const { return _has_field_[5]; }
  uint64_t idle_ns() const { return idle_ns_; }
  void set_idle_ns(uint64_t value) { idle_ns_ = value; _has_field_.set(5); }

  bool has_io_wait_ns() const { return _has_field_[6]; }
  uint64_t io_wait_ns() const { return io_wait_ns_; }
  void set_io_wait_ns(uint64_t value) { io_wait_ns_ = value; _has_field_.set(6); }

  bool has_irq_ns() const { return _has_field_[7]; }
  uint64_t irq_ns() const { return irq_ns_; }
  void set_irq_ns(uint64_t value) { irq_ns_ = value; _has_field_.set(7); }

  bool has_softirq_ns() const { return _has_field_[8]; }
  uint64_t softirq_ns() const { return softirq_ns_; }
  void set_softirq_ns(uint64_t value) { softirq_ns_ = value; _has_field_.set(8); }

 private:
  uint32_t cpu_id_{};
  uint64_t user_ns_{};
  uint64_t user_nice_ns_{};
  uint64_t system_mode_ns_{};
  uint64_t idle_ns_{};
  uint64_t io_wait_ns_{};
  uint64_t irq_ns_{};
  uint64_t softirq_ns_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<9> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT SysStats_VmstatValue : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };

  SysStats_VmstatValue();
  ~SysStats_VmstatValue() override;
  SysStats_VmstatValue(SysStats_VmstatValue&&) noexcept;
  SysStats_VmstatValue& operator=(SysStats_VmstatValue&&);
  SysStats_VmstatValue(const SysStats_VmstatValue&);
  SysStats_VmstatValue& operator=(const SysStats_VmstatValue&);
  bool operator==(const SysStats_VmstatValue&) const;
  bool operator!=(const SysStats_VmstatValue& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_key() const { return _has_field_[1]; }
  VmstatCounters key() const { return key_; }
  void set_key(VmstatCounters value) { key_ = value; _has_field_.set(1); }

  bool has_value() const { return _has_field_[2]; }
  uint64_t value() const { return value_; }
  void set_value(uint64_t value) { value_ = value; _has_field_.set(2); }

 private:
  VmstatCounters key_{};
  uint64_t value_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT SysStats_MeminfoValue : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };

  SysStats_MeminfoValue();
  ~SysStats_MeminfoValue() override;
  SysStats_MeminfoValue(SysStats_MeminfoValue&&) noexcept;
  SysStats_MeminfoValue& operator=(SysStats_MeminfoValue&&);
  SysStats_MeminfoValue(const SysStats_MeminfoValue&);
  SysStats_MeminfoValue& operator=(const SysStats_MeminfoValue&);
  bool operator==(const SysStats_MeminfoValue&) const;
  bool operator!=(const SysStats_MeminfoValue& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_key() const { return _has_field_[1]; }
  MeminfoCounters key() const { return key_; }
  void set_key(MeminfoCounters value) { key_ = value; _has_field_.set(1); }

  bool has_value() const { return _has_field_[2]; }
  uint64_t value() const { return value_; }
  void set_value(uint64_t value) { value_ = value; _has_field_.set(2); }

 private:
  MeminfoCounters key_{};
  uint64_t value_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_SYS_STATS_SYS_STATS_PROTO_CPP_H_
