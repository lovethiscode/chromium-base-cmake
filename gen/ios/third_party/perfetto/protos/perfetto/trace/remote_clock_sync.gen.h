// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_REMOTE_CLOCK_SYNC_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_REMOTE_CLOCK_SYNC_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class RemoteClockSync;
class RemoteClockSync_SyncedClocks;
class ClockSnapshot;
class ClockSnapshot_Clock;
enum BuiltinClock : int;
enum ClockSnapshot_Clock_BuiltinClocks : int;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {

class PERFETTO_EXPORT_COMPONENT RemoteClockSync : public ::protozero::CppMessageObj {
 public:
  using SyncedClocks = RemoteClockSync_SyncedClocks;
  enum FieldNumbers {
    kSyncedClocksFieldNumber = 1,
  };

  RemoteClockSync();
  ~RemoteClockSync() override;
  RemoteClockSync(RemoteClockSync&&) noexcept;
  RemoteClockSync& operator=(RemoteClockSync&&);
  RemoteClockSync(const RemoteClockSync&);
  RemoteClockSync& operator=(const RemoteClockSync&);
  bool operator==(const RemoteClockSync&) const;
  bool operator!=(const RemoteClockSync& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  const std::vector<RemoteClockSync_SyncedClocks>& synced_clocks() const { return synced_clocks_; }
  std::vector<RemoteClockSync_SyncedClocks>* mutable_synced_clocks() { return &synced_clocks_; }
  int synced_clocks_size() const;
  void clear_synced_clocks();
  RemoteClockSync_SyncedClocks* add_synced_clocks();

 private:
  std::vector<RemoteClockSync_SyncedClocks> synced_clocks_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT RemoteClockSync_SyncedClocks : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kClientClocksFieldNumber = 2,
    kHostClocksFieldNumber = 3,
  };

  RemoteClockSync_SyncedClocks();
  ~RemoteClockSync_SyncedClocks() override;
  RemoteClockSync_SyncedClocks(RemoteClockSync_SyncedClocks&&) noexcept;
  RemoteClockSync_SyncedClocks& operator=(RemoteClockSync_SyncedClocks&&);
  RemoteClockSync_SyncedClocks(const RemoteClockSync_SyncedClocks&);
  RemoteClockSync_SyncedClocks& operator=(const RemoteClockSync_SyncedClocks&);
  bool operator==(const RemoteClockSync_SyncedClocks&) const;
  bool operator!=(const RemoteClockSync_SyncedClocks& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_client_clocks() const { return _has_field_[2]; }
  const ClockSnapshot& client_clocks() const { return *client_clocks_; }
  ClockSnapshot* mutable_client_clocks() { _has_field_.set(2); return client_clocks_.get(); }

  bool has_host_clocks() const { return _has_field_[3]; }
  const ClockSnapshot& host_clocks() const { return *host_clocks_; }
  ClockSnapshot* mutable_host_clocks() { _has_field_.set(3); return host_clocks_.get(); }

 private:
  ::protozero::CopyablePtr<ClockSnapshot> client_clocks_;
  ::protozero::CopyablePtr<ClockSnapshot> host_clocks_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_REMOTE_CLOCK_SYNC_PROTO_CPP_H_
