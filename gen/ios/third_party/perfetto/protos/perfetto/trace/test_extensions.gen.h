// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TEST_EXTENSIONS_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TEST_EXTENSIONS_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class TestExtensionChild;
class DebugAnnotation;
class DebugAnnotation_NestedValue;
class TestExtension;
enum DebugAnnotation_NestedValue_NestedType : int;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {

class PERFETTO_EXPORT_COMPONENT TestExtensionChild : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kChildFieldForTestingFieldNumber = 1,
    kDebugAnnotationsFieldNumber = 99,
  };

  TestExtensionChild();
  ~TestExtensionChild() override;
  TestExtensionChild(TestExtensionChild&&) noexcept;
  TestExtensionChild& operator=(TestExtensionChild&&);
  TestExtensionChild(const TestExtensionChild&);
  TestExtensionChild& operator=(const TestExtensionChild&);
  bool operator==(const TestExtensionChild&) const;
  bool operator!=(const TestExtensionChild& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_child_field_for_testing() const { return _has_field_[1]; }
  const std::string& child_field_for_testing() const { return child_field_for_testing_; }
  void set_child_field_for_testing(const std::string& value) { child_field_for_testing_ = value; _has_field_.set(1); }

  const std::vector<DebugAnnotation>& debug_annotations() const { return debug_annotations_; }
  std::vector<DebugAnnotation>* mutable_debug_annotations() { return &debug_annotations_; }
  int debug_annotations_size() const;
  void clear_debug_annotations();
  DebugAnnotation* add_debug_annotations();

 private:
  std::string child_field_for_testing_{};
  std::vector<DebugAnnotation> debug_annotations_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<100> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT TestExtension : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
  };

  TestExtension();
  ~TestExtension() override;
  TestExtension(TestExtension&&) noexcept;
  TestExtension& operator=(TestExtension&&);
  TestExtension(const TestExtension&);
  TestExtension& operator=(const TestExtension&);
  bool operator==(const TestExtension&) const;
  bool operator!=(const TestExtension& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

 private:

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TEST_EXTENSIONS_PROTO_CPP_H_
