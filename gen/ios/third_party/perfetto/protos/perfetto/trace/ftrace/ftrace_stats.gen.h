// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_FTRACE_STATS_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_FTRACE_STATS_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class FtraceStats;
class FtraceCpuStats;
enum FtraceParseStatus : int;
enum FtraceStats_Phase : int;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {
enum FtraceParseStatus : int {
  FTRACE_STATUS_UNSPECIFIED = 0,
  FTRACE_STATUS_OK = 1,
  FTRACE_STATUS_UNEXPECTED_READ_ERROR = 2,
  FTRACE_STATUS_PARTIAL_PAGE_READ = 3,
  FTRACE_STATUS_ABI_INVALID_PAGE_HEADER = 4,
  FTRACE_STATUS_ABI_SHORT_EVENT_HEADER = 5,
  FTRACE_STATUS_ABI_NULL_PADDING = 6,
  FTRACE_STATUS_ABI_SHORT_PADDING_LENGTH = 7,
  FTRACE_STATUS_ABI_INVALID_PADDING_LENGTH = 8,
  FTRACE_STATUS_ABI_SHORT_TIME_EXTEND = 9,
  FTRACE_STATUS_ABI_SHORT_TIME_STAMP = 10,
  FTRACE_STATUS_ABI_SHORT_DATA_LENGTH = 11,
  FTRACE_STATUS_ABI_ZERO_DATA_LENGTH = 12,
  FTRACE_STATUS_ABI_INVALID_DATA_LENGTH = 13,
  FTRACE_STATUS_ABI_SHORT_EVENT_ID = 14,
  FTRACE_STATUS_ABI_END_OVERFLOW = 15,
  FTRACE_STATUS_SHORT_COMPACT_EVENT = 16,
  FTRACE_STATUS_INVALID_EVENT = 17,
};
enum FtraceStats_Phase : int {
  FtraceStats_Phase_UNSPECIFIED = 0,
  FtraceStats_Phase_START_OF_TRACE = 1,
  FtraceStats_Phase_END_OF_TRACE = 2,
};

class PERFETTO_EXPORT_COMPONENT FtraceStats : public ::protozero::CppMessageObj {
 public:
  using Phase = FtraceStats_Phase;
  static constexpr auto UNSPECIFIED = FtraceStats_Phase_UNSPECIFIED;
  static constexpr auto START_OF_TRACE = FtraceStats_Phase_START_OF_TRACE;
  static constexpr auto END_OF_TRACE = FtraceStats_Phase_END_OF_TRACE;
  static constexpr auto Phase_MIN = FtraceStats_Phase_UNSPECIFIED;
  static constexpr auto Phase_MAX = FtraceStats_Phase_END_OF_TRACE;
  enum FieldNumbers {
    kPhaseFieldNumber = 1,
    kCpuStatsFieldNumber = 2,
    kKernelSymbolsParsedFieldNumber = 3,
    kKernelSymbolsMemKbFieldNumber = 4,
    kAtraceErrorsFieldNumber = 5,
    kUnknownFtraceEventsFieldNumber = 6,
    kFailedFtraceEventsFieldNumber = 7,
    kPreserveFtraceBufferFieldNumber = 8,
    kFtraceParseErrorsFieldNumber = 9,
  };

  FtraceStats();
  ~FtraceStats() override;
  FtraceStats(FtraceStats&&) noexcept;
  FtraceStats& operator=(FtraceStats&&);
  FtraceStats(const FtraceStats&);
  FtraceStats& operator=(const FtraceStats&);
  bool operator==(const FtraceStats&) const;
  bool operator!=(const FtraceStats& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_phase() const { return _has_field_[1]; }
  FtraceStats_Phase phase() const { return phase_; }
  void set_phase(FtraceStats_Phase value) { phase_ = value; _has_field_.set(1); }

  const std::vector<FtraceCpuStats>& cpu_stats() const { return cpu_stats_; }
  std::vector<FtraceCpuStats>* mutable_cpu_stats() { return &cpu_stats_; }
  int cpu_stats_size() const;
  void clear_cpu_stats();
  FtraceCpuStats* add_cpu_stats();

  bool has_kernel_symbols_parsed() const { return _has_field_[3]; }
  uint32_t kernel_symbols_parsed() const { return kernel_symbols_parsed_; }
  void set_kernel_symbols_parsed(uint32_t value) { kernel_symbols_parsed_ = value; _has_field_.set(3); }

  bool has_kernel_symbols_mem_kb() const { return _has_field_[4]; }
  uint32_t kernel_symbols_mem_kb() const { return kernel_symbols_mem_kb_; }
  void set_kernel_symbols_mem_kb(uint32_t value) { kernel_symbols_mem_kb_ = value; _has_field_.set(4); }

  bool has_atrace_errors() const { return _has_field_[5]; }
  const std::string& atrace_errors() const { return atrace_errors_; }
  void set_atrace_errors(const std::string& value) { atrace_errors_ = value; _has_field_.set(5); }

  const std::vector<std::string>& unknown_ftrace_events() const { return unknown_ftrace_events_; }
  std::vector<std::string>* mutable_unknown_ftrace_events() { return &unknown_ftrace_events_; }
  int unknown_ftrace_events_size() const { return static_cast<int>(unknown_ftrace_events_.size()); }
  void clear_unknown_ftrace_events() { unknown_ftrace_events_.clear(); }
  void add_unknown_ftrace_events(std::string value) { unknown_ftrace_events_.emplace_back(value); }
  std::string* add_unknown_ftrace_events() { unknown_ftrace_events_.emplace_back(); return &unknown_ftrace_events_.back(); }

  const std::vector<std::string>& failed_ftrace_events() const { return failed_ftrace_events_; }
  std::vector<std::string>* mutable_failed_ftrace_events() { return &failed_ftrace_events_; }
  int failed_ftrace_events_size() const { return static_cast<int>(failed_ftrace_events_.size()); }
  void clear_failed_ftrace_events() { failed_ftrace_events_.clear(); }
  void add_failed_ftrace_events(std::string value) { failed_ftrace_events_.emplace_back(value); }
  std::string* add_failed_ftrace_events() { failed_ftrace_events_.emplace_back(); return &failed_ftrace_events_.back(); }

  bool has_preserve_ftrace_buffer() const { return _has_field_[8]; }
  bool preserve_ftrace_buffer() const { return preserve_ftrace_buffer_; }
  void set_preserve_ftrace_buffer(bool value) { preserve_ftrace_buffer_ = value; _has_field_.set(8); }

  const std::vector<FtraceParseStatus>& ftrace_parse_errors() const { return ftrace_parse_errors_; }
  std::vector<FtraceParseStatus>* mutable_ftrace_parse_errors() { return &ftrace_parse_errors_; }
  int ftrace_parse_errors_size() const { return static_cast<int>(ftrace_parse_errors_.size()); }
  void clear_ftrace_parse_errors() { ftrace_parse_errors_.clear(); }
  void add_ftrace_parse_errors(FtraceParseStatus value) { ftrace_parse_errors_.emplace_back(value); }
  FtraceParseStatus* add_ftrace_parse_errors() { ftrace_parse_errors_.emplace_back(); return &ftrace_parse_errors_.back(); }

 private:
  FtraceStats_Phase phase_{};
  std::vector<FtraceCpuStats> cpu_stats_;
  uint32_t kernel_symbols_parsed_{};
  uint32_t kernel_symbols_mem_kb_{};
  std::string atrace_errors_{};
  std::vector<std::string> unknown_ftrace_events_;
  std::vector<std::string> failed_ftrace_events_;
  bool preserve_ftrace_buffer_{};
  std::vector<FtraceParseStatus> ftrace_parse_errors_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<10> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT FtraceCpuStats : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCpuFieldNumber = 1,
    kEntriesFieldNumber = 2,
    kOverrunFieldNumber = 3,
    kCommitOverrunFieldNumber = 4,
    kBytesReadFieldNumber = 5,
    kOldestEventTsFieldNumber = 6,
    kNowTsFieldNumber = 7,
    kDroppedEventsFieldNumber = 8,
    kReadEventsFieldNumber = 9,
  };

  FtraceCpuStats();
  ~FtraceCpuStats() override;
  FtraceCpuStats(FtraceCpuStats&&) noexcept;
  FtraceCpuStats& operator=(FtraceCpuStats&&);
  FtraceCpuStats(const FtraceCpuStats&);
  FtraceCpuStats& operator=(const FtraceCpuStats&);
  bool operator==(const FtraceCpuStats&) const;
  bool operator!=(const FtraceCpuStats& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_cpu() const { return _has_field_[1]; }
  uint64_t cpu() const { return cpu_; }
  void set_cpu(uint64_t value) { cpu_ = value; _has_field_.set(1); }

  bool has_entries() const { return _has_field_[2]; }
  uint64_t entries() const { return entries_; }
  void set_entries(uint64_t value) { entries_ = value; _has_field_.set(2); }

  bool has_overrun() const { return _has_field_[3]; }
  uint64_t overrun() const { return overrun_; }
  void set_overrun(uint64_t value) { overrun_ = value; _has_field_.set(3); }

  bool has_commit_overrun() const { return _has_field_[4]; }
  uint64_t commit_overrun() const { return commit_overrun_; }
  void set_commit_overrun(uint64_t value) { commit_overrun_ = value; _has_field_.set(4); }

  bool has_bytes_read() const { return _has_field_[5]; }
  uint64_t bytes_read() const { return bytes_read_; }
  void set_bytes_read(uint64_t value) { bytes_read_ = value; _has_field_.set(5); }

  bool has_oldest_event_ts() const { return _has_field_[6]; }
  double oldest_event_ts() const { return oldest_event_ts_; }
  void set_oldest_event_ts(double value) { oldest_event_ts_ = value; _has_field_.set(6); }

  bool has_now_ts() const { return _has_field_[7]; }
  double now_ts() const { return now_ts_; }
  void set_now_ts(double value) { now_ts_ = value; _has_field_.set(7); }

  bool has_dropped_events() const { return _has_field_[8]; }
  uint64_t dropped_events() const { return dropped_events_; }
  void set_dropped_events(uint64_t value) { dropped_events_ = value; _has_field_.set(8); }

  bool has_read_events() const { return _has_field_[9]; }
  uint64_t read_events() const { return read_events_; }
  void set_read_events(uint64_t value) { read_events_ = value; _has_field_.set(9); }

 private:
  uint64_t cpu_{};
  uint64_t entries_{};
  uint64_t overrun_{};
  uint64_t commit_overrun_{};
  uint64_t bytes_read_{};
  double oldest_event_ts_{};
  double now_ts_{};
  uint64_t dropped_events_{};
  uint64_t read_events_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<10> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_FTRACE_STATS_PROTO_CPP_H_
