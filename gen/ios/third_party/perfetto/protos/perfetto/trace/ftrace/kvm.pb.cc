// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/trace/ftrace/kvm.proto

#include "protos/perfetto/trace/ftrace/kvm.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace perfetto {
namespace protos {
PROTOBUF_CONSTEXPR KvmAccessFaultFtraceEvent::KvmAccessFaultFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ipa_)*/uint64_t{0u}} {}
struct KvmAccessFaultFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmAccessFaultFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmAccessFaultFtraceEventDefaultTypeInternal() {}
  union {
    KvmAccessFaultFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmAccessFaultFtraceEventDefaultTypeInternal _KvmAccessFaultFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmAckIrqFtraceEvent::KvmAckIrqFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.irqchip_)*/0u
  , /*decltype(_impl_.pin_)*/0u} {}
struct KvmAckIrqFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmAckIrqFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmAckIrqFtraceEventDefaultTypeInternal() {}
  union {
    KvmAckIrqFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmAckIrqFtraceEventDefaultTypeInternal _KvmAckIrqFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmAgeHvaFtraceEvent::KvmAgeHvaFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.end_)*/uint64_t{0u}
  , /*decltype(_impl_.start_)*/uint64_t{0u}} {}
struct KvmAgeHvaFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmAgeHvaFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmAgeHvaFtraceEventDefaultTypeInternal() {}
  union {
    KvmAgeHvaFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmAgeHvaFtraceEventDefaultTypeInternal _KvmAgeHvaFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmAgePageFtraceEvent::KvmAgePageFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gfn_)*/uint64_t{0u}
  , /*decltype(_impl_.hva_)*/uint64_t{0u}
  , /*decltype(_impl_.level_)*/0u
  , /*decltype(_impl_.referenced_)*/0u} {}
struct KvmAgePageFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmAgePageFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmAgePageFtraceEventDefaultTypeInternal() {}
  union {
    KvmAgePageFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmAgePageFtraceEventDefaultTypeInternal _KvmAgePageFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmArmClearDebugFtraceEvent::KvmArmClearDebugFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.guest_debug_)*/0u} {}
struct KvmArmClearDebugFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmArmClearDebugFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmArmClearDebugFtraceEventDefaultTypeInternal() {}
  union {
    KvmArmClearDebugFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmArmClearDebugFtraceEventDefaultTypeInternal _KvmArmClearDebugFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmArmSetDreg32FtraceEvent::KvmArmSetDreg32FtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/0u} {}
struct KvmArmSetDreg32FtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmArmSetDreg32FtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmArmSetDreg32FtraceEventDefaultTypeInternal() {}
  union {
    KvmArmSetDreg32FtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmArmSetDreg32FtraceEventDefaultTypeInternal _KvmArmSetDreg32FtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmArmSetRegsetFtraceEvent::KvmArmSetRegsetFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.len_)*/0} {}
struct KvmArmSetRegsetFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmArmSetRegsetFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmArmSetRegsetFtraceEventDefaultTypeInternal() {}
  union {
    KvmArmSetRegsetFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmArmSetRegsetFtraceEventDefaultTypeInternal _KvmArmSetRegsetFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmArmSetupDebugFtraceEvent::KvmArmSetupDebugFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.vcpu_)*/uint64_t{0u}
  , /*decltype(_impl_.guest_debug_)*/0u} {}
struct KvmArmSetupDebugFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmArmSetupDebugFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmArmSetupDebugFtraceEventDefaultTypeInternal() {}
  union {
    KvmArmSetupDebugFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmArmSetupDebugFtraceEventDefaultTypeInternal _KvmArmSetupDebugFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmEntryFtraceEvent::KvmEntryFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.vcpu_pc_)*/uint64_t{0u}} {}
struct KvmEntryFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmEntryFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmEntryFtraceEventDefaultTypeInternal() {}
  union {
    KvmEntryFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmEntryFtraceEventDefaultTypeInternal _KvmEntryFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmExitFtraceEvent::KvmExitFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.esr_ec_)*/0u
  , /*decltype(_impl_.ret_)*/0
  , /*decltype(_impl_.vcpu_pc_)*/uint64_t{0u}} {}
struct KvmExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmExitFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmExitFtraceEventDefaultTypeInternal() {}
  union {
    KvmExitFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmExitFtraceEventDefaultTypeInternal _KvmExitFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmFpuFtraceEvent::KvmFpuFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.load_)*/0u} {}
struct KvmFpuFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmFpuFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmFpuFtraceEventDefaultTypeInternal() {}
  union {
    KvmFpuFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmFpuFtraceEventDefaultTypeInternal _KvmFpuFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmGetTimerMapFtraceEvent::KvmGetTimerMapFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.direct_ptimer_)*/0
  , /*decltype(_impl_.direct_vtimer_)*/0
  , /*decltype(_impl_.vcpu_id_)*/uint64_t{0u}
  , /*decltype(_impl_.emul_ptimer_)*/0} {}
struct KvmGetTimerMapFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmGetTimerMapFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmGetTimerMapFtraceEventDefaultTypeInternal() {}
  union {
    KvmGetTimerMapFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmGetTimerMapFtraceEventDefaultTypeInternal _KvmGetTimerMapFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmGuestFaultFtraceEvent::KvmGuestFaultFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hsr_)*/uint64_t{0u}
  , /*decltype(_impl_.hxfar_)*/uint64_t{0u}
  , /*decltype(_impl_.ipa_)*/uint64_t{0u}
  , /*decltype(_impl_.vcpu_pc_)*/uint64_t{0u}} {}
struct KvmGuestFaultFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmGuestFaultFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmGuestFaultFtraceEventDefaultTypeInternal() {}
  union {
    KvmGuestFaultFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmGuestFaultFtraceEventDefaultTypeInternal _KvmGuestFaultFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmHandleSysRegFtraceEvent::KvmHandleSysRegFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hsr_)*/uint64_t{0u}} {}
struct KvmHandleSysRegFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmHandleSysRegFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmHandleSysRegFtraceEventDefaultTypeInternal() {}
  union {
    KvmHandleSysRegFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmHandleSysRegFtraceEventDefaultTypeInternal _KvmHandleSysRegFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmHvcArm64FtraceEvent::KvmHvcArm64FtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.imm_)*/uint64_t{0u}
  , /*decltype(_impl_.r0_)*/uint64_t{0u}
  , /*decltype(_impl_.vcpu_pc_)*/uint64_t{0u}} {}
struct KvmHvcArm64FtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmHvcArm64FtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmHvcArm64FtraceEventDefaultTypeInternal() {}
  union {
    KvmHvcArm64FtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmHvcArm64FtraceEventDefaultTypeInternal _KvmHvcArm64FtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmIrqLineFtraceEvent::KvmIrqLineFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.irq_num_)*/0
  , /*decltype(_impl_.level_)*/0
  , /*decltype(_impl_.type_)*/0u
  , /*decltype(_impl_.vcpu_idx_)*/0} {}
struct KvmIrqLineFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmIrqLineFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmIrqLineFtraceEventDefaultTypeInternal() {}
  union {
    KvmIrqLineFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmIrqLineFtraceEventDefaultTypeInternal _KvmIrqLineFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmMmioFtraceEvent::KvmMmioFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gpa_)*/uint64_t{0u}
  , /*decltype(_impl_.len_)*/0u
  , /*decltype(_impl_.type_)*/0u
  , /*decltype(_impl_.val_)*/uint64_t{0u}} {}
struct KvmMmioFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmMmioFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmMmioFtraceEventDefaultTypeInternal() {}
  union {
    KvmMmioFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmMmioFtraceEventDefaultTypeInternal _KvmMmioFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmMmioEmulateFtraceEvent::KvmMmioEmulateFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cpsr_)*/uint64_t{0u}
  , /*decltype(_impl_.instr_)*/uint64_t{0u}
  , /*decltype(_impl_.vcpu_pc_)*/uint64_t{0u}} {}
struct KvmMmioEmulateFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmMmioEmulateFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmMmioEmulateFtraceEventDefaultTypeInternal() {}
  union {
    KvmMmioEmulateFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmMmioEmulateFtraceEventDefaultTypeInternal _KvmMmioEmulateFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmSetGuestDebugFtraceEvent::KvmSetGuestDebugFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.vcpu_)*/uint64_t{0u}
  , /*decltype(_impl_.guest_debug_)*/0u} {}
struct KvmSetGuestDebugFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmSetGuestDebugFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmSetGuestDebugFtraceEventDefaultTypeInternal() {}
  union {
    KvmSetGuestDebugFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmSetGuestDebugFtraceEventDefaultTypeInternal _KvmSetGuestDebugFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmSetIrqFtraceEvent::KvmSetIrqFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gsi_)*/0u
  , /*decltype(_impl_.irq_source_id_)*/0
  , /*decltype(_impl_.level_)*/0} {}
struct KvmSetIrqFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmSetIrqFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmSetIrqFtraceEventDefaultTypeInternal() {}
  union {
    KvmSetIrqFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmSetIrqFtraceEventDefaultTypeInternal _KvmSetIrqFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmSetSpteHvaFtraceEvent::KvmSetSpteHvaFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hva_)*/uint64_t{0u}} {}
struct KvmSetSpteHvaFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmSetSpteHvaFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmSetSpteHvaFtraceEventDefaultTypeInternal() {}
  union {
    KvmSetSpteHvaFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmSetSpteHvaFtraceEventDefaultTypeInternal _KvmSetSpteHvaFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmSetWayFlushFtraceEvent::KvmSetWayFlushFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.vcpu_pc_)*/uint64_t{0u}
  , /*decltype(_impl_.cache_)*/0u} {}
struct KvmSetWayFlushFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmSetWayFlushFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmSetWayFlushFtraceEventDefaultTypeInternal() {}
  union {
    KvmSetWayFlushFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmSetWayFlushFtraceEventDefaultTypeInternal _KvmSetWayFlushFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmSysAccessFtraceEvent::KvmSysAccessFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.crm_)*/0u
  , /*decltype(_impl_.crn_)*/0u
  , /*decltype(_impl_.op0_)*/0u
  , /*decltype(_impl_.op1_)*/0u
  , /*decltype(_impl_.op2_)*/0u
  , /*decltype(_impl_.is_write_)*/0u
  , /*decltype(_impl_.vcpu_pc_)*/uint64_t{0u}} {}
struct KvmSysAccessFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmSysAccessFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmSysAccessFtraceEventDefaultTypeInternal() {}
  union {
    KvmSysAccessFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmSysAccessFtraceEventDefaultTypeInternal _KvmSysAccessFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmTestAgeHvaFtraceEvent::KvmTestAgeHvaFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hva_)*/uint64_t{0u}} {}
struct KvmTestAgeHvaFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmTestAgeHvaFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmTestAgeHvaFtraceEventDefaultTypeInternal() {}
  union {
    KvmTestAgeHvaFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmTestAgeHvaFtraceEventDefaultTypeInternal _KvmTestAgeHvaFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmTimerEmulateFtraceEvent::KvmTimerEmulateFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.should_fire_)*/0u
  , /*decltype(_impl_.timer_idx_)*/0} {}
struct KvmTimerEmulateFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmTimerEmulateFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmTimerEmulateFtraceEventDefaultTypeInternal() {}
  union {
    KvmTimerEmulateFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmTimerEmulateFtraceEventDefaultTypeInternal _KvmTimerEmulateFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmTimerHrtimerExpireFtraceEvent::KvmTimerHrtimerExpireFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.timer_idx_)*/0} {}
struct KvmTimerHrtimerExpireFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmTimerHrtimerExpireFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmTimerHrtimerExpireFtraceEventDefaultTypeInternal() {}
  union {
    KvmTimerHrtimerExpireFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmTimerHrtimerExpireFtraceEventDefaultTypeInternal _KvmTimerHrtimerExpireFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmTimerRestoreStateFtraceEvent::KvmTimerRestoreStateFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ctl_)*/uint64_t{0u}
  , /*decltype(_impl_.cval_)*/uint64_t{0u}
  , /*decltype(_impl_.timer_idx_)*/0} {}
struct KvmTimerRestoreStateFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmTimerRestoreStateFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmTimerRestoreStateFtraceEventDefaultTypeInternal() {}
  union {
    KvmTimerRestoreStateFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmTimerRestoreStateFtraceEventDefaultTypeInternal _KvmTimerRestoreStateFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmTimerSaveStateFtraceEvent::KvmTimerSaveStateFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ctl_)*/uint64_t{0u}
  , /*decltype(_impl_.cval_)*/uint64_t{0u}
  , /*decltype(_impl_.timer_idx_)*/0} {}
struct KvmTimerSaveStateFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmTimerSaveStateFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmTimerSaveStateFtraceEventDefaultTypeInternal() {}
  union {
    KvmTimerSaveStateFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmTimerSaveStateFtraceEventDefaultTypeInternal _KvmTimerSaveStateFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmTimerUpdateIrqFtraceEvent::KvmTimerUpdateIrqFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.irq_)*/0u
  , /*decltype(_impl_.level_)*/0
  , /*decltype(_impl_.vcpu_id_)*/uint64_t{0u}} {}
struct KvmTimerUpdateIrqFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmTimerUpdateIrqFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmTimerUpdateIrqFtraceEventDefaultTypeInternal() {}
  union {
    KvmTimerUpdateIrqFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmTimerUpdateIrqFtraceEventDefaultTypeInternal _KvmTimerUpdateIrqFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmToggleCacheFtraceEvent::KvmToggleCacheFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.vcpu_pc_)*/uint64_t{0u}
  , /*decltype(_impl_.now_)*/0u
  , /*decltype(_impl_.was_)*/0u} {}
struct KvmToggleCacheFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmToggleCacheFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmToggleCacheFtraceEventDefaultTypeInternal() {}
  union {
    KvmToggleCacheFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmToggleCacheFtraceEventDefaultTypeInternal _KvmToggleCacheFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmUnmapHvaRangeFtraceEvent::KvmUnmapHvaRangeFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.end_)*/uint64_t{0u}
  , /*decltype(_impl_.start_)*/uint64_t{0u}} {}
struct KvmUnmapHvaRangeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmUnmapHvaRangeFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmUnmapHvaRangeFtraceEventDefaultTypeInternal() {}
  union {
    KvmUnmapHvaRangeFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmUnmapHvaRangeFtraceEventDefaultTypeInternal _KvmUnmapHvaRangeFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmUserspaceExitFtraceEvent::KvmUserspaceExitFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.reason_)*/0u} {}
struct KvmUserspaceExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmUserspaceExitFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmUserspaceExitFtraceEventDefaultTypeInternal() {}
  union {
    KvmUserspaceExitFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmUserspaceExitFtraceEventDefaultTypeInternal _KvmUserspaceExitFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmVcpuWakeupFtraceEvent::KvmVcpuWakeupFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ns_)*/uint64_t{0u}
  , /*decltype(_impl_.valid_)*/0u
  , /*decltype(_impl_.waited_)*/0u} {}
struct KvmVcpuWakeupFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmVcpuWakeupFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmVcpuWakeupFtraceEventDefaultTypeInternal() {}
  union {
    KvmVcpuWakeupFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmVcpuWakeupFtraceEventDefaultTypeInternal _KvmVcpuWakeupFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KvmWfxArm64FtraceEvent::KvmWfxArm64FtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.vcpu_pc_)*/uint64_t{0u}
  , /*decltype(_impl_.is_wfe_)*/0u} {}
struct KvmWfxArm64FtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KvmWfxArm64FtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KvmWfxArm64FtraceEventDefaultTypeInternal() {}
  union {
    KvmWfxArm64FtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KvmWfxArm64FtraceEventDefaultTypeInternal _KvmWfxArm64FtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR TrapRegFtraceEvent::TrapRegFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.fn_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.is_write_)*/0u
  , /*decltype(_impl_.reg_)*/0
  , /*decltype(_impl_.write_value_)*/uint64_t{0u}} {}
struct TrapRegFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TrapRegFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TrapRegFtraceEventDefaultTypeInternal() {}
  union {
    TrapRegFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TrapRegFtraceEventDefaultTypeInternal _TrapRegFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR VgicUpdateIrqPendingFtraceEvent::VgicUpdateIrqPendingFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.irq_)*/0u
  , /*decltype(_impl_.level_)*/0u
  , /*decltype(_impl_.vcpu_id_)*/uint64_t{0u}} {}
struct VgicUpdateIrqPendingFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VgicUpdateIrqPendingFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VgicUpdateIrqPendingFtraceEventDefaultTypeInternal() {}
  union {
    VgicUpdateIrqPendingFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VgicUpdateIrqPendingFtraceEventDefaultTypeInternal _VgicUpdateIrqPendingFtraceEvent_default_instance_;
}  // namespace protos
}  // namespace perfetto
namespace perfetto {
namespace protos {

// ===================================================================

class KvmAccessFaultFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmAccessFaultFtraceEvent>()._impl_._has_bits_);
  static void set_has_ipa(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmAccessFaultFtraceEvent::KvmAccessFaultFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmAccessFaultFtraceEvent)
}
KvmAccessFaultFtraceEvent::KvmAccessFaultFtraceEvent(const KvmAccessFaultFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KvmAccessFaultFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ipa_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.ipa_ = from._impl_.ipa_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmAccessFaultFtraceEvent)
}

inline void KvmAccessFaultFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ipa_){uint64_t{0u}}
  };
}

KvmAccessFaultFtraceEvent::~KvmAccessFaultFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmAccessFaultFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmAccessFaultFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmAccessFaultFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmAccessFaultFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmAccessFaultFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ipa_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmAccessFaultFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 ipa = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ipa(&has_bits);
          _impl_.ipa_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmAccessFaultFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmAccessFaultFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 ipa = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_ipa(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmAccessFaultFtraceEvent)
  return target;
}

size_t KvmAccessFaultFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmAccessFaultFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 ipa = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ipa());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmAccessFaultFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmAccessFaultFtraceEvent*>(
      &from));
}

void KvmAccessFaultFtraceEvent::MergeFrom(const KvmAccessFaultFtraceEvent& from) {
  KvmAccessFaultFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmAccessFaultFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_ipa()) {
    _this->_internal_set_ipa(from._internal_ipa());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmAccessFaultFtraceEvent::CopyFrom(const KvmAccessFaultFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmAccessFaultFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmAccessFaultFtraceEvent::IsInitialized() const {
  return true;
}

void KvmAccessFaultFtraceEvent::InternalSwap(KvmAccessFaultFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.ipa_, other->_impl_.ipa_);
}

std::string KvmAccessFaultFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmAccessFaultFtraceEvent";
}


// ===================================================================

class KvmAckIrqFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmAckIrqFtraceEvent>()._impl_._has_bits_);
  static void set_has_irqchip(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pin(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

KvmAckIrqFtraceEvent::KvmAckIrqFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmAckIrqFtraceEvent)
}
KvmAckIrqFtraceEvent::KvmAckIrqFtraceEvent(const KvmAckIrqFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KvmAckIrqFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.irqchip_){}
    , decltype(_impl_.pin_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.irqchip_, &from._impl_.irqchip_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.pin_) -
    reinterpret_cast<char*>(&_impl_.irqchip_)) + sizeof(_impl_.pin_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmAckIrqFtraceEvent)
}

inline void KvmAckIrqFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.irqchip_){0u}
    , decltype(_impl_.pin_){0u}
  };
}

KvmAckIrqFtraceEvent::~KvmAckIrqFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmAckIrqFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmAckIrqFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmAckIrqFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmAckIrqFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmAckIrqFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.irqchip_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.pin_) -
        reinterpret_cast<char*>(&_impl_.irqchip_)) + sizeof(_impl_.pin_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmAckIrqFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 irqchip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_irqchip(&has_bits);
          _impl_.irqchip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 pin = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_pin(&has_bits);
          _impl_.pin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmAckIrqFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmAckIrqFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 irqchip = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_irqchip(), target);
  }

  // optional uint32 pin = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_pin(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmAckIrqFtraceEvent)
  return target;
}

size_t KvmAckIrqFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmAckIrqFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 irqchip = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_irqchip());
    }

    // optional uint32 pin = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_pin());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmAckIrqFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmAckIrqFtraceEvent*>(
      &from));
}

void KvmAckIrqFtraceEvent::MergeFrom(const KvmAckIrqFtraceEvent& from) {
  KvmAckIrqFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmAckIrqFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.irqchip_ = from._impl_.irqchip_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pin_ = from._impl_.pin_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmAckIrqFtraceEvent::CopyFrom(const KvmAckIrqFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmAckIrqFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmAckIrqFtraceEvent::IsInitialized() const {
  return true;
}

void KvmAckIrqFtraceEvent::InternalSwap(KvmAckIrqFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmAckIrqFtraceEvent, _impl_.pin_)
      + sizeof(KvmAckIrqFtraceEvent::_impl_.pin_)
      - PROTOBUF_FIELD_OFFSET(KvmAckIrqFtraceEvent, _impl_.irqchip_)>(
          reinterpret_cast<char*>(&_impl_.irqchip_),
          reinterpret_cast<char*>(&other->_impl_.irqchip_));
}

std::string KvmAckIrqFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmAckIrqFtraceEvent";
}


// ===================================================================

class KvmAgeHvaFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmAgeHvaFtraceEvent>()._impl_._has_bits_);
  static void set_has_end(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

KvmAgeHvaFtraceEvent::KvmAgeHvaFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmAgeHvaFtraceEvent)
}
KvmAgeHvaFtraceEvent::KvmAgeHvaFtraceEvent(const KvmAgeHvaFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KvmAgeHvaFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.end_){}
    , decltype(_impl_.start_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.end_, &from._impl_.end_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.start_) -
    reinterpret_cast<char*>(&_impl_.end_)) + sizeof(_impl_.start_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmAgeHvaFtraceEvent)
}

inline void KvmAgeHvaFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.end_){uint64_t{0u}}
    , decltype(_impl_.start_){uint64_t{0u}}
  };
}

KvmAgeHvaFtraceEvent::~KvmAgeHvaFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmAgeHvaFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmAgeHvaFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmAgeHvaFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmAgeHvaFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmAgeHvaFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.end_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.start_) -
        reinterpret_cast<char*>(&_impl_.end_)) + sizeof(_impl_.start_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmAgeHvaFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 end = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_end(&has_bits);
          _impl_.end_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 start = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_start(&has_bits);
          _impl_.start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmAgeHvaFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmAgeHvaFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 end = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_end(), target);
  }

  // optional uint64 start = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_start(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmAgeHvaFtraceEvent)
  return target;
}

size_t KvmAgeHvaFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmAgeHvaFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 end = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_end());
    }

    // optional uint64 start = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_start());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmAgeHvaFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmAgeHvaFtraceEvent*>(
      &from));
}

void KvmAgeHvaFtraceEvent::MergeFrom(const KvmAgeHvaFtraceEvent& from) {
  KvmAgeHvaFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmAgeHvaFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.end_ = from._impl_.end_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.start_ = from._impl_.start_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmAgeHvaFtraceEvent::CopyFrom(const KvmAgeHvaFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmAgeHvaFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmAgeHvaFtraceEvent::IsInitialized() const {
  return true;
}

void KvmAgeHvaFtraceEvent::InternalSwap(KvmAgeHvaFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmAgeHvaFtraceEvent, _impl_.start_)
      + sizeof(KvmAgeHvaFtraceEvent::_impl_.start_)
      - PROTOBUF_FIELD_OFFSET(KvmAgeHvaFtraceEvent, _impl_.end_)>(
          reinterpret_cast<char*>(&_impl_.end_),
          reinterpret_cast<char*>(&other->_impl_.end_));
}

std::string KvmAgeHvaFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmAgeHvaFtraceEvent";
}


// ===================================================================

class KvmAgePageFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmAgePageFtraceEvent>()._impl_._has_bits_);
  static void set_has_gfn(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_hva(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_level(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_referenced(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

KvmAgePageFtraceEvent::KvmAgePageFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmAgePageFtraceEvent)
}
KvmAgePageFtraceEvent::KvmAgePageFtraceEvent(const KvmAgePageFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KvmAgePageFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gfn_){}
    , decltype(_impl_.hva_){}
    , decltype(_impl_.level_){}
    , decltype(_impl_.referenced_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.gfn_, &from._impl_.gfn_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.referenced_) -
    reinterpret_cast<char*>(&_impl_.gfn_)) + sizeof(_impl_.referenced_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmAgePageFtraceEvent)
}

inline void KvmAgePageFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gfn_){uint64_t{0u}}
    , decltype(_impl_.hva_){uint64_t{0u}}
    , decltype(_impl_.level_){0u}
    , decltype(_impl_.referenced_){0u}
  };
}

KvmAgePageFtraceEvent::~KvmAgePageFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmAgePageFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmAgePageFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmAgePageFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmAgePageFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmAgePageFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.gfn_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.referenced_) -
        reinterpret_cast<char*>(&_impl_.gfn_)) + sizeof(_impl_.referenced_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmAgePageFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 gfn = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gfn(&has_bits);
          _impl_.gfn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 hva = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_hva(&has_bits);
          _impl_.hva_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 level = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_level(&has_bits);
          _impl_.level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 referenced = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_referenced(&has_bits);
          _impl_.referenced_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmAgePageFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmAgePageFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 gfn = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_gfn(), target);
  }

  // optional uint64 hva = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_hva(), target);
  }

  // optional uint32 level = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_level(), target);
  }

  // optional uint32 referenced = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_referenced(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmAgePageFtraceEvent)
  return target;
}

size_t KvmAgePageFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmAgePageFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 gfn = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_gfn());
    }

    // optional uint64 hva = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_hva());
    }

    // optional uint32 level = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_level());
    }

    // optional uint32 referenced = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_referenced());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmAgePageFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmAgePageFtraceEvent*>(
      &from));
}

void KvmAgePageFtraceEvent::MergeFrom(const KvmAgePageFtraceEvent& from) {
  KvmAgePageFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmAgePageFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.gfn_ = from._impl_.gfn_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.hva_ = from._impl_.hva_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.level_ = from._impl_.level_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.referenced_ = from._impl_.referenced_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmAgePageFtraceEvent::CopyFrom(const KvmAgePageFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmAgePageFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmAgePageFtraceEvent::IsInitialized() const {
  return true;
}

void KvmAgePageFtraceEvent::InternalSwap(KvmAgePageFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmAgePageFtraceEvent, _impl_.referenced_)
      + sizeof(KvmAgePageFtraceEvent::_impl_.referenced_)
      - PROTOBUF_FIELD_OFFSET(KvmAgePageFtraceEvent, _impl_.gfn_)>(
          reinterpret_cast<char*>(&_impl_.gfn_),
          reinterpret_cast<char*>(&other->_impl_.gfn_));
}

std::string KvmAgePageFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmAgePageFtraceEvent";
}


// ===================================================================

class KvmArmClearDebugFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmArmClearDebugFtraceEvent>()._impl_._has_bits_);
  static void set_has_guest_debug(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmArmClearDebugFtraceEvent::KvmArmClearDebugFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmArmClearDebugFtraceEvent)
}
KvmArmClearDebugFtraceEvent::KvmArmClearDebugFtraceEvent(const KvmArmClearDebugFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KvmArmClearDebugFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.guest_debug_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.guest_debug_ = from._impl_.guest_debug_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmArmClearDebugFtraceEvent)
}

inline void KvmArmClearDebugFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.guest_debug_){0u}
  };
}

KvmArmClearDebugFtraceEvent::~KvmArmClearDebugFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmArmClearDebugFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmArmClearDebugFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmArmClearDebugFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmArmClearDebugFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmArmClearDebugFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.guest_debug_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmArmClearDebugFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 guest_debug = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_guest_debug(&has_bits);
          _impl_.guest_debug_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmArmClearDebugFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmArmClearDebugFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 guest_debug = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_guest_debug(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmArmClearDebugFtraceEvent)
  return target;
}

size_t KvmArmClearDebugFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmArmClearDebugFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 guest_debug = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_guest_debug());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmArmClearDebugFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmArmClearDebugFtraceEvent*>(
      &from));
}

void KvmArmClearDebugFtraceEvent::MergeFrom(const KvmArmClearDebugFtraceEvent& from) {
  KvmArmClearDebugFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmArmClearDebugFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_guest_debug()) {
    _this->_internal_set_guest_debug(from._internal_guest_debug());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmArmClearDebugFtraceEvent::CopyFrom(const KvmArmClearDebugFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmArmClearDebugFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmArmClearDebugFtraceEvent::IsInitialized() const {
  return true;
}

void KvmArmClearDebugFtraceEvent::InternalSwap(KvmArmClearDebugFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.guest_debug_, other->_impl_.guest_debug_);
}

std::string KvmArmClearDebugFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmArmClearDebugFtraceEvent";
}


// ===================================================================

class KvmArmSetDreg32FtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmArmSetDreg32FtraceEvent>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

KvmArmSetDreg32FtraceEvent::KvmArmSetDreg32FtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmArmSetDreg32FtraceEvent)
}
KvmArmSetDreg32FtraceEvent::KvmArmSetDreg32FtraceEvent(const KvmArmSetDreg32FtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KvmArmSetDreg32FtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.value_ = from._impl_.value_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmArmSetDreg32FtraceEvent)
}

inline void KvmArmSetDreg32FtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){0u}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

KvmArmSetDreg32FtraceEvent::~KvmArmSetDreg32FtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmArmSetDreg32FtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmArmSetDreg32FtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void KvmArmSetDreg32FtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmArmSetDreg32FtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmArmSetDreg32FtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  _impl_.value_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmArmSetDreg32FtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_value(&has_bits);
          _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmArmSetDreg32FtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmArmSetDreg32FtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional uint32 value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmArmSetDreg32FtraceEvent)
  return target;
}

size_t KvmArmSetDreg32FtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmArmSetDreg32FtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional uint32 value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_value());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmArmSetDreg32FtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmArmSetDreg32FtraceEvent*>(
      &from));
}

void KvmArmSetDreg32FtraceEvent::MergeFrom(const KvmArmSetDreg32FtraceEvent& from) {
  KvmArmSetDreg32FtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmArmSetDreg32FtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.value_ = from._impl_.value_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmArmSetDreg32FtraceEvent::CopyFrom(const KvmArmSetDreg32FtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmArmSetDreg32FtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmArmSetDreg32FtraceEvent::IsInitialized() const {
  return true;
}

void KvmArmSetDreg32FtraceEvent::InternalSwap(KvmArmSetDreg32FtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.value_, other->_impl_.value_);
}

std::string KvmArmSetDreg32FtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmArmSetDreg32FtraceEvent";
}


// ===================================================================

class KvmArmSetRegsetFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmArmSetRegsetFtraceEvent>()._impl_._has_bits_);
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmArmSetRegsetFtraceEvent::KvmArmSetRegsetFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmArmSetRegsetFtraceEvent)
}
KvmArmSetRegsetFtraceEvent::KvmArmSetRegsetFtraceEvent(const KvmArmSetRegsetFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KvmArmSetRegsetFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.len_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.len_ = from._impl_.len_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmArmSetRegsetFtraceEvent)
}

inline void KvmArmSetRegsetFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.len_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

KvmArmSetRegsetFtraceEvent::~KvmArmSetRegsetFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmArmSetRegsetFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmArmSetRegsetFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void KvmArmSetRegsetFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmArmSetRegsetFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmArmSetRegsetFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  _impl_.len_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmArmSetRegsetFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 len = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmArmSetRegsetFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmArmSetRegsetFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 len = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_len(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmArmSetRegsetFtraceEvent)
  return target;
}

size_t KvmArmSetRegsetFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmArmSetRegsetFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional int32 len = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_len());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmArmSetRegsetFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmArmSetRegsetFtraceEvent*>(
      &from));
}

void KvmArmSetRegsetFtraceEvent::MergeFrom(const KvmArmSetRegsetFtraceEvent& from) {
  KvmArmSetRegsetFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmArmSetRegsetFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmArmSetRegsetFtraceEvent::CopyFrom(const KvmArmSetRegsetFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmArmSetRegsetFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmArmSetRegsetFtraceEvent::IsInitialized() const {
  return true;
}

void KvmArmSetRegsetFtraceEvent::InternalSwap(KvmArmSetRegsetFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.len_, other->_impl_.len_);
}

std::string KvmArmSetRegsetFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmArmSetRegsetFtraceEvent";
}


// ===================================================================

class KvmArmSetupDebugFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmArmSetupDebugFtraceEvent>()._impl_._has_bits_);
  static void set_has_guest_debug(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vcpu(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmArmSetupDebugFtraceEvent::KvmArmSetupDebugFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmArmSetupDebugFtraceEvent)
}
KvmArmSetupDebugFtraceEvent::KvmArmSetupDebugFtraceEvent(const KvmArmSetupDebugFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KvmArmSetupDebugFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vcpu_){}
    , decltype(_impl_.guest_debug_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.vcpu_, &from._impl_.vcpu_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.guest_debug_) -
    reinterpret_cast<char*>(&_impl_.vcpu_)) + sizeof(_impl_.guest_debug_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmArmSetupDebugFtraceEvent)
}

inline void KvmArmSetupDebugFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vcpu_){uint64_t{0u}}
    , decltype(_impl_.guest_debug_){0u}
  };
}

KvmArmSetupDebugFtraceEvent::~KvmArmSetupDebugFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmArmSetupDebugFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmArmSetupDebugFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmArmSetupDebugFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmArmSetupDebugFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmArmSetupDebugFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.vcpu_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.guest_debug_) -
        reinterpret_cast<char*>(&_impl_.vcpu_)) + sizeof(_impl_.guest_debug_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmArmSetupDebugFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 guest_debug = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_guest_debug(&has_bits);
          _impl_.guest_debug_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 vcpu = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_vcpu(&has_bits);
          _impl_.vcpu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmArmSetupDebugFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmArmSetupDebugFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 guest_debug = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_guest_debug(), target);
  }

  // optional uint64 vcpu = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_vcpu(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmArmSetupDebugFtraceEvent)
  return target;
}

size_t KvmArmSetupDebugFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmArmSetupDebugFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 vcpu = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_vcpu());
    }

    // optional uint32 guest_debug = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_guest_debug());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmArmSetupDebugFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmArmSetupDebugFtraceEvent*>(
      &from));
}

void KvmArmSetupDebugFtraceEvent::MergeFrom(const KvmArmSetupDebugFtraceEvent& from) {
  KvmArmSetupDebugFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmArmSetupDebugFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.vcpu_ = from._impl_.vcpu_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.guest_debug_ = from._impl_.guest_debug_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmArmSetupDebugFtraceEvent::CopyFrom(const KvmArmSetupDebugFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmArmSetupDebugFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmArmSetupDebugFtraceEvent::IsInitialized() const {
  return true;
}

void KvmArmSetupDebugFtraceEvent::InternalSwap(KvmArmSetupDebugFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmArmSetupDebugFtraceEvent, _impl_.guest_debug_)
      + sizeof(KvmArmSetupDebugFtraceEvent::_impl_.guest_debug_)
      - PROTOBUF_FIELD_OFFSET(KvmArmSetupDebugFtraceEvent, _impl_.vcpu_)>(
          reinterpret_cast<char*>(&_impl_.vcpu_),
          reinterpret_cast<char*>(&other->_impl_.vcpu_));
}

std::string KvmArmSetupDebugFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmArmSetupDebugFtraceEvent";
}


// ===================================================================

class KvmEntryFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmEntryFtraceEvent>()._impl_._has_bits_);
  static void set_has_vcpu_pc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmEntryFtraceEvent::KvmEntryFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmEntryFtraceEvent)
}
KvmEntryFtraceEvent::KvmEntryFtraceEvent(const KvmEntryFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KvmEntryFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vcpu_pc_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.vcpu_pc_ = from._impl_.vcpu_pc_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmEntryFtraceEvent)
}

inline void KvmEntryFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vcpu_pc_){uint64_t{0u}}
  };
}

KvmEntryFtraceEvent::~KvmEntryFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmEntryFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmEntryFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmEntryFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmEntryFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmEntryFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.vcpu_pc_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmEntryFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 vcpu_pc = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_vcpu_pc(&has_bits);
          _impl_.vcpu_pc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmEntryFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmEntryFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 vcpu_pc = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_vcpu_pc(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmEntryFtraceEvent)
  return target;
}

size_t KvmEntryFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmEntryFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 vcpu_pc = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_vcpu_pc());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmEntryFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmEntryFtraceEvent*>(
      &from));
}

void KvmEntryFtraceEvent::MergeFrom(const KvmEntryFtraceEvent& from) {
  KvmEntryFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmEntryFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_vcpu_pc()) {
    _this->_internal_set_vcpu_pc(from._internal_vcpu_pc());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmEntryFtraceEvent::CopyFrom(const KvmEntryFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmEntryFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmEntryFtraceEvent::IsInitialized() const {
  return true;
}

void KvmEntryFtraceEvent::InternalSwap(KvmEntryFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.vcpu_pc_, other->_impl_.vcpu_pc_);
}

std::string KvmEntryFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmEntryFtraceEvent";
}


// ===================================================================

class KvmExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmExitFtraceEvent>()._impl_._has_bits_);
  static void set_has_esr_ec(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vcpu_pc(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

KvmExitFtraceEvent::KvmExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmExitFtraceEvent)
}
KvmExitFtraceEvent::KvmExitFtraceEvent(const KvmExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KvmExitFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.esr_ec_){}
    , decltype(_impl_.ret_){}
    , decltype(_impl_.vcpu_pc_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.esr_ec_, &from._impl_.esr_ec_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.vcpu_pc_) -
    reinterpret_cast<char*>(&_impl_.esr_ec_)) + sizeof(_impl_.vcpu_pc_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmExitFtraceEvent)
}

inline void KvmExitFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.esr_ec_){0u}
    , decltype(_impl_.ret_){0}
    , decltype(_impl_.vcpu_pc_){uint64_t{0u}}
  };
}

KvmExitFtraceEvent::~KvmExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmExitFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmExitFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.esr_ec_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.vcpu_pc_) -
        reinterpret_cast<char*>(&_impl_.esr_ec_)) + sizeof(_impl_.vcpu_pc_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 esr_ec = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_esr_ec(&has_bits);
          _impl_.esr_ec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ret = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ret(&has_bits);
          _impl_.ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 vcpu_pc = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_vcpu_pc(&has_bits);
          _impl_.vcpu_pc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmExitFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 esr_ec = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_esr_ec(), target);
  }

  // optional int32 ret = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_ret(), target);
  }

  // optional uint64 vcpu_pc = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_vcpu_pc(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmExitFtraceEvent)
  return target;
}

size_t KvmExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmExitFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 esr_ec = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_esr_ec());
    }

    // optional int32 ret = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ret());
    }

    // optional uint64 vcpu_pc = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_vcpu_pc());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmExitFtraceEvent*>(
      &from));
}

void KvmExitFtraceEvent::MergeFrom(const KvmExitFtraceEvent& from) {
  KvmExitFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.esr_ec_ = from._impl_.esr_ec_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ret_ = from._impl_.ret_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.vcpu_pc_ = from._impl_.vcpu_pc_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmExitFtraceEvent::CopyFrom(const KvmExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmExitFtraceEvent::IsInitialized() const {
  return true;
}

void KvmExitFtraceEvent::InternalSwap(KvmExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmExitFtraceEvent, _impl_.vcpu_pc_)
      + sizeof(KvmExitFtraceEvent::_impl_.vcpu_pc_)
      - PROTOBUF_FIELD_OFFSET(KvmExitFtraceEvent, _impl_.esr_ec_)>(
          reinterpret_cast<char*>(&_impl_.esr_ec_),
          reinterpret_cast<char*>(&other->_impl_.esr_ec_));
}

std::string KvmExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmExitFtraceEvent";
}


// ===================================================================

class KvmFpuFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmFpuFtraceEvent>()._impl_._has_bits_);
  static void set_has_load(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmFpuFtraceEvent::KvmFpuFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmFpuFtraceEvent)
}
KvmFpuFtraceEvent::KvmFpuFtraceEvent(const KvmFpuFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KvmFpuFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.load_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.load_ = from._impl_.load_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmFpuFtraceEvent)
}

inline void KvmFpuFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.load_){0u}
  };
}

KvmFpuFtraceEvent::~KvmFpuFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmFpuFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmFpuFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmFpuFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmFpuFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmFpuFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.load_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmFpuFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 load = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_load(&has_bits);
          _impl_.load_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmFpuFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmFpuFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 load = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_load(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmFpuFtraceEvent)
  return target;
}

size_t KvmFpuFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmFpuFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 load = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_load());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmFpuFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmFpuFtraceEvent*>(
      &from));
}

void KvmFpuFtraceEvent::MergeFrom(const KvmFpuFtraceEvent& from) {
  KvmFpuFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmFpuFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_load()) {
    _this->_internal_set_load(from._internal_load());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmFpuFtraceEvent::CopyFrom(const KvmFpuFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmFpuFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmFpuFtraceEvent::IsInitialized() const {
  return true;
}

void KvmFpuFtraceEvent::InternalSwap(KvmFpuFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.load_, other->_impl_.load_);
}

std::string KvmFpuFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmFpuFtraceEvent";
}


// ===================================================================

class KvmGetTimerMapFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmGetTimerMapFtraceEvent>()._impl_._has_bits_);
  static void set_has_direct_ptimer(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_direct_vtimer(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_emul_ptimer(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_vcpu_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

KvmGetTimerMapFtraceEvent::KvmGetTimerMapFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmGetTimerMapFtraceEvent)
}
KvmGetTimerMapFtraceEvent::KvmGetTimerMapFtraceEvent(const KvmGetTimerMapFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KvmGetTimerMapFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.direct_ptimer_){}
    , decltype(_impl_.direct_vtimer_){}
    , decltype(_impl_.vcpu_id_){}
    , decltype(_impl_.emul_ptimer_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.direct_ptimer_, &from._impl_.direct_ptimer_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.emul_ptimer_) -
    reinterpret_cast<char*>(&_impl_.direct_ptimer_)) + sizeof(_impl_.emul_ptimer_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmGetTimerMapFtraceEvent)
}

inline void KvmGetTimerMapFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.direct_ptimer_){0}
    , decltype(_impl_.direct_vtimer_){0}
    , decltype(_impl_.vcpu_id_){uint64_t{0u}}
    , decltype(_impl_.emul_ptimer_){0}
  };
}

KvmGetTimerMapFtraceEvent::~KvmGetTimerMapFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmGetTimerMapFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmGetTimerMapFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmGetTimerMapFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmGetTimerMapFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmGetTimerMapFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.direct_ptimer_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.emul_ptimer_) -
        reinterpret_cast<char*>(&_impl_.direct_ptimer_)) + sizeof(_impl_.emul_ptimer_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmGetTimerMapFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 direct_ptimer = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_direct_ptimer(&has_bits);
          _impl_.direct_ptimer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 direct_vtimer = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_direct_vtimer(&has_bits);
          _impl_.direct_vtimer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 emul_ptimer = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_emul_ptimer(&has_bits);
          _impl_.emul_ptimer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 vcpu_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_vcpu_id(&has_bits);
          _impl_.vcpu_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmGetTimerMapFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmGetTimerMapFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 direct_ptimer = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_direct_ptimer(), target);
  }

  // optional int32 direct_vtimer = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_direct_vtimer(), target);
  }

  // optional int32 emul_ptimer = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_emul_ptimer(), target);
  }

  // optional uint64 vcpu_id = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_vcpu_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmGetTimerMapFtraceEvent)
  return target;
}

size_t KvmGetTimerMapFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmGetTimerMapFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int32 direct_ptimer = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_direct_ptimer());
    }

    // optional int32 direct_vtimer = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_direct_vtimer());
    }

    // optional uint64 vcpu_id = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_vcpu_id());
    }

    // optional int32 emul_ptimer = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_emul_ptimer());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmGetTimerMapFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmGetTimerMapFtraceEvent*>(
      &from));
}

void KvmGetTimerMapFtraceEvent::MergeFrom(const KvmGetTimerMapFtraceEvent& from) {
  KvmGetTimerMapFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmGetTimerMapFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.direct_ptimer_ = from._impl_.direct_ptimer_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.direct_vtimer_ = from._impl_.direct_vtimer_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.vcpu_id_ = from._impl_.vcpu_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.emul_ptimer_ = from._impl_.emul_ptimer_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmGetTimerMapFtraceEvent::CopyFrom(const KvmGetTimerMapFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmGetTimerMapFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmGetTimerMapFtraceEvent::IsInitialized() const {
  return true;
}

void KvmGetTimerMapFtraceEvent::InternalSwap(KvmGetTimerMapFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmGetTimerMapFtraceEvent, _impl_.emul_ptimer_)
      + sizeof(KvmGetTimerMapFtraceEvent::_impl_.emul_ptimer_)
      - PROTOBUF_FIELD_OFFSET(KvmGetTimerMapFtraceEvent, _impl_.direct_ptimer_)>(
          reinterpret_cast<char*>(&_impl_.direct_ptimer_),
          reinterpret_cast<char*>(&other->_impl_.direct_ptimer_));
}

std::string KvmGetTimerMapFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmGetTimerMapFtraceEvent";
}


// ===================================================================

class KvmGuestFaultFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmGuestFaultFtraceEvent>()._impl_._has_bits_);
  static void set_has_hsr(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_hxfar(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ipa(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_vcpu_pc(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

KvmGuestFaultFtraceEvent::KvmGuestFaultFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmGuestFaultFtraceEvent)
}
KvmGuestFaultFtraceEvent::KvmGuestFaultFtraceEvent(const KvmGuestFaultFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KvmGuestFaultFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hsr_){}
    , decltype(_impl_.hxfar_){}
    , decltype(_impl_.ipa_){}
    , decltype(_impl_.vcpu_pc_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.hsr_, &from._impl_.hsr_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.vcpu_pc_) -
    reinterpret_cast<char*>(&_impl_.hsr_)) + sizeof(_impl_.vcpu_pc_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmGuestFaultFtraceEvent)
}

inline void KvmGuestFaultFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hsr_){uint64_t{0u}}
    , decltype(_impl_.hxfar_){uint64_t{0u}}
    , decltype(_impl_.ipa_){uint64_t{0u}}
    , decltype(_impl_.vcpu_pc_){uint64_t{0u}}
  };
}

KvmGuestFaultFtraceEvent::~KvmGuestFaultFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmGuestFaultFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmGuestFaultFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmGuestFaultFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmGuestFaultFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmGuestFaultFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.hsr_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.vcpu_pc_) -
        reinterpret_cast<char*>(&_impl_.hsr_)) + sizeof(_impl_.vcpu_pc_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmGuestFaultFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 hsr = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_hsr(&has_bits);
          _impl_.hsr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 hxfar = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_hxfar(&has_bits);
          _impl_.hxfar_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ipa = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_ipa(&has_bits);
          _impl_.ipa_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 vcpu_pc = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_vcpu_pc(&has_bits);
          _impl_.vcpu_pc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmGuestFaultFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmGuestFaultFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 hsr = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_hsr(), target);
  }

  // optional uint64 hxfar = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_hxfar(), target);
  }

  // optional uint64 ipa = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_ipa(), target);
  }

  // optional uint64 vcpu_pc = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_vcpu_pc(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmGuestFaultFtraceEvent)
  return target;
}

size_t KvmGuestFaultFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmGuestFaultFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 hsr = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_hsr());
    }

    // optional uint64 hxfar = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_hxfar());
    }

    // optional uint64 ipa = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ipa());
    }

    // optional uint64 vcpu_pc = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_vcpu_pc());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmGuestFaultFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmGuestFaultFtraceEvent*>(
      &from));
}

void KvmGuestFaultFtraceEvent::MergeFrom(const KvmGuestFaultFtraceEvent& from) {
  KvmGuestFaultFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmGuestFaultFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.hsr_ = from._impl_.hsr_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.hxfar_ = from._impl_.hxfar_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ipa_ = from._impl_.ipa_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.vcpu_pc_ = from._impl_.vcpu_pc_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmGuestFaultFtraceEvent::CopyFrom(const KvmGuestFaultFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmGuestFaultFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmGuestFaultFtraceEvent::IsInitialized() const {
  return true;
}

void KvmGuestFaultFtraceEvent::InternalSwap(KvmGuestFaultFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmGuestFaultFtraceEvent, _impl_.vcpu_pc_)
      + sizeof(KvmGuestFaultFtraceEvent::_impl_.vcpu_pc_)
      - PROTOBUF_FIELD_OFFSET(KvmGuestFaultFtraceEvent, _impl_.hsr_)>(
          reinterpret_cast<char*>(&_impl_.hsr_),
          reinterpret_cast<char*>(&other->_impl_.hsr_));
}

std::string KvmGuestFaultFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmGuestFaultFtraceEvent";
}


// ===================================================================

class KvmHandleSysRegFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmHandleSysRegFtraceEvent>()._impl_._has_bits_);
  static void set_has_hsr(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmHandleSysRegFtraceEvent::KvmHandleSysRegFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmHandleSysRegFtraceEvent)
}
KvmHandleSysRegFtraceEvent::KvmHandleSysRegFtraceEvent(const KvmHandleSysRegFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KvmHandleSysRegFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hsr_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.hsr_ = from._impl_.hsr_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmHandleSysRegFtraceEvent)
}

inline void KvmHandleSysRegFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hsr_){uint64_t{0u}}
  };
}

KvmHandleSysRegFtraceEvent::~KvmHandleSysRegFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmHandleSysRegFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmHandleSysRegFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmHandleSysRegFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmHandleSysRegFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmHandleSysRegFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.hsr_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmHandleSysRegFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 hsr = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_hsr(&has_bits);
          _impl_.hsr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmHandleSysRegFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmHandleSysRegFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 hsr = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_hsr(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmHandleSysRegFtraceEvent)
  return target;
}

size_t KvmHandleSysRegFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmHandleSysRegFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 hsr = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_hsr());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmHandleSysRegFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmHandleSysRegFtraceEvent*>(
      &from));
}

void KvmHandleSysRegFtraceEvent::MergeFrom(const KvmHandleSysRegFtraceEvent& from) {
  KvmHandleSysRegFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmHandleSysRegFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_hsr()) {
    _this->_internal_set_hsr(from._internal_hsr());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmHandleSysRegFtraceEvent::CopyFrom(const KvmHandleSysRegFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmHandleSysRegFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmHandleSysRegFtraceEvent::IsInitialized() const {
  return true;
}

void KvmHandleSysRegFtraceEvent::InternalSwap(KvmHandleSysRegFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.hsr_, other->_impl_.hsr_);
}

std::string KvmHandleSysRegFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmHandleSysRegFtraceEvent";
}


// ===================================================================

class KvmHvcArm64FtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmHvcArm64FtraceEvent>()._impl_._has_bits_);
  static void set_has_imm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_r0(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vcpu_pc(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

KvmHvcArm64FtraceEvent::KvmHvcArm64FtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmHvcArm64FtraceEvent)
}
KvmHvcArm64FtraceEvent::KvmHvcArm64FtraceEvent(const KvmHvcArm64FtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KvmHvcArm64FtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.imm_){}
    , decltype(_impl_.r0_){}
    , decltype(_impl_.vcpu_pc_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.imm_, &from._impl_.imm_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.vcpu_pc_) -
    reinterpret_cast<char*>(&_impl_.imm_)) + sizeof(_impl_.vcpu_pc_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmHvcArm64FtraceEvent)
}

inline void KvmHvcArm64FtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.imm_){uint64_t{0u}}
    , decltype(_impl_.r0_){uint64_t{0u}}
    , decltype(_impl_.vcpu_pc_){uint64_t{0u}}
  };
}

KvmHvcArm64FtraceEvent::~KvmHvcArm64FtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmHvcArm64FtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmHvcArm64FtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmHvcArm64FtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmHvcArm64FtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmHvcArm64FtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.imm_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.vcpu_pc_) -
        reinterpret_cast<char*>(&_impl_.imm_)) + sizeof(_impl_.vcpu_pc_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmHvcArm64FtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 imm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_imm(&has_bits);
          _impl_.imm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 r0 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_r0(&has_bits);
          _impl_.r0_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 vcpu_pc = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_vcpu_pc(&has_bits);
          _impl_.vcpu_pc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmHvcArm64FtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmHvcArm64FtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 imm = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_imm(), target);
  }

  // optional uint64 r0 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_r0(), target);
  }

  // optional uint64 vcpu_pc = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_vcpu_pc(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmHvcArm64FtraceEvent)
  return target;
}

size_t KvmHvcArm64FtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmHvcArm64FtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 imm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_imm());
    }

    // optional uint64 r0 = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_r0());
    }

    // optional uint64 vcpu_pc = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_vcpu_pc());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmHvcArm64FtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmHvcArm64FtraceEvent*>(
      &from));
}

void KvmHvcArm64FtraceEvent::MergeFrom(const KvmHvcArm64FtraceEvent& from) {
  KvmHvcArm64FtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmHvcArm64FtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.imm_ = from._impl_.imm_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.r0_ = from._impl_.r0_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.vcpu_pc_ = from._impl_.vcpu_pc_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmHvcArm64FtraceEvent::CopyFrom(const KvmHvcArm64FtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmHvcArm64FtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmHvcArm64FtraceEvent::IsInitialized() const {
  return true;
}

void KvmHvcArm64FtraceEvent::InternalSwap(KvmHvcArm64FtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmHvcArm64FtraceEvent, _impl_.vcpu_pc_)
      + sizeof(KvmHvcArm64FtraceEvent::_impl_.vcpu_pc_)
      - PROTOBUF_FIELD_OFFSET(KvmHvcArm64FtraceEvent, _impl_.imm_)>(
          reinterpret_cast<char*>(&_impl_.imm_),
          reinterpret_cast<char*>(&other->_impl_.imm_));
}

std::string KvmHvcArm64FtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmHvcArm64FtraceEvent";
}


// ===================================================================

class KvmIrqLineFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmIrqLineFtraceEvent>()._impl_._has_bits_);
  static void set_has_irq_num(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_level(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_vcpu_idx(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

KvmIrqLineFtraceEvent::KvmIrqLineFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmIrqLineFtraceEvent)
}
KvmIrqLineFtraceEvent::KvmIrqLineFtraceEvent(const KvmIrqLineFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KvmIrqLineFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.irq_num_){}
    , decltype(_impl_.level_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.vcpu_idx_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.irq_num_, &from._impl_.irq_num_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.vcpu_idx_) -
    reinterpret_cast<char*>(&_impl_.irq_num_)) + sizeof(_impl_.vcpu_idx_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmIrqLineFtraceEvent)
}

inline void KvmIrqLineFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.irq_num_){0}
    , decltype(_impl_.level_){0}
    , decltype(_impl_.type_){0u}
    , decltype(_impl_.vcpu_idx_){0}
  };
}

KvmIrqLineFtraceEvent::~KvmIrqLineFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmIrqLineFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmIrqLineFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmIrqLineFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmIrqLineFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmIrqLineFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.irq_num_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.vcpu_idx_) -
        reinterpret_cast<char*>(&_impl_.irq_num_)) + sizeof(_impl_.vcpu_idx_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmIrqLineFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 irq_num = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_irq_num(&has_bits);
          _impl_.irq_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 level = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_level(&has_bits);
          _impl_.level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 vcpu_idx = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_vcpu_idx(&has_bits);
          _impl_.vcpu_idx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmIrqLineFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmIrqLineFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 irq_num = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_irq_num(), target);
  }

  // optional int32 level = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_level(), target);
  }

  // optional uint32 type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_type(), target);
  }

  // optional int32 vcpu_idx = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_vcpu_idx(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmIrqLineFtraceEvent)
  return target;
}

size_t KvmIrqLineFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmIrqLineFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int32 irq_num = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_irq_num());
    }

    // optional int32 level = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_level());
    }

    // optional uint32 type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
    }

    // optional int32 vcpu_idx = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_vcpu_idx());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmIrqLineFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmIrqLineFtraceEvent*>(
      &from));
}

void KvmIrqLineFtraceEvent::MergeFrom(const KvmIrqLineFtraceEvent& from) {
  KvmIrqLineFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmIrqLineFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.irq_num_ = from._impl_.irq_num_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.level_ = from._impl_.level_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.vcpu_idx_ = from._impl_.vcpu_idx_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmIrqLineFtraceEvent::CopyFrom(const KvmIrqLineFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmIrqLineFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmIrqLineFtraceEvent::IsInitialized() const {
  return true;
}

void KvmIrqLineFtraceEvent::InternalSwap(KvmIrqLineFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmIrqLineFtraceEvent, _impl_.vcpu_idx_)
      + sizeof(KvmIrqLineFtraceEvent::_impl_.vcpu_idx_)
      - PROTOBUF_FIELD_OFFSET(KvmIrqLineFtraceEvent, _impl_.irq_num_)>(
          reinterpret_cast<char*>(&_impl_.irq_num_),
          reinterpret_cast<char*>(&other->_impl_.irq_num_));
}

std::string KvmIrqLineFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmIrqLineFtraceEvent";
}


// ===================================================================

class KvmMmioFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmMmioFtraceEvent>()._impl_._has_bits_);
  static void set_has_gpa(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_val(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

KvmMmioFtraceEvent::KvmMmioFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmMmioFtraceEvent)
}
KvmMmioFtraceEvent::KvmMmioFtraceEvent(const KvmMmioFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KvmMmioFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gpa_){}
    , decltype(_impl_.len_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.val_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.gpa_, &from._impl_.gpa_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.val_) -
    reinterpret_cast<char*>(&_impl_.gpa_)) + sizeof(_impl_.val_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmMmioFtraceEvent)
}

inline void KvmMmioFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gpa_){uint64_t{0u}}
    , decltype(_impl_.len_){0u}
    , decltype(_impl_.type_){0u}
    , decltype(_impl_.val_){uint64_t{0u}}
  };
}

KvmMmioFtraceEvent::~KvmMmioFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmMmioFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmMmioFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmMmioFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmMmioFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmMmioFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.gpa_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.val_) -
        reinterpret_cast<char*>(&_impl_.gpa_)) + sizeof(_impl_.val_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmMmioFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 gpa = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gpa(&has_bits);
          _impl_.gpa_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 len = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 val = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_val(&has_bits);
          _impl_.val_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmMmioFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmMmioFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 gpa = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_gpa(), target);
  }

  // optional uint32 len = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_len(), target);
  }

  // optional uint32 type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_type(), target);
  }

  // optional uint64 val = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_val(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmMmioFtraceEvent)
  return target;
}

size_t KvmMmioFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmMmioFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 gpa = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_gpa());
    }

    // optional uint32 len = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_len());
    }

    // optional uint32 type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
    }

    // optional uint64 val = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_val());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmMmioFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmMmioFtraceEvent*>(
      &from));
}

void KvmMmioFtraceEvent::MergeFrom(const KvmMmioFtraceEvent& from) {
  KvmMmioFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmMmioFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.gpa_ = from._impl_.gpa_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.val_ = from._impl_.val_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmMmioFtraceEvent::CopyFrom(const KvmMmioFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmMmioFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmMmioFtraceEvent::IsInitialized() const {
  return true;
}

void KvmMmioFtraceEvent::InternalSwap(KvmMmioFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmMmioFtraceEvent, _impl_.val_)
      + sizeof(KvmMmioFtraceEvent::_impl_.val_)
      - PROTOBUF_FIELD_OFFSET(KvmMmioFtraceEvent, _impl_.gpa_)>(
          reinterpret_cast<char*>(&_impl_.gpa_),
          reinterpret_cast<char*>(&other->_impl_.gpa_));
}

std::string KvmMmioFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmMmioFtraceEvent";
}


// ===================================================================

class KvmMmioEmulateFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmMmioEmulateFtraceEvent>()._impl_._has_bits_);
  static void set_has_cpsr(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_instr(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vcpu_pc(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

KvmMmioEmulateFtraceEvent::KvmMmioEmulateFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmMmioEmulateFtraceEvent)
}
KvmMmioEmulateFtraceEvent::KvmMmioEmulateFtraceEvent(const KvmMmioEmulateFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KvmMmioEmulateFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cpsr_){}
    , decltype(_impl_.instr_){}
    , decltype(_impl_.vcpu_pc_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.cpsr_, &from._impl_.cpsr_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.vcpu_pc_) -
    reinterpret_cast<char*>(&_impl_.cpsr_)) + sizeof(_impl_.vcpu_pc_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmMmioEmulateFtraceEvent)
}

inline void KvmMmioEmulateFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cpsr_){uint64_t{0u}}
    , decltype(_impl_.instr_){uint64_t{0u}}
    , decltype(_impl_.vcpu_pc_){uint64_t{0u}}
  };
}

KvmMmioEmulateFtraceEvent::~KvmMmioEmulateFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmMmioEmulateFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmMmioEmulateFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmMmioEmulateFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmMmioEmulateFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmMmioEmulateFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.cpsr_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.vcpu_pc_) -
        reinterpret_cast<char*>(&_impl_.cpsr_)) + sizeof(_impl_.vcpu_pc_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmMmioEmulateFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 cpsr = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_cpsr(&has_bits);
          _impl_.cpsr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 instr = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_instr(&has_bits);
          _impl_.instr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 vcpu_pc = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_vcpu_pc(&has_bits);
          _impl_.vcpu_pc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmMmioEmulateFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmMmioEmulateFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 cpsr = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_cpsr(), target);
  }

  // optional uint64 instr = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_instr(), target);
  }

  // optional uint64 vcpu_pc = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_vcpu_pc(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmMmioEmulateFtraceEvent)
  return target;
}

size_t KvmMmioEmulateFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmMmioEmulateFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 cpsr = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_cpsr());
    }

    // optional uint64 instr = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_instr());
    }

    // optional uint64 vcpu_pc = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_vcpu_pc());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmMmioEmulateFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmMmioEmulateFtraceEvent*>(
      &from));
}

void KvmMmioEmulateFtraceEvent::MergeFrom(const KvmMmioEmulateFtraceEvent& from) {
  KvmMmioEmulateFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmMmioEmulateFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.cpsr_ = from._impl_.cpsr_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.instr_ = from._impl_.instr_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.vcpu_pc_ = from._impl_.vcpu_pc_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmMmioEmulateFtraceEvent::CopyFrom(const KvmMmioEmulateFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmMmioEmulateFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmMmioEmulateFtraceEvent::IsInitialized() const {
  return true;
}

void KvmMmioEmulateFtraceEvent::InternalSwap(KvmMmioEmulateFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmMmioEmulateFtraceEvent, _impl_.vcpu_pc_)
      + sizeof(KvmMmioEmulateFtraceEvent::_impl_.vcpu_pc_)
      - PROTOBUF_FIELD_OFFSET(KvmMmioEmulateFtraceEvent, _impl_.cpsr_)>(
          reinterpret_cast<char*>(&_impl_.cpsr_),
          reinterpret_cast<char*>(&other->_impl_.cpsr_));
}

std::string KvmMmioEmulateFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmMmioEmulateFtraceEvent";
}


// ===================================================================

class KvmSetGuestDebugFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmSetGuestDebugFtraceEvent>()._impl_._has_bits_);
  static void set_has_guest_debug(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vcpu(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmSetGuestDebugFtraceEvent::KvmSetGuestDebugFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmSetGuestDebugFtraceEvent)
}
KvmSetGuestDebugFtraceEvent::KvmSetGuestDebugFtraceEvent(const KvmSetGuestDebugFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KvmSetGuestDebugFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vcpu_){}
    , decltype(_impl_.guest_debug_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.vcpu_, &from._impl_.vcpu_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.guest_debug_) -
    reinterpret_cast<char*>(&_impl_.vcpu_)) + sizeof(_impl_.guest_debug_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmSetGuestDebugFtraceEvent)
}

inline void KvmSetGuestDebugFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vcpu_){uint64_t{0u}}
    , decltype(_impl_.guest_debug_){0u}
  };
}

KvmSetGuestDebugFtraceEvent::~KvmSetGuestDebugFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmSetGuestDebugFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmSetGuestDebugFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmSetGuestDebugFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmSetGuestDebugFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmSetGuestDebugFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.vcpu_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.guest_debug_) -
        reinterpret_cast<char*>(&_impl_.vcpu_)) + sizeof(_impl_.guest_debug_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmSetGuestDebugFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 guest_debug = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_guest_debug(&has_bits);
          _impl_.guest_debug_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 vcpu = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_vcpu(&has_bits);
          _impl_.vcpu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmSetGuestDebugFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmSetGuestDebugFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 guest_debug = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_guest_debug(), target);
  }

  // optional uint64 vcpu = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_vcpu(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmSetGuestDebugFtraceEvent)
  return target;
}

size_t KvmSetGuestDebugFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmSetGuestDebugFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 vcpu = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_vcpu());
    }

    // optional uint32 guest_debug = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_guest_debug());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmSetGuestDebugFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmSetGuestDebugFtraceEvent*>(
      &from));
}

void KvmSetGuestDebugFtraceEvent::MergeFrom(const KvmSetGuestDebugFtraceEvent& from) {
  KvmSetGuestDebugFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmSetGuestDebugFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.vcpu_ = from._impl_.vcpu_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.guest_debug_ = from._impl_.guest_debug_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmSetGuestDebugFtraceEvent::CopyFrom(const KvmSetGuestDebugFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmSetGuestDebugFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmSetGuestDebugFtraceEvent::IsInitialized() const {
  return true;
}

void KvmSetGuestDebugFtraceEvent::InternalSwap(KvmSetGuestDebugFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmSetGuestDebugFtraceEvent, _impl_.guest_debug_)
      + sizeof(KvmSetGuestDebugFtraceEvent::_impl_.guest_debug_)
      - PROTOBUF_FIELD_OFFSET(KvmSetGuestDebugFtraceEvent, _impl_.vcpu_)>(
          reinterpret_cast<char*>(&_impl_.vcpu_),
          reinterpret_cast<char*>(&other->_impl_.vcpu_));
}

std::string KvmSetGuestDebugFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmSetGuestDebugFtraceEvent";
}


// ===================================================================

class KvmSetIrqFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmSetIrqFtraceEvent>()._impl_._has_bits_);
  static void set_has_gsi(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_irq_source_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_level(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

KvmSetIrqFtraceEvent::KvmSetIrqFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmSetIrqFtraceEvent)
}
KvmSetIrqFtraceEvent::KvmSetIrqFtraceEvent(const KvmSetIrqFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KvmSetIrqFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gsi_){}
    , decltype(_impl_.irq_source_id_){}
    , decltype(_impl_.level_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.gsi_, &from._impl_.gsi_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.level_) -
    reinterpret_cast<char*>(&_impl_.gsi_)) + sizeof(_impl_.level_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmSetIrqFtraceEvent)
}

inline void KvmSetIrqFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gsi_){0u}
    , decltype(_impl_.irq_source_id_){0}
    , decltype(_impl_.level_){0}
  };
}

KvmSetIrqFtraceEvent::~KvmSetIrqFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmSetIrqFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmSetIrqFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmSetIrqFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmSetIrqFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmSetIrqFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.gsi_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.level_) -
        reinterpret_cast<char*>(&_impl_.gsi_)) + sizeof(_impl_.level_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmSetIrqFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 gsi = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gsi(&has_bits);
          _impl_.gsi_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 irq_source_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_irq_source_id(&has_bits);
          _impl_.irq_source_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 level = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_level(&has_bits);
          _impl_.level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmSetIrqFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmSetIrqFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 gsi = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gsi(), target);
  }

  // optional int32 irq_source_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_irq_source_id(), target);
  }

  // optional int32 level = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_level(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmSetIrqFtraceEvent)
  return target;
}

size_t KvmSetIrqFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmSetIrqFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 gsi = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gsi());
    }

    // optional int32 irq_source_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_irq_source_id());
    }

    // optional int32 level = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_level());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmSetIrqFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmSetIrqFtraceEvent*>(
      &from));
}

void KvmSetIrqFtraceEvent::MergeFrom(const KvmSetIrqFtraceEvent& from) {
  KvmSetIrqFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmSetIrqFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.gsi_ = from._impl_.gsi_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.irq_source_id_ = from._impl_.irq_source_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.level_ = from._impl_.level_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmSetIrqFtraceEvent::CopyFrom(const KvmSetIrqFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmSetIrqFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmSetIrqFtraceEvent::IsInitialized() const {
  return true;
}

void KvmSetIrqFtraceEvent::InternalSwap(KvmSetIrqFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmSetIrqFtraceEvent, _impl_.level_)
      + sizeof(KvmSetIrqFtraceEvent::_impl_.level_)
      - PROTOBUF_FIELD_OFFSET(KvmSetIrqFtraceEvent, _impl_.gsi_)>(
          reinterpret_cast<char*>(&_impl_.gsi_),
          reinterpret_cast<char*>(&other->_impl_.gsi_));
}

std::string KvmSetIrqFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmSetIrqFtraceEvent";
}


// ===================================================================

class KvmSetSpteHvaFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmSetSpteHvaFtraceEvent>()._impl_._has_bits_);
  static void set_has_hva(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmSetSpteHvaFtraceEvent::KvmSetSpteHvaFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmSetSpteHvaFtraceEvent)
}
KvmSetSpteHvaFtraceEvent::KvmSetSpteHvaFtraceEvent(const KvmSetSpteHvaFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KvmSetSpteHvaFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hva_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.hva_ = from._impl_.hva_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmSetSpteHvaFtraceEvent)
}

inline void KvmSetSpteHvaFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hva_){uint64_t{0u}}
  };
}

KvmSetSpteHvaFtraceEvent::~KvmSetSpteHvaFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmSetSpteHvaFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmSetSpteHvaFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmSetSpteHvaFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmSetSpteHvaFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmSetSpteHvaFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.hva_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmSetSpteHvaFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 hva = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_hva(&has_bits);
          _impl_.hva_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmSetSpteHvaFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmSetSpteHvaFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 hva = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_hva(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmSetSpteHvaFtraceEvent)
  return target;
}

size_t KvmSetSpteHvaFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmSetSpteHvaFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 hva = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_hva());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmSetSpteHvaFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmSetSpteHvaFtraceEvent*>(
      &from));
}

void KvmSetSpteHvaFtraceEvent::MergeFrom(const KvmSetSpteHvaFtraceEvent& from) {
  KvmSetSpteHvaFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmSetSpteHvaFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_hva()) {
    _this->_internal_set_hva(from._internal_hva());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmSetSpteHvaFtraceEvent::CopyFrom(const KvmSetSpteHvaFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmSetSpteHvaFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmSetSpteHvaFtraceEvent::IsInitialized() const {
  return true;
}

void KvmSetSpteHvaFtraceEvent::InternalSwap(KvmSetSpteHvaFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.hva_, other->_impl_.hva_);
}

std::string KvmSetSpteHvaFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmSetSpteHvaFtraceEvent";
}


// ===================================================================

class KvmSetWayFlushFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmSetWayFlushFtraceEvent>()._impl_._has_bits_);
  static void set_has_cache(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vcpu_pc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmSetWayFlushFtraceEvent::KvmSetWayFlushFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmSetWayFlushFtraceEvent)
}
KvmSetWayFlushFtraceEvent::KvmSetWayFlushFtraceEvent(const KvmSetWayFlushFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KvmSetWayFlushFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vcpu_pc_){}
    , decltype(_impl_.cache_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.vcpu_pc_, &from._impl_.vcpu_pc_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.cache_) -
    reinterpret_cast<char*>(&_impl_.vcpu_pc_)) + sizeof(_impl_.cache_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmSetWayFlushFtraceEvent)
}

inline void KvmSetWayFlushFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vcpu_pc_){uint64_t{0u}}
    , decltype(_impl_.cache_){0u}
  };
}

KvmSetWayFlushFtraceEvent::~KvmSetWayFlushFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmSetWayFlushFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmSetWayFlushFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmSetWayFlushFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmSetWayFlushFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmSetWayFlushFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.vcpu_pc_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.cache_) -
        reinterpret_cast<char*>(&_impl_.vcpu_pc_)) + sizeof(_impl_.cache_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmSetWayFlushFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 cache = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_cache(&has_bits);
          _impl_.cache_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 vcpu_pc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_vcpu_pc(&has_bits);
          _impl_.vcpu_pc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmSetWayFlushFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmSetWayFlushFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 cache = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_cache(), target);
  }

  // optional uint64 vcpu_pc = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_vcpu_pc(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmSetWayFlushFtraceEvent)
  return target;
}

size_t KvmSetWayFlushFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmSetWayFlushFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 vcpu_pc = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_vcpu_pc());
    }

    // optional uint32 cache = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_cache());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmSetWayFlushFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmSetWayFlushFtraceEvent*>(
      &from));
}

void KvmSetWayFlushFtraceEvent::MergeFrom(const KvmSetWayFlushFtraceEvent& from) {
  KvmSetWayFlushFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmSetWayFlushFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.vcpu_pc_ = from._impl_.vcpu_pc_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.cache_ = from._impl_.cache_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmSetWayFlushFtraceEvent::CopyFrom(const KvmSetWayFlushFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmSetWayFlushFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmSetWayFlushFtraceEvent::IsInitialized() const {
  return true;
}

void KvmSetWayFlushFtraceEvent::InternalSwap(KvmSetWayFlushFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmSetWayFlushFtraceEvent, _impl_.cache_)
      + sizeof(KvmSetWayFlushFtraceEvent::_impl_.cache_)
      - PROTOBUF_FIELD_OFFSET(KvmSetWayFlushFtraceEvent, _impl_.vcpu_pc_)>(
          reinterpret_cast<char*>(&_impl_.vcpu_pc_),
          reinterpret_cast<char*>(&other->_impl_.vcpu_pc_));
}

std::string KvmSetWayFlushFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmSetWayFlushFtraceEvent";
}


// ===================================================================

class KvmSysAccessFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmSysAccessFtraceEvent>()._impl_._has_bits_);
  static void set_has_crm(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_crn(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_op0(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_op1(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_op2(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_is_write(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_vcpu_pc(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

KvmSysAccessFtraceEvent::KvmSysAccessFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmSysAccessFtraceEvent)
}
KvmSysAccessFtraceEvent::KvmSysAccessFtraceEvent(const KvmSysAccessFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KvmSysAccessFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.crm_){}
    , decltype(_impl_.crn_){}
    , decltype(_impl_.op0_){}
    , decltype(_impl_.op1_){}
    , decltype(_impl_.op2_){}
    , decltype(_impl_.is_write_){}
    , decltype(_impl_.vcpu_pc_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.crm_, &from._impl_.crm_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.vcpu_pc_) -
    reinterpret_cast<char*>(&_impl_.crm_)) + sizeof(_impl_.vcpu_pc_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmSysAccessFtraceEvent)
}

inline void KvmSysAccessFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.crm_){0u}
    , decltype(_impl_.crn_){0u}
    , decltype(_impl_.op0_){0u}
    , decltype(_impl_.op1_){0u}
    , decltype(_impl_.op2_){0u}
    , decltype(_impl_.is_write_){0u}
    , decltype(_impl_.vcpu_pc_){uint64_t{0u}}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

KvmSysAccessFtraceEvent::~KvmSysAccessFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmSysAccessFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmSysAccessFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void KvmSysAccessFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmSysAccessFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmSysAccessFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.crm_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.vcpu_pc_) -
        reinterpret_cast<char*>(&_impl_.crm_)) + sizeof(_impl_.vcpu_pc_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmSysAccessFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 CRm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_crm(&has_bits);
          _impl_.crm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 CRn = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_crn(&has_bits);
          _impl_.crn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 Op0 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_op0(&has_bits);
          _impl_.op0_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 Op1 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_op1(&has_bits);
          _impl_.op1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 Op2 = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_op2(&has_bits);
          _impl_.op2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 is_write = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_is_write(&has_bits);
          _impl_.is_write_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 vcpu_pc = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_vcpu_pc(&has_bits);
          _impl_.vcpu_pc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmSysAccessFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmSysAccessFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 CRm = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_crm(), target);
  }

  // optional uint32 CRn = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_crn(), target);
  }

  // optional uint32 Op0 = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_op0(), target);
  }

  // optional uint32 Op1 = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_op1(), target);
  }

  // optional uint32 Op2 = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_op2(), target);
  }

  // optional uint32 is_write = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_is_write(), target);
  }

  // optional string name = 7;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_name(), target);
  }

  // optional uint64 vcpu_pc = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(8, this->_internal_vcpu_pc(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmSysAccessFtraceEvent)
  return target;
}

size_t KvmSysAccessFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmSysAccessFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional uint32 CRm = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_crm());
    }

    // optional uint32 CRn = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_crn());
    }

    // optional uint32 Op0 = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_op0());
    }

    // optional uint32 Op1 = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_op1());
    }

    // optional uint32 Op2 = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_op2());
    }

    // optional uint32 is_write = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_is_write());
    }

    // optional uint64 vcpu_pc = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_vcpu_pc());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmSysAccessFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmSysAccessFtraceEvent*>(
      &from));
}

void KvmSysAccessFtraceEvent::MergeFrom(const KvmSysAccessFtraceEvent& from) {
  KvmSysAccessFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmSysAccessFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.crm_ = from._impl_.crm_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.crn_ = from._impl_.crn_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.op0_ = from._impl_.op0_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.op1_ = from._impl_.op1_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.op2_ = from._impl_.op2_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.is_write_ = from._impl_.is_write_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.vcpu_pc_ = from._impl_.vcpu_pc_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmSysAccessFtraceEvent::CopyFrom(const KvmSysAccessFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmSysAccessFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmSysAccessFtraceEvent::IsInitialized() const {
  return true;
}

void KvmSysAccessFtraceEvent::InternalSwap(KvmSysAccessFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmSysAccessFtraceEvent, _impl_.vcpu_pc_)
      + sizeof(KvmSysAccessFtraceEvent::_impl_.vcpu_pc_)
      - PROTOBUF_FIELD_OFFSET(KvmSysAccessFtraceEvent, _impl_.crm_)>(
          reinterpret_cast<char*>(&_impl_.crm_),
          reinterpret_cast<char*>(&other->_impl_.crm_));
}

std::string KvmSysAccessFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmSysAccessFtraceEvent";
}


// ===================================================================

class KvmTestAgeHvaFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmTestAgeHvaFtraceEvent>()._impl_._has_bits_);
  static void set_has_hva(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmTestAgeHvaFtraceEvent::KvmTestAgeHvaFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmTestAgeHvaFtraceEvent)
}
KvmTestAgeHvaFtraceEvent::KvmTestAgeHvaFtraceEvent(const KvmTestAgeHvaFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KvmTestAgeHvaFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hva_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.hva_ = from._impl_.hva_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmTestAgeHvaFtraceEvent)
}

inline void KvmTestAgeHvaFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hva_){uint64_t{0u}}
  };
}

KvmTestAgeHvaFtraceEvent::~KvmTestAgeHvaFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmTestAgeHvaFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmTestAgeHvaFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmTestAgeHvaFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmTestAgeHvaFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmTestAgeHvaFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.hva_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmTestAgeHvaFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 hva = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_hva(&has_bits);
          _impl_.hva_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmTestAgeHvaFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmTestAgeHvaFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 hva = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_hva(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmTestAgeHvaFtraceEvent)
  return target;
}

size_t KvmTestAgeHvaFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmTestAgeHvaFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 hva = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_hva());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmTestAgeHvaFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmTestAgeHvaFtraceEvent*>(
      &from));
}

void KvmTestAgeHvaFtraceEvent::MergeFrom(const KvmTestAgeHvaFtraceEvent& from) {
  KvmTestAgeHvaFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmTestAgeHvaFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_hva()) {
    _this->_internal_set_hva(from._internal_hva());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmTestAgeHvaFtraceEvent::CopyFrom(const KvmTestAgeHvaFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmTestAgeHvaFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmTestAgeHvaFtraceEvent::IsInitialized() const {
  return true;
}

void KvmTestAgeHvaFtraceEvent::InternalSwap(KvmTestAgeHvaFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.hva_, other->_impl_.hva_);
}

std::string KvmTestAgeHvaFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmTestAgeHvaFtraceEvent";
}


// ===================================================================

class KvmTimerEmulateFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmTimerEmulateFtraceEvent>()._impl_._has_bits_);
  static void set_has_should_fire(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_timer_idx(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

KvmTimerEmulateFtraceEvent::KvmTimerEmulateFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmTimerEmulateFtraceEvent)
}
KvmTimerEmulateFtraceEvent::KvmTimerEmulateFtraceEvent(const KvmTimerEmulateFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KvmTimerEmulateFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.should_fire_){}
    , decltype(_impl_.timer_idx_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.should_fire_, &from._impl_.should_fire_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.timer_idx_) -
    reinterpret_cast<char*>(&_impl_.should_fire_)) + sizeof(_impl_.timer_idx_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmTimerEmulateFtraceEvent)
}

inline void KvmTimerEmulateFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.should_fire_){0u}
    , decltype(_impl_.timer_idx_){0}
  };
}

KvmTimerEmulateFtraceEvent::~KvmTimerEmulateFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmTimerEmulateFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmTimerEmulateFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmTimerEmulateFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmTimerEmulateFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmTimerEmulateFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.should_fire_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.timer_idx_) -
        reinterpret_cast<char*>(&_impl_.should_fire_)) + sizeof(_impl_.timer_idx_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmTimerEmulateFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 should_fire = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_should_fire(&has_bits);
          _impl_.should_fire_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 timer_idx = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_timer_idx(&has_bits);
          _impl_.timer_idx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmTimerEmulateFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmTimerEmulateFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 should_fire = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_should_fire(), target);
  }

  // optional int32 timer_idx = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_timer_idx(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmTimerEmulateFtraceEvent)
  return target;
}

size_t KvmTimerEmulateFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmTimerEmulateFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 should_fire = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_should_fire());
    }

    // optional int32 timer_idx = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_timer_idx());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmTimerEmulateFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmTimerEmulateFtraceEvent*>(
      &from));
}

void KvmTimerEmulateFtraceEvent::MergeFrom(const KvmTimerEmulateFtraceEvent& from) {
  KvmTimerEmulateFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmTimerEmulateFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.should_fire_ = from._impl_.should_fire_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.timer_idx_ = from._impl_.timer_idx_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmTimerEmulateFtraceEvent::CopyFrom(const KvmTimerEmulateFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmTimerEmulateFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmTimerEmulateFtraceEvent::IsInitialized() const {
  return true;
}

void KvmTimerEmulateFtraceEvent::InternalSwap(KvmTimerEmulateFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmTimerEmulateFtraceEvent, _impl_.timer_idx_)
      + sizeof(KvmTimerEmulateFtraceEvent::_impl_.timer_idx_)
      - PROTOBUF_FIELD_OFFSET(KvmTimerEmulateFtraceEvent, _impl_.should_fire_)>(
          reinterpret_cast<char*>(&_impl_.should_fire_),
          reinterpret_cast<char*>(&other->_impl_.should_fire_));
}

std::string KvmTimerEmulateFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmTimerEmulateFtraceEvent";
}


// ===================================================================

class KvmTimerHrtimerExpireFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmTimerHrtimerExpireFtraceEvent>()._impl_._has_bits_);
  static void set_has_timer_idx(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmTimerHrtimerExpireFtraceEvent::KvmTimerHrtimerExpireFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmTimerHrtimerExpireFtraceEvent)
}
KvmTimerHrtimerExpireFtraceEvent::KvmTimerHrtimerExpireFtraceEvent(const KvmTimerHrtimerExpireFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KvmTimerHrtimerExpireFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timer_idx_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.timer_idx_ = from._impl_.timer_idx_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmTimerHrtimerExpireFtraceEvent)
}

inline void KvmTimerHrtimerExpireFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timer_idx_){0}
  };
}

KvmTimerHrtimerExpireFtraceEvent::~KvmTimerHrtimerExpireFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmTimerHrtimerExpireFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmTimerHrtimerExpireFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmTimerHrtimerExpireFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmTimerHrtimerExpireFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmTimerHrtimerExpireFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.timer_idx_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmTimerHrtimerExpireFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 timer_idx = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timer_idx(&has_bits);
          _impl_.timer_idx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmTimerHrtimerExpireFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmTimerHrtimerExpireFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 timer_idx = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_timer_idx(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmTimerHrtimerExpireFtraceEvent)
  return target;
}

size_t KvmTimerHrtimerExpireFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmTimerHrtimerExpireFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 timer_idx = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_timer_idx());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmTimerHrtimerExpireFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmTimerHrtimerExpireFtraceEvent*>(
      &from));
}

void KvmTimerHrtimerExpireFtraceEvent::MergeFrom(const KvmTimerHrtimerExpireFtraceEvent& from) {
  KvmTimerHrtimerExpireFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmTimerHrtimerExpireFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_timer_idx()) {
    _this->_internal_set_timer_idx(from._internal_timer_idx());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmTimerHrtimerExpireFtraceEvent::CopyFrom(const KvmTimerHrtimerExpireFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmTimerHrtimerExpireFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmTimerHrtimerExpireFtraceEvent::IsInitialized() const {
  return true;
}

void KvmTimerHrtimerExpireFtraceEvent::InternalSwap(KvmTimerHrtimerExpireFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.timer_idx_, other->_impl_.timer_idx_);
}

std::string KvmTimerHrtimerExpireFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmTimerHrtimerExpireFtraceEvent";
}


// ===================================================================

class KvmTimerRestoreStateFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmTimerRestoreStateFtraceEvent>()._impl_._has_bits_);
  static void set_has_ctl(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cval(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_timer_idx(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

KvmTimerRestoreStateFtraceEvent::KvmTimerRestoreStateFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmTimerRestoreStateFtraceEvent)
}
KvmTimerRestoreStateFtraceEvent::KvmTimerRestoreStateFtraceEvent(const KvmTimerRestoreStateFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KvmTimerRestoreStateFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ctl_){}
    , decltype(_impl_.cval_){}
    , decltype(_impl_.timer_idx_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.ctl_, &from._impl_.ctl_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.timer_idx_) -
    reinterpret_cast<char*>(&_impl_.ctl_)) + sizeof(_impl_.timer_idx_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmTimerRestoreStateFtraceEvent)
}

inline void KvmTimerRestoreStateFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ctl_){uint64_t{0u}}
    , decltype(_impl_.cval_){uint64_t{0u}}
    , decltype(_impl_.timer_idx_){0}
  };
}

KvmTimerRestoreStateFtraceEvent::~KvmTimerRestoreStateFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmTimerRestoreStateFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmTimerRestoreStateFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmTimerRestoreStateFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmTimerRestoreStateFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmTimerRestoreStateFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.ctl_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.timer_idx_) -
        reinterpret_cast<char*>(&_impl_.ctl_)) + sizeof(_impl_.timer_idx_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmTimerRestoreStateFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 ctl = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ctl(&has_bits);
          _impl_.ctl_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 cval = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_cval(&has_bits);
          _impl_.cval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 timer_idx = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_timer_idx(&has_bits);
          _impl_.timer_idx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmTimerRestoreStateFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmTimerRestoreStateFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 ctl = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_ctl(), target);
  }

  // optional uint64 cval = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_cval(), target);
  }

  // optional int32 timer_idx = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_timer_idx(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmTimerRestoreStateFtraceEvent)
  return target;
}

size_t KvmTimerRestoreStateFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmTimerRestoreStateFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 ctl = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ctl());
    }

    // optional uint64 cval = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_cval());
    }

    // optional int32 timer_idx = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_timer_idx());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmTimerRestoreStateFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmTimerRestoreStateFtraceEvent*>(
      &from));
}

void KvmTimerRestoreStateFtraceEvent::MergeFrom(const KvmTimerRestoreStateFtraceEvent& from) {
  KvmTimerRestoreStateFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmTimerRestoreStateFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.ctl_ = from._impl_.ctl_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.cval_ = from._impl_.cval_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.timer_idx_ = from._impl_.timer_idx_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmTimerRestoreStateFtraceEvent::CopyFrom(const KvmTimerRestoreStateFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmTimerRestoreStateFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmTimerRestoreStateFtraceEvent::IsInitialized() const {
  return true;
}

void KvmTimerRestoreStateFtraceEvent::InternalSwap(KvmTimerRestoreStateFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmTimerRestoreStateFtraceEvent, _impl_.timer_idx_)
      + sizeof(KvmTimerRestoreStateFtraceEvent::_impl_.timer_idx_)
      - PROTOBUF_FIELD_OFFSET(KvmTimerRestoreStateFtraceEvent, _impl_.ctl_)>(
          reinterpret_cast<char*>(&_impl_.ctl_),
          reinterpret_cast<char*>(&other->_impl_.ctl_));
}

std::string KvmTimerRestoreStateFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmTimerRestoreStateFtraceEvent";
}


// ===================================================================

class KvmTimerSaveStateFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmTimerSaveStateFtraceEvent>()._impl_._has_bits_);
  static void set_has_ctl(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cval(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_timer_idx(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

KvmTimerSaveStateFtraceEvent::KvmTimerSaveStateFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmTimerSaveStateFtraceEvent)
}
KvmTimerSaveStateFtraceEvent::KvmTimerSaveStateFtraceEvent(const KvmTimerSaveStateFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KvmTimerSaveStateFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ctl_){}
    , decltype(_impl_.cval_){}
    , decltype(_impl_.timer_idx_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.ctl_, &from._impl_.ctl_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.timer_idx_) -
    reinterpret_cast<char*>(&_impl_.ctl_)) + sizeof(_impl_.timer_idx_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmTimerSaveStateFtraceEvent)
}

inline void KvmTimerSaveStateFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ctl_){uint64_t{0u}}
    , decltype(_impl_.cval_){uint64_t{0u}}
    , decltype(_impl_.timer_idx_){0}
  };
}

KvmTimerSaveStateFtraceEvent::~KvmTimerSaveStateFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmTimerSaveStateFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmTimerSaveStateFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmTimerSaveStateFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmTimerSaveStateFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmTimerSaveStateFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.ctl_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.timer_idx_) -
        reinterpret_cast<char*>(&_impl_.ctl_)) + sizeof(_impl_.timer_idx_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmTimerSaveStateFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 ctl = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ctl(&has_bits);
          _impl_.ctl_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 cval = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_cval(&has_bits);
          _impl_.cval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 timer_idx = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_timer_idx(&has_bits);
          _impl_.timer_idx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmTimerSaveStateFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmTimerSaveStateFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 ctl = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_ctl(), target);
  }

  // optional uint64 cval = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_cval(), target);
  }

  // optional int32 timer_idx = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_timer_idx(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmTimerSaveStateFtraceEvent)
  return target;
}

size_t KvmTimerSaveStateFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmTimerSaveStateFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 ctl = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ctl());
    }

    // optional uint64 cval = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_cval());
    }

    // optional int32 timer_idx = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_timer_idx());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmTimerSaveStateFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmTimerSaveStateFtraceEvent*>(
      &from));
}

void KvmTimerSaveStateFtraceEvent::MergeFrom(const KvmTimerSaveStateFtraceEvent& from) {
  KvmTimerSaveStateFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmTimerSaveStateFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.ctl_ = from._impl_.ctl_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.cval_ = from._impl_.cval_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.timer_idx_ = from._impl_.timer_idx_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmTimerSaveStateFtraceEvent::CopyFrom(const KvmTimerSaveStateFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmTimerSaveStateFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmTimerSaveStateFtraceEvent::IsInitialized() const {
  return true;
}

void KvmTimerSaveStateFtraceEvent::InternalSwap(KvmTimerSaveStateFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmTimerSaveStateFtraceEvent, _impl_.timer_idx_)
      + sizeof(KvmTimerSaveStateFtraceEvent::_impl_.timer_idx_)
      - PROTOBUF_FIELD_OFFSET(KvmTimerSaveStateFtraceEvent, _impl_.ctl_)>(
          reinterpret_cast<char*>(&_impl_.ctl_),
          reinterpret_cast<char*>(&other->_impl_.ctl_));
}

std::string KvmTimerSaveStateFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmTimerSaveStateFtraceEvent";
}


// ===================================================================

class KvmTimerUpdateIrqFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmTimerUpdateIrqFtraceEvent>()._impl_._has_bits_);
  static void set_has_irq(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_level(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vcpu_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

KvmTimerUpdateIrqFtraceEvent::KvmTimerUpdateIrqFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmTimerUpdateIrqFtraceEvent)
}
KvmTimerUpdateIrqFtraceEvent::KvmTimerUpdateIrqFtraceEvent(const KvmTimerUpdateIrqFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KvmTimerUpdateIrqFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.irq_){}
    , decltype(_impl_.level_){}
    , decltype(_impl_.vcpu_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.irq_, &from._impl_.irq_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.vcpu_id_) -
    reinterpret_cast<char*>(&_impl_.irq_)) + sizeof(_impl_.vcpu_id_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmTimerUpdateIrqFtraceEvent)
}

inline void KvmTimerUpdateIrqFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.irq_){0u}
    , decltype(_impl_.level_){0}
    , decltype(_impl_.vcpu_id_){uint64_t{0u}}
  };
}

KvmTimerUpdateIrqFtraceEvent::~KvmTimerUpdateIrqFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmTimerUpdateIrqFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmTimerUpdateIrqFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmTimerUpdateIrqFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmTimerUpdateIrqFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmTimerUpdateIrqFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.irq_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.vcpu_id_) -
        reinterpret_cast<char*>(&_impl_.irq_)) + sizeof(_impl_.vcpu_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmTimerUpdateIrqFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 irq = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_irq(&has_bits);
          _impl_.irq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 level = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_level(&has_bits);
          _impl_.level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 vcpu_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_vcpu_id(&has_bits);
          _impl_.vcpu_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmTimerUpdateIrqFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmTimerUpdateIrqFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 irq = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_irq(), target);
  }

  // optional int32 level = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_level(), target);
  }

  // optional uint64 vcpu_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_vcpu_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmTimerUpdateIrqFtraceEvent)
  return target;
}

size_t KvmTimerUpdateIrqFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmTimerUpdateIrqFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 irq = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_irq());
    }

    // optional int32 level = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_level());
    }

    // optional uint64 vcpu_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_vcpu_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmTimerUpdateIrqFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmTimerUpdateIrqFtraceEvent*>(
      &from));
}

void KvmTimerUpdateIrqFtraceEvent::MergeFrom(const KvmTimerUpdateIrqFtraceEvent& from) {
  KvmTimerUpdateIrqFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmTimerUpdateIrqFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.irq_ = from._impl_.irq_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.level_ = from._impl_.level_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.vcpu_id_ = from._impl_.vcpu_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmTimerUpdateIrqFtraceEvent::CopyFrom(const KvmTimerUpdateIrqFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmTimerUpdateIrqFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmTimerUpdateIrqFtraceEvent::IsInitialized() const {
  return true;
}

void KvmTimerUpdateIrqFtraceEvent::InternalSwap(KvmTimerUpdateIrqFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmTimerUpdateIrqFtraceEvent, _impl_.vcpu_id_)
      + sizeof(KvmTimerUpdateIrqFtraceEvent::_impl_.vcpu_id_)
      - PROTOBUF_FIELD_OFFSET(KvmTimerUpdateIrqFtraceEvent, _impl_.irq_)>(
          reinterpret_cast<char*>(&_impl_.irq_),
          reinterpret_cast<char*>(&other->_impl_.irq_));
}

std::string KvmTimerUpdateIrqFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmTimerUpdateIrqFtraceEvent";
}


// ===================================================================

class KvmToggleCacheFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmToggleCacheFtraceEvent>()._impl_._has_bits_);
  static void set_has_now(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vcpu_pc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_was(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

KvmToggleCacheFtraceEvent::KvmToggleCacheFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmToggleCacheFtraceEvent)
}
KvmToggleCacheFtraceEvent::KvmToggleCacheFtraceEvent(const KvmToggleCacheFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KvmToggleCacheFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vcpu_pc_){}
    , decltype(_impl_.now_){}
    , decltype(_impl_.was_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.vcpu_pc_, &from._impl_.vcpu_pc_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.was_) -
    reinterpret_cast<char*>(&_impl_.vcpu_pc_)) + sizeof(_impl_.was_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmToggleCacheFtraceEvent)
}

inline void KvmToggleCacheFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vcpu_pc_){uint64_t{0u}}
    , decltype(_impl_.now_){0u}
    , decltype(_impl_.was_){0u}
  };
}

KvmToggleCacheFtraceEvent::~KvmToggleCacheFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmToggleCacheFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmToggleCacheFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmToggleCacheFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmToggleCacheFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmToggleCacheFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.vcpu_pc_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.was_) -
        reinterpret_cast<char*>(&_impl_.vcpu_pc_)) + sizeof(_impl_.was_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmToggleCacheFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 now = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_now(&has_bits);
          _impl_.now_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 vcpu_pc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_vcpu_pc(&has_bits);
          _impl_.vcpu_pc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 was = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_was(&has_bits);
          _impl_.was_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmToggleCacheFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmToggleCacheFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 now = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_now(), target);
  }

  // optional uint64 vcpu_pc = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_vcpu_pc(), target);
  }

  // optional uint32 was = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_was(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmToggleCacheFtraceEvent)
  return target;
}

size_t KvmToggleCacheFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmToggleCacheFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 vcpu_pc = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_vcpu_pc());
    }

    // optional uint32 now = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_now());
    }

    // optional uint32 was = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_was());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmToggleCacheFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmToggleCacheFtraceEvent*>(
      &from));
}

void KvmToggleCacheFtraceEvent::MergeFrom(const KvmToggleCacheFtraceEvent& from) {
  KvmToggleCacheFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmToggleCacheFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.vcpu_pc_ = from._impl_.vcpu_pc_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.now_ = from._impl_.now_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.was_ = from._impl_.was_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmToggleCacheFtraceEvent::CopyFrom(const KvmToggleCacheFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmToggleCacheFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmToggleCacheFtraceEvent::IsInitialized() const {
  return true;
}

void KvmToggleCacheFtraceEvent::InternalSwap(KvmToggleCacheFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmToggleCacheFtraceEvent, _impl_.was_)
      + sizeof(KvmToggleCacheFtraceEvent::_impl_.was_)
      - PROTOBUF_FIELD_OFFSET(KvmToggleCacheFtraceEvent, _impl_.vcpu_pc_)>(
          reinterpret_cast<char*>(&_impl_.vcpu_pc_),
          reinterpret_cast<char*>(&other->_impl_.vcpu_pc_));
}

std::string KvmToggleCacheFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmToggleCacheFtraceEvent";
}


// ===================================================================

class KvmUnmapHvaRangeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmUnmapHvaRangeFtraceEvent>()._impl_._has_bits_);
  static void set_has_end(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

KvmUnmapHvaRangeFtraceEvent::KvmUnmapHvaRangeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmUnmapHvaRangeFtraceEvent)
}
KvmUnmapHvaRangeFtraceEvent::KvmUnmapHvaRangeFtraceEvent(const KvmUnmapHvaRangeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KvmUnmapHvaRangeFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.end_){}
    , decltype(_impl_.start_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.end_, &from._impl_.end_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.start_) -
    reinterpret_cast<char*>(&_impl_.end_)) + sizeof(_impl_.start_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmUnmapHvaRangeFtraceEvent)
}

inline void KvmUnmapHvaRangeFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.end_){uint64_t{0u}}
    , decltype(_impl_.start_){uint64_t{0u}}
  };
}

KvmUnmapHvaRangeFtraceEvent::~KvmUnmapHvaRangeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmUnmapHvaRangeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmUnmapHvaRangeFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmUnmapHvaRangeFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmUnmapHvaRangeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmUnmapHvaRangeFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.end_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.start_) -
        reinterpret_cast<char*>(&_impl_.end_)) + sizeof(_impl_.start_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmUnmapHvaRangeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 end = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_end(&has_bits);
          _impl_.end_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 start = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_start(&has_bits);
          _impl_.start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmUnmapHvaRangeFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmUnmapHvaRangeFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 end = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_end(), target);
  }

  // optional uint64 start = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_start(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmUnmapHvaRangeFtraceEvent)
  return target;
}

size_t KvmUnmapHvaRangeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmUnmapHvaRangeFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 end = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_end());
    }

    // optional uint64 start = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_start());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmUnmapHvaRangeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmUnmapHvaRangeFtraceEvent*>(
      &from));
}

void KvmUnmapHvaRangeFtraceEvent::MergeFrom(const KvmUnmapHvaRangeFtraceEvent& from) {
  KvmUnmapHvaRangeFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmUnmapHvaRangeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.end_ = from._impl_.end_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.start_ = from._impl_.start_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmUnmapHvaRangeFtraceEvent::CopyFrom(const KvmUnmapHvaRangeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmUnmapHvaRangeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmUnmapHvaRangeFtraceEvent::IsInitialized() const {
  return true;
}

void KvmUnmapHvaRangeFtraceEvent::InternalSwap(KvmUnmapHvaRangeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmUnmapHvaRangeFtraceEvent, _impl_.start_)
      + sizeof(KvmUnmapHvaRangeFtraceEvent::_impl_.start_)
      - PROTOBUF_FIELD_OFFSET(KvmUnmapHvaRangeFtraceEvent, _impl_.end_)>(
          reinterpret_cast<char*>(&_impl_.end_),
          reinterpret_cast<char*>(&other->_impl_.end_));
}

std::string KvmUnmapHvaRangeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmUnmapHvaRangeFtraceEvent";
}


// ===================================================================

class KvmUserspaceExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmUserspaceExitFtraceEvent>()._impl_._has_bits_);
  static void set_has_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmUserspaceExitFtraceEvent::KvmUserspaceExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmUserspaceExitFtraceEvent)
}
KvmUserspaceExitFtraceEvent::KvmUserspaceExitFtraceEvent(const KvmUserspaceExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KvmUserspaceExitFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.reason_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.reason_ = from._impl_.reason_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmUserspaceExitFtraceEvent)
}

inline void KvmUserspaceExitFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.reason_){0u}
  };
}

KvmUserspaceExitFtraceEvent::~KvmUserspaceExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmUserspaceExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmUserspaceExitFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmUserspaceExitFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmUserspaceExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmUserspaceExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.reason_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmUserspaceExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 reason = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_reason(&has_bits);
          _impl_.reason_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmUserspaceExitFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmUserspaceExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 reason = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_reason(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmUserspaceExitFtraceEvent)
  return target;
}

size_t KvmUserspaceExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmUserspaceExitFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 reason = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_reason());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmUserspaceExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmUserspaceExitFtraceEvent*>(
      &from));
}

void KvmUserspaceExitFtraceEvent::MergeFrom(const KvmUserspaceExitFtraceEvent& from) {
  KvmUserspaceExitFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmUserspaceExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_reason()) {
    _this->_internal_set_reason(from._internal_reason());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmUserspaceExitFtraceEvent::CopyFrom(const KvmUserspaceExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmUserspaceExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmUserspaceExitFtraceEvent::IsInitialized() const {
  return true;
}

void KvmUserspaceExitFtraceEvent::InternalSwap(KvmUserspaceExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.reason_, other->_impl_.reason_);
}

std::string KvmUserspaceExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmUserspaceExitFtraceEvent";
}


// ===================================================================

class KvmVcpuWakeupFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmVcpuWakeupFtraceEvent>()._impl_._has_bits_);
  static void set_has_ns(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_valid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_waited(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

KvmVcpuWakeupFtraceEvent::KvmVcpuWakeupFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmVcpuWakeupFtraceEvent)
}
KvmVcpuWakeupFtraceEvent::KvmVcpuWakeupFtraceEvent(const KvmVcpuWakeupFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KvmVcpuWakeupFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ns_){}
    , decltype(_impl_.valid_){}
    , decltype(_impl_.waited_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.ns_, &from._impl_.ns_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.waited_) -
    reinterpret_cast<char*>(&_impl_.ns_)) + sizeof(_impl_.waited_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmVcpuWakeupFtraceEvent)
}

inline void KvmVcpuWakeupFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ns_){uint64_t{0u}}
    , decltype(_impl_.valid_){0u}
    , decltype(_impl_.waited_){0u}
  };
}

KvmVcpuWakeupFtraceEvent::~KvmVcpuWakeupFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmVcpuWakeupFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmVcpuWakeupFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmVcpuWakeupFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmVcpuWakeupFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmVcpuWakeupFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.ns_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.waited_) -
        reinterpret_cast<char*>(&_impl_.ns_)) + sizeof(_impl_.waited_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmVcpuWakeupFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 ns = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ns(&has_bits);
          _impl_.ns_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 valid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_valid(&has_bits);
          _impl_.valid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 waited = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_waited(&has_bits);
          _impl_.waited_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmVcpuWakeupFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmVcpuWakeupFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 ns = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_ns(), target);
  }

  // optional uint32 valid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_valid(), target);
  }

  // optional uint32 waited = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_waited(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmVcpuWakeupFtraceEvent)
  return target;
}

size_t KvmVcpuWakeupFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmVcpuWakeupFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 ns = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ns());
    }

    // optional uint32 valid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_valid());
    }

    // optional uint32 waited = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_waited());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmVcpuWakeupFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmVcpuWakeupFtraceEvent*>(
      &from));
}

void KvmVcpuWakeupFtraceEvent::MergeFrom(const KvmVcpuWakeupFtraceEvent& from) {
  KvmVcpuWakeupFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmVcpuWakeupFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.ns_ = from._impl_.ns_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.valid_ = from._impl_.valid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.waited_ = from._impl_.waited_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmVcpuWakeupFtraceEvent::CopyFrom(const KvmVcpuWakeupFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmVcpuWakeupFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmVcpuWakeupFtraceEvent::IsInitialized() const {
  return true;
}

void KvmVcpuWakeupFtraceEvent::InternalSwap(KvmVcpuWakeupFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmVcpuWakeupFtraceEvent, _impl_.waited_)
      + sizeof(KvmVcpuWakeupFtraceEvent::_impl_.waited_)
      - PROTOBUF_FIELD_OFFSET(KvmVcpuWakeupFtraceEvent, _impl_.ns_)>(
          reinterpret_cast<char*>(&_impl_.ns_),
          reinterpret_cast<char*>(&other->_impl_.ns_));
}

std::string KvmVcpuWakeupFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmVcpuWakeupFtraceEvent";
}


// ===================================================================

class KvmWfxArm64FtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KvmWfxArm64FtraceEvent>()._impl_._has_bits_);
  static void set_has_is_wfe(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vcpu_pc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

KvmWfxArm64FtraceEvent::KvmWfxArm64FtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KvmWfxArm64FtraceEvent)
}
KvmWfxArm64FtraceEvent::KvmWfxArm64FtraceEvent(const KvmWfxArm64FtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KvmWfxArm64FtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vcpu_pc_){}
    , decltype(_impl_.is_wfe_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.vcpu_pc_, &from._impl_.vcpu_pc_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_wfe_) -
    reinterpret_cast<char*>(&_impl_.vcpu_pc_)) + sizeof(_impl_.is_wfe_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KvmWfxArm64FtraceEvent)
}

inline void KvmWfxArm64FtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vcpu_pc_){uint64_t{0u}}
    , decltype(_impl_.is_wfe_){0u}
  };
}

KvmWfxArm64FtraceEvent::~KvmWfxArm64FtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KvmWfxArm64FtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KvmWfxArm64FtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KvmWfxArm64FtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KvmWfxArm64FtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KvmWfxArm64FtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.vcpu_pc_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_wfe_) -
        reinterpret_cast<char*>(&_impl_.vcpu_pc_)) + sizeof(_impl_.is_wfe_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KvmWfxArm64FtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 is_wfe = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_is_wfe(&has_bits);
          _impl_.is_wfe_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 vcpu_pc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_vcpu_pc(&has_bits);
          _impl_.vcpu_pc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvmWfxArm64FtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KvmWfxArm64FtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 is_wfe = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_is_wfe(), target);
  }

  // optional uint64 vcpu_pc = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_vcpu_pc(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KvmWfxArm64FtraceEvent)
  return target;
}

size_t KvmWfxArm64FtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KvmWfxArm64FtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 vcpu_pc = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_vcpu_pc());
    }

    // optional uint32 is_wfe = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_is_wfe());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KvmWfxArm64FtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KvmWfxArm64FtraceEvent*>(
      &from));
}

void KvmWfxArm64FtraceEvent::MergeFrom(const KvmWfxArm64FtraceEvent& from) {
  KvmWfxArm64FtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KvmWfxArm64FtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.vcpu_pc_ = from._impl_.vcpu_pc_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.is_wfe_ = from._impl_.is_wfe_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KvmWfxArm64FtraceEvent::CopyFrom(const KvmWfxArm64FtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KvmWfxArm64FtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvmWfxArm64FtraceEvent::IsInitialized() const {
  return true;
}

void KvmWfxArm64FtraceEvent::InternalSwap(KvmWfxArm64FtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvmWfxArm64FtraceEvent, _impl_.is_wfe_)
      + sizeof(KvmWfxArm64FtraceEvent::_impl_.is_wfe_)
      - PROTOBUF_FIELD_OFFSET(KvmWfxArm64FtraceEvent, _impl_.vcpu_pc_)>(
          reinterpret_cast<char*>(&_impl_.vcpu_pc_),
          reinterpret_cast<char*>(&other->_impl_.vcpu_pc_));
}

std::string KvmWfxArm64FtraceEvent::GetTypeName() const {
  return "perfetto.protos.KvmWfxArm64FtraceEvent";
}


// ===================================================================

class TrapRegFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<TrapRegFtraceEvent>()._impl_._has_bits_);
  static void set_has_fn(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_write(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_reg(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_write_value(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

TrapRegFtraceEvent::TrapRegFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.TrapRegFtraceEvent)
}
TrapRegFtraceEvent::TrapRegFtraceEvent(const TrapRegFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TrapRegFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.fn_){}
    , decltype(_impl_.is_write_){}
    , decltype(_impl_.reg_){}
    , decltype(_impl_.write_value_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.fn_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fn_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_fn()) {
    _this->_impl_.fn_.Set(from._internal_fn(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.is_write_, &from._impl_.is_write_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.write_value_) -
    reinterpret_cast<char*>(&_impl_.is_write_)) + sizeof(_impl_.write_value_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.TrapRegFtraceEvent)
}

inline void TrapRegFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.fn_){}
    , decltype(_impl_.is_write_){0u}
    , decltype(_impl_.reg_){0}
    , decltype(_impl_.write_value_){uint64_t{0u}}
  };
  _impl_.fn_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fn_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TrapRegFtraceEvent::~TrapRegFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.TrapRegFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TrapRegFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.fn_.Destroy();
}

void TrapRegFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TrapRegFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.TrapRegFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.fn_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.is_write_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.write_value_) -
        reinterpret_cast<char*>(&_impl_.is_write_)) + sizeof(_impl_.write_value_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TrapRegFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string fn = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_fn();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 is_write = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_is_write(&has_bits);
          _impl_.is_write_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 reg = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_reg(&has_bits);
          _impl_.reg_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 write_value = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_write_value(&has_bits);
          _impl_.write_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TrapRegFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.TrapRegFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string fn = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_fn(), target);
  }

  // optional uint32 is_write = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_is_write(), target);
  }

  // optional int32 reg = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_reg(), target);
  }

  // optional uint64 write_value = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_write_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.TrapRegFtraceEvent)
  return target;
}

size_t TrapRegFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.TrapRegFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string fn = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_fn());
    }

    // optional uint32 is_write = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_is_write());
    }

    // optional int32 reg = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_reg());
    }

    // optional uint64 write_value = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_write_value());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TrapRegFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TrapRegFtraceEvent*>(
      &from));
}

void TrapRegFtraceEvent::MergeFrom(const TrapRegFtraceEvent& from) {
  TrapRegFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.TrapRegFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_fn(from._internal_fn());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.is_write_ = from._impl_.is_write_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.reg_ = from._impl_.reg_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.write_value_ = from._impl_.write_value_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TrapRegFtraceEvent::CopyFrom(const TrapRegFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.TrapRegFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrapRegFtraceEvent::IsInitialized() const {
  return true;
}

void TrapRegFtraceEvent::InternalSwap(TrapRegFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fn_, lhs_arena,
      &other->_impl_.fn_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TrapRegFtraceEvent, _impl_.write_value_)
      + sizeof(TrapRegFtraceEvent::_impl_.write_value_)
      - PROTOBUF_FIELD_OFFSET(TrapRegFtraceEvent, _impl_.is_write_)>(
          reinterpret_cast<char*>(&_impl_.is_write_),
          reinterpret_cast<char*>(&other->_impl_.is_write_));
}

std::string TrapRegFtraceEvent::GetTypeName() const {
  return "perfetto.protos.TrapRegFtraceEvent";
}


// ===================================================================

class VgicUpdateIrqPendingFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<VgicUpdateIrqPendingFtraceEvent>()._impl_._has_bits_);
  static void set_has_irq(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_level(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vcpu_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

VgicUpdateIrqPendingFtraceEvent::VgicUpdateIrqPendingFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.VgicUpdateIrqPendingFtraceEvent)
}
VgicUpdateIrqPendingFtraceEvent::VgicUpdateIrqPendingFtraceEvent(const VgicUpdateIrqPendingFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  VgicUpdateIrqPendingFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.irq_){}
    , decltype(_impl_.level_){}
    , decltype(_impl_.vcpu_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.irq_, &from._impl_.irq_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.vcpu_id_) -
    reinterpret_cast<char*>(&_impl_.irq_)) + sizeof(_impl_.vcpu_id_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.VgicUpdateIrqPendingFtraceEvent)
}

inline void VgicUpdateIrqPendingFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.irq_){0u}
    , decltype(_impl_.level_){0u}
    , decltype(_impl_.vcpu_id_){uint64_t{0u}}
  };
}

VgicUpdateIrqPendingFtraceEvent::~VgicUpdateIrqPendingFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.VgicUpdateIrqPendingFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VgicUpdateIrqPendingFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VgicUpdateIrqPendingFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VgicUpdateIrqPendingFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.VgicUpdateIrqPendingFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.irq_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.vcpu_id_) -
        reinterpret_cast<char*>(&_impl_.irq_)) + sizeof(_impl_.vcpu_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* VgicUpdateIrqPendingFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 irq = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_irq(&has_bits);
          _impl_.irq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 level = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_level(&has_bits);
          _impl_.level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 vcpu_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_vcpu_id(&has_bits);
          _impl_.vcpu_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VgicUpdateIrqPendingFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.VgicUpdateIrqPendingFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 irq = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_irq(), target);
  }

  // optional uint32 level = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_level(), target);
  }

  // optional uint64 vcpu_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_vcpu_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.VgicUpdateIrqPendingFtraceEvent)
  return target;
}

size_t VgicUpdateIrqPendingFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.VgicUpdateIrqPendingFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 irq = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_irq());
    }

    // optional uint32 level = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_level());
    }

    // optional uint64 vcpu_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_vcpu_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VgicUpdateIrqPendingFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const VgicUpdateIrqPendingFtraceEvent*>(
      &from));
}

void VgicUpdateIrqPendingFtraceEvent::MergeFrom(const VgicUpdateIrqPendingFtraceEvent& from) {
  VgicUpdateIrqPendingFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.VgicUpdateIrqPendingFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.irq_ = from._impl_.irq_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.level_ = from._impl_.level_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.vcpu_id_ = from._impl_.vcpu_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void VgicUpdateIrqPendingFtraceEvent::CopyFrom(const VgicUpdateIrqPendingFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.VgicUpdateIrqPendingFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VgicUpdateIrqPendingFtraceEvent::IsInitialized() const {
  return true;
}

void VgicUpdateIrqPendingFtraceEvent::InternalSwap(VgicUpdateIrqPendingFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VgicUpdateIrqPendingFtraceEvent, _impl_.vcpu_id_)
      + sizeof(VgicUpdateIrqPendingFtraceEvent::_impl_.vcpu_id_)
      - PROTOBUF_FIELD_OFFSET(VgicUpdateIrqPendingFtraceEvent, _impl_.irq_)>(
          reinterpret_cast<char*>(&_impl_.irq_),
          reinterpret_cast<char*>(&other->_impl_.irq_));
}

std::string VgicUpdateIrqPendingFtraceEvent::GetTypeName() const {
  return "perfetto.protos.VgicUpdateIrqPendingFtraceEvent";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace protos
}  // namespace perfetto
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmAccessFaultFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmAccessFaultFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmAccessFaultFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmAckIrqFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmAckIrqFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmAckIrqFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmAgeHvaFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmAgeHvaFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmAgeHvaFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmAgePageFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmAgePageFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmAgePageFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmArmClearDebugFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmArmClearDebugFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmArmClearDebugFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmArmSetDreg32FtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmArmSetDreg32FtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmArmSetDreg32FtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmArmSetRegsetFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmArmSetRegsetFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmArmSetRegsetFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmArmSetupDebugFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmArmSetupDebugFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmArmSetupDebugFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmEntryFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmEntryFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmEntryFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmFpuFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmFpuFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmFpuFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmGetTimerMapFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmGetTimerMapFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmGetTimerMapFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmGuestFaultFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmGuestFaultFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmGuestFaultFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmHandleSysRegFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmHandleSysRegFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmHandleSysRegFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmHvcArm64FtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmHvcArm64FtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmHvcArm64FtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmIrqLineFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmIrqLineFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmIrqLineFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmMmioFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmMmioFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmMmioFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmMmioEmulateFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmMmioEmulateFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmMmioEmulateFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmSetGuestDebugFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmSetGuestDebugFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmSetGuestDebugFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmSetIrqFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmSetIrqFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmSetIrqFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmSetSpteHvaFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmSetSpteHvaFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmSetSpteHvaFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmSetWayFlushFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmSetWayFlushFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmSetWayFlushFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmSysAccessFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmSysAccessFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmSysAccessFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmTestAgeHvaFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmTestAgeHvaFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmTestAgeHvaFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmTimerEmulateFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmTimerEmulateFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmTimerEmulateFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmTimerHrtimerExpireFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmTimerHrtimerExpireFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmTimerHrtimerExpireFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmTimerRestoreStateFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmTimerRestoreStateFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmTimerRestoreStateFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmTimerSaveStateFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmTimerSaveStateFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmTimerSaveStateFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmTimerUpdateIrqFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmTimerUpdateIrqFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmTimerUpdateIrqFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmToggleCacheFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmToggleCacheFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmToggleCacheFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmUnmapHvaRangeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmUnmapHvaRangeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmUnmapHvaRangeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmUserspaceExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmUserspaceExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmUserspaceExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmVcpuWakeupFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmVcpuWakeupFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmVcpuWakeupFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KvmWfxArm64FtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KvmWfxArm64FtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KvmWfxArm64FtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::TrapRegFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::TrapRegFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::TrapRegFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::VgicUpdateIrqPendingFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::VgicUpdateIrqPendingFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::VgicUpdateIrqPendingFtraceEvent >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
