// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/trace/ftrace/sched.proto

#include "protos/perfetto/trace/ftrace/sched.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace perfetto {
namespace protos {
PROTOBUF_CONSTEXPR SchedSwitchFtraceEvent::SchedSwitchFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.prev_comm_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.next_comm_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.prev_pid_)*/0
  , /*decltype(_impl_.prev_prio_)*/0
  , /*decltype(_impl_.prev_state_)*/int64_t{0}
  , /*decltype(_impl_.next_pid_)*/0
  , /*decltype(_impl_.next_prio_)*/0} {}
struct SchedSwitchFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedSwitchFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedSwitchFtraceEventDefaultTypeInternal() {}
  union {
    SchedSwitchFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedSwitchFtraceEventDefaultTypeInternal _SchedSwitchFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR SchedWakeupFtraceEvent::SchedWakeupFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.comm_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pid_)*/0
  , /*decltype(_impl_.prio_)*/0
  , /*decltype(_impl_.success_)*/0
  , /*decltype(_impl_.target_cpu_)*/0} {}
struct SchedWakeupFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedWakeupFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedWakeupFtraceEventDefaultTypeInternal() {}
  union {
    SchedWakeupFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedWakeupFtraceEventDefaultTypeInternal _SchedWakeupFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR SchedBlockedReasonFtraceEvent::SchedBlockedReasonFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.caller_)*/uint64_t{0u}
  , /*decltype(_impl_.pid_)*/0
  , /*decltype(_impl_.io_wait_)*/0u} {}
struct SchedBlockedReasonFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedBlockedReasonFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedBlockedReasonFtraceEventDefaultTypeInternal() {}
  union {
    SchedBlockedReasonFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedBlockedReasonFtraceEventDefaultTypeInternal _SchedBlockedReasonFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR SchedCpuHotplugFtraceEvent::SchedCpuHotplugFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.affected_cpu_)*/0
  , /*decltype(_impl_.error_)*/0
  , /*decltype(_impl_.status_)*/0} {}
struct SchedCpuHotplugFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedCpuHotplugFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedCpuHotplugFtraceEventDefaultTypeInternal() {}
  union {
    SchedCpuHotplugFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedCpuHotplugFtraceEventDefaultTypeInternal _SchedCpuHotplugFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR SchedWakingFtraceEvent::SchedWakingFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.comm_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pid_)*/0
  , /*decltype(_impl_.prio_)*/0
  , /*decltype(_impl_.success_)*/0
  , /*decltype(_impl_.target_cpu_)*/0} {}
struct SchedWakingFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedWakingFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedWakingFtraceEventDefaultTypeInternal() {}
  union {
    SchedWakingFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedWakingFtraceEventDefaultTypeInternal _SchedWakingFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR SchedWakeupNewFtraceEvent::SchedWakeupNewFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.comm_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pid_)*/0
  , /*decltype(_impl_.prio_)*/0
  , /*decltype(_impl_.success_)*/0
  , /*decltype(_impl_.target_cpu_)*/0} {}
struct SchedWakeupNewFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedWakeupNewFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedWakeupNewFtraceEventDefaultTypeInternal() {}
  union {
    SchedWakeupNewFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedWakeupNewFtraceEventDefaultTypeInternal _SchedWakeupNewFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR SchedProcessExecFtraceEvent::SchedProcessExecFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.filename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pid_)*/0
  , /*decltype(_impl_.old_pid_)*/0} {}
struct SchedProcessExecFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedProcessExecFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedProcessExecFtraceEventDefaultTypeInternal() {}
  union {
    SchedProcessExecFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedProcessExecFtraceEventDefaultTypeInternal _SchedProcessExecFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR SchedProcessExitFtraceEvent::SchedProcessExitFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.comm_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pid_)*/0
  , /*decltype(_impl_.tgid_)*/0
  , /*decltype(_impl_.prio_)*/0} {}
struct SchedProcessExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedProcessExitFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedProcessExitFtraceEventDefaultTypeInternal() {}
  union {
    SchedProcessExitFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedProcessExitFtraceEventDefaultTypeInternal _SchedProcessExitFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR SchedProcessForkFtraceEvent::SchedProcessForkFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.parent_comm_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.child_comm_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.parent_pid_)*/0
  , /*decltype(_impl_.child_pid_)*/0} {}
struct SchedProcessForkFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedProcessForkFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedProcessForkFtraceEventDefaultTypeInternal() {}
  union {
    SchedProcessForkFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedProcessForkFtraceEventDefaultTypeInternal _SchedProcessForkFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR SchedProcessFreeFtraceEvent::SchedProcessFreeFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.comm_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pid_)*/0
  , /*decltype(_impl_.prio_)*/0} {}
struct SchedProcessFreeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedProcessFreeFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedProcessFreeFtraceEventDefaultTypeInternal() {}
  union {
    SchedProcessFreeFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedProcessFreeFtraceEventDefaultTypeInternal _SchedProcessFreeFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR SchedProcessHangFtraceEvent::SchedProcessHangFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.comm_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pid_)*/0} {}
struct SchedProcessHangFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedProcessHangFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedProcessHangFtraceEventDefaultTypeInternal() {}
  union {
    SchedProcessHangFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedProcessHangFtraceEventDefaultTypeInternal _SchedProcessHangFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR SchedProcessWaitFtraceEvent::SchedProcessWaitFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.comm_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pid_)*/0
  , /*decltype(_impl_.prio_)*/0} {}
struct SchedProcessWaitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedProcessWaitFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedProcessWaitFtraceEventDefaultTypeInternal() {}
  union {
    SchedProcessWaitFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedProcessWaitFtraceEventDefaultTypeInternal _SchedProcessWaitFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR SchedPiSetprioFtraceEvent::SchedPiSetprioFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.comm_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.newprio_)*/0
  , /*decltype(_impl_.oldprio_)*/0
  , /*decltype(_impl_.pid_)*/0} {}
struct SchedPiSetprioFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedPiSetprioFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedPiSetprioFtraceEventDefaultTypeInternal() {}
  union {
    SchedPiSetprioFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedPiSetprioFtraceEventDefaultTypeInternal _SchedPiSetprioFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR SchedCpuUtilCfsFtraceEvent::SchedCpuUtilCfsFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.capacity_)*/uint64_t{0u}
  , /*decltype(_impl_.active_)*/0
  , /*decltype(_impl_.cpu_)*/0u
  , /*decltype(_impl_.capacity_orig_)*/uint64_t{0u}
  , /*decltype(_impl_.cpu_importance_)*/uint64_t{0u}
  , /*decltype(_impl_.cpu_util_)*/uint64_t{0u}
  , /*decltype(_impl_.group_capacity_)*/uint64_t{0u}
  , /*decltype(_impl_.exit_lat_)*/0u
  , /*decltype(_impl_.grp_overutilized_)*/0u
  , /*decltype(_impl_.idle_cpu_)*/0u
  , /*decltype(_impl_.nr_running_)*/0u
  , /*decltype(_impl_.spare_cap_)*/int64_t{0}
  , /*decltype(_impl_.wake_group_util_)*/uint64_t{0u}
  , /*decltype(_impl_.wake_util_)*/uint64_t{0u}
  , /*decltype(_impl_.task_fits_)*/0u} {}
struct SchedCpuUtilCfsFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedCpuUtilCfsFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedCpuUtilCfsFtraceEventDefaultTypeInternal() {}
  union {
    SchedCpuUtilCfsFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedCpuUtilCfsFtraceEventDefaultTypeInternal _SchedCpuUtilCfsFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR SchedMigrateTaskFtraceEvent::SchedMigrateTaskFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.comm_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pid_)*/0
  , /*decltype(_impl_.prio_)*/0
  , /*decltype(_impl_.orig_cpu_)*/0
  , /*decltype(_impl_.dest_cpu_)*/0
  , /*decltype(_impl_.running_)*/0
  , /*decltype(_impl_.load_)*/0u} {}
struct SchedMigrateTaskFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchedMigrateTaskFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchedMigrateTaskFtraceEventDefaultTypeInternal() {}
  union {
    SchedMigrateTaskFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchedMigrateTaskFtraceEventDefaultTypeInternal _SchedMigrateTaskFtraceEvent_default_instance_;
}  // namespace protos
}  // namespace perfetto
namespace perfetto {
namespace protos {

// ===================================================================

class SchedSwitchFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedSwitchFtraceEvent>()._impl_._has_bits_);
  static void set_has_prev_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_prev_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_prev_prio(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_prev_state(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_next_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_next_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_next_prio(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

SchedSwitchFtraceEvent::SchedSwitchFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedSwitchFtraceEvent)
}
SchedSwitchFtraceEvent::SchedSwitchFtraceEvent(const SchedSwitchFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SchedSwitchFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.prev_comm_){}
    , decltype(_impl_.next_comm_){}
    , decltype(_impl_.prev_pid_){}
    , decltype(_impl_.prev_prio_){}
    , decltype(_impl_.prev_state_){}
    , decltype(_impl_.next_pid_){}
    , decltype(_impl_.next_prio_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.prev_comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.prev_comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_prev_comm()) {
    _this->_impl_.prev_comm_.Set(from._internal_prev_comm(), 
      _this->GetArenaForAllocation());
  }
  _impl_.next_comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.next_comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_next_comm()) {
    _this->_impl_.next_comm_.Set(from._internal_next_comm(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.prev_pid_, &from._impl_.prev_pid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.next_prio_) -
    reinterpret_cast<char*>(&_impl_.prev_pid_)) + sizeof(_impl_.next_prio_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedSwitchFtraceEvent)
}

inline void SchedSwitchFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.prev_comm_){}
    , decltype(_impl_.next_comm_){}
    , decltype(_impl_.prev_pid_){0}
    , decltype(_impl_.prev_prio_){0}
    , decltype(_impl_.prev_state_){int64_t{0}}
    , decltype(_impl_.next_pid_){0}
    , decltype(_impl_.next_prio_){0}
  };
  _impl_.prev_comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.prev_comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.next_comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.next_comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SchedSwitchFtraceEvent::~SchedSwitchFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedSwitchFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedSwitchFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.prev_comm_.Destroy();
  _impl_.next_comm_.Destroy();
}

void SchedSwitchFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SchedSwitchFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedSwitchFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.prev_comm_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.next_comm_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000007cu) {
    ::memset(&_impl_.prev_pid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.next_prio_) -
        reinterpret_cast<char*>(&_impl_.prev_pid_)) + sizeof(_impl_.next_prio_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SchedSwitchFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string prev_comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_prev_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 prev_pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_prev_pid(&has_bits);
          _impl_.prev_pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 prev_prio = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_prev_prio(&has_bits);
          _impl_.prev_prio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 prev_state = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_prev_state(&has_bits);
          _impl_.prev_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string next_comm = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_next_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 next_pid = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_next_pid(&has_bits);
          _impl_.next_pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 next_prio = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_next_prio(&has_bits);
          _impl_.next_prio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SchedSwitchFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedSwitchFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string prev_comm = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_prev_comm(), target);
  }

  // optional int32 prev_pid = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_prev_pid(), target);
  }

  // optional int32 prev_prio = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_prev_prio(), target);
  }

  // optional int64 prev_state = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_prev_state(), target);
  }

  // optional string next_comm = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_next_comm(), target);
  }

  // optional int32 next_pid = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_next_pid(), target);
  }

  // optional int32 next_prio = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_next_prio(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedSwitchFtraceEvent)
  return target;
}

size_t SchedSwitchFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedSwitchFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string prev_comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_prev_comm());
    }

    // optional string next_comm = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_next_comm());
    }

    // optional int32 prev_pid = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_prev_pid());
    }

    // optional int32 prev_prio = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_prev_prio());
    }

    // optional int64 prev_state = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_prev_state());
    }

    // optional int32 next_pid = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_next_pid());
    }

    // optional int32 next_prio = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_next_prio());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedSwitchFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SchedSwitchFtraceEvent*>(
      &from));
}

void SchedSwitchFtraceEvent::MergeFrom(const SchedSwitchFtraceEvent& from) {
  SchedSwitchFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedSwitchFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_prev_comm(from._internal_prev_comm());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_next_comm(from._internal_next_comm());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.prev_pid_ = from._impl_.prev_pid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.prev_prio_ = from._impl_.prev_prio_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.prev_state_ = from._impl_.prev_state_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.next_pid_ = from._impl_.next_pid_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.next_prio_ = from._impl_.next_prio_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SchedSwitchFtraceEvent::CopyFrom(const SchedSwitchFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedSwitchFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedSwitchFtraceEvent::IsInitialized() const {
  return true;
}

void SchedSwitchFtraceEvent::InternalSwap(SchedSwitchFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.prev_comm_, lhs_arena,
      &other->_impl_.prev_comm_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.next_comm_, lhs_arena,
      &other->_impl_.next_comm_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedSwitchFtraceEvent, _impl_.next_prio_)
      + sizeof(SchedSwitchFtraceEvent::_impl_.next_prio_)
      - PROTOBUF_FIELD_OFFSET(SchedSwitchFtraceEvent, _impl_.prev_pid_)>(
          reinterpret_cast<char*>(&_impl_.prev_pid_),
          reinterpret_cast<char*>(&other->_impl_.prev_pid_));
}

std::string SchedSwitchFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedSwitchFtraceEvent";
}


// ===================================================================

class SchedWakeupFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedWakeupFtraceEvent>()._impl_._has_bits_);
  static void set_has_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_prio(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_success(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_target_cpu(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

SchedWakeupFtraceEvent::SchedWakeupFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedWakeupFtraceEvent)
}
SchedWakeupFtraceEvent::SchedWakeupFtraceEvent(const SchedWakeupFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SchedWakeupFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comm_){}
    , decltype(_impl_.pid_){}
    , decltype(_impl_.prio_){}
    , decltype(_impl_.success_){}
    , decltype(_impl_.target_cpu_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_comm()) {
    _this->_impl_.comm_.Set(from._internal_comm(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.pid_, &from._impl_.pid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.target_cpu_) -
    reinterpret_cast<char*>(&_impl_.pid_)) + sizeof(_impl_.target_cpu_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedWakeupFtraceEvent)
}

inline void SchedWakeupFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comm_){}
    , decltype(_impl_.pid_){0}
    , decltype(_impl_.prio_){0}
    , decltype(_impl_.success_){0}
    , decltype(_impl_.target_cpu_){0}
  };
  _impl_.comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SchedWakeupFtraceEvent::~SchedWakeupFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedWakeupFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedWakeupFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.comm_.Destroy();
}

void SchedWakeupFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SchedWakeupFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedWakeupFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.comm_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.pid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.target_cpu_) -
        reinterpret_cast<char*>(&_impl_.pid_)) + sizeof(_impl_.target_cpu_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SchedWakeupFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_pid(&has_bits);
          _impl_.pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 prio = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_prio(&has_bits);
          _impl_.prio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 success = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_success(&has_bits);
          _impl_.success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 target_cpu = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_target_cpu(&has_bits);
          _impl_.target_cpu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SchedWakeupFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedWakeupFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string comm = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_comm(), target);
  }

  // optional int32 pid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_pid(), target);
  }

  // optional int32 prio = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_prio(), target);
  }

  // optional int32 success = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_success(), target);
  }

  // optional int32 target_cpu = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_target_cpu(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedWakeupFtraceEvent)
  return target;
}

size_t SchedWakeupFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedWakeupFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_comm());
    }

    // optional int32 pid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pid());
    }

    // optional int32 prio = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_prio());
    }

    // optional int32 success = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_success());
    }

    // optional int32 target_cpu = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_target_cpu());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedWakeupFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SchedWakeupFtraceEvent*>(
      &from));
}

void SchedWakeupFtraceEvent::MergeFrom(const SchedWakeupFtraceEvent& from) {
  SchedWakeupFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedWakeupFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_comm(from._internal_comm());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pid_ = from._impl_.pid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.prio_ = from._impl_.prio_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.success_ = from._impl_.success_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.target_cpu_ = from._impl_.target_cpu_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SchedWakeupFtraceEvent::CopyFrom(const SchedWakeupFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedWakeupFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedWakeupFtraceEvent::IsInitialized() const {
  return true;
}

void SchedWakeupFtraceEvent::InternalSwap(SchedWakeupFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.comm_, lhs_arena,
      &other->_impl_.comm_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedWakeupFtraceEvent, _impl_.target_cpu_)
      + sizeof(SchedWakeupFtraceEvent::_impl_.target_cpu_)
      - PROTOBUF_FIELD_OFFSET(SchedWakeupFtraceEvent, _impl_.pid_)>(
          reinterpret_cast<char*>(&_impl_.pid_),
          reinterpret_cast<char*>(&other->_impl_.pid_));
}

std::string SchedWakeupFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedWakeupFtraceEvent";
}


// ===================================================================

class SchedBlockedReasonFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedBlockedReasonFtraceEvent>()._impl_._has_bits_);
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_caller(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_io_wait(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

SchedBlockedReasonFtraceEvent::SchedBlockedReasonFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedBlockedReasonFtraceEvent)
}
SchedBlockedReasonFtraceEvent::SchedBlockedReasonFtraceEvent(const SchedBlockedReasonFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SchedBlockedReasonFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.caller_){}
    , decltype(_impl_.pid_){}
    , decltype(_impl_.io_wait_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.caller_, &from._impl_.caller_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.io_wait_) -
    reinterpret_cast<char*>(&_impl_.caller_)) + sizeof(_impl_.io_wait_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedBlockedReasonFtraceEvent)
}

inline void SchedBlockedReasonFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.caller_){uint64_t{0u}}
    , decltype(_impl_.pid_){0}
    , decltype(_impl_.io_wait_){0u}
  };
}

SchedBlockedReasonFtraceEvent::~SchedBlockedReasonFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedBlockedReasonFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedBlockedReasonFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SchedBlockedReasonFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SchedBlockedReasonFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedBlockedReasonFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.caller_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.io_wait_) -
        reinterpret_cast<char*>(&_impl_.caller_)) + sizeof(_impl_.io_wait_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SchedBlockedReasonFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 pid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_pid(&has_bits);
          _impl_.pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 caller = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_caller(&has_bits);
          _impl_.caller_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 io_wait = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_io_wait(&has_bits);
          _impl_.io_wait_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SchedBlockedReasonFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedBlockedReasonFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 pid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_pid(), target);
  }

  // optional uint64 caller = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_caller(), target);
  }

  // optional uint32 io_wait = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_io_wait(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedBlockedReasonFtraceEvent)
  return target;
}

size_t SchedBlockedReasonFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedBlockedReasonFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 caller = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_caller());
    }

    // optional int32 pid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pid());
    }

    // optional uint32 io_wait = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_io_wait());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedBlockedReasonFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SchedBlockedReasonFtraceEvent*>(
      &from));
}

void SchedBlockedReasonFtraceEvent::MergeFrom(const SchedBlockedReasonFtraceEvent& from) {
  SchedBlockedReasonFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedBlockedReasonFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.caller_ = from._impl_.caller_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pid_ = from._impl_.pid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.io_wait_ = from._impl_.io_wait_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SchedBlockedReasonFtraceEvent::CopyFrom(const SchedBlockedReasonFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedBlockedReasonFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedBlockedReasonFtraceEvent::IsInitialized() const {
  return true;
}

void SchedBlockedReasonFtraceEvent::InternalSwap(SchedBlockedReasonFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedBlockedReasonFtraceEvent, _impl_.io_wait_)
      + sizeof(SchedBlockedReasonFtraceEvent::_impl_.io_wait_)
      - PROTOBUF_FIELD_OFFSET(SchedBlockedReasonFtraceEvent, _impl_.caller_)>(
          reinterpret_cast<char*>(&_impl_.caller_),
          reinterpret_cast<char*>(&other->_impl_.caller_));
}

std::string SchedBlockedReasonFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedBlockedReasonFtraceEvent";
}


// ===================================================================

class SchedCpuHotplugFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedCpuHotplugFtraceEvent>()._impl_._has_bits_);
  static void set_has_affected_cpu(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

SchedCpuHotplugFtraceEvent::SchedCpuHotplugFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedCpuHotplugFtraceEvent)
}
SchedCpuHotplugFtraceEvent::SchedCpuHotplugFtraceEvent(const SchedCpuHotplugFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SchedCpuHotplugFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.affected_cpu_){}
    , decltype(_impl_.error_){}
    , decltype(_impl_.status_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.affected_cpu_, &from._impl_.affected_cpu_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.status_) -
    reinterpret_cast<char*>(&_impl_.affected_cpu_)) + sizeof(_impl_.status_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedCpuHotplugFtraceEvent)
}

inline void SchedCpuHotplugFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.affected_cpu_){0}
    , decltype(_impl_.error_){0}
    , decltype(_impl_.status_){0}
  };
}

SchedCpuHotplugFtraceEvent::~SchedCpuHotplugFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedCpuHotplugFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedCpuHotplugFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SchedCpuHotplugFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SchedCpuHotplugFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedCpuHotplugFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.affected_cpu_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.status_) -
        reinterpret_cast<char*>(&_impl_.affected_cpu_)) + sizeof(_impl_.status_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SchedCpuHotplugFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 affected_cpu = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_affected_cpu(&has_bits);
          _impl_.affected_cpu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 error = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_error(&has_bits);
          _impl_.error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_status(&has_bits);
          _impl_.status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SchedCpuHotplugFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedCpuHotplugFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 affected_cpu = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_affected_cpu(), target);
  }

  // optional int32 error = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_error(), target);
  }

  // optional int32 status = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedCpuHotplugFtraceEvent)
  return target;
}

size_t SchedCpuHotplugFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedCpuHotplugFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int32 affected_cpu = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_affected_cpu());
    }

    // optional int32 error = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_error());
    }

    // optional int32 status = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_status());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedCpuHotplugFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SchedCpuHotplugFtraceEvent*>(
      &from));
}

void SchedCpuHotplugFtraceEvent::MergeFrom(const SchedCpuHotplugFtraceEvent& from) {
  SchedCpuHotplugFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedCpuHotplugFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.affected_cpu_ = from._impl_.affected_cpu_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.error_ = from._impl_.error_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.status_ = from._impl_.status_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SchedCpuHotplugFtraceEvent::CopyFrom(const SchedCpuHotplugFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedCpuHotplugFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedCpuHotplugFtraceEvent::IsInitialized() const {
  return true;
}

void SchedCpuHotplugFtraceEvent::InternalSwap(SchedCpuHotplugFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedCpuHotplugFtraceEvent, _impl_.status_)
      + sizeof(SchedCpuHotplugFtraceEvent::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(SchedCpuHotplugFtraceEvent, _impl_.affected_cpu_)>(
          reinterpret_cast<char*>(&_impl_.affected_cpu_),
          reinterpret_cast<char*>(&other->_impl_.affected_cpu_));
}

std::string SchedCpuHotplugFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedCpuHotplugFtraceEvent";
}


// ===================================================================

class SchedWakingFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedWakingFtraceEvent>()._impl_._has_bits_);
  static void set_has_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_prio(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_success(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_target_cpu(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

SchedWakingFtraceEvent::SchedWakingFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedWakingFtraceEvent)
}
SchedWakingFtraceEvent::SchedWakingFtraceEvent(const SchedWakingFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SchedWakingFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comm_){}
    , decltype(_impl_.pid_){}
    , decltype(_impl_.prio_){}
    , decltype(_impl_.success_){}
    , decltype(_impl_.target_cpu_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_comm()) {
    _this->_impl_.comm_.Set(from._internal_comm(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.pid_, &from._impl_.pid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.target_cpu_) -
    reinterpret_cast<char*>(&_impl_.pid_)) + sizeof(_impl_.target_cpu_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedWakingFtraceEvent)
}

inline void SchedWakingFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comm_){}
    , decltype(_impl_.pid_){0}
    , decltype(_impl_.prio_){0}
    , decltype(_impl_.success_){0}
    , decltype(_impl_.target_cpu_){0}
  };
  _impl_.comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SchedWakingFtraceEvent::~SchedWakingFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedWakingFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedWakingFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.comm_.Destroy();
}

void SchedWakingFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SchedWakingFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedWakingFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.comm_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.pid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.target_cpu_) -
        reinterpret_cast<char*>(&_impl_.pid_)) + sizeof(_impl_.target_cpu_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SchedWakingFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_pid(&has_bits);
          _impl_.pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 prio = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_prio(&has_bits);
          _impl_.prio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 success = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_success(&has_bits);
          _impl_.success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 target_cpu = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_target_cpu(&has_bits);
          _impl_.target_cpu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SchedWakingFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedWakingFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string comm = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_comm(), target);
  }

  // optional int32 pid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_pid(), target);
  }

  // optional int32 prio = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_prio(), target);
  }

  // optional int32 success = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_success(), target);
  }

  // optional int32 target_cpu = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_target_cpu(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedWakingFtraceEvent)
  return target;
}

size_t SchedWakingFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedWakingFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_comm());
    }

    // optional int32 pid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pid());
    }

    // optional int32 prio = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_prio());
    }

    // optional int32 success = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_success());
    }

    // optional int32 target_cpu = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_target_cpu());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedWakingFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SchedWakingFtraceEvent*>(
      &from));
}

void SchedWakingFtraceEvent::MergeFrom(const SchedWakingFtraceEvent& from) {
  SchedWakingFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedWakingFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_comm(from._internal_comm());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pid_ = from._impl_.pid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.prio_ = from._impl_.prio_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.success_ = from._impl_.success_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.target_cpu_ = from._impl_.target_cpu_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SchedWakingFtraceEvent::CopyFrom(const SchedWakingFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedWakingFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedWakingFtraceEvent::IsInitialized() const {
  return true;
}

void SchedWakingFtraceEvent::InternalSwap(SchedWakingFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.comm_, lhs_arena,
      &other->_impl_.comm_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedWakingFtraceEvent, _impl_.target_cpu_)
      + sizeof(SchedWakingFtraceEvent::_impl_.target_cpu_)
      - PROTOBUF_FIELD_OFFSET(SchedWakingFtraceEvent, _impl_.pid_)>(
          reinterpret_cast<char*>(&_impl_.pid_),
          reinterpret_cast<char*>(&other->_impl_.pid_));
}

std::string SchedWakingFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedWakingFtraceEvent";
}


// ===================================================================

class SchedWakeupNewFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedWakeupNewFtraceEvent>()._impl_._has_bits_);
  static void set_has_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_prio(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_success(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_target_cpu(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

SchedWakeupNewFtraceEvent::SchedWakeupNewFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedWakeupNewFtraceEvent)
}
SchedWakeupNewFtraceEvent::SchedWakeupNewFtraceEvent(const SchedWakeupNewFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SchedWakeupNewFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comm_){}
    , decltype(_impl_.pid_){}
    , decltype(_impl_.prio_){}
    , decltype(_impl_.success_){}
    , decltype(_impl_.target_cpu_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_comm()) {
    _this->_impl_.comm_.Set(from._internal_comm(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.pid_, &from._impl_.pid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.target_cpu_) -
    reinterpret_cast<char*>(&_impl_.pid_)) + sizeof(_impl_.target_cpu_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedWakeupNewFtraceEvent)
}

inline void SchedWakeupNewFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comm_){}
    , decltype(_impl_.pid_){0}
    , decltype(_impl_.prio_){0}
    , decltype(_impl_.success_){0}
    , decltype(_impl_.target_cpu_){0}
  };
  _impl_.comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SchedWakeupNewFtraceEvent::~SchedWakeupNewFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedWakeupNewFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedWakeupNewFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.comm_.Destroy();
}

void SchedWakeupNewFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SchedWakeupNewFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedWakeupNewFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.comm_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.pid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.target_cpu_) -
        reinterpret_cast<char*>(&_impl_.pid_)) + sizeof(_impl_.target_cpu_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SchedWakeupNewFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_pid(&has_bits);
          _impl_.pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 prio = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_prio(&has_bits);
          _impl_.prio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 success = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_success(&has_bits);
          _impl_.success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 target_cpu = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_target_cpu(&has_bits);
          _impl_.target_cpu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SchedWakeupNewFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedWakeupNewFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string comm = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_comm(), target);
  }

  // optional int32 pid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_pid(), target);
  }

  // optional int32 prio = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_prio(), target);
  }

  // optional int32 success = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_success(), target);
  }

  // optional int32 target_cpu = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_target_cpu(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedWakeupNewFtraceEvent)
  return target;
}

size_t SchedWakeupNewFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedWakeupNewFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_comm());
    }

    // optional int32 pid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pid());
    }

    // optional int32 prio = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_prio());
    }

    // optional int32 success = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_success());
    }

    // optional int32 target_cpu = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_target_cpu());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedWakeupNewFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SchedWakeupNewFtraceEvent*>(
      &from));
}

void SchedWakeupNewFtraceEvent::MergeFrom(const SchedWakeupNewFtraceEvent& from) {
  SchedWakeupNewFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedWakeupNewFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_comm(from._internal_comm());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pid_ = from._impl_.pid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.prio_ = from._impl_.prio_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.success_ = from._impl_.success_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.target_cpu_ = from._impl_.target_cpu_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SchedWakeupNewFtraceEvent::CopyFrom(const SchedWakeupNewFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedWakeupNewFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedWakeupNewFtraceEvent::IsInitialized() const {
  return true;
}

void SchedWakeupNewFtraceEvent::InternalSwap(SchedWakeupNewFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.comm_, lhs_arena,
      &other->_impl_.comm_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedWakeupNewFtraceEvent, _impl_.target_cpu_)
      + sizeof(SchedWakeupNewFtraceEvent::_impl_.target_cpu_)
      - PROTOBUF_FIELD_OFFSET(SchedWakeupNewFtraceEvent, _impl_.pid_)>(
          reinterpret_cast<char*>(&_impl_.pid_),
          reinterpret_cast<char*>(&other->_impl_.pid_));
}

std::string SchedWakeupNewFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedWakeupNewFtraceEvent";
}


// ===================================================================

class SchedProcessExecFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedProcessExecFtraceEvent>()._impl_._has_bits_);
  static void set_has_filename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_old_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

SchedProcessExecFtraceEvent::SchedProcessExecFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedProcessExecFtraceEvent)
}
SchedProcessExecFtraceEvent::SchedProcessExecFtraceEvent(const SchedProcessExecFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SchedProcessExecFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.filename_){}
    , decltype(_impl_.pid_){}
    , decltype(_impl_.old_pid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_filename()) {
    _this->_impl_.filename_.Set(from._internal_filename(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.pid_, &from._impl_.pid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.old_pid_) -
    reinterpret_cast<char*>(&_impl_.pid_)) + sizeof(_impl_.old_pid_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedProcessExecFtraceEvent)
}

inline void SchedProcessExecFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.filename_){}
    , decltype(_impl_.pid_){0}
    , decltype(_impl_.old_pid_){0}
  };
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SchedProcessExecFtraceEvent::~SchedProcessExecFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedProcessExecFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedProcessExecFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.filename_.Destroy();
}

void SchedProcessExecFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SchedProcessExecFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedProcessExecFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.filename_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.pid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.old_pid_) -
        reinterpret_cast<char*>(&_impl_.pid_)) + sizeof(_impl_.old_pid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SchedProcessExecFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string filename = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_filename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_pid(&has_bits);
          _impl_.pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 old_pid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_old_pid(&has_bits);
          _impl_.old_pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SchedProcessExecFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedProcessExecFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string filename = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_filename(), target);
  }

  // optional int32 pid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_pid(), target);
  }

  // optional int32 old_pid = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_old_pid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedProcessExecFtraceEvent)
  return target;
}

size_t SchedProcessExecFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedProcessExecFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string filename = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_filename());
    }

    // optional int32 pid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pid());
    }

    // optional int32 old_pid = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_old_pid());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedProcessExecFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SchedProcessExecFtraceEvent*>(
      &from));
}

void SchedProcessExecFtraceEvent::MergeFrom(const SchedProcessExecFtraceEvent& from) {
  SchedProcessExecFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedProcessExecFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_filename(from._internal_filename());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pid_ = from._impl_.pid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.old_pid_ = from._impl_.old_pid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SchedProcessExecFtraceEvent::CopyFrom(const SchedProcessExecFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedProcessExecFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedProcessExecFtraceEvent::IsInitialized() const {
  return true;
}

void SchedProcessExecFtraceEvent::InternalSwap(SchedProcessExecFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.filename_, lhs_arena,
      &other->_impl_.filename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedProcessExecFtraceEvent, _impl_.old_pid_)
      + sizeof(SchedProcessExecFtraceEvent::_impl_.old_pid_)
      - PROTOBUF_FIELD_OFFSET(SchedProcessExecFtraceEvent, _impl_.pid_)>(
          reinterpret_cast<char*>(&_impl_.pid_),
          reinterpret_cast<char*>(&other->_impl_.pid_));
}

std::string SchedProcessExecFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedProcessExecFtraceEvent";
}


// ===================================================================

class SchedProcessExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedProcessExitFtraceEvent>()._impl_._has_bits_);
  static void set_has_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_tgid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_prio(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

SchedProcessExitFtraceEvent::SchedProcessExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedProcessExitFtraceEvent)
}
SchedProcessExitFtraceEvent::SchedProcessExitFtraceEvent(const SchedProcessExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SchedProcessExitFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comm_){}
    , decltype(_impl_.pid_){}
    , decltype(_impl_.tgid_){}
    , decltype(_impl_.prio_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_comm()) {
    _this->_impl_.comm_.Set(from._internal_comm(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.pid_, &from._impl_.pid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.prio_) -
    reinterpret_cast<char*>(&_impl_.pid_)) + sizeof(_impl_.prio_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedProcessExitFtraceEvent)
}

inline void SchedProcessExitFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comm_){}
    , decltype(_impl_.pid_){0}
    , decltype(_impl_.tgid_){0}
    , decltype(_impl_.prio_){0}
  };
  _impl_.comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SchedProcessExitFtraceEvent::~SchedProcessExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedProcessExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedProcessExitFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.comm_.Destroy();
}

void SchedProcessExitFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SchedProcessExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedProcessExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.comm_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.pid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.prio_) -
        reinterpret_cast<char*>(&_impl_.pid_)) + sizeof(_impl_.prio_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SchedProcessExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_pid(&has_bits);
          _impl_.pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 tgid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_tgid(&has_bits);
          _impl_.tgid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 prio = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_prio(&has_bits);
          _impl_.prio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SchedProcessExitFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedProcessExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string comm = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_comm(), target);
  }

  // optional int32 pid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_pid(), target);
  }

  // optional int32 tgid = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_tgid(), target);
  }

  // optional int32 prio = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_prio(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedProcessExitFtraceEvent)
  return target;
}

size_t SchedProcessExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedProcessExitFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_comm());
    }

    // optional int32 pid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pid());
    }

    // optional int32 tgid = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_tgid());
    }

    // optional int32 prio = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_prio());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedProcessExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SchedProcessExitFtraceEvent*>(
      &from));
}

void SchedProcessExitFtraceEvent::MergeFrom(const SchedProcessExitFtraceEvent& from) {
  SchedProcessExitFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedProcessExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_comm(from._internal_comm());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pid_ = from._impl_.pid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.tgid_ = from._impl_.tgid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.prio_ = from._impl_.prio_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SchedProcessExitFtraceEvent::CopyFrom(const SchedProcessExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedProcessExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedProcessExitFtraceEvent::IsInitialized() const {
  return true;
}

void SchedProcessExitFtraceEvent::InternalSwap(SchedProcessExitFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.comm_, lhs_arena,
      &other->_impl_.comm_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedProcessExitFtraceEvent, _impl_.prio_)
      + sizeof(SchedProcessExitFtraceEvent::_impl_.prio_)
      - PROTOBUF_FIELD_OFFSET(SchedProcessExitFtraceEvent, _impl_.pid_)>(
          reinterpret_cast<char*>(&_impl_.pid_),
          reinterpret_cast<char*>(&other->_impl_.pid_));
}

std::string SchedProcessExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedProcessExitFtraceEvent";
}


// ===================================================================

class SchedProcessForkFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedProcessForkFtraceEvent>()._impl_._has_bits_);
  static void set_has_parent_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_parent_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_child_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_child_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

SchedProcessForkFtraceEvent::SchedProcessForkFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedProcessForkFtraceEvent)
}
SchedProcessForkFtraceEvent::SchedProcessForkFtraceEvent(const SchedProcessForkFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SchedProcessForkFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parent_comm_){}
    , decltype(_impl_.child_comm_){}
    , decltype(_impl_.parent_pid_){}
    , decltype(_impl_.child_pid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.parent_comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.parent_comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_parent_comm()) {
    _this->_impl_.parent_comm_.Set(from._internal_parent_comm(), 
      _this->GetArenaForAllocation());
  }
  _impl_.child_comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.child_comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_child_comm()) {
    _this->_impl_.child_comm_.Set(from._internal_child_comm(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.parent_pid_, &from._impl_.parent_pid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.child_pid_) -
    reinterpret_cast<char*>(&_impl_.parent_pid_)) + sizeof(_impl_.child_pid_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedProcessForkFtraceEvent)
}

inline void SchedProcessForkFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.parent_comm_){}
    , decltype(_impl_.child_comm_){}
    , decltype(_impl_.parent_pid_){0}
    , decltype(_impl_.child_pid_){0}
  };
  _impl_.parent_comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.parent_comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.child_comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.child_comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SchedProcessForkFtraceEvent::~SchedProcessForkFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedProcessForkFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedProcessForkFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.parent_comm_.Destroy();
  _impl_.child_comm_.Destroy();
}

void SchedProcessForkFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SchedProcessForkFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedProcessForkFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.parent_comm_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.child_comm_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.parent_pid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.child_pid_) -
        reinterpret_cast<char*>(&_impl_.parent_pid_)) + sizeof(_impl_.child_pid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SchedProcessForkFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string parent_comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_parent_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 parent_pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_parent_pid(&has_bits);
          _impl_.parent_pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string child_comm = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_child_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 child_pid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_child_pid(&has_bits);
          _impl_.child_pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SchedProcessForkFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedProcessForkFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string parent_comm = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_parent_comm(), target);
  }

  // optional int32 parent_pid = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_parent_pid(), target);
  }

  // optional string child_comm = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_child_comm(), target);
  }

  // optional int32 child_pid = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_child_pid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedProcessForkFtraceEvent)
  return target;
}

size_t SchedProcessForkFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedProcessForkFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string parent_comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_parent_comm());
    }

    // optional string child_comm = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_child_comm());
    }

    // optional int32 parent_pid = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_parent_pid());
    }

    // optional int32 child_pid = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_child_pid());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedProcessForkFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SchedProcessForkFtraceEvent*>(
      &from));
}

void SchedProcessForkFtraceEvent::MergeFrom(const SchedProcessForkFtraceEvent& from) {
  SchedProcessForkFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedProcessForkFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_parent_comm(from._internal_parent_comm());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_child_comm(from._internal_child_comm());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.parent_pid_ = from._impl_.parent_pid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.child_pid_ = from._impl_.child_pid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SchedProcessForkFtraceEvent::CopyFrom(const SchedProcessForkFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedProcessForkFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedProcessForkFtraceEvent::IsInitialized() const {
  return true;
}

void SchedProcessForkFtraceEvent::InternalSwap(SchedProcessForkFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.parent_comm_, lhs_arena,
      &other->_impl_.parent_comm_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.child_comm_, lhs_arena,
      &other->_impl_.child_comm_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedProcessForkFtraceEvent, _impl_.child_pid_)
      + sizeof(SchedProcessForkFtraceEvent::_impl_.child_pid_)
      - PROTOBUF_FIELD_OFFSET(SchedProcessForkFtraceEvent, _impl_.parent_pid_)>(
          reinterpret_cast<char*>(&_impl_.parent_pid_),
          reinterpret_cast<char*>(&other->_impl_.parent_pid_));
}

std::string SchedProcessForkFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedProcessForkFtraceEvent";
}


// ===================================================================

class SchedProcessFreeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedProcessFreeFtraceEvent>()._impl_._has_bits_);
  static void set_has_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_prio(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

SchedProcessFreeFtraceEvent::SchedProcessFreeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedProcessFreeFtraceEvent)
}
SchedProcessFreeFtraceEvent::SchedProcessFreeFtraceEvent(const SchedProcessFreeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SchedProcessFreeFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comm_){}
    , decltype(_impl_.pid_){}
    , decltype(_impl_.prio_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_comm()) {
    _this->_impl_.comm_.Set(from._internal_comm(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.pid_, &from._impl_.pid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.prio_) -
    reinterpret_cast<char*>(&_impl_.pid_)) + sizeof(_impl_.prio_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedProcessFreeFtraceEvent)
}

inline void SchedProcessFreeFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comm_){}
    , decltype(_impl_.pid_){0}
    , decltype(_impl_.prio_){0}
  };
  _impl_.comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SchedProcessFreeFtraceEvent::~SchedProcessFreeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedProcessFreeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedProcessFreeFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.comm_.Destroy();
}

void SchedProcessFreeFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SchedProcessFreeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedProcessFreeFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.comm_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.pid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.prio_) -
        reinterpret_cast<char*>(&_impl_.pid_)) + sizeof(_impl_.prio_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SchedProcessFreeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_pid(&has_bits);
          _impl_.pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 prio = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_prio(&has_bits);
          _impl_.prio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SchedProcessFreeFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedProcessFreeFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string comm = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_comm(), target);
  }

  // optional int32 pid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_pid(), target);
  }

  // optional int32 prio = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_prio(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedProcessFreeFtraceEvent)
  return target;
}

size_t SchedProcessFreeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedProcessFreeFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_comm());
    }

    // optional int32 pid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pid());
    }

    // optional int32 prio = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_prio());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedProcessFreeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SchedProcessFreeFtraceEvent*>(
      &from));
}

void SchedProcessFreeFtraceEvent::MergeFrom(const SchedProcessFreeFtraceEvent& from) {
  SchedProcessFreeFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedProcessFreeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_comm(from._internal_comm());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pid_ = from._impl_.pid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.prio_ = from._impl_.prio_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SchedProcessFreeFtraceEvent::CopyFrom(const SchedProcessFreeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedProcessFreeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedProcessFreeFtraceEvent::IsInitialized() const {
  return true;
}

void SchedProcessFreeFtraceEvent::InternalSwap(SchedProcessFreeFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.comm_, lhs_arena,
      &other->_impl_.comm_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedProcessFreeFtraceEvent, _impl_.prio_)
      + sizeof(SchedProcessFreeFtraceEvent::_impl_.prio_)
      - PROTOBUF_FIELD_OFFSET(SchedProcessFreeFtraceEvent, _impl_.pid_)>(
          reinterpret_cast<char*>(&_impl_.pid_),
          reinterpret_cast<char*>(&other->_impl_.pid_));
}

std::string SchedProcessFreeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedProcessFreeFtraceEvent";
}


// ===================================================================

class SchedProcessHangFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedProcessHangFtraceEvent>()._impl_._has_bits_);
  static void set_has_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

SchedProcessHangFtraceEvent::SchedProcessHangFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedProcessHangFtraceEvent)
}
SchedProcessHangFtraceEvent::SchedProcessHangFtraceEvent(const SchedProcessHangFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SchedProcessHangFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comm_){}
    , decltype(_impl_.pid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_comm()) {
    _this->_impl_.comm_.Set(from._internal_comm(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.pid_ = from._impl_.pid_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedProcessHangFtraceEvent)
}

inline void SchedProcessHangFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comm_){}
    , decltype(_impl_.pid_){0}
  };
  _impl_.comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SchedProcessHangFtraceEvent::~SchedProcessHangFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedProcessHangFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedProcessHangFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.comm_.Destroy();
}

void SchedProcessHangFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SchedProcessHangFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedProcessHangFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.comm_.ClearNonDefaultToEmpty();
  }
  _impl_.pid_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SchedProcessHangFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_pid(&has_bits);
          _impl_.pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SchedProcessHangFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedProcessHangFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string comm = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_comm(), target);
  }

  // optional int32 pid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_pid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedProcessHangFtraceEvent)
  return target;
}

size_t SchedProcessHangFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedProcessHangFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_comm());
    }

    // optional int32 pid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pid());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedProcessHangFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SchedProcessHangFtraceEvent*>(
      &from));
}

void SchedProcessHangFtraceEvent::MergeFrom(const SchedProcessHangFtraceEvent& from) {
  SchedProcessHangFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedProcessHangFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_comm(from._internal_comm());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pid_ = from._impl_.pid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SchedProcessHangFtraceEvent::CopyFrom(const SchedProcessHangFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedProcessHangFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedProcessHangFtraceEvent::IsInitialized() const {
  return true;
}

void SchedProcessHangFtraceEvent::InternalSwap(SchedProcessHangFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.comm_, lhs_arena,
      &other->_impl_.comm_, rhs_arena
  );
  swap(_impl_.pid_, other->_impl_.pid_);
}

std::string SchedProcessHangFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedProcessHangFtraceEvent";
}


// ===================================================================

class SchedProcessWaitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedProcessWaitFtraceEvent>()._impl_._has_bits_);
  static void set_has_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_prio(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

SchedProcessWaitFtraceEvent::SchedProcessWaitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedProcessWaitFtraceEvent)
}
SchedProcessWaitFtraceEvent::SchedProcessWaitFtraceEvent(const SchedProcessWaitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SchedProcessWaitFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comm_){}
    , decltype(_impl_.pid_){}
    , decltype(_impl_.prio_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_comm()) {
    _this->_impl_.comm_.Set(from._internal_comm(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.pid_, &from._impl_.pid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.prio_) -
    reinterpret_cast<char*>(&_impl_.pid_)) + sizeof(_impl_.prio_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedProcessWaitFtraceEvent)
}

inline void SchedProcessWaitFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comm_){}
    , decltype(_impl_.pid_){0}
    , decltype(_impl_.prio_){0}
  };
  _impl_.comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SchedProcessWaitFtraceEvent::~SchedProcessWaitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedProcessWaitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedProcessWaitFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.comm_.Destroy();
}

void SchedProcessWaitFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SchedProcessWaitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedProcessWaitFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.comm_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.pid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.prio_) -
        reinterpret_cast<char*>(&_impl_.pid_)) + sizeof(_impl_.prio_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SchedProcessWaitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_pid(&has_bits);
          _impl_.pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 prio = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_prio(&has_bits);
          _impl_.prio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SchedProcessWaitFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedProcessWaitFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string comm = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_comm(), target);
  }

  // optional int32 pid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_pid(), target);
  }

  // optional int32 prio = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_prio(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedProcessWaitFtraceEvent)
  return target;
}

size_t SchedProcessWaitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedProcessWaitFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_comm());
    }

    // optional int32 pid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pid());
    }

    // optional int32 prio = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_prio());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedProcessWaitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SchedProcessWaitFtraceEvent*>(
      &from));
}

void SchedProcessWaitFtraceEvent::MergeFrom(const SchedProcessWaitFtraceEvent& from) {
  SchedProcessWaitFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedProcessWaitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_comm(from._internal_comm());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pid_ = from._impl_.pid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.prio_ = from._impl_.prio_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SchedProcessWaitFtraceEvent::CopyFrom(const SchedProcessWaitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedProcessWaitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedProcessWaitFtraceEvent::IsInitialized() const {
  return true;
}

void SchedProcessWaitFtraceEvent::InternalSwap(SchedProcessWaitFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.comm_, lhs_arena,
      &other->_impl_.comm_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedProcessWaitFtraceEvent, _impl_.prio_)
      + sizeof(SchedProcessWaitFtraceEvent::_impl_.prio_)
      - PROTOBUF_FIELD_OFFSET(SchedProcessWaitFtraceEvent, _impl_.pid_)>(
          reinterpret_cast<char*>(&_impl_.pid_),
          reinterpret_cast<char*>(&other->_impl_.pid_));
}

std::string SchedProcessWaitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedProcessWaitFtraceEvent";
}


// ===================================================================

class SchedPiSetprioFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedPiSetprioFtraceEvent>()._impl_._has_bits_);
  static void set_has_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_newprio(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_oldprio(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

SchedPiSetprioFtraceEvent::SchedPiSetprioFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedPiSetprioFtraceEvent)
}
SchedPiSetprioFtraceEvent::SchedPiSetprioFtraceEvent(const SchedPiSetprioFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SchedPiSetprioFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comm_){}
    , decltype(_impl_.newprio_){}
    , decltype(_impl_.oldprio_){}
    , decltype(_impl_.pid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_comm()) {
    _this->_impl_.comm_.Set(from._internal_comm(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.newprio_, &from._impl_.newprio_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.pid_) -
    reinterpret_cast<char*>(&_impl_.newprio_)) + sizeof(_impl_.pid_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedPiSetprioFtraceEvent)
}

inline void SchedPiSetprioFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comm_){}
    , decltype(_impl_.newprio_){0}
    , decltype(_impl_.oldprio_){0}
    , decltype(_impl_.pid_){0}
  };
  _impl_.comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SchedPiSetprioFtraceEvent::~SchedPiSetprioFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedPiSetprioFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedPiSetprioFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.comm_.Destroy();
}

void SchedPiSetprioFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SchedPiSetprioFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedPiSetprioFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.comm_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.newprio_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.pid_) -
        reinterpret_cast<char*>(&_impl_.newprio_)) + sizeof(_impl_.pid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SchedPiSetprioFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 newprio = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_newprio(&has_bits);
          _impl_.newprio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 oldprio = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_oldprio(&has_bits);
          _impl_.oldprio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 pid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_pid(&has_bits);
          _impl_.pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SchedPiSetprioFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedPiSetprioFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string comm = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_comm(), target);
  }

  // optional int32 newprio = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_newprio(), target);
  }

  // optional int32 oldprio = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_oldprio(), target);
  }

  // optional int32 pid = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_pid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedPiSetprioFtraceEvent)
  return target;
}

size_t SchedPiSetprioFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedPiSetprioFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_comm());
    }

    // optional int32 newprio = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_newprio());
    }

    // optional int32 oldprio = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_oldprio());
    }

    // optional int32 pid = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pid());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedPiSetprioFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SchedPiSetprioFtraceEvent*>(
      &from));
}

void SchedPiSetprioFtraceEvent::MergeFrom(const SchedPiSetprioFtraceEvent& from) {
  SchedPiSetprioFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedPiSetprioFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_comm(from._internal_comm());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.newprio_ = from._impl_.newprio_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.oldprio_ = from._impl_.oldprio_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.pid_ = from._impl_.pid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SchedPiSetprioFtraceEvent::CopyFrom(const SchedPiSetprioFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedPiSetprioFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedPiSetprioFtraceEvent::IsInitialized() const {
  return true;
}

void SchedPiSetprioFtraceEvent::InternalSwap(SchedPiSetprioFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.comm_, lhs_arena,
      &other->_impl_.comm_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedPiSetprioFtraceEvent, _impl_.pid_)
      + sizeof(SchedPiSetprioFtraceEvent::_impl_.pid_)
      - PROTOBUF_FIELD_OFFSET(SchedPiSetprioFtraceEvent, _impl_.newprio_)>(
          reinterpret_cast<char*>(&_impl_.newprio_),
          reinterpret_cast<char*>(&other->_impl_.newprio_));
}

std::string SchedPiSetprioFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedPiSetprioFtraceEvent";
}


// ===================================================================

class SchedCpuUtilCfsFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedCpuUtilCfsFtraceEvent>()._impl_._has_bits_);
  static void set_has_active(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_capacity(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_capacity_orig(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_cpu(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_cpu_importance(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_cpu_util(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_exit_lat(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_group_capacity(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_grp_overutilized(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_idle_cpu(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_nr_running(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_spare_cap(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_task_fits(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_wake_group_util(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_wake_util(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
};

SchedCpuUtilCfsFtraceEvent::SchedCpuUtilCfsFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedCpuUtilCfsFtraceEvent)
}
SchedCpuUtilCfsFtraceEvent::SchedCpuUtilCfsFtraceEvent(const SchedCpuUtilCfsFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SchedCpuUtilCfsFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.capacity_){}
    , decltype(_impl_.active_){}
    , decltype(_impl_.cpu_){}
    , decltype(_impl_.capacity_orig_){}
    , decltype(_impl_.cpu_importance_){}
    , decltype(_impl_.cpu_util_){}
    , decltype(_impl_.group_capacity_){}
    , decltype(_impl_.exit_lat_){}
    , decltype(_impl_.grp_overutilized_){}
    , decltype(_impl_.idle_cpu_){}
    , decltype(_impl_.nr_running_){}
    , decltype(_impl_.spare_cap_){}
    , decltype(_impl_.wake_group_util_){}
    , decltype(_impl_.wake_util_){}
    , decltype(_impl_.task_fits_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.capacity_, &from._impl_.capacity_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.task_fits_) -
    reinterpret_cast<char*>(&_impl_.capacity_)) + sizeof(_impl_.task_fits_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedCpuUtilCfsFtraceEvent)
}

inline void SchedCpuUtilCfsFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.capacity_){uint64_t{0u}}
    , decltype(_impl_.active_){0}
    , decltype(_impl_.cpu_){0u}
    , decltype(_impl_.capacity_orig_){uint64_t{0u}}
    , decltype(_impl_.cpu_importance_){uint64_t{0u}}
    , decltype(_impl_.cpu_util_){uint64_t{0u}}
    , decltype(_impl_.group_capacity_){uint64_t{0u}}
    , decltype(_impl_.exit_lat_){0u}
    , decltype(_impl_.grp_overutilized_){0u}
    , decltype(_impl_.idle_cpu_){0u}
    , decltype(_impl_.nr_running_){0u}
    , decltype(_impl_.spare_cap_){int64_t{0}}
    , decltype(_impl_.wake_group_util_){uint64_t{0u}}
    , decltype(_impl_.wake_util_){uint64_t{0u}}
    , decltype(_impl_.task_fits_){0u}
  };
}

SchedCpuUtilCfsFtraceEvent::~SchedCpuUtilCfsFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedCpuUtilCfsFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedCpuUtilCfsFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SchedCpuUtilCfsFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SchedCpuUtilCfsFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedCpuUtilCfsFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.capacity_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.exit_lat_) -
        reinterpret_cast<char*>(&_impl_.capacity_)) + sizeof(_impl_.exit_lat_));
  }
  if (cached_has_bits & 0x00007f00u) {
    ::memset(&_impl_.grp_overutilized_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.task_fits_) -
        reinterpret_cast<char*>(&_impl_.grp_overutilized_)) + sizeof(_impl_.task_fits_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SchedCpuUtilCfsFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 active = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_active(&has_bits);
          _impl_.active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 capacity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_capacity(&has_bits);
          _impl_.capacity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 capacity_orig = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_capacity_orig(&has_bits);
          _impl_.capacity_orig_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 cpu = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_cpu(&has_bits);
          _impl_.cpu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 cpu_importance = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_cpu_importance(&has_bits);
          _impl_.cpu_importance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 cpu_util = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_cpu_util(&has_bits);
          _impl_.cpu_util_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 exit_lat = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_exit_lat(&has_bits);
          _impl_.exit_lat_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 group_capacity = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_group_capacity(&has_bits);
          _impl_.group_capacity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 grp_overutilized = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_grp_overutilized(&has_bits);
          _impl_.grp_overutilized_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 idle_cpu = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_idle_cpu(&has_bits);
          _impl_.idle_cpu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 nr_running = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_nr_running(&has_bits);
          _impl_.nr_running_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 spare_cap = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_spare_cap(&has_bits);
          _impl_.spare_cap_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 task_fits = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_task_fits(&has_bits);
          _impl_.task_fits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 wake_group_util = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_wake_group_util(&has_bits);
          _impl_.wake_group_util_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 wake_util = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_wake_util(&has_bits);
          _impl_.wake_util_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SchedCpuUtilCfsFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedCpuUtilCfsFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 active = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_active(), target);
  }

  // optional uint64 capacity = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_capacity(), target);
  }

  // optional uint64 capacity_orig = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_capacity_orig(), target);
  }

  // optional uint32 cpu = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_cpu(), target);
  }

  // optional uint64 cpu_importance = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_cpu_importance(), target);
  }

  // optional uint64 cpu_util = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_cpu_util(), target);
  }

  // optional uint32 exit_lat = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_exit_lat(), target);
  }

  // optional uint64 group_capacity = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(8, this->_internal_group_capacity(), target);
  }

  // optional uint32 grp_overutilized = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_grp_overutilized(), target);
  }

  // optional uint32 idle_cpu = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_idle_cpu(), target);
  }

  // optional uint32 nr_running = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_nr_running(), target);
  }

  // optional int64 spare_cap = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(12, this->_internal_spare_cap(), target);
  }

  // optional uint32 task_fits = 13;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_task_fits(), target);
  }

  // optional uint64 wake_group_util = 14;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(14, this->_internal_wake_group_util(), target);
  }

  // optional uint64 wake_util = 15;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(15, this->_internal_wake_util(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedCpuUtilCfsFtraceEvent)
  return target;
}

size_t SchedCpuUtilCfsFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedCpuUtilCfsFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 capacity = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_capacity());
    }

    // optional int32 active = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_active());
    }

    // optional uint32 cpu = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_cpu());
    }

    // optional uint64 capacity_orig = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_capacity_orig());
    }

    // optional uint64 cpu_importance = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_cpu_importance());
    }

    // optional uint64 cpu_util = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_cpu_util());
    }

    // optional uint64 group_capacity = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_group_capacity());
    }

    // optional uint32 exit_lat = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_exit_lat());
    }

  }
  if (cached_has_bits & 0x00007f00u) {
    // optional uint32 grp_overutilized = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_grp_overutilized());
    }

    // optional uint32 idle_cpu = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_idle_cpu());
    }

    // optional uint32 nr_running = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nr_running());
    }

    // optional int64 spare_cap = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_spare_cap());
    }

    // optional uint64 wake_group_util = 14;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_wake_group_util());
    }

    // optional uint64 wake_util = 15;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_wake_util());
    }

    // optional uint32 task_fits = 13;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_task_fits());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedCpuUtilCfsFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SchedCpuUtilCfsFtraceEvent*>(
      &from));
}

void SchedCpuUtilCfsFtraceEvent::MergeFrom(const SchedCpuUtilCfsFtraceEvent& from) {
  SchedCpuUtilCfsFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedCpuUtilCfsFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.capacity_ = from._impl_.capacity_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.active_ = from._impl_.active_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.cpu_ = from._impl_.cpu_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.capacity_orig_ = from._impl_.capacity_orig_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.cpu_importance_ = from._impl_.cpu_importance_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.cpu_util_ = from._impl_.cpu_util_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.group_capacity_ = from._impl_.group_capacity_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.exit_lat_ = from._impl_.exit_lat_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.grp_overutilized_ = from._impl_.grp_overutilized_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.idle_cpu_ = from._impl_.idle_cpu_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.nr_running_ = from._impl_.nr_running_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.spare_cap_ = from._impl_.spare_cap_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.wake_group_util_ = from._impl_.wake_group_util_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.wake_util_ = from._impl_.wake_util_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.task_fits_ = from._impl_.task_fits_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SchedCpuUtilCfsFtraceEvent::CopyFrom(const SchedCpuUtilCfsFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedCpuUtilCfsFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedCpuUtilCfsFtraceEvent::IsInitialized() const {
  return true;
}

void SchedCpuUtilCfsFtraceEvent::InternalSwap(SchedCpuUtilCfsFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedCpuUtilCfsFtraceEvent, _impl_.task_fits_)
      + sizeof(SchedCpuUtilCfsFtraceEvent::_impl_.task_fits_)
      - PROTOBUF_FIELD_OFFSET(SchedCpuUtilCfsFtraceEvent, _impl_.capacity_)>(
          reinterpret_cast<char*>(&_impl_.capacity_),
          reinterpret_cast<char*>(&other->_impl_.capacity_));
}

std::string SchedCpuUtilCfsFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedCpuUtilCfsFtraceEvent";
}


// ===================================================================

class SchedMigrateTaskFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SchedMigrateTaskFtraceEvent>()._impl_._has_bits_);
  static void set_has_comm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_prio(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_orig_cpu(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_dest_cpu(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_running(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_load(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

SchedMigrateTaskFtraceEvent::SchedMigrateTaskFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.SchedMigrateTaskFtraceEvent)
}
SchedMigrateTaskFtraceEvent::SchedMigrateTaskFtraceEvent(const SchedMigrateTaskFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SchedMigrateTaskFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comm_){}
    , decltype(_impl_.pid_){}
    , decltype(_impl_.prio_){}
    , decltype(_impl_.orig_cpu_){}
    , decltype(_impl_.dest_cpu_){}
    , decltype(_impl_.running_){}
    , decltype(_impl_.load_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_comm()) {
    _this->_impl_.comm_.Set(from._internal_comm(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.pid_, &from._impl_.pid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.load_) -
    reinterpret_cast<char*>(&_impl_.pid_)) + sizeof(_impl_.load_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SchedMigrateTaskFtraceEvent)
}

inline void SchedMigrateTaskFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comm_){}
    , decltype(_impl_.pid_){0}
    , decltype(_impl_.prio_){0}
    , decltype(_impl_.orig_cpu_){0}
    , decltype(_impl_.dest_cpu_){0}
    , decltype(_impl_.running_){0}
    , decltype(_impl_.load_){0u}
  };
  _impl_.comm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SchedMigrateTaskFtraceEvent::~SchedMigrateTaskFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SchedMigrateTaskFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SchedMigrateTaskFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.comm_.Destroy();
}

void SchedMigrateTaskFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SchedMigrateTaskFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SchedMigrateTaskFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.comm_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000007eu) {
    ::memset(&_impl_.pid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.load_) -
        reinterpret_cast<char*>(&_impl_.pid_)) + sizeof(_impl_.load_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SchedMigrateTaskFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string comm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_comm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 pid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_pid(&has_bits);
          _impl_.pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 prio = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_prio(&has_bits);
          _impl_.prio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 orig_cpu = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_orig_cpu(&has_bits);
          _impl_.orig_cpu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 dest_cpu = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_dest_cpu(&has_bits);
          _impl_.dest_cpu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 running = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_running(&has_bits);
          _impl_.running_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 load = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_load(&has_bits);
          _impl_.load_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SchedMigrateTaskFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.SchedMigrateTaskFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string comm = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_comm(), target);
  }

  // optional int32 pid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_pid(), target);
  }

  // optional int32 prio = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_prio(), target);
  }

  // optional int32 orig_cpu = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_orig_cpu(), target);
  }

  // optional int32 dest_cpu = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_dest_cpu(), target);
  }

  // optional int32 running = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_running(), target);
  }

  // optional uint32 load = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_load(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.SchedMigrateTaskFtraceEvent)
  return target;
}

size_t SchedMigrateTaskFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SchedMigrateTaskFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string comm = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_comm());
    }

    // optional int32 pid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pid());
    }

    // optional int32 prio = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_prio());
    }

    // optional int32 orig_cpu = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_orig_cpu());
    }

    // optional int32 dest_cpu = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dest_cpu());
    }

    // optional int32 running = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_running());
    }

    // optional uint32 load = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_load());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SchedMigrateTaskFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SchedMigrateTaskFtraceEvent*>(
      &from));
}

void SchedMigrateTaskFtraceEvent::MergeFrom(const SchedMigrateTaskFtraceEvent& from) {
  SchedMigrateTaskFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SchedMigrateTaskFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_comm(from._internal_comm());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pid_ = from._impl_.pid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.prio_ = from._impl_.prio_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.orig_cpu_ = from._impl_.orig_cpu_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.dest_cpu_ = from._impl_.dest_cpu_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.running_ = from._impl_.running_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.load_ = from._impl_.load_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SchedMigrateTaskFtraceEvent::CopyFrom(const SchedMigrateTaskFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SchedMigrateTaskFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SchedMigrateTaskFtraceEvent::IsInitialized() const {
  return true;
}

void SchedMigrateTaskFtraceEvent::InternalSwap(SchedMigrateTaskFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.comm_, lhs_arena,
      &other->_impl_.comm_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SchedMigrateTaskFtraceEvent, _impl_.load_)
      + sizeof(SchedMigrateTaskFtraceEvent::_impl_.load_)
      - PROTOBUF_FIELD_OFFSET(SchedMigrateTaskFtraceEvent, _impl_.pid_)>(
          reinterpret_cast<char*>(&_impl_.pid_),
          reinterpret_cast<char*>(&other->_impl_.pid_));
}

std::string SchedMigrateTaskFtraceEvent::GetTypeName() const {
  return "perfetto.protos.SchedMigrateTaskFtraceEvent";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace protos
}  // namespace perfetto
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedSwitchFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedSwitchFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedSwitchFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedWakeupFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedWakeupFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedWakeupFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedBlockedReasonFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedBlockedReasonFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedBlockedReasonFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedCpuHotplugFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedCpuHotplugFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedCpuHotplugFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedWakingFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedWakingFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedWakingFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedWakeupNewFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedWakeupNewFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedWakeupNewFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedProcessExecFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedProcessExecFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedProcessExecFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedProcessExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedProcessExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedProcessExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedProcessForkFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedProcessForkFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedProcessForkFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedProcessFreeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedProcessFreeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedProcessFreeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedProcessHangFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedProcessHangFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedProcessHangFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedProcessWaitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedProcessWaitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedProcessWaitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedPiSetprioFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedPiSetprioFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedPiSetprioFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedCpuUtilCfsFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedCpuUtilCfsFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedCpuUtilCfsFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::SchedMigrateTaskFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::SchedMigrateTaskFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::SchedMigrateTaskFtraceEvent >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
