// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_VMSCAN_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_VMSCAN_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class MmShrinkSlabEndFtraceEvent;
class MmShrinkSlabStartFtraceEvent;
class MmVmscanKswapdSleepFtraceEvent;
class MmVmscanKswapdWakeFtraceEvent;
class MmVmscanDirectReclaimEndFtraceEvent;
class MmVmscanDirectReclaimBeginFtraceEvent;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {

class PERFETTO_EXPORT_COMPONENT MmShrinkSlabEndFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kNewScanFieldNumber = 1,
    kRetvalFieldNumber = 2,
    kShrFieldNumber = 3,
    kShrinkFieldNumber = 4,
    kTotalScanFieldNumber = 5,
    kUnusedScanFieldNumber = 6,
    kNidFieldNumber = 7,
  };

  MmShrinkSlabEndFtraceEvent();
  ~MmShrinkSlabEndFtraceEvent() override;
  MmShrinkSlabEndFtraceEvent(MmShrinkSlabEndFtraceEvent&&) noexcept;
  MmShrinkSlabEndFtraceEvent& operator=(MmShrinkSlabEndFtraceEvent&&);
  MmShrinkSlabEndFtraceEvent(const MmShrinkSlabEndFtraceEvent&);
  MmShrinkSlabEndFtraceEvent& operator=(const MmShrinkSlabEndFtraceEvent&);
  bool operator==(const MmShrinkSlabEndFtraceEvent&) const;
  bool operator!=(const MmShrinkSlabEndFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_new_scan() const { return _has_field_[1]; }
  int64_t new_scan() const { return new_scan_; }
  void set_new_scan(int64_t value) { new_scan_ = value; _has_field_.set(1); }

  bool has_retval() const { return _has_field_[2]; }
  int32_t retval() const { return retval_; }
  void set_retval(int32_t value) { retval_ = value; _has_field_.set(2); }

  bool has_shr() const { return _has_field_[3]; }
  uint64_t shr() const { return shr_; }
  void set_shr(uint64_t value) { shr_ = value; _has_field_.set(3); }

  bool has_shrink() const { return _has_field_[4]; }
  uint64_t shrink() const { return shrink_; }
  void set_shrink(uint64_t value) { shrink_ = value; _has_field_.set(4); }

  bool has_total_scan() const { return _has_field_[5]; }
  int64_t total_scan() const { return total_scan_; }
  void set_total_scan(int64_t value) { total_scan_ = value; _has_field_.set(5); }

  bool has_unused_scan() const { return _has_field_[6]; }
  int64_t unused_scan() const { return unused_scan_; }
  void set_unused_scan(int64_t value) { unused_scan_ = value; _has_field_.set(6); }

  bool has_nid() const { return _has_field_[7]; }
  int32_t nid() const { return nid_; }
  void set_nid(int32_t value) { nid_ = value; _has_field_.set(7); }

 private:
  int64_t new_scan_{};
  int32_t retval_{};
  uint64_t shr_{};
  uint64_t shrink_{};
  int64_t total_scan_{};
  int64_t unused_scan_{};
  int32_t nid_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<8> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT MmShrinkSlabStartFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCacheItemsFieldNumber = 1,
    kDeltaFieldNumber = 2,
    kGfpFlagsFieldNumber = 3,
    kLruPgsFieldNumber = 4,
    kNrObjectsToShrinkFieldNumber = 5,
    kPgsScannedFieldNumber = 6,
    kShrFieldNumber = 7,
    kShrinkFieldNumber = 8,
    kTotalScanFieldNumber = 9,
    kNidFieldNumber = 10,
    kPriorityFieldNumber = 11,
  };

  MmShrinkSlabStartFtraceEvent();
  ~MmShrinkSlabStartFtraceEvent() override;
  MmShrinkSlabStartFtraceEvent(MmShrinkSlabStartFtraceEvent&&) noexcept;
  MmShrinkSlabStartFtraceEvent& operator=(MmShrinkSlabStartFtraceEvent&&);
  MmShrinkSlabStartFtraceEvent(const MmShrinkSlabStartFtraceEvent&);
  MmShrinkSlabStartFtraceEvent& operator=(const MmShrinkSlabStartFtraceEvent&);
  bool operator==(const MmShrinkSlabStartFtraceEvent&) const;
  bool operator!=(const MmShrinkSlabStartFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_cache_items() const { return _has_field_[1]; }
  uint64_t cache_items() const { return cache_items_; }
  void set_cache_items(uint64_t value) { cache_items_ = value; _has_field_.set(1); }

  bool has_delta() const { return _has_field_[2]; }
  uint64_t delta() const { return delta_; }
  void set_delta(uint64_t value) { delta_ = value; _has_field_.set(2); }

  bool has_gfp_flags() const { return _has_field_[3]; }
  uint32_t gfp_flags() const { return gfp_flags_; }
  void set_gfp_flags(uint32_t value) { gfp_flags_ = value; _has_field_.set(3); }

  bool has_lru_pgs() const { return _has_field_[4]; }
  uint64_t lru_pgs() const { return lru_pgs_; }
  void set_lru_pgs(uint64_t value) { lru_pgs_ = value; _has_field_.set(4); }

  bool has_nr_objects_to_shrink() const { return _has_field_[5]; }
  int64_t nr_objects_to_shrink() const { return nr_objects_to_shrink_; }
  void set_nr_objects_to_shrink(int64_t value) { nr_objects_to_shrink_ = value; _has_field_.set(5); }

  bool has_pgs_scanned() const { return _has_field_[6]; }
  uint64_t pgs_scanned() const { return pgs_scanned_; }
  void set_pgs_scanned(uint64_t value) { pgs_scanned_ = value; _has_field_.set(6); }

  bool has_shr() const { return _has_field_[7]; }
  uint64_t shr() const { return shr_; }
  void set_shr(uint64_t value) { shr_ = value; _has_field_.set(7); }

  bool has_shrink() const { return _has_field_[8]; }
  uint64_t shrink() const { return shrink_; }
  void set_shrink(uint64_t value) { shrink_ = value; _has_field_.set(8); }

  bool has_total_scan() const { return _has_field_[9]; }
  uint64_t total_scan() const { return total_scan_; }
  void set_total_scan(uint64_t value) { total_scan_ = value; _has_field_.set(9); }

  bool has_nid() const { return _has_field_[10]; }
  int32_t nid() const { return nid_; }
  void set_nid(int32_t value) { nid_ = value; _has_field_.set(10); }

  bool has_priority() const { return _has_field_[11]; }
  int32_t priority() const { return priority_; }
  void set_priority(int32_t value) { priority_ = value; _has_field_.set(11); }

 private:
  uint64_t cache_items_{};
  uint64_t delta_{};
  uint32_t gfp_flags_{};
  uint64_t lru_pgs_{};
  int64_t nr_objects_to_shrink_{};
  uint64_t pgs_scanned_{};
  uint64_t shr_{};
  uint64_t shrink_{};
  uint64_t total_scan_{};
  int32_t nid_{};
  int32_t priority_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<12> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT MmVmscanKswapdSleepFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kNidFieldNumber = 1,
  };

  MmVmscanKswapdSleepFtraceEvent();
  ~MmVmscanKswapdSleepFtraceEvent() override;
  MmVmscanKswapdSleepFtraceEvent(MmVmscanKswapdSleepFtraceEvent&&) noexcept;
  MmVmscanKswapdSleepFtraceEvent& operator=(MmVmscanKswapdSleepFtraceEvent&&);
  MmVmscanKswapdSleepFtraceEvent(const MmVmscanKswapdSleepFtraceEvent&);
  MmVmscanKswapdSleepFtraceEvent& operator=(const MmVmscanKswapdSleepFtraceEvent&);
  bool operator==(const MmVmscanKswapdSleepFtraceEvent&) const;
  bool operator!=(const MmVmscanKswapdSleepFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_nid() const { return _has_field_[1]; }
  int32_t nid() const { return nid_; }
  void set_nid(int32_t value) { nid_ = value; _has_field_.set(1); }

 private:
  int32_t nid_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT MmVmscanKswapdWakeFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kNidFieldNumber = 1,
    kOrderFieldNumber = 2,
    kZidFieldNumber = 3,
  };

  MmVmscanKswapdWakeFtraceEvent();
  ~MmVmscanKswapdWakeFtraceEvent() override;
  MmVmscanKswapdWakeFtraceEvent(MmVmscanKswapdWakeFtraceEvent&&) noexcept;
  MmVmscanKswapdWakeFtraceEvent& operator=(MmVmscanKswapdWakeFtraceEvent&&);
  MmVmscanKswapdWakeFtraceEvent(const MmVmscanKswapdWakeFtraceEvent&);
  MmVmscanKswapdWakeFtraceEvent& operator=(const MmVmscanKswapdWakeFtraceEvent&);
  bool operator==(const MmVmscanKswapdWakeFtraceEvent&) const;
  bool operator!=(const MmVmscanKswapdWakeFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_nid() const { return _has_field_[1]; }
  int32_t nid() const { return nid_; }
  void set_nid(int32_t value) { nid_ = value; _has_field_.set(1); }

  bool has_order() const { return _has_field_[2]; }
  int32_t order() const { return order_; }
  void set_order(int32_t value) { order_ = value; _has_field_.set(2); }

  bool has_zid() const { return _has_field_[3]; }
  int32_t zid() const { return zid_; }
  void set_zid(int32_t value) { zid_ = value; _has_field_.set(3); }

 private:
  int32_t nid_{};
  int32_t order_{};
  int32_t zid_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT MmVmscanDirectReclaimEndFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kNrReclaimedFieldNumber = 1,
  };

  MmVmscanDirectReclaimEndFtraceEvent();
  ~MmVmscanDirectReclaimEndFtraceEvent() override;
  MmVmscanDirectReclaimEndFtraceEvent(MmVmscanDirectReclaimEndFtraceEvent&&) noexcept;
  MmVmscanDirectReclaimEndFtraceEvent& operator=(MmVmscanDirectReclaimEndFtraceEvent&&);
  MmVmscanDirectReclaimEndFtraceEvent(const MmVmscanDirectReclaimEndFtraceEvent&);
  MmVmscanDirectReclaimEndFtraceEvent& operator=(const MmVmscanDirectReclaimEndFtraceEvent&);
  bool operator==(const MmVmscanDirectReclaimEndFtraceEvent&) const;
  bool operator!=(const MmVmscanDirectReclaimEndFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_nr_reclaimed() const { return _has_field_[1]; }
  uint64_t nr_reclaimed() const { return nr_reclaimed_; }
  void set_nr_reclaimed(uint64_t value) { nr_reclaimed_ = value; _has_field_.set(1); }

 private:
  uint64_t nr_reclaimed_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT MmVmscanDirectReclaimBeginFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kOrderFieldNumber = 1,
    kMayWritepageFieldNumber = 2,
    kGfpFlagsFieldNumber = 3,
  };

  MmVmscanDirectReclaimBeginFtraceEvent();
  ~MmVmscanDirectReclaimBeginFtraceEvent() override;
  MmVmscanDirectReclaimBeginFtraceEvent(MmVmscanDirectReclaimBeginFtraceEvent&&) noexcept;
  MmVmscanDirectReclaimBeginFtraceEvent& operator=(MmVmscanDirectReclaimBeginFtraceEvent&&);
  MmVmscanDirectReclaimBeginFtraceEvent(const MmVmscanDirectReclaimBeginFtraceEvent&);
  MmVmscanDirectReclaimBeginFtraceEvent& operator=(const MmVmscanDirectReclaimBeginFtraceEvent&);
  bool operator==(const MmVmscanDirectReclaimBeginFtraceEvent&) const;
  bool operator!=(const MmVmscanDirectReclaimBeginFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_order() const { return _has_field_[1]; }
  int32_t order() const { return order_; }
  void set_order(int32_t value) { order_ = value; _has_field_.set(1); }

  bool has_may_writepage() const { return _has_field_[2]; }
  int32_t may_writepage() const { return may_writepage_; }
  void set_may_writepage(int32_t value) { may_writepage_ = value; _has_field_.set(2); }

  bool has_gfp_flags() const { return _has_field_[3]; }
  uint32_t gfp_flags() const { return gfp_flags_; }
  void set_gfp_flags(uint32_t value) { gfp_flags_ = value; _has_field_.set(3); }

 private:
  int32_t order_{};
  int32_t may_writepage_{};
  uint32_t gfp_flags_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_VMSCAN_PROTO_CPP_H_
