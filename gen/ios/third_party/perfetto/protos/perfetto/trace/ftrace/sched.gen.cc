#include "perfetto/protozero/gen_field_helpers.h"
#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/scattered_heap_buffer.h"
// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
#endif
#include "protos/perfetto/trace/ftrace/sched.gen.h"

namespace perfetto {
namespace protos {
namespace gen {

SchedMigrateTaskFtraceEvent::SchedMigrateTaskFtraceEvent() = default;
SchedMigrateTaskFtraceEvent::~SchedMigrateTaskFtraceEvent() = default;
SchedMigrateTaskFtraceEvent::SchedMigrateTaskFtraceEvent(const SchedMigrateTaskFtraceEvent&) = default;
SchedMigrateTaskFtraceEvent& SchedMigrateTaskFtraceEvent::operator=(const SchedMigrateTaskFtraceEvent&) = default;
SchedMigrateTaskFtraceEvent::SchedMigrateTaskFtraceEvent(SchedMigrateTaskFtraceEvent&&) noexcept = default;
SchedMigrateTaskFtraceEvent& SchedMigrateTaskFtraceEvent::operator=(SchedMigrateTaskFtraceEvent&&) = default;

bool SchedMigrateTaskFtraceEvent::operator==(const SchedMigrateTaskFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(comm_, other.comm_)
   && ::protozero::internal::gen_helpers::EqualsField(pid_, other.pid_)
   && ::protozero::internal::gen_helpers::EqualsField(prio_, other.prio_)
   && ::protozero::internal::gen_helpers::EqualsField(orig_cpu_, other.orig_cpu_)
   && ::protozero::internal::gen_helpers::EqualsField(dest_cpu_, other.dest_cpu_)
   && ::protozero::internal::gen_helpers::EqualsField(running_, other.running_)
   && ::protozero::internal::gen_helpers::EqualsField(load_, other.load_);
}

bool SchedMigrateTaskFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* comm */:
        ::protozero::internal::gen_helpers::DeserializeString(field, &comm_);
        break;
      case 2 /* pid */:
        field.get(&pid_);
        break;
      case 3 /* prio */:
        field.get(&prio_);
        break;
      case 4 /* orig_cpu */:
        field.get(&orig_cpu_);
        break;
      case 5 /* dest_cpu */:
        field.get(&dest_cpu_);
        break;
      case 6 /* running */:
        field.get(&running_);
        break;
      case 7 /* load */:
        field.get(&load_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string SchedMigrateTaskFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> SchedMigrateTaskFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void SchedMigrateTaskFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: comm
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeString(1, comm_, msg);
  }

  // Field 2: pid
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, pid_, msg);
  }

  // Field 3: prio
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, prio_, msg);
  }

  // Field 4: orig_cpu
  if (_has_field_[4]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(4, orig_cpu_, msg);
  }

  // Field 5: dest_cpu
  if (_has_field_[5]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(5, dest_cpu_, msg);
  }

  // Field 6: running
  if (_has_field_[6]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(6, running_, msg);
  }

  // Field 7: load
  if (_has_field_[7]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(7, load_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


SchedCpuUtilCfsFtraceEvent::SchedCpuUtilCfsFtraceEvent() = default;
SchedCpuUtilCfsFtraceEvent::~SchedCpuUtilCfsFtraceEvent() = default;
SchedCpuUtilCfsFtraceEvent::SchedCpuUtilCfsFtraceEvent(const SchedCpuUtilCfsFtraceEvent&) = default;
SchedCpuUtilCfsFtraceEvent& SchedCpuUtilCfsFtraceEvent::operator=(const SchedCpuUtilCfsFtraceEvent&) = default;
SchedCpuUtilCfsFtraceEvent::SchedCpuUtilCfsFtraceEvent(SchedCpuUtilCfsFtraceEvent&&) noexcept = default;
SchedCpuUtilCfsFtraceEvent& SchedCpuUtilCfsFtraceEvent::operator=(SchedCpuUtilCfsFtraceEvent&&) = default;

bool SchedCpuUtilCfsFtraceEvent::operator==(const SchedCpuUtilCfsFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(active_, other.active_)
   && ::protozero::internal::gen_helpers::EqualsField(capacity_, other.capacity_)
   && ::protozero::internal::gen_helpers::EqualsField(capacity_orig_, other.capacity_orig_)
   && ::protozero::internal::gen_helpers::EqualsField(cpu_, other.cpu_)
   && ::protozero::internal::gen_helpers::EqualsField(cpu_importance_, other.cpu_importance_)
   && ::protozero::internal::gen_helpers::EqualsField(cpu_util_, other.cpu_util_)
   && ::protozero::internal::gen_helpers::EqualsField(exit_lat_, other.exit_lat_)
   && ::protozero::internal::gen_helpers::EqualsField(group_capacity_, other.group_capacity_)
   && ::protozero::internal::gen_helpers::EqualsField(grp_overutilized_, other.grp_overutilized_)
   && ::protozero::internal::gen_helpers::EqualsField(idle_cpu_, other.idle_cpu_)
   && ::protozero::internal::gen_helpers::EqualsField(nr_running_, other.nr_running_)
   && ::protozero::internal::gen_helpers::EqualsField(spare_cap_, other.spare_cap_)
   && ::protozero::internal::gen_helpers::EqualsField(task_fits_, other.task_fits_)
   && ::protozero::internal::gen_helpers::EqualsField(wake_group_util_, other.wake_group_util_)
   && ::protozero::internal::gen_helpers::EqualsField(wake_util_, other.wake_util_);
}

bool SchedCpuUtilCfsFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* active */:
        field.get(&active_);
        break;
      case 2 /* capacity */:
        field.get(&capacity_);
        break;
      case 3 /* capacity_orig */:
        field.get(&capacity_orig_);
        break;
      case 4 /* cpu */:
        field.get(&cpu_);
        break;
      case 5 /* cpu_importance */:
        field.get(&cpu_importance_);
        break;
      case 6 /* cpu_util */:
        field.get(&cpu_util_);
        break;
      case 7 /* exit_lat */:
        field.get(&exit_lat_);
        break;
      case 8 /* group_capacity */:
        field.get(&group_capacity_);
        break;
      case 9 /* grp_overutilized */:
        field.get(&grp_overutilized_);
        break;
      case 10 /* idle_cpu */:
        field.get(&idle_cpu_);
        break;
      case 11 /* nr_running */:
        field.get(&nr_running_);
        break;
      case 12 /* spare_cap */:
        field.get(&spare_cap_);
        break;
      case 13 /* task_fits */:
        field.get(&task_fits_);
        break;
      case 14 /* wake_group_util */:
        field.get(&wake_group_util_);
        break;
      case 15 /* wake_util */:
        field.get(&wake_util_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string SchedCpuUtilCfsFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> SchedCpuUtilCfsFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void SchedCpuUtilCfsFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: active
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, active_, msg);
  }

  // Field 2: capacity
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, capacity_, msg);
  }

  // Field 3: capacity_orig
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, capacity_orig_, msg);
  }

  // Field 4: cpu
  if (_has_field_[4]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(4, cpu_, msg);
  }

  // Field 5: cpu_importance
  if (_has_field_[5]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(5, cpu_importance_, msg);
  }

  // Field 6: cpu_util
  if (_has_field_[6]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(6, cpu_util_, msg);
  }

  // Field 7: exit_lat
  if (_has_field_[7]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(7, exit_lat_, msg);
  }

  // Field 8: group_capacity
  if (_has_field_[8]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(8, group_capacity_, msg);
  }

  // Field 9: grp_overutilized
  if (_has_field_[9]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(9, grp_overutilized_, msg);
  }

  // Field 10: idle_cpu
  if (_has_field_[10]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(10, idle_cpu_, msg);
  }

  // Field 11: nr_running
  if (_has_field_[11]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(11, nr_running_, msg);
  }

  // Field 12: spare_cap
  if (_has_field_[12]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(12, spare_cap_, msg);
  }

  // Field 13: task_fits
  if (_has_field_[13]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(13, task_fits_, msg);
  }

  // Field 14: wake_group_util
  if (_has_field_[14]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(14, wake_group_util_, msg);
  }

  // Field 15: wake_util
  if (_has_field_[15]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(15, wake_util_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


SchedPiSetprioFtraceEvent::SchedPiSetprioFtraceEvent() = default;
SchedPiSetprioFtraceEvent::~SchedPiSetprioFtraceEvent() = default;
SchedPiSetprioFtraceEvent::SchedPiSetprioFtraceEvent(const SchedPiSetprioFtraceEvent&) = default;
SchedPiSetprioFtraceEvent& SchedPiSetprioFtraceEvent::operator=(const SchedPiSetprioFtraceEvent&) = default;
SchedPiSetprioFtraceEvent::SchedPiSetprioFtraceEvent(SchedPiSetprioFtraceEvent&&) noexcept = default;
SchedPiSetprioFtraceEvent& SchedPiSetprioFtraceEvent::operator=(SchedPiSetprioFtraceEvent&&) = default;

bool SchedPiSetprioFtraceEvent::operator==(const SchedPiSetprioFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(comm_, other.comm_)
   && ::protozero::internal::gen_helpers::EqualsField(newprio_, other.newprio_)
   && ::protozero::internal::gen_helpers::EqualsField(oldprio_, other.oldprio_)
   && ::protozero::internal::gen_helpers::EqualsField(pid_, other.pid_);
}

bool SchedPiSetprioFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* comm */:
        ::protozero::internal::gen_helpers::DeserializeString(field, &comm_);
        break;
      case 2 /* newprio */:
        field.get(&newprio_);
        break;
      case 3 /* oldprio */:
        field.get(&oldprio_);
        break;
      case 4 /* pid */:
        field.get(&pid_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string SchedPiSetprioFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> SchedPiSetprioFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void SchedPiSetprioFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: comm
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeString(1, comm_, msg);
  }

  // Field 2: newprio
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, newprio_, msg);
  }

  // Field 3: oldprio
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, oldprio_, msg);
  }

  // Field 4: pid
  if (_has_field_[4]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(4, pid_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


SchedProcessWaitFtraceEvent::SchedProcessWaitFtraceEvent() = default;
SchedProcessWaitFtraceEvent::~SchedProcessWaitFtraceEvent() = default;
SchedProcessWaitFtraceEvent::SchedProcessWaitFtraceEvent(const SchedProcessWaitFtraceEvent&) = default;
SchedProcessWaitFtraceEvent& SchedProcessWaitFtraceEvent::operator=(const SchedProcessWaitFtraceEvent&) = default;
SchedProcessWaitFtraceEvent::SchedProcessWaitFtraceEvent(SchedProcessWaitFtraceEvent&&) noexcept = default;
SchedProcessWaitFtraceEvent& SchedProcessWaitFtraceEvent::operator=(SchedProcessWaitFtraceEvent&&) = default;

bool SchedProcessWaitFtraceEvent::operator==(const SchedProcessWaitFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(comm_, other.comm_)
   && ::protozero::internal::gen_helpers::EqualsField(pid_, other.pid_)
   && ::protozero::internal::gen_helpers::EqualsField(prio_, other.prio_);
}

bool SchedProcessWaitFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* comm */:
        ::protozero::internal::gen_helpers::DeserializeString(field, &comm_);
        break;
      case 2 /* pid */:
        field.get(&pid_);
        break;
      case 3 /* prio */:
        field.get(&prio_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string SchedProcessWaitFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> SchedProcessWaitFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void SchedProcessWaitFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: comm
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeString(1, comm_, msg);
  }

  // Field 2: pid
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, pid_, msg);
  }

  // Field 3: prio
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, prio_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


SchedProcessHangFtraceEvent::SchedProcessHangFtraceEvent() = default;
SchedProcessHangFtraceEvent::~SchedProcessHangFtraceEvent() = default;
SchedProcessHangFtraceEvent::SchedProcessHangFtraceEvent(const SchedProcessHangFtraceEvent&) = default;
SchedProcessHangFtraceEvent& SchedProcessHangFtraceEvent::operator=(const SchedProcessHangFtraceEvent&) = default;
SchedProcessHangFtraceEvent::SchedProcessHangFtraceEvent(SchedProcessHangFtraceEvent&&) noexcept = default;
SchedProcessHangFtraceEvent& SchedProcessHangFtraceEvent::operator=(SchedProcessHangFtraceEvent&&) = default;

bool SchedProcessHangFtraceEvent::operator==(const SchedProcessHangFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(comm_, other.comm_)
   && ::protozero::internal::gen_helpers::EqualsField(pid_, other.pid_);
}

bool SchedProcessHangFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* comm */:
        ::protozero::internal::gen_helpers::DeserializeString(field, &comm_);
        break;
      case 2 /* pid */:
        field.get(&pid_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string SchedProcessHangFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> SchedProcessHangFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void SchedProcessHangFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: comm
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeString(1, comm_, msg);
  }

  // Field 2: pid
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, pid_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


SchedProcessFreeFtraceEvent::SchedProcessFreeFtraceEvent() = default;
SchedProcessFreeFtraceEvent::~SchedProcessFreeFtraceEvent() = default;
SchedProcessFreeFtraceEvent::SchedProcessFreeFtraceEvent(const SchedProcessFreeFtraceEvent&) = default;
SchedProcessFreeFtraceEvent& SchedProcessFreeFtraceEvent::operator=(const SchedProcessFreeFtraceEvent&) = default;
SchedProcessFreeFtraceEvent::SchedProcessFreeFtraceEvent(SchedProcessFreeFtraceEvent&&) noexcept = default;
SchedProcessFreeFtraceEvent& SchedProcessFreeFtraceEvent::operator=(SchedProcessFreeFtraceEvent&&) = default;

bool SchedProcessFreeFtraceEvent::operator==(const SchedProcessFreeFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(comm_, other.comm_)
   && ::protozero::internal::gen_helpers::EqualsField(pid_, other.pid_)
   && ::protozero::internal::gen_helpers::EqualsField(prio_, other.prio_);
}

bool SchedProcessFreeFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* comm */:
        ::protozero::internal::gen_helpers::DeserializeString(field, &comm_);
        break;
      case 2 /* pid */:
        field.get(&pid_);
        break;
      case 3 /* prio */:
        field.get(&prio_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string SchedProcessFreeFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> SchedProcessFreeFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void SchedProcessFreeFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: comm
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeString(1, comm_, msg);
  }

  // Field 2: pid
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, pid_, msg);
  }

  // Field 3: prio
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, prio_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


SchedProcessForkFtraceEvent::SchedProcessForkFtraceEvent() = default;
SchedProcessForkFtraceEvent::~SchedProcessForkFtraceEvent() = default;
SchedProcessForkFtraceEvent::SchedProcessForkFtraceEvent(const SchedProcessForkFtraceEvent&) = default;
SchedProcessForkFtraceEvent& SchedProcessForkFtraceEvent::operator=(const SchedProcessForkFtraceEvent&) = default;
SchedProcessForkFtraceEvent::SchedProcessForkFtraceEvent(SchedProcessForkFtraceEvent&&) noexcept = default;
SchedProcessForkFtraceEvent& SchedProcessForkFtraceEvent::operator=(SchedProcessForkFtraceEvent&&) = default;

bool SchedProcessForkFtraceEvent::operator==(const SchedProcessForkFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(parent_comm_, other.parent_comm_)
   && ::protozero::internal::gen_helpers::EqualsField(parent_pid_, other.parent_pid_)
   && ::protozero::internal::gen_helpers::EqualsField(child_comm_, other.child_comm_)
   && ::protozero::internal::gen_helpers::EqualsField(child_pid_, other.child_pid_);
}

bool SchedProcessForkFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* parent_comm */:
        ::protozero::internal::gen_helpers::DeserializeString(field, &parent_comm_);
        break;
      case 2 /* parent_pid */:
        field.get(&parent_pid_);
        break;
      case 3 /* child_comm */:
        ::protozero::internal::gen_helpers::DeserializeString(field, &child_comm_);
        break;
      case 4 /* child_pid */:
        field.get(&child_pid_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string SchedProcessForkFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> SchedProcessForkFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void SchedProcessForkFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: parent_comm
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeString(1, parent_comm_, msg);
  }

  // Field 2: parent_pid
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, parent_pid_, msg);
  }

  // Field 3: child_comm
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeString(3, child_comm_, msg);
  }

  // Field 4: child_pid
  if (_has_field_[4]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(4, child_pid_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


SchedProcessExitFtraceEvent::SchedProcessExitFtraceEvent() = default;
SchedProcessExitFtraceEvent::~SchedProcessExitFtraceEvent() = default;
SchedProcessExitFtraceEvent::SchedProcessExitFtraceEvent(const SchedProcessExitFtraceEvent&) = default;
SchedProcessExitFtraceEvent& SchedProcessExitFtraceEvent::operator=(const SchedProcessExitFtraceEvent&) = default;
SchedProcessExitFtraceEvent::SchedProcessExitFtraceEvent(SchedProcessExitFtraceEvent&&) noexcept = default;
SchedProcessExitFtraceEvent& SchedProcessExitFtraceEvent::operator=(SchedProcessExitFtraceEvent&&) = default;

bool SchedProcessExitFtraceEvent::operator==(const SchedProcessExitFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(comm_, other.comm_)
   && ::protozero::internal::gen_helpers::EqualsField(pid_, other.pid_)
   && ::protozero::internal::gen_helpers::EqualsField(tgid_, other.tgid_)
   && ::protozero::internal::gen_helpers::EqualsField(prio_, other.prio_);
}

bool SchedProcessExitFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* comm */:
        ::protozero::internal::gen_helpers::DeserializeString(field, &comm_);
        break;
      case 2 /* pid */:
        field.get(&pid_);
        break;
      case 3 /* tgid */:
        field.get(&tgid_);
        break;
      case 4 /* prio */:
        field.get(&prio_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string SchedProcessExitFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> SchedProcessExitFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void SchedProcessExitFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: comm
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeString(1, comm_, msg);
  }

  // Field 2: pid
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, pid_, msg);
  }

  // Field 3: tgid
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, tgid_, msg);
  }

  // Field 4: prio
  if (_has_field_[4]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(4, prio_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


SchedProcessExecFtraceEvent::SchedProcessExecFtraceEvent() = default;
SchedProcessExecFtraceEvent::~SchedProcessExecFtraceEvent() = default;
SchedProcessExecFtraceEvent::SchedProcessExecFtraceEvent(const SchedProcessExecFtraceEvent&) = default;
SchedProcessExecFtraceEvent& SchedProcessExecFtraceEvent::operator=(const SchedProcessExecFtraceEvent&) = default;
SchedProcessExecFtraceEvent::SchedProcessExecFtraceEvent(SchedProcessExecFtraceEvent&&) noexcept = default;
SchedProcessExecFtraceEvent& SchedProcessExecFtraceEvent::operator=(SchedProcessExecFtraceEvent&&) = default;

bool SchedProcessExecFtraceEvent::operator==(const SchedProcessExecFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(filename_, other.filename_)
   && ::protozero::internal::gen_helpers::EqualsField(pid_, other.pid_)
   && ::protozero::internal::gen_helpers::EqualsField(old_pid_, other.old_pid_);
}

bool SchedProcessExecFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* filename */:
        ::protozero::internal::gen_helpers::DeserializeString(field, &filename_);
        break;
      case 2 /* pid */:
        field.get(&pid_);
        break;
      case 3 /* old_pid */:
        field.get(&old_pid_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string SchedProcessExecFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> SchedProcessExecFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void SchedProcessExecFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: filename
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeString(1, filename_, msg);
  }

  // Field 2: pid
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, pid_, msg);
  }

  // Field 3: old_pid
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, old_pid_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


SchedWakeupNewFtraceEvent::SchedWakeupNewFtraceEvent() = default;
SchedWakeupNewFtraceEvent::~SchedWakeupNewFtraceEvent() = default;
SchedWakeupNewFtraceEvent::SchedWakeupNewFtraceEvent(const SchedWakeupNewFtraceEvent&) = default;
SchedWakeupNewFtraceEvent& SchedWakeupNewFtraceEvent::operator=(const SchedWakeupNewFtraceEvent&) = default;
SchedWakeupNewFtraceEvent::SchedWakeupNewFtraceEvent(SchedWakeupNewFtraceEvent&&) noexcept = default;
SchedWakeupNewFtraceEvent& SchedWakeupNewFtraceEvent::operator=(SchedWakeupNewFtraceEvent&&) = default;

bool SchedWakeupNewFtraceEvent::operator==(const SchedWakeupNewFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(comm_, other.comm_)
   && ::protozero::internal::gen_helpers::EqualsField(pid_, other.pid_)
   && ::protozero::internal::gen_helpers::EqualsField(prio_, other.prio_)
   && ::protozero::internal::gen_helpers::EqualsField(success_, other.success_)
   && ::protozero::internal::gen_helpers::EqualsField(target_cpu_, other.target_cpu_);
}

bool SchedWakeupNewFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* comm */:
        ::protozero::internal::gen_helpers::DeserializeString(field, &comm_);
        break;
      case 2 /* pid */:
        field.get(&pid_);
        break;
      case 3 /* prio */:
        field.get(&prio_);
        break;
      case 4 /* success */:
        field.get(&success_);
        break;
      case 5 /* target_cpu */:
        field.get(&target_cpu_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string SchedWakeupNewFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> SchedWakeupNewFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void SchedWakeupNewFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: comm
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeString(1, comm_, msg);
  }

  // Field 2: pid
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, pid_, msg);
  }

  // Field 3: prio
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, prio_, msg);
  }

  // Field 4: success
  if (_has_field_[4]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(4, success_, msg);
  }

  // Field 5: target_cpu
  if (_has_field_[5]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(5, target_cpu_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


SchedWakingFtraceEvent::SchedWakingFtraceEvent() = default;
SchedWakingFtraceEvent::~SchedWakingFtraceEvent() = default;
SchedWakingFtraceEvent::SchedWakingFtraceEvent(const SchedWakingFtraceEvent&) = default;
SchedWakingFtraceEvent& SchedWakingFtraceEvent::operator=(const SchedWakingFtraceEvent&) = default;
SchedWakingFtraceEvent::SchedWakingFtraceEvent(SchedWakingFtraceEvent&&) noexcept = default;
SchedWakingFtraceEvent& SchedWakingFtraceEvent::operator=(SchedWakingFtraceEvent&&) = default;

bool SchedWakingFtraceEvent::operator==(const SchedWakingFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(comm_, other.comm_)
   && ::protozero::internal::gen_helpers::EqualsField(pid_, other.pid_)
   && ::protozero::internal::gen_helpers::EqualsField(prio_, other.prio_)
   && ::protozero::internal::gen_helpers::EqualsField(success_, other.success_)
   && ::protozero::internal::gen_helpers::EqualsField(target_cpu_, other.target_cpu_);
}

bool SchedWakingFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* comm */:
        ::protozero::internal::gen_helpers::DeserializeString(field, &comm_);
        break;
      case 2 /* pid */:
        field.get(&pid_);
        break;
      case 3 /* prio */:
        field.get(&prio_);
        break;
      case 4 /* success */:
        field.get(&success_);
        break;
      case 5 /* target_cpu */:
        field.get(&target_cpu_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string SchedWakingFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> SchedWakingFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void SchedWakingFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: comm
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeString(1, comm_, msg);
  }

  // Field 2: pid
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, pid_, msg);
  }

  // Field 3: prio
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, prio_, msg);
  }

  // Field 4: success
  if (_has_field_[4]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(4, success_, msg);
  }

  // Field 5: target_cpu
  if (_has_field_[5]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(5, target_cpu_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


SchedCpuHotplugFtraceEvent::SchedCpuHotplugFtraceEvent() = default;
SchedCpuHotplugFtraceEvent::~SchedCpuHotplugFtraceEvent() = default;
SchedCpuHotplugFtraceEvent::SchedCpuHotplugFtraceEvent(const SchedCpuHotplugFtraceEvent&) = default;
SchedCpuHotplugFtraceEvent& SchedCpuHotplugFtraceEvent::operator=(const SchedCpuHotplugFtraceEvent&) = default;
SchedCpuHotplugFtraceEvent::SchedCpuHotplugFtraceEvent(SchedCpuHotplugFtraceEvent&&) noexcept = default;
SchedCpuHotplugFtraceEvent& SchedCpuHotplugFtraceEvent::operator=(SchedCpuHotplugFtraceEvent&&) = default;

bool SchedCpuHotplugFtraceEvent::operator==(const SchedCpuHotplugFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(affected_cpu_, other.affected_cpu_)
   && ::protozero::internal::gen_helpers::EqualsField(error_, other.error_)
   && ::protozero::internal::gen_helpers::EqualsField(status_, other.status_);
}

bool SchedCpuHotplugFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* affected_cpu */:
        field.get(&affected_cpu_);
        break;
      case 2 /* error */:
        field.get(&error_);
        break;
      case 3 /* status */:
        field.get(&status_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string SchedCpuHotplugFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> SchedCpuHotplugFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void SchedCpuHotplugFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: affected_cpu
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, affected_cpu_, msg);
  }

  // Field 2: error
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, error_, msg);
  }

  // Field 3: status
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, status_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


SchedBlockedReasonFtraceEvent::SchedBlockedReasonFtraceEvent() = default;
SchedBlockedReasonFtraceEvent::~SchedBlockedReasonFtraceEvent() = default;
SchedBlockedReasonFtraceEvent::SchedBlockedReasonFtraceEvent(const SchedBlockedReasonFtraceEvent&) = default;
SchedBlockedReasonFtraceEvent& SchedBlockedReasonFtraceEvent::operator=(const SchedBlockedReasonFtraceEvent&) = default;
SchedBlockedReasonFtraceEvent::SchedBlockedReasonFtraceEvent(SchedBlockedReasonFtraceEvent&&) noexcept = default;
SchedBlockedReasonFtraceEvent& SchedBlockedReasonFtraceEvent::operator=(SchedBlockedReasonFtraceEvent&&) = default;

bool SchedBlockedReasonFtraceEvent::operator==(const SchedBlockedReasonFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(pid_, other.pid_)
   && ::protozero::internal::gen_helpers::EqualsField(caller_, other.caller_)
   && ::protozero::internal::gen_helpers::EqualsField(io_wait_, other.io_wait_);
}

bool SchedBlockedReasonFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* pid */:
        field.get(&pid_);
        break;
      case 2 /* caller */:
        field.get(&caller_);
        break;
      case 3 /* io_wait */:
        field.get(&io_wait_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string SchedBlockedReasonFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> SchedBlockedReasonFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void SchedBlockedReasonFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: pid
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, pid_, msg);
  }

  // Field 2: caller
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, caller_, msg);
  }

  // Field 3: io_wait
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, io_wait_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


SchedWakeupFtraceEvent::SchedWakeupFtraceEvent() = default;
SchedWakeupFtraceEvent::~SchedWakeupFtraceEvent() = default;
SchedWakeupFtraceEvent::SchedWakeupFtraceEvent(const SchedWakeupFtraceEvent&) = default;
SchedWakeupFtraceEvent& SchedWakeupFtraceEvent::operator=(const SchedWakeupFtraceEvent&) = default;
SchedWakeupFtraceEvent::SchedWakeupFtraceEvent(SchedWakeupFtraceEvent&&) noexcept = default;
SchedWakeupFtraceEvent& SchedWakeupFtraceEvent::operator=(SchedWakeupFtraceEvent&&) = default;

bool SchedWakeupFtraceEvent::operator==(const SchedWakeupFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(comm_, other.comm_)
   && ::protozero::internal::gen_helpers::EqualsField(pid_, other.pid_)
   && ::protozero::internal::gen_helpers::EqualsField(prio_, other.prio_)
   && ::protozero::internal::gen_helpers::EqualsField(success_, other.success_)
   && ::protozero::internal::gen_helpers::EqualsField(target_cpu_, other.target_cpu_);
}

bool SchedWakeupFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* comm */:
        ::protozero::internal::gen_helpers::DeserializeString(field, &comm_);
        break;
      case 2 /* pid */:
        field.get(&pid_);
        break;
      case 3 /* prio */:
        field.get(&prio_);
        break;
      case 4 /* success */:
        field.get(&success_);
        break;
      case 5 /* target_cpu */:
        field.get(&target_cpu_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string SchedWakeupFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> SchedWakeupFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void SchedWakeupFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: comm
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeString(1, comm_, msg);
  }

  // Field 2: pid
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, pid_, msg);
  }

  // Field 3: prio
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, prio_, msg);
  }

  // Field 4: success
  if (_has_field_[4]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(4, success_, msg);
  }

  // Field 5: target_cpu
  if (_has_field_[5]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(5, target_cpu_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


SchedSwitchFtraceEvent::SchedSwitchFtraceEvent() = default;
SchedSwitchFtraceEvent::~SchedSwitchFtraceEvent() = default;
SchedSwitchFtraceEvent::SchedSwitchFtraceEvent(const SchedSwitchFtraceEvent&) = default;
SchedSwitchFtraceEvent& SchedSwitchFtraceEvent::operator=(const SchedSwitchFtraceEvent&) = default;
SchedSwitchFtraceEvent::SchedSwitchFtraceEvent(SchedSwitchFtraceEvent&&) noexcept = default;
SchedSwitchFtraceEvent& SchedSwitchFtraceEvent::operator=(SchedSwitchFtraceEvent&&) = default;

bool SchedSwitchFtraceEvent::operator==(const SchedSwitchFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(prev_comm_, other.prev_comm_)
   && ::protozero::internal::gen_helpers::EqualsField(prev_pid_, other.prev_pid_)
   && ::protozero::internal::gen_helpers::EqualsField(prev_prio_, other.prev_prio_)
   && ::protozero::internal::gen_helpers::EqualsField(prev_state_, other.prev_state_)
   && ::protozero::internal::gen_helpers::EqualsField(next_comm_, other.next_comm_)
   && ::protozero::internal::gen_helpers::EqualsField(next_pid_, other.next_pid_)
   && ::protozero::internal::gen_helpers::EqualsField(next_prio_, other.next_prio_);
}

bool SchedSwitchFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* prev_comm */:
        ::protozero::internal::gen_helpers::DeserializeString(field, &prev_comm_);
        break;
      case 2 /* prev_pid */:
        field.get(&prev_pid_);
        break;
      case 3 /* prev_prio */:
        field.get(&prev_prio_);
        break;
      case 4 /* prev_state */:
        field.get(&prev_state_);
        break;
      case 5 /* next_comm */:
        ::protozero::internal::gen_helpers::DeserializeString(field, &next_comm_);
        break;
      case 6 /* next_pid */:
        field.get(&next_pid_);
        break;
      case 7 /* next_prio */:
        field.get(&next_prio_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string SchedSwitchFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> SchedSwitchFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void SchedSwitchFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: prev_comm
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeString(1, prev_comm_, msg);
  }

  // Field 2: prev_pid
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, prev_pid_, msg);
  }

  // Field 3: prev_prio
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, prev_prio_, msg);
  }

  // Field 4: prev_state
  if (_has_field_[4]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(4, prev_state_, msg);
  }

  // Field 5: next_comm
  if (_has_field_[5]) {
    ::protozero::internal::gen_helpers::SerializeString(5, next_comm_, msg);
  }

  // Field 6: next_pid
  if (_has_field_[6]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(6, next_pid_, msg);
  }

  // Field 7: next_prio
  if (_has_field_[7]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(7, next_prio_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}

}  // namespace perfetto
}  // namespace protos
}  // namespace gen
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif
