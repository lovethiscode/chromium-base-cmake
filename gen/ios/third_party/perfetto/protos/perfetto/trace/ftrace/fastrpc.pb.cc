// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/trace/ftrace/fastrpc.proto

#include "protos/perfetto/trace/ftrace/fastrpc.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace perfetto {
namespace protos {
PROTOBUF_CONSTEXPR FastrpcDmaStatFtraceEvent::FastrpcDmaStatFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.len_)*/int64_t{0}
  , /*decltype(_impl_.total_allocated_)*/uint64_t{0u}
  , /*decltype(_impl_.cid_)*/0} {}
struct FastrpcDmaStatFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FastrpcDmaStatFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FastrpcDmaStatFtraceEventDefaultTypeInternal() {}
  union {
    FastrpcDmaStatFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FastrpcDmaStatFtraceEventDefaultTypeInternal _FastrpcDmaStatFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR FastrpcDmaFreeFtraceEvent::FastrpcDmaFreeFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.phys_)*/uint64_t{0u}
  , /*decltype(_impl_.size_)*/uint64_t{0u}
  , /*decltype(_impl_.cid_)*/0} {}
struct FastrpcDmaFreeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FastrpcDmaFreeFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FastrpcDmaFreeFtraceEventDefaultTypeInternal() {}
  union {
    FastrpcDmaFreeFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FastrpcDmaFreeFtraceEventDefaultTypeInternal _FastrpcDmaFreeFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR FastrpcDmaAllocFtraceEvent::FastrpcDmaAllocFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.phys_)*/uint64_t{0u}
  , /*decltype(_impl_.size_)*/uint64_t{0u}
  , /*decltype(_impl_.cid_)*/0
  , /*decltype(_impl_.mflags_)*/0
  , /*decltype(_impl_.attr_)*/uint64_t{0u}} {}
struct FastrpcDmaAllocFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FastrpcDmaAllocFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FastrpcDmaAllocFtraceEventDefaultTypeInternal() {}
  union {
    FastrpcDmaAllocFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FastrpcDmaAllocFtraceEventDefaultTypeInternal _FastrpcDmaAllocFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR FastrpcDmaUnmapFtraceEvent::FastrpcDmaUnmapFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.phys_)*/uint64_t{0u}
  , /*decltype(_impl_.size_)*/uint64_t{0u}
  , /*decltype(_impl_.cid_)*/0} {}
struct FastrpcDmaUnmapFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FastrpcDmaUnmapFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FastrpcDmaUnmapFtraceEventDefaultTypeInternal() {}
  union {
    FastrpcDmaUnmapFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FastrpcDmaUnmapFtraceEventDefaultTypeInternal _FastrpcDmaUnmapFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR FastrpcDmaMapFtraceEvent::FastrpcDmaMapFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cid_)*/0
  , /*decltype(_impl_.fd_)*/0
  , /*decltype(_impl_.phys_)*/uint64_t{0u}
  , /*decltype(_impl_.size_)*/uint64_t{0u}
  , /*decltype(_impl_.len_)*/uint64_t{0u}
  , /*decltype(_impl_.attr_)*/0u
  , /*decltype(_impl_.mflags_)*/0} {}
struct FastrpcDmaMapFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FastrpcDmaMapFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FastrpcDmaMapFtraceEventDefaultTypeInternal() {}
  union {
    FastrpcDmaMapFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FastrpcDmaMapFtraceEventDefaultTypeInternal _FastrpcDmaMapFtraceEvent_default_instance_;
}  // namespace protos
}  // namespace perfetto
namespace perfetto {
namespace protos {

// ===================================================================

class FastrpcDmaStatFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<FastrpcDmaStatFtraceEvent>()._impl_._has_bits_);
  static void set_has_cid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_total_allocated(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

FastrpcDmaStatFtraceEvent::FastrpcDmaStatFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.FastrpcDmaStatFtraceEvent)
}
FastrpcDmaStatFtraceEvent::FastrpcDmaStatFtraceEvent(const FastrpcDmaStatFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  FastrpcDmaStatFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.len_){}
    , decltype(_impl_.total_allocated_){}
    , decltype(_impl_.cid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.len_, &from._impl_.len_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.cid_) -
    reinterpret_cast<char*>(&_impl_.len_)) + sizeof(_impl_.cid_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.FastrpcDmaStatFtraceEvent)
}

inline void FastrpcDmaStatFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.len_){int64_t{0}}
    , decltype(_impl_.total_allocated_){uint64_t{0u}}
    , decltype(_impl_.cid_){0}
  };
}

FastrpcDmaStatFtraceEvent::~FastrpcDmaStatFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.FastrpcDmaStatFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FastrpcDmaStatFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FastrpcDmaStatFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FastrpcDmaStatFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.FastrpcDmaStatFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.len_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.cid_) -
        reinterpret_cast<char*>(&_impl_.len_)) + sizeof(_impl_.cid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FastrpcDmaStatFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 cid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_cid(&has_bits);
          _impl_.cid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 len = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 total_allocated = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_total_allocated(&has_bits);
          _impl_.total_allocated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FastrpcDmaStatFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.FastrpcDmaStatFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 cid = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_cid(), target);
  }

  // optional int64 len = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_len(), target);
  }

  // optional uint64 total_allocated = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_total_allocated(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.FastrpcDmaStatFtraceEvent)
  return target;
}

size_t FastrpcDmaStatFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.FastrpcDmaStatFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int64 len = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_len());
    }

    // optional uint64 total_allocated = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_total_allocated());
    }

    // optional int32 cid = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_cid());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FastrpcDmaStatFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FastrpcDmaStatFtraceEvent*>(
      &from));
}

void FastrpcDmaStatFtraceEvent::MergeFrom(const FastrpcDmaStatFtraceEvent& from) {
  FastrpcDmaStatFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.FastrpcDmaStatFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.total_allocated_ = from._impl_.total_allocated_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.cid_ = from._impl_.cid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FastrpcDmaStatFtraceEvent::CopyFrom(const FastrpcDmaStatFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.FastrpcDmaStatFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FastrpcDmaStatFtraceEvent::IsInitialized() const {
  return true;
}

void FastrpcDmaStatFtraceEvent::InternalSwap(FastrpcDmaStatFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FastrpcDmaStatFtraceEvent, _impl_.cid_)
      + sizeof(FastrpcDmaStatFtraceEvent::_impl_.cid_)
      - PROTOBUF_FIELD_OFFSET(FastrpcDmaStatFtraceEvent, _impl_.len_)>(
          reinterpret_cast<char*>(&_impl_.len_),
          reinterpret_cast<char*>(&other->_impl_.len_));
}

std::string FastrpcDmaStatFtraceEvent::GetTypeName() const {
  return "perfetto.protos.FastrpcDmaStatFtraceEvent";
}


// ===================================================================

class FastrpcDmaFreeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<FastrpcDmaFreeFtraceEvent>()._impl_._has_bits_);
  static void set_has_cid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_phys(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

FastrpcDmaFreeFtraceEvent::FastrpcDmaFreeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.FastrpcDmaFreeFtraceEvent)
}
FastrpcDmaFreeFtraceEvent::FastrpcDmaFreeFtraceEvent(const FastrpcDmaFreeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  FastrpcDmaFreeFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.phys_){}
    , decltype(_impl_.size_){}
    , decltype(_impl_.cid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.phys_, &from._impl_.phys_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.cid_) -
    reinterpret_cast<char*>(&_impl_.phys_)) + sizeof(_impl_.cid_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.FastrpcDmaFreeFtraceEvent)
}

inline void FastrpcDmaFreeFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.phys_){uint64_t{0u}}
    , decltype(_impl_.size_){uint64_t{0u}}
    , decltype(_impl_.cid_){0}
  };
}

FastrpcDmaFreeFtraceEvent::~FastrpcDmaFreeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.FastrpcDmaFreeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FastrpcDmaFreeFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FastrpcDmaFreeFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FastrpcDmaFreeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.FastrpcDmaFreeFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.phys_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.cid_) -
        reinterpret_cast<char*>(&_impl_.phys_)) + sizeof(_impl_.cid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FastrpcDmaFreeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 cid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_cid(&has_bits);
          _impl_.cid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 phys = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_phys(&has_bits);
          _impl_.phys_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FastrpcDmaFreeFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.FastrpcDmaFreeFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 cid = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_cid(), target);
  }

  // optional uint64 phys = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_phys(), target);
  }

  // optional uint64 size = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.FastrpcDmaFreeFtraceEvent)
  return target;
}

size_t FastrpcDmaFreeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.FastrpcDmaFreeFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 phys = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_phys());
    }

    // optional uint64 size = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_size());
    }

    // optional int32 cid = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_cid());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FastrpcDmaFreeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FastrpcDmaFreeFtraceEvent*>(
      &from));
}

void FastrpcDmaFreeFtraceEvent::MergeFrom(const FastrpcDmaFreeFtraceEvent& from) {
  FastrpcDmaFreeFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.FastrpcDmaFreeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.phys_ = from._impl_.phys_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.cid_ = from._impl_.cid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FastrpcDmaFreeFtraceEvent::CopyFrom(const FastrpcDmaFreeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.FastrpcDmaFreeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FastrpcDmaFreeFtraceEvent::IsInitialized() const {
  return true;
}

void FastrpcDmaFreeFtraceEvent::InternalSwap(FastrpcDmaFreeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FastrpcDmaFreeFtraceEvent, _impl_.cid_)
      + sizeof(FastrpcDmaFreeFtraceEvent::_impl_.cid_)
      - PROTOBUF_FIELD_OFFSET(FastrpcDmaFreeFtraceEvent, _impl_.phys_)>(
          reinterpret_cast<char*>(&_impl_.phys_),
          reinterpret_cast<char*>(&other->_impl_.phys_));
}

std::string FastrpcDmaFreeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.FastrpcDmaFreeFtraceEvent";
}


// ===================================================================

class FastrpcDmaAllocFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<FastrpcDmaAllocFtraceEvent>()._impl_._has_bits_);
  static void set_has_cid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_phys(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_attr(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_mflags(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

FastrpcDmaAllocFtraceEvent::FastrpcDmaAllocFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.FastrpcDmaAllocFtraceEvent)
}
FastrpcDmaAllocFtraceEvent::FastrpcDmaAllocFtraceEvent(const FastrpcDmaAllocFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  FastrpcDmaAllocFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.phys_){}
    , decltype(_impl_.size_){}
    , decltype(_impl_.cid_){}
    , decltype(_impl_.mflags_){}
    , decltype(_impl_.attr_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.phys_, &from._impl_.phys_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.attr_) -
    reinterpret_cast<char*>(&_impl_.phys_)) + sizeof(_impl_.attr_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.FastrpcDmaAllocFtraceEvent)
}

inline void FastrpcDmaAllocFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.phys_){uint64_t{0u}}
    , decltype(_impl_.size_){uint64_t{0u}}
    , decltype(_impl_.cid_){0}
    , decltype(_impl_.mflags_){0}
    , decltype(_impl_.attr_){uint64_t{0u}}
  };
}

FastrpcDmaAllocFtraceEvent::~FastrpcDmaAllocFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.FastrpcDmaAllocFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FastrpcDmaAllocFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FastrpcDmaAllocFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FastrpcDmaAllocFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.FastrpcDmaAllocFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.phys_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.attr_) -
        reinterpret_cast<char*>(&_impl_.phys_)) + sizeof(_impl_.attr_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FastrpcDmaAllocFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 cid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_cid(&has_bits);
          _impl_.cid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 phys = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_phys(&has_bits);
          _impl_.phys_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 attr = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_attr(&has_bits);
          _impl_.attr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mflags = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_mflags(&has_bits);
          _impl_.mflags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FastrpcDmaAllocFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.FastrpcDmaAllocFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 cid = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_cid(), target);
  }

  // optional uint64 phys = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_phys(), target);
  }

  // optional uint64 size = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_size(), target);
  }

  // optional uint64 attr = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_attr(), target);
  }

  // optional int32 mflags = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_mflags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.FastrpcDmaAllocFtraceEvent)
  return target;
}

size_t FastrpcDmaAllocFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.FastrpcDmaAllocFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 phys = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_phys());
    }

    // optional uint64 size = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_size());
    }

    // optional int32 cid = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_cid());
    }

    // optional int32 mflags = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mflags());
    }

    // optional uint64 attr = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_attr());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FastrpcDmaAllocFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FastrpcDmaAllocFtraceEvent*>(
      &from));
}

void FastrpcDmaAllocFtraceEvent::MergeFrom(const FastrpcDmaAllocFtraceEvent& from) {
  FastrpcDmaAllocFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.FastrpcDmaAllocFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.phys_ = from._impl_.phys_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.cid_ = from._impl_.cid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.mflags_ = from._impl_.mflags_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.attr_ = from._impl_.attr_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FastrpcDmaAllocFtraceEvent::CopyFrom(const FastrpcDmaAllocFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.FastrpcDmaAllocFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FastrpcDmaAllocFtraceEvent::IsInitialized() const {
  return true;
}

void FastrpcDmaAllocFtraceEvent::InternalSwap(FastrpcDmaAllocFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FastrpcDmaAllocFtraceEvent, _impl_.attr_)
      + sizeof(FastrpcDmaAllocFtraceEvent::_impl_.attr_)
      - PROTOBUF_FIELD_OFFSET(FastrpcDmaAllocFtraceEvent, _impl_.phys_)>(
          reinterpret_cast<char*>(&_impl_.phys_),
          reinterpret_cast<char*>(&other->_impl_.phys_));
}

std::string FastrpcDmaAllocFtraceEvent::GetTypeName() const {
  return "perfetto.protos.FastrpcDmaAllocFtraceEvent";
}


// ===================================================================

class FastrpcDmaUnmapFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<FastrpcDmaUnmapFtraceEvent>()._impl_._has_bits_);
  static void set_has_cid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_phys(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

FastrpcDmaUnmapFtraceEvent::FastrpcDmaUnmapFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.FastrpcDmaUnmapFtraceEvent)
}
FastrpcDmaUnmapFtraceEvent::FastrpcDmaUnmapFtraceEvent(const FastrpcDmaUnmapFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  FastrpcDmaUnmapFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.phys_){}
    , decltype(_impl_.size_){}
    , decltype(_impl_.cid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.phys_, &from._impl_.phys_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.cid_) -
    reinterpret_cast<char*>(&_impl_.phys_)) + sizeof(_impl_.cid_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.FastrpcDmaUnmapFtraceEvent)
}

inline void FastrpcDmaUnmapFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.phys_){uint64_t{0u}}
    , decltype(_impl_.size_){uint64_t{0u}}
    , decltype(_impl_.cid_){0}
  };
}

FastrpcDmaUnmapFtraceEvent::~FastrpcDmaUnmapFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.FastrpcDmaUnmapFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FastrpcDmaUnmapFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FastrpcDmaUnmapFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FastrpcDmaUnmapFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.FastrpcDmaUnmapFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.phys_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.cid_) -
        reinterpret_cast<char*>(&_impl_.phys_)) + sizeof(_impl_.cid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FastrpcDmaUnmapFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 cid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_cid(&has_bits);
          _impl_.cid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 phys = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_phys(&has_bits);
          _impl_.phys_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FastrpcDmaUnmapFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.FastrpcDmaUnmapFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 cid = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_cid(), target);
  }

  // optional uint64 phys = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_phys(), target);
  }

  // optional uint64 size = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.FastrpcDmaUnmapFtraceEvent)
  return target;
}

size_t FastrpcDmaUnmapFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.FastrpcDmaUnmapFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 phys = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_phys());
    }

    // optional uint64 size = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_size());
    }

    // optional int32 cid = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_cid());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FastrpcDmaUnmapFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FastrpcDmaUnmapFtraceEvent*>(
      &from));
}

void FastrpcDmaUnmapFtraceEvent::MergeFrom(const FastrpcDmaUnmapFtraceEvent& from) {
  FastrpcDmaUnmapFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.FastrpcDmaUnmapFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.phys_ = from._impl_.phys_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.cid_ = from._impl_.cid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FastrpcDmaUnmapFtraceEvent::CopyFrom(const FastrpcDmaUnmapFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.FastrpcDmaUnmapFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FastrpcDmaUnmapFtraceEvent::IsInitialized() const {
  return true;
}

void FastrpcDmaUnmapFtraceEvent::InternalSwap(FastrpcDmaUnmapFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FastrpcDmaUnmapFtraceEvent, _impl_.cid_)
      + sizeof(FastrpcDmaUnmapFtraceEvent::_impl_.cid_)
      - PROTOBUF_FIELD_OFFSET(FastrpcDmaUnmapFtraceEvent, _impl_.phys_)>(
          reinterpret_cast<char*>(&_impl_.phys_),
          reinterpret_cast<char*>(&other->_impl_.phys_));
}

std::string FastrpcDmaUnmapFtraceEvent::GetTypeName() const {
  return "perfetto.protos.FastrpcDmaUnmapFtraceEvent";
}


// ===================================================================

class FastrpcDmaMapFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<FastrpcDmaMapFtraceEvent>()._impl_._has_bits_);
  static void set_has_cid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_fd(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_phys(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_attr(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_mflags(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

FastrpcDmaMapFtraceEvent::FastrpcDmaMapFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.FastrpcDmaMapFtraceEvent)
}
FastrpcDmaMapFtraceEvent::FastrpcDmaMapFtraceEvent(const FastrpcDmaMapFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  FastrpcDmaMapFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cid_){}
    , decltype(_impl_.fd_){}
    , decltype(_impl_.phys_){}
    , decltype(_impl_.size_){}
    , decltype(_impl_.len_){}
    , decltype(_impl_.attr_){}
    , decltype(_impl_.mflags_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.cid_, &from._impl_.cid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.mflags_) -
    reinterpret_cast<char*>(&_impl_.cid_)) + sizeof(_impl_.mflags_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.FastrpcDmaMapFtraceEvent)
}

inline void FastrpcDmaMapFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cid_){0}
    , decltype(_impl_.fd_){0}
    , decltype(_impl_.phys_){uint64_t{0u}}
    , decltype(_impl_.size_){uint64_t{0u}}
    , decltype(_impl_.len_){uint64_t{0u}}
    , decltype(_impl_.attr_){0u}
    , decltype(_impl_.mflags_){0}
  };
}

FastrpcDmaMapFtraceEvent::~FastrpcDmaMapFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.FastrpcDmaMapFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FastrpcDmaMapFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FastrpcDmaMapFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FastrpcDmaMapFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.FastrpcDmaMapFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&_impl_.cid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.mflags_) -
        reinterpret_cast<char*>(&_impl_.cid_)) + sizeof(_impl_.mflags_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FastrpcDmaMapFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 cid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_cid(&has_bits);
          _impl_.cid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 fd = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_fd(&has_bits);
          _impl_.fd_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 phys = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_phys(&has_bits);
          _impl_.phys_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 len = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 attr = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_attr(&has_bits);
          _impl_.attr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mflags = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_mflags(&has_bits);
          _impl_.mflags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FastrpcDmaMapFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.FastrpcDmaMapFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 cid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_cid(), target);
  }

  // optional int32 fd = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_fd(), target);
  }

  // optional uint64 phys = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_phys(), target);
  }

  // optional uint64 size = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_size(), target);
  }

  // optional uint64 len = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_len(), target);
  }

  // optional uint32 attr = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_attr(), target);
  }

  // optional int32 mflags = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_mflags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.FastrpcDmaMapFtraceEvent)
  return target;
}

size_t FastrpcDmaMapFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.FastrpcDmaMapFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional int32 cid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_cid());
    }

    // optional int32 fd = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_fd());
    }

    // optional uint64 phys = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_phys());
    }

    // optional uint64 size = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_size());
    }

    // optional uint64 len = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_len());
    }

    // optional uint32 attr = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_attr());
    }

    // optional int32 mflags = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mflags());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FastrpcDmaMapFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FastrpcDmaMapFtraceEvent*>(
      &from));
}

void FastrpcDmaMapFtraceEvent::MergeFrom(const FastrpcDmaMapFtraceEvent& from) {
  FastrpcDmaMapFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.FastrpcDmaMapFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.cid_ = from._impl_.cid_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.fd_ = from._impl_.fd_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.phys_ = from._impl_.phys_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.attr_ = from._impl_.attr_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.mflags_ = from._impl_.mflags_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FastrpcDmaMapFtraceEvent::CopyFrom(const FastrpcDmaMapFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.FastrpcDmaMapFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FastrpcDmaMapFtraceEvent::IsInitialized() const {
  return true;
}

void FastrpcDmaMapFtraceEvent::InternalSwap(FastrpcDmaMapFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FastrpcDmaMapFtraceEvent, _impl_.mflags_)
      + sizeof(FastrpcDmaMapFtraceEvent::_impl_.mflags_)
      - PROTOBUF_FIELD_OFFSET(FastrpcDmaMapFtraceEvent, _impl_.cid_)>(
          reinterpret_cast<char*>(&_impl_.cid_),
          reinterpret_cast<char*>(&other->_impl_.cid_));
}

std::string FastrpcDmaMapFtraceEvent::GetTypeName() const {
  return "perfetto.protos.FastrpcDmaMapFtraceEvent";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace protos
}  // namespace perfetto
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::perfetto::protos::FastrpcDmaStatFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::FastrpcDmaStatFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::FastrpcDmaStatFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::FastrpcDmaFreeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::FastrpcDmaFreeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::FastrpcDmaFreeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::FastrpcDmaAllocFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::FastrpcDmaAllocFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::FastrpcDmaAllocFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::FastrpcDmaUnmapFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::FastrpcDmaUnmapFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::FastrpcDmaUnmapFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::FastrpcDmaMapFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::FastrpcDmaMapFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::FastrpcDmaMapFtraceEvent >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
