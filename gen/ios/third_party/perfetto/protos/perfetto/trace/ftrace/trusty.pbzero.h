// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_TRUSTY_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_TRUSTY_PROTO_H_

#include <stddef.h>
#include <stdint.h>

#include "perfetto/protozero/field_writer.h"
#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/proto_utils.h"


namespace perfetto {
namespace protos {
namespace pbzero {

class TrustyEnqueueNopFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TrustyEnqueueNopFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TrustyEnqueueNopFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TrustyEnqueueNopFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_arg1() const { return at<1>().valid(); }
  uint32_t arg1() const { return at<1>().as_uint32(); }
  bool has_arg2() const { return at<2>().valid(); }
  uint32_t arg2() const { return at<2>().as_uint32(); }
  bool has_arg3() const { return at<3>().valid(); }
  uint32_t arg3() const { return at<3>().as_uint32(); }
};

class TrustyEnqueueNopFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = TrustyEnqueueNopFtraceEvent_Decoder;
  enum : int32_t {
    kArg1FieldNumber = 1,
    kArg2FieldNumber = 2,
    kArg3FieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.TrustyEnqueueNopFtraceEvent"; }


  using FieldMetadata_Arg1 =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      TrustyEnqueueNopFtraceEvent>;

  static constexpr FieldMetadata_Arg1 kArg1{};
  void set_arg1(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Arg1::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Arg2 =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      TrustyEnqueueNopFtraceEvent>;

  static constexpr FieldMetadata_Arg2 kArg2{};
  void set_arg2(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Arg2::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Arg3 =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      TrustyEnqueueNopFtraceEvent>;

  static constexpr FieldMetadata_Arg3 kArg3{};
  void set_arg3(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Arg3::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }
};

class TrustyIpcRxFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TrustyIpcRxFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TrustyIpcRxFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TrustyIpcRxFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_buf_id() const { return at<1>().valid(); }
  uint64_t buf_id() const { return at<1>().as_uint64(); }
  bool has_chan() const { return at<2>().valid(); }
  uint32_t chan() const { return at<2>().as_uint32(); }
  bool has_srv_name() const { return at<3>().valid(); }
  ::protozero::ConstChars srv_name() const { return at<3>().as_string(); }
};

class TrustyIpcRxFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = TrustyIpcRxFtraceEvent_Decoder;
  enum : int32_t {
    kBufIdFieldNumber = 1,
    kChanFieldNumber = 2,
    kSrvNameFieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.TrustyIpcRxFtraceEvent"; }


  using FieldMetadata_BufId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      TrustyIpcRxFtraceEvent>;

  static constexpr FieldMetadata_BufId kBufId{};
  void set_buf_id(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_BufId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Chan =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      TrustyIpcRxFtraceEvent>;

  static constexpr FieldMetadata_Chan kChan{};
  void set_chan(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Chan::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SrvName =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      TrustyIpcRxFtraceEvent>;

  static constexpr FieldMetadata_SrvName kSrvName{};
  void set_srv_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_SrvName::kFieldId, data, size);
  }
  void set_srv_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_SrvName::kFieldId, chars.data, chars.size);
  }
  void set_srv_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_SrvName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }
};

class TrustyIpcReadEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TrustyIpcReadEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TrustyIpcReadEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TrustyIpcReadEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_buf_id() const { return at<1>().valid(); }
  uint64_t buf_id() const { return at<1>().as_uint64(); }
  bool has_chan() const { return at<2>().valid(); }
  uint32_t chan() const { return at<2>().as_uint32(); }
  bool has_len_or_err() const { return at<3>().valid(); }
  int32_t len_or_err() const { return at<3>().as_int32(); }
  bool has_shm_cnt() const { return at<4>().valid(); }
  uint64_t shm_cnt() const { return at<4>().as_uint64(); }
  bool has_srv_name() const { return at<5>().valid(); }
  ::protozero::ConstChars srv_name() const { return at<5>().as_string(); }
};

class TrustyIpcReadEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = TrustyIpcReadEndFtraceEvent_Decoder;
  enum : int32_t {
    kBufIdFieldNumber = 1,
    kChanFieldNumber = 2,
    kLenOrErrFieldNumber = 3,
    kShmCntFieldNumber = 4,
    kSrvNameFieldNumber = 5,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.TrustyIpcReadEndFtraceEvent"; }


  using FieldMetadata_BufId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      TrustyIpcReadEndFtraceEvent>;

  static constexpr FieldMetadata_BufId kBufId{};
  void set_buf_id(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_BufId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Chan =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      TrustyIpcReadEndFtraceEvent>;

  static constexpr FieldMetadata_Chan kChan{};
  void set_chan(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Chan::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_LenOrErr =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      TrustyIpcReadEndFtraceEvent>;

  static constexpr FieldMetadata_LenOrErr kLenOrErr{};
  void set_len_or_err(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_LenOrErr::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ShmCnt =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      TrustyIpcReadEndFtraceEvent>;

  static constexpr FieldMetadata_ShmCnt kShmCnt{};
  void set_shm_cnt(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ShmCnt::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SrvName =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      TrustyIpcReadEndFtraceEvent>;

  static constexpr FieldMetadata_SrvName kSrvName{};
  void set_srv_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_SrvName::kFieldId, data, size);
  }
  void set_srv_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_SrvName::kFieldId, chars.data, chars.size);
  }
  void set_srv_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_SrvName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }
};

class TrustyIpcReadFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TrustyIpcReadFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TrustyIpcReadFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TrustyIpcReadFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_chan() const { return at<1>().valid(); }
  uint32_t chan() const { return at<1>().as_uint32(); }
  bool has_srv_name() const { return at<2>().valid(); }
  ::protozero::ConstChars srv_name() const { return at<2>().as_string(); }
};

class TrustyIpcReadFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = TrustyIpcReadFtraceEvent_Decoder;
  enum : int32_t {
    kChanFieldNumber = 1,
    kSrvNameFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.TrustyIpcReadFtraceEvent"; }


  using FieldMetadata_Chan =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      TrustyIpcReadFtraceEvent>;

  static constexpr FieldMetadata_Chan kChan{};
  void set_chan(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Chan::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SrvName =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      TrustyIpcReadFtraceEvent>;

  static constexpr FieldMetadata_SrvName kSrvName{};
  void set_srv_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_SrvName::kFieldId, data, size);
  }
  void set_srv_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_SrvName::kFieldId, chars.data, chars.size);
  }
  void set_srv_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_SrvName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }
};

class TrustyIpcPollFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TrustyIpcPollFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TrustyIpcPollFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TrustyIpcPollFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_chan() const { return at<1>().valid(); }
  uint32_t chan() const { return at<1>().as_uint32(); }
  bool has_poll_mask() const { return at<2>().valid(); }
  uint32_t poll_mask() const { return at<2>().as_uint32(); }
  bool has_srv_name() const { return at<3>().valid(); }
  ::protozero::ConstChars srv_name() const { return at<3>().as_string(); }
};

class TrustyIpcPollFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = TrustyIpcPollFtraceEvent_Decoder;
  enum : int32_t {
    kChanFieldNumber = 1,
    kPollMaskFieldNumber = 2,
    kSrvNameFieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.TrustyIpcPollFtraceEvent"; }


  using FieldMetadata_Chan =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      TrustyIpcPollFtraceEvent>;

  static constexpr FieldMetadata_Chan kChan{};
  void set_chan(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Chan::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_PollMask =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      TrustyIpcPollFtraceEvent>;

  static constexpr FieldMetadata_PollMask kPollMask{};
  void set_poll_mask(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_PollMask::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SrvName =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      TrustyIpcPollFtraceEvent>;

  static constexpr FieldMetadata_SrvName kSrvName{};
  void set_srv_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_SrvName::kFieldId, data, size);
  }
  void set_srv_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_SrvName::kFieldId, chars.data, chars.size);
  }
  void set_srv_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_SrvName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }
};

class TrustyIpcWriteFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TrustyIpcWriteFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TrustyIpcWriteFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TrustyIpcWriteFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_buf_id() const { return at<1>().valid(); }
  uint64_t buf_id() const { return at<1>().as_uint64(); }
  bool has_chan() const { return at<2>().valid(); }
  uint32_t chan() const { return at<2>().as_uint32(); }
  bool has_kind_shm() const { return at<3>().valid(); }
  int32_t kind_shm() const { return at<3>().as_int32(); }
  bool has_len_or_err() const { return at<4>().valid(); }
  int32_t len_or_err() const { return at<4>().as_int32(); }
  bool has_shm_cnt() const { return at<5>().valid(); }
  uint64_t shm_cnt() const { return at<5>().as_uint64(); }
  bool has_srv_name() const { return at<6>().valid(); }
  ::protozero::ConstChars srv_name() const { return at<6>().as_string(); }
};

class TrustyIpcWriteFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = TrustyIpcWriteFtraceEvent_Decoder;
  enum : int32_t {
    kBufIdFieldNumber = 1,
    kChanFieldNumber = 2,
    kKindShmFieldNumber = 3,
    kLenOrErrFieldNumber = 4,
    kShmCntFieldNumber = 5,
    kSrvNameFieldNumber = 6,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.TrustyIpcWriteFtraceEvent"; }


  using FieldMetadata_BufId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      TrustyIpcWriteFtraceEvent>;

  static constexpr FieldMetadata_BufId kBufId{};
  void set_buf_id(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_BufId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Chan =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      TrustyIpcWriteFtraceEvent>;

  static constexpr FieldMetadata_Chan kChan{};
  void set_chan(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Chan::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_KindShm =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      TrustyIpcWriteFtraceEvent>;

  static constexpr FieldMetadata_KindShm kKindShm{};
  void set_kind_shm(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_KindShm::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_LenOrErr =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      TrustyIpcWriteFtraceEvent>;

  static constexpr FieldMetadata_LenOrErr kLenOrErr{};
  void set_len_or_err(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_LenOrErr::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ShmCnt =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      TrustyIpcWriteFtraceEvent>;

  static constexpr FieldMetadata_ShmCnt kShmCnt{};
  void set_shm_cnt(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ShmCnt::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SrvName =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      TrustyIpcWriteFtraceEvent>;

  static constexpr FieldMetadata_SrvName kSrvName{};
  void set_srv_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_SrvName::kFieldId, data, size);
  }
  void set_srv_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_SrvName::kFieldId, chars.data, chars.size);
  }
  void set_srv_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_SrvName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }
};

class TrustyIpcConnectEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TrustyIpcConnectEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TrustyIpcConnectEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TrustyIpcConnectEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_chan() const { return at<1>().valid(); }
  uint32_t chan() const { return at<1>().as_uint32(); }
  bool has_err() const { return at<2>().valid(); }
  int32_t err() const { return at<2>().as_int32(); }
  bool has_state() const { return at<3>().valid(); }
  int32_t state() const { return at<3>().as_int32(); }
};

class TrustyIpcConnectEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = TrustyIpcConnectEndFtraceEvent_Decoder;
  enum : int32_t {
    kChanFieldNumber = 1,
    kErrFieldNumber = 2,
    kStateFieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.TrustyIpcConnectEndFtraceEvent"; }


  using FieldMetadata_Chan =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      TrustyIpcConnectEndFtraceEvent>;

  static constexpr FieldMetadata_Chan kChan{};
  void set_chan(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Chan::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Err =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      TrustyIpcConnectEndFtraceEvent>;

  static constexpr FieldMetadata_Err kErr{};
  void set_err(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Err::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_State =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      TrustyIpcConnectEndFtraceEvent>;

  static constexpr FieldMetadata_State kState{};
  void set_state(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_State::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

class TrustyIpcConnectFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TrustyIpcConnectFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TrustyIpcConnectFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TrustyIpcConnectFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_chan() const { return at<1>().valid(); }
  uint32_t chan() const { return at<1>().as_uint32(); }
  bool has_port() const { return at<2>().valid(); }
  ::protozero::ConstChars port() const { return at<2>().as_string(); }
  bool has_state() const { return at<3>().valid(); }
  int32_t state() const { return at<3>().as_int32(); }
};

class TrustyIpcConnectFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = TrustyIpcConnectFtraceEvent_Decoder;
  enum : int32_t {
    kChanFieldNumber = 1,
    kPortFieldNumber = 2,
    kStateFieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.TrustyIpcConnectFtraceEvent"; }


  using FieldMetadata_Chan =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      TrustyIpcConnectFtraceEvent>;

  static constexpr FieldMetadata_Chan kChan{};
  void set_chan(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Chan::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Port =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      TrustyIpcConnectFtraceEvent>;

  static constexpr FieldMetadata_Port kPort{};
  void set_port(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Port::kFieldId, data, size);
  }
  void set_port(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Port::kFieldId, chars.data, chars.size);
  }
  void set_port(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Port::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_State =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      TrustyIpcConnectFtraceEvent>;

  static constexpr FieldMetadata_State kState{};
  void set_state(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_State::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

class TrustyIpcHandleEventFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TrustyIpcHandleEventFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TrustyIpcHandleEventFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TrustyIpcHandleEventFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_chan() const { return at<1>().valid(); }
  uint32_t chan() const { return at<1>().as_uint32(); }
  bool has_event_id() const { return at<2>().valid(); }
  uint32_t event_id() const { return at<2>().as_uint32(); }
  bool has_srv_name() const { return at<3>().valid(); }
  ::protozero::ConstChars srv_name() const { return at<3>().as_string(); }
};

class TrustyIpcHandleEventFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = TrustyIpcHandleEventFtraceEvent_Decoder;
  enum : int32_t {
    kChanFieldNumber = 1,
    kEventIdFieldNumber = 2,
    kSrvNameFieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.TrustyIpcHandleEventFtraceEvent"; }


  using FieldMetadata_Chan =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      TrustyIpcHandleEventFtraceEvent>;

  static constexpr FieldMetadata_Chan kChan{};
  void set_chan(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Chan::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_EventId =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      TrustyIpcHandleEventFtraceEvent>;

  static constexpr FieldMetadata_EventId kEventId{};
  void set_event_id(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_EventId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SrvName =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      TrustyIpcHandleEventFtraceEvent>;

  static constexpr FieldMetadata_SrvName kSrvName{};
  void set_srv_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_SrvName::kFieldId, data, size);
  }
  void set_srv_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_SrvName::kFieldId, chars.data, chars.size);
  }
  void set_srv_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_SrvName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }
};

class TrustyIrqFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TrustyIrqFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TrustyIrqFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TrustyIrqFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_irq() const { return at<1>().valid(); }
  int32_t irq() const { return at<1>().as_int32(); }
};

class TrustyIrqFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = TrustyIrqFtraceEvent_Decoder;
  enum : int32_t {
    kIrqFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.TrustyIrqFtraceEvent"; }


  using FieldMetadata_Irq =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      TrustyIrqFtraceEvent>;

  static constexpr FieldMetadata_Irq kIrq{};
  void set_irq(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Irq::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

class TrustyReclaimMemoryDoneFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TrustyReclaimMemoryDoneFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TrustyReclaimMemoryDoneFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TrustyReclaimMemoryDoneFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_id() const { return at<1>().valid(); }
  uint64_t id() const { return at<1>().as_uint64(); }
  bool has_ret() const { return at<2>().valid(); }
  int32_t ret() const { return at<2>().as_int32(); }
};

class TrustyReclaimMemoryDoneFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = TrustyReclaimMemoryDoneFtraceEvent_Decoder;
  enum : int32_t {
    kIdFieldNumber = 1,
    kRetFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.TrustyReclaimMemoryDoneFtraceEvent"; }


  using FieldMetadata_Id =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      TrustyReclaimMemoryDoneFtraceEvent>;

  static constexpr FieldMetadata_Id kId{};
  void set_id(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Id::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Ret =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      TrustyReclaimMemoryDoneFtraceEvent>;

  static constexpr FieldMetadata_Ret kRet{};
  void set_ret(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Ret::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

class TrustyReclaimMemoryFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TrustyReclaimMemoryFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TrustyReclaimMemoryFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TrustyReclaimMemoryFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_id() const { return at<1>().valid(); }
  uint64_t id() const { return at<1>().as_uint64(); }
};

class TrustyReclaimMemoryFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = TrustyReclaimMemoryFtraceEvent_Decoder;
  enum : int32_t {
    kIdFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.TrustyReclaimMemoryFtraceEvent"; }


  using FieldMetadata_Id =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      TrustyReclaimMemoryFtraceEvent>;

  static constexpr FieldMetadata_Id kId{};
  void set_id(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Id::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }
};

class TrustyShareMemoryDoneFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TrustyShareMemoryDoneFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TrustyShareMemoryDoneFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TrustyShareMemoryDoneFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_handle() const { return at<1>().valid(); }
  uint64_t handle() const { return at<1>().as_uint64(); }
  bool has_len() const { return at<2>().valid(); }
  uint64_t len() const { return at<2>().as_uint64(); }
  bool has_lend() const { return at<3>().valid(); }
  uint32_t lend() const { return at<3>().as_uint32(); }
  bool has_nents() const { return at<4>().valid(); }
  uint32_t nents() const { return at<4>().as_uint32(); }
  bool has_ret() const { return at<5>().valid(); }
  int32_t ret() const { return at<5>().as_int32(); }
};

class TrustyShareMemoryDoneFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = TrustyShareMemoryDoneFtraceEvent_Decoder;
  enum : int32_t {
    kHandleFieldNumber = 1,
    kLenFieldNumber = 2,
    kLendFieldNumber = 3,
    kNentsFieldNumber = 4,
    kRetFieldNumber = 5,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.TrustyShareMemoryDoneFtraceEvent"; }


  using FieldMetadata_Handle =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      TrustyShareMemoryDoneFtraceEvent>;

  static constexpr FieldMetadata_Handle kHandle{};
  void set_handle(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Handle::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Len =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      TrustyShareMemoryDoneFtraceEvent>;

  static constexpr FieldMetadata_Len kLen{};
  void set_len(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Len::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Lend =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      TrustyShareMemoryDoneFtraceEvent>;

  static constexpr FieldMetadata_Lend kLend{};
  void set_lend(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Lend::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Nents =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      TrustyShareMemoryDoneFtraceEvent>;

  static constexpr FieldMetadata_Nents kNents{};
  void set_nents(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Nents::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Ret =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      TrustyShareMemoryDoneFtraceEvent>;

  static constexpr FieldMetadata_Ret kRet{};
  void set_ret(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Ret::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

class TrustyShareMemoryFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TrustyShareMemoryFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TrustyShareMemoryFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TrustyShareMemoryFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_len() const { return at<1>().valid(); }
  uint64_t len() const { return at<1>().as_uint64(); }
  bool has_lend() const { return at<2>().valid(); }
  uint32_t lend() const { return at<2>().as_uint32(); }
  bool has_nents() const { return at<3>().valid(); }
  uint32_t nents() const { return at<3>().as_uint32(); }
};

class TrustyShareMemoryFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = TrustyShareMemoryFtraceEvent_Decoder;
  enum : int32_t {
    kLenFieldNumber = 1,
    kLendFieldNumber = 2,
    kNentsFieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.TrustyShareMemoryFtraceEvent"; }


  using FieldMetadata_Len =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      TrustyShareMemoryFtraceEvent>;

  static constexpr FieldMetadata_Len kLen{};
  void set_len(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Len::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Lend =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      TrustyShareMemoryFtraceEvent>;

  static constexpr FieldMetadata_Lend kLend{};
  void set_lend(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Lend::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Nents =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      TrustyShareMemoryFtraceEvent>;

  static constexpr FieldMetadata_Nents kNents{};
  void set_nents(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Nents::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }
};

class TrustyStdCall32DoneFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TrustyStdCall32DoneFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TrustyStdCall32DoneFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TrustyStdCall32DoneFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_ret() const { return at<1>().valid(); }
  int64_t ret() const { return at<1>().as_int64(); }
};

class TrustyStdCall32DoneFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = TrustyStdCall32DoneFtraceEvent_Decoder;
  enum : int32_t {
    kRetFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.TrustyStdCall32DoneFtraceEvent"; }


  using FieldMetadata_Ret =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      TrustyStdCall32DoneFtraceEvent>;

  static constexpr FieldMetadata_Ret kRet{};
  void set_ret(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Ret::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }
};

class TrustyStdCall32FtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TrustyStdCall32FtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TrustyStdCall32FtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TrustyStdCall32FtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_r0() const { return at<1>().valid(); }
  uint64_t r0() const { return at<1>().as_uint64(); }
  bool has_r1() const { return at<2>().valid(); }
  uint64_t r1() const { return at<2>().as_uint64(); }
  bool has_r2() const { return at<3>().valid(); }
  uint64_t r2() const { return at<3>().as_uint64(); }
  bool has_r3() const { return at<4>().valid(); }
  uint64_t r3() const { return at<4>().as_uint64(); }
};

class TrustyStdCall32FtraceEvent : public ::protozero::Message {
 public:
  using Decoder = TrustyStdCall32FtraceEvent_Decoder;
  enum : int32_t {
    kR0FieldNumber = 1,
    kR1FieldNumber = 2,
    kR2FieldNumber = 3,
    kR3FieldNumber = 4,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.TrustyStdCall32FtraceEvent"; }


  using FieldMetadata_R0 =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      TrustyStdCall32FtraceEvent>;

  static constexpr FieldMetadata_R0 kR0{};
  void set_r0(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_R0::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_R1 =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      TrustyStdCall32FtraceEvent>;

  static constexpr FieldMetadata_R1 kR1{};
  void set_r1(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_R1::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_R2 =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      TrustyStdCall32FtraceEvent>;

  static constexpr FieldMetadata_R2 kR2{};
  void set_r2(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_R2::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_R3 =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      TrustyStdCall32FtraceEvent>;

  static constexpr FieldMetadata_R3 kR3{};
  void set_r3(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_R3::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }
};

class TrustySmcDoneFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TrustySmcDoneFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TrustySmcDoneFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TrustySmcDoneFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_ret() const { return at<1>().valid(); }
  uint64_t ret() const { return at<1>().as_uint64(); }
};

class TrustySmcDoneFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = TrustySmcDoneFtraceEvent_Decoder;
  enum : int32_t {
    kRetFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.TrustySmcDoneFtraceEvent"; }


  using FieldMetadata_Ret =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      TrustySmcDoneFtraceEvent>;

  static constexpr FieldMetadata_Ret kRet{};
  void set_ret(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Ret::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }
};

class TrustySmcFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TrustySmcFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TrustySmcFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TrustySmcFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_r0() const { return at<1>().valid(); }
  uint64_t r0() const { return at<1>().as_uint64(); }
  bool has_r1() const { return at<2>().valid(); }
  uint64_t r1() const { return at<2>().as_uint64(); }
  bool has_r2() const { return at<3>().valid(); }
  uint64_t r2() const { return at<3>().as_uint64(); }
  bool has_r3() const { return at<4>().valid(); }
  uint64_t r3() const { return at<4>().as_uint64(); }
};

class TrustySmcFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = TrustySmcFtraceEvent_Decoder;
  enum : int32_t {
    kR0FieldNumber = 1,
    kR1FieldNumber = 2,
    kR2FieldNumber = 3,
    kR3FieldNumber = 4,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.TrustySmcFtraceEvent"; }


  using FieldMetadata_R0 =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      TrustySmcFtraceEvent>;

  static constexpr FieldMetadata_R0 kR0{};
  void set_r0(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_R0::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_R1 =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      TrustySmcFtraceEvent>;

  static constexpr FieldMetadata_R1 kR1{};
  void set_r1(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_R1::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_R2 =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      TrustySmcFtraceEvent>;

  static constexpr FieldMetadata_R2 kR2{};
  void set_r2(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_R2::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_R3 =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      TrustySmcFtraceEvent>;

  static constexpr FieldMetadata_R3 kR3{};
  void set_r3(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_R3::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
