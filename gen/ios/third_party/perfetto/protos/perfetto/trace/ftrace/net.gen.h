// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_NET_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_NET_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class NapiGroReceiveExitFtraceEvent;
class NapiGroReceiveEntryFtraceEvent;
class NetDevXmitFtraceEvent;
class NetifReceiveSkbFtraceEvent;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {

class PERFETTO_EXPORT_COMPONENT NapiGroReceiveExitFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kRetFieldNumber = 1,
  };

  NapiGroReceiveExitFtraceEvent();
  ~NapiGroReceiveExitFtraceEvent() override;
  NapiGroReceiveExitFtraceEvent(NapiGroReceiveExitFtraceEvent&&) noexcept;
  NapiGroReceiveExitFtraceEvent& operator=(NapiGroReceiveExitFtraceEvent&&);
  NapiGroReceiveExitFtraceEvent(const NapiGroReceiveExitFtraceEvent&);
  NapiGroReceiveExitFtraceEvent& operator=(const NapiGroReceiveExitFtraceEvent&);
  bool operator==(const NapiGroReceiveExitFtraceEvent&) const;
  bool operator!=(const NapiGroReceiveExitFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_ret() const { return _has_field_[1]; }
  int32_t ret() const { return ret_; }
  void set_ret(int32_t value) { ret_ = value; _has_field_.set(1); }

 private:
  int32_t ret_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT NapiGroReceiveEntryFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDataLenFieldNumber = 1,
    kGsoSizeFieldNumber = 2,
    kGsoTypeFieldNumber = 3,
    kHashFieldNumber = 4,
    kIpSummedFieldNumber = 5,
    kL4HashFieldNumber = 6,
    kLenFieldNumber = 7,
    kMacHeaderFieldNumber = 8,
    kMacHeaderValidFieldNumber = 9,
    kNameFieldNumber = 10,
    kNapiIdFieldNumber = 11,
    kNrFragsFieldNumber = 12,
    kProtocolFieldNumber = 13,
    kQueueMappingFieldNumber = 14,
    kSkbaddrFieldNumber = 15,
    kTruesizeFieldNumber = 16,
    kVlanProtoFieldNumber = 17,
    kVlanTaggedFieldNumber = 18,
    kVlanTciFieldNumber = 19,
  };

  NapiGroReceiveEntryFtraceEvent();
  ~NapiGroReceiveEntryFtraceEvent() override;
  NapiGroReceiveEntryFtraceEvent(NapiGroReceiveEntryFtraceEvent&&) noexcept;
  NapiGroReceiveEntryFtraceEvent& operator=(NapiGroReceiveEntryFtraceEvent&&);
  NapiGroReceiveEntryFtraceEvent(const NapiGroReceiveEntryFtraceEvent&);
  NapiGroReceiveEntryFtraceEvent& operator=(const NapiGroReceiveEntryFtraceEvent&);
  bool operator==(const NapiGroReceiveEntryFtraceEvent&) const;
  bool operator!=(const NapiGroReceiveEntryFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_data_len() const { return _has_field_[1]; }
  uint32_t data_len() const { return data_len_; }
  void set_data_len(uint32_t value) { data_len_ = value; _has_field_.set(1); }

  bool has_gso_size() const { return _has_field_[2]; }
  uint32_t gso_size() const { return gso_size_; }
  void set_gso_size(uint32_t value) { gso_size_ = value; _has_field_.set(2); }

  bool has_gso_type() const { return _has_field_[3]; }
  uint32_t gso_type() const { return gso_type_; }
  void set_gso_type(uint32_t value) { gso_type_ = value; _has_field_.set(3); }

  bool has_hash() const { return _has_field_[4]; }
  uint32_t hash() const { return hash_; }
  void set_hash(uint32_t value) { hash_ = value; _has_field_.set(4); }

  bool has_ip_summed() const { return _has_field_[5]; }
  uint32_t ip_summed() const { return ip_summed_; }
  void set_ip_summed(uint32_t value) { ip_summed_ = value; _has_field_.set(5); }

  bool has_l4_hash() const { return _has_field_[6]; }
  uint32_t l4_hash() const { return l4_hash_; }
  void set_l4_hash(uint32_t value) { l4_hash_ = value; _has_field_.set(6); }

  bool has_len() const { return _has_field_[7]; }
  uint32_t len() const { return len_; }
  void set_len(uint32_t value) { len_ = value; _has_field_.set(7); }

  bool has_mac_header() const { return _has_field_[8]; }
  int32_t mac_header() const { return mac_header_; }
  void set_mac_header(int32_t value) { mac_header_ = value; _has_field_.set(8); }

  bool has_mac_header_valid() const { return _has_field_[9]; }
  uint32_t mac_header_valid() const { return mac_header_valid_; }
  void set_mac_header_valid(uint32_t value) { mac_header_valid_ = value; _has_field_.set(9); }

  bool has_name() const { return _has_field_[10]; }
  const std::string& name() const { return name_; }
  void set_name(const std::string& value) { name_ = value; _has_field_.set(10); }

  bool has_napi_id() const { return _has_field_[11]; }
  uint32_t napi_id() const { return napi_id_; }
  void set_napi_id(uint32_t value) { napi_id_ = value; _has_field_.set(11); }

  bool has_nr_frags() const { return _has_field_[12]; }
  uint32_t nr_frags() const { return nr_frags_; }
  void set_nr_frags(uint32_t value) { nr_frags_ = value; _has_field_.set(12); }

  bool has_protocol() const { return _has_field_[13]; }
  uint32_t protocol() const { return protocol_; }
  void set_protocol(uint32_t value) { protocol_ = value; _has_field_.set(13); }

  bool has_queue_mapping() const { return _has_field_[14]; }
  uint32_t queue_mapping() const { return queue_mapping_; }
  void set_queue_mapping(uint32_t value) { queue_mapping_ = value; _has_field_.set(14); }

  bool has_skbaddr() const { return _has_field_[15]; }
  uint64_t skbaddr() const { return skbaddr_; }
  void set_skbaddr(uint64_t value) { skbaddr_ = value; _has_field_.set(15); }

  bool has_truesize() const { return _has_field_[16]; }
  uint32_t truesize() const { return truesize_; }
  void set_truesize(uint32_t value) { truesize_ = value; _has_field_.set(16); }

  bool has_vlan_proto() const { return _has_field_[17]; }
  uint32_t vlan_proto() const { return vlan_proto_; }
  void set_vlan_proto(uint32_t value) { vlan_proto_ = value; _has_field_.set(17); }

  bool has_vlan_tagged() const { return _has_field_[18]; }
  uint32_t vlan_tagged() const { return vlan_tagged_; }
  void set_vlan_tagged(uint32_t value) { vlan_tagged_ = value; _has_field_.set(18); }

  bool has_vlan_tci() const { return _has_field_[19]; }
  uint32_t vlan_tci() const { return vlan_tci_; }
  void set_vlan_tci(uint32_t value) { vlan_tci_ = value; _has_field_.set(19); }

 private:
  uint32_t data_len_{};
  uint32_t gso_size_{};
  uint32_t gso_type_{};
  uint32_t hash_{};
  uint32_t ip_summed_{};
  uint32_t l4_hash_{};
  uint32_t len_{};
  int32_t mac_header_{};
  uint32_t mac_header_valid_{};
  std::string name_{};
  uint32_t napi_id_{};
  uint32_t nr_frags_{};
  uint32_t protocol_{};
  uint32_t queue_mapping_{};
  uint64_t skbaddr_{};
  uint32_t truesize_{};
  uint32_t vlan_proto_{};
  uint32_t vlan_tagged_{};
  uint32_t vlan_tci_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<20> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT NetDevXmitFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kLenFieldNumber = 1,
    kNameFieldNumber = 2,
    kRcFieldNumber = 3,
    kSkbaddrFieldNumber = 4,
  };

  NetDevXmitFtraceEvent();
  ~NetDevXmitFtraceEvent() override;
  NetDevXmitFtraceEvent(NetDevXmitFtraceEvent&&) noexcept;
  NetDevXmitFtraceEvent& operator=(NetDevXmitFtraceEvent&&);
  NetDevXmitFtraceEvent(const NetDevXmitFtraceEvent&);
  NetDevXmitFtraceEvent& operator=(const NetDevXmitFtraceEvent&);
  bool operator==(const NetDevXmitFtraceEvent&) const;
  bool operator!=(const NetDevXmitFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_len() const { return _has_field_[1]; }
  uint32_t len() const { return len_; }
  void set_len(uint32_t value) { len_ = value; _has_field_.set(1); }

  bool has_name() const { return _has_field_[2]; }
  const std::string& name() const { return name_; }
  void set_name(const std::string& value) { name_ = value; _has_field_.set(2); }

  bool has_rc() const { return _has_field_[3]; }
  int32_t rc() const { return rc_; }
  void set_rc(int32_t value) { rc_ = value; _has_field_.set(3); }

  bool has_skbaddr() const { return _has_field_[4]; }
  uint64_t skbaddr() const { return skbaddr_; }
  void set_skbaddr(uint64_t value) { skbaddr_ = value; _has_field_.set(4); }

 private:
  uint32_t len_{};
  std::string name_{};
  int32_t rc_{};
  uint64_t skbaddr_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT NetifReceiveSkbFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kLenFieldNumber = 1,
    kNameFieldNumber = 2,
    kSkbaddrFieldNumber = 3,
  };

  NetifReceiveSkbFtraceEvent();
  ~NetifReceiveSkbFtraceEvent() override;
  NetifReceiveSkbFtraceEvent(NetifReceiveSkbFtraceEvent&&) noexcept;
  NetifReceiveSkbFtraceEvent& operator=(NetifReceiveSkbFtraceEvent&&);
  NetifReceiveSkbFtraceEvent(const NetifReceiveSkbFtraceEvent&);
  NetifReceiveSkbFtraceEvent& operator=(const NetifReceiveSkbFtraceEvent&);
  bool operator==(const NetifReceiveSkbFtraceEvent&) const;
  bool operator!=(const NetifReceiveSkbFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_len() const { return _has_field_[1]; }
  uint32_t len() const { return len_; }
  void set_len(uint32_t value) { len_ = value; _has_field_.set(1); }

  bool has_name() const { return _has_field_[2]; }
  const std::string& name() const { return name_; }
  void set_name(const std::string& value) { name_ = value; _has_field_.set(2); }

  bool has_skbaddr() const { return _has_field_[3]; }
  uint64_t skbaddr() const { return skbaddr_; }
  void set_skbaddr(uint64_t value) { skbaddr_ = value; _has_field_.set(3); }

 private:
  uint32_t len_{};
  std::string name_{};
  uint64_t skbaddr_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_NET_PROTO_CPP_H_
