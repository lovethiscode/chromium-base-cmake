// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_SCHED_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_SCHED_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class SchedMigrateTaskFtraceEvent;
class SchedCpuUtilCfsFtraceEvent;
class SchedPiSetprioFtraceEvent;
class SchedProcessWaitFtraceEvent;
class SchedProcessHangFtraceEvent;
class SchedProcessFreeFtraceEvent;
class SchedProcessForkFtraceEvent;
class SchedProcessExitFtraceEvent;
class SchedProcessExecFtraceEvent;
class SchedWakeupNewFtraceEvent;
class SchedWakingFtraceEvent;
class SchedCpuHotplugFtraceEvent;
class SchedBlockedReasonFtraceEvent;
class SchedWakeupFtraceEvent;
class SchedSwitchFtraceEvent;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {

class PERFETTO_EXPORT_COMPONENT SchedMigrateTaskFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
    kOrigCpuFieldNumber = 4,
    kDestCpuFieldNumber = 5,
    kRunningFieldNumber = 6,
    kLoadFieldNumber = 7,
  };

  SchedMigrateTaskFtraceEvent();
  ~SchedMigrateTaskFtraceEvent() override;
  SchedMigrateTaskFtraceEvent(SchedMigrateTaskFtraceEvent&&) noexcept;
  SchedMigrateTaskFtraceEvent& operator=(SchedMigrateTaskFtraceEvent&&);
  SchedMigrateTaskFtraceEvent(const SchedMigrateTaskFtraceEvent&);
  SchedMigrateTaskFtraceEvent& operator=(const SchedMigrateTaskFtraceEvent&);
  bool operator==(const SchedMigrateTaskFtraceEvent&) const;
  bool operator!=(const SchedMigrateTaskFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_comm() const { return _has_field_[1]; }
  const std::string& comm() const { return comm_; }
  void set_comm(const std::string& value) { comm_ = value; _has_field_.set(1); }

  bool has_pid() const { return _has_field_[2]; }
  int32_t pid() const { return pid_; }
  void set_pid(int32_t value) { pid_ = value; _has_field_.set(2); }

  bool has_prio() const { return _has_field_[3]; }
  int32_t prio() const { return prio_; }
  void set_prio(int32_t value) { prio_ = value; _has_field_.set(3); }

  bool has_orig_cpu() const { return _has_field_[4]; }
  int32_t orig_cpu() const { return orig_cpu_; }
  void set_orig_cpu(int32_t value) { orig_cpu_ = value; _has_field_.set(4); }

  bool has_dest_cpu() const { return _has_field_[5]; }
  int32_t dest_cpu() const { return dest_cpu_; }
  void set_dest_cpu(int32_t value) { dest_cpu_ = value; _has_field_.set(5); }

  bool has_running() const { return _has_field_[6]; }
  int32_t running() const { return running_; }
  void set_running(int32_t value) { running_ = value; _has_field_.set(6); }

  bool has_load() const { return _has_field_[7]; }
  uint32_t load() const { return load_; }
  void set_load(uint32_t value) { load_ = value; _has_field_.set(7); }

 private:
  std::string comm_{};
  int32_t pid_{};
  int32_t prio_{};
  int32_t orig_cpu_{};
  int32_t dest_cpu_{};
  int32_t running_{};
  uint32_t load_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<8> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT SchedCpuUtilCfsFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kActiveFieldNumber = 1,
    kCapacityFieldNumber = 2,
    kCapacityOrigFieldNumber = 3,
    kCpuFieldNumber = 4,
    kCpuImportanceFieldNumber = 5,
    kCpuUtilFieldNumber = 6,
    kExitLatFieldNumber = 7,
    kGroupCapacityFieldNumber = 8,
    kGrpOverutilizedFieldNumber = 9,
    kIdleCpuFieldNumber = 10,
    kNrRunningFieldNumber = 11,
    kSpareCapFieldNumber = 12,
    kTaskFitsFieldNumber = 13,
    kWakeGroupUtilFieldNumber = 14,
    kWakeUtilFieldNumber = 15,
  };

  SchedCpuUtilCfsFtraceEvent();
  ~SchedCpuUtilCfsFtraceEvent() override;
  SchedCpuUtilCfsFtraceEvent(SchedCpuUtilCfsFtraceEvent&&) noexcept;
  SchedCpuUtilCfsFtraceEvent& operator=(SchedCpuUtilCfsFtraceEvent&&);
  SchedCpuUtilCfsFtraceEvent(const SchedCpuUtilCfsFtraceEvent&);
  SchedCpuUtilCfsFtraceEvent& operator=(const SchedCpuUtilCfsFtraceEvent&);
  bool operator==(const SchedCpuUtilCfsFtraceEvent&) const;
  bool operator!=(const SchedCpuUtilCfsFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_active() const { return _has_field_[1]; }
  int32_t active() const { return active_; }
  void set_active(int32_t value) { active_ = value; _has_field_.set(1); }

  bool has_capacity() const { return _has_field_[2]; }
  uint64_t capacity() const { return capacity_; }
  void set_capacity(uint64_t value) { capacity_ = value; _has_field_.set(2); }

  bool has_capacity_orig() const { return _has_field_[3]; }
  uint64_t capacity_orig() const { return capacity_orig_; }
  void set_capacity_orig(uint64_t value) { capacity_orig_ = value; _has_field_.set(3); }

  bool has_cpu() const { return _has_field_[4]; }
  uint32_t cpu() const { return cpu_; }
  void set_cpu(uint32_t value) { cpu_ = value; _has_field_.set(4); }

  bool has_cpu_importance() const { return _has_field_[5]; }
  uint64_t cpu_importance() const { return cpu_importance_; }
  void set_cpu_importance(uint64_t value) { cpu_importance_ = value; _has_field_.set(5); }

  bool has_cpu_util() const { return _has_field_[6]; }
  uint64_t cpu_util() const { return cpu_util_; }
  void set_cpu_util(uint64_t value) { cpu_util_ = value; _has_field_.set(6); }

  bool has_exit_lat() const { return _has_field_[7]; }
  uint32_t exit_lat() const { return exit_lat_; }
  void set_exit_lat(uint32_t value) { exit_lat_ = value; _has_field_.set(7); }

  bool has_group_capacity() const { return _has_field_[8]; }
  uint64_t group_capacity() const { return group_capacity_; }
  void set_group_capacity(uint64_t value) { group_capacity_ = value; _has_field_.set(8); }

  bool has_grp_overutilized() const { return _has_field_[9]; }
  uint32_t grp_overutilized() const { return grp_overutilized_; }
  void set_grp_overutilized(uint32_t value) { grp_overutilized_ = value; _has_field_.set(9); }

  bool has_idle_cpu() const { return _has_field_[10]; }
  uint32_t idle_cpu() const { return idle_cpu_; }
  void set_idle_cpu(uint32_t value) { idle_cpu_ = value; _has_field_.set(10); }

  bool has_nr_running() const { return _has_field_[11]; }
  uint32_t nr_running() const { return nr_running_; }
  void set_nr_running(uint32_t value) { nr_running_ = value; _has_field_.set(11); }

  bool has_spare_cap() const { return _has_field_[12]; }
  int64_t spare_cap() const { return spare_cap_; }
  void set_spare_cap(int64_t value) { spare_cap_ = value; _has_field_.set(12); }

  bool has_task_fits() const { return _has_field_[13]; }
  uint32_t task_fits() const { return task_fits_; }
  void set_task_fits(uint32_t value) { task_fits_ = value; _has_field_.set(13); }

  bool has_wake_group_util() const { return _has_field_[14]; }
  uint64_t wake_group_util() const { return wake_group_util_; }
  void set_wake_group_util(uint64_t value) { wake_group_util_ = value; _has_field_.set(14); }

  bool has_wake_util() const { return _has_field_[15]; }
  uint64_t wake_util() const { return wake_util_; }
  void set_wake_util(uint64_t value) { wake_util_ = value; _has_field_.set(15); }

 private:
  int32_t active_{};
  uint64_t capacity_{};
  uint64_t capacity_orig_{};
  uint32_t cpu_{};
  uint64_t cpu_importance_{};
  uint64_t cpu_util_{};
  uint32_t exit_lat_{};
  uint64_t group_capacity_{};
  uint32_t grp_overutilized_{};
  uint32_t idle_cpu_{};
  uint32_t nr_running_{};
  int64_t spare_cap_{};
  uint32_t task_fits_{};
  uint64_t wake_group_util_{};
  uint64_t wake_util_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<16> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT SchedPiSetprioFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCommFieldNumber = 1,
    kNewprioFieldNumber = 2,
    kOldprioFieldNumber = 3,
    kPidFieldNumber = 4,
  };

  SchedPiSetprioFtraceEvent();
  ~SchedPiSetprioFtraceEvent() override;
  SchedPiSetprioFtraceEvent(SchedPiSetprioFtraceEvent&&) noexcept;
  SchedPiSetprioFtraceEvent& operator=(SchedPiSetprioFtraceEvent&&);
  SchedPiSetprioFtraceEvent(const SchedPiSetprioFtraceEvent&);
  SchedPiSetprioFtraceEvent& operator=(const SchedPiSetprioFtraceEvent&);
  bool operator==(const SchedPiSetprioFtraceEvent&) const;
  bool operator!=(const SchedPiSetprioFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_comm() const { return _has_field_[1]; }
  const std::string& comm() const { return comm_; }
  void set_comm(const std::string& value) { comm_ = value; _has_field_.set(1); }

  bool has_newprio() const { return _has_field_[2]; }
  int32_t newprio() const { return newprio_; }
  void set_newprio(int32_t value) { newprio_ = value; _has_field_.set(2); }

  bool has_oldprio() const { return _has_field_[3]; }
  int32_t oldprio() const { return oldprio_; }
  void set_oldprio(int32_t value) { oldprio_ = value; _has_field_.set(3); }

  bool has_pid() const { return _has_field_[4]; }
  int32_t pid() const { return pid_; }
  void set_pid(int32_t value) { pid_ = value; _has_field_.set(4); }

 private:
  std::string comm_{};
  int32_t newprio_{};
  int32_t oldprio_{};
  int32_t pid_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT SchedProcessWaitFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
  };

  SchedProcessWaitFtraceEvent();
  ~SchedProcessWaitFtraceEvent() override;
  SchedProcessWaitFtraceEvent(SchedProcessWaitFtraceEvent&&) noexcept;
  SchedProcessWaitFtraceEvent& operator=(SchedProcessWaitFtraceEvent&&);
  SchedProcessWaitFtraceEvent(const SchedProcessWaitFtraceEvent&);
  SchedProcessWaitFtraceEvent& operator=(const SchedProcessWaitFtraceEvent&);
  bool operator==(const SchedProcessWaitFtraceEvent&) const;
  bool operator!=(const SchedProcessWaitFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_comm() const { return _has_field_[1]; }
  const std::string& comm() const { return comm_; }
  void set_comm(const std::string& value) { comm_ = value; _has_field_.set(1); }

  bool has_pid() const { return _has_field_[2]; }
  int32_t pid() const { return pid_; }
  void set_pid(int32_t value) { pid_ = value; _has_field_.set(2); }

  bool has_prio() const { return _has_field_[3]; }
  int32_t prio() const { return prio_; }
  void set_prio(int32_t value) { prio_ = value; _has_field_.set(3); }

 private:
  std::string comm_{};
  int32_t pid_{};
  int32_t prio_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT SchedProcessHangFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
  };

  SchedProcessHangFtraceEvent();
  ~SchedProcessHangFtraceEvent() override;
  SchedProcessHangFtraceEvent(SchedProcessHangFtraceEvent&&) noexcept;
  SchedProcessHangFtraceEvent& operator=(SchedProcessHangFtraceEvent&&);
  SchedProcessHangFtraceEvent(const SchedProcessHangFtraceEvent&);
  SchedProcessHangFtraceEvent& operator=(const SchedProcessHangFtraceEvent&);
  bool operator==(const SchedProcessHangFtraceEvent&) const;
  bool operator!=(const SchedProcessHangFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_comm() const { return _has_field_[1]; }
  const std::string& comm() const { return comm_; }
  void set_comm(const std::string& value) { comm_ = value; _has_field_.set(1); }

  bool has_pid() const { return _has_field_[2]; }
  int32_t pid() const { return pid_; }
  void set_pid(int32_t value) { pid_ = value; _has_field_.set(2); }

 private:
  std::string comm_{};
  int32_t pid_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT SchedProcessFreeFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
  };

  SchedProcessFreeFtraceEvent();
  ~SchedProcessFreeFtraceEvent() override;
  SchedProcessFreeFtraceEvent(SchedProcessFreeFtraceEvent&&) noexcept;
  SchedProcessFreeFtraceEvent& operator=(SchedProcessFreeFtraceEvent&&);
  SchedProcessFreeFtraceEvent(const SchedProcessFreeFtraceEvent&);
  SchedProcessFreeFtraceEvent& operator=(const SchedProcessFreeFtraceEvent&);
  bool operator==(const SchedProcessFreeFtraceEvent&) const;
  bool operator!=(const SchedProcessFreeFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_comm() const { return _has_field_[1]; }
  const std::string& comm() const { return comm_; }
  void set_comm(const std::string& value) { comm_ = value; _has_field_.set(1); }

  bool has_pid() const { return _has_field_[2]; }
  int32_t pid() const { return pid_; }
  void set_pid(int32_t value) { pid_ = value; _has_field_.set(2); }

  bool has_prio() const { return _has_field_[3]; }
  int32_t prio() const { return prio_; }
  void set_prio(int32_t value) { prio_ = value; _has_field_.set(3); }

 private:
  std::string comm_{};
  int32_t pid_{};
  int32_t prio_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT SchedProcessForkFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kParentCommFieldNumber = 1,
    kParentPidFieldNumber = 2,
    kChildCommFieldNumber = 3,
    kChildPidFieldNumber = 4,
  };

  SchedProcessForkFtraceEvent();
  ~SchedProcessForkFtraceEvent() override;
  SchedProcessForkFtraceEvent(SchedProcessForkFtraceEvent&&) noexcept;
  SchedProcessForkFtraceEvent& operator=(SchedProcessForkFtraceEvent&&);
  SchedProcessForkFtraceEvent(const SchedProcessForkFtraceEvent&);
  SchedProcessForkFtraceEvent& operator=(const SchedProcessForkFtraceEvent&);
  bool operator==(const SchedProcessForkFtraceEvent&) const;
  bool operator!=(const SchedProcessForkFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_parent_comm() const { return _has_field_[1]; }
  const std::string& parent_comm() const { return parent_comm_; }
  void set_parent_comm(const std::string& value) { parent_comm_ = value; _has_field_.set(1); }

  bool has_parent_pid() const { return _has_field_[2]; }
  int32_t parent_pid() const { return parent_pid_; }
  void set_parent_pid(int32_t value) { parent_pid_ = value; _has_field_.set(2); }

  bool has_child_comm() const { return _has_field_[3]; }
  const std::string& child_comm() const { return child_comm_; }
  void set_child_comm(const std::string& value) { child_comm_ = value; _has_field_.set(3); }

  bool has_child_pid() const { return _has_field_[4]; }
  int32_t child_pid() const { return child_pid_; }
  void set_child_pid(int32_t value) { child_pid_ = value; _has_field_.set(4); }

 private:
  std::string parent_comm_{};
  int32_t parent_pid_{};
  std::string child_comm_{};
  int32_t child_pid_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT SchedProcessExitFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kTgidFieldNumber = 3,
    kPrioFieldNumber = 4,
  };

  SchedProcessExitFtraceEvent();
  ~SchedProcessExitFtraceEvent() override;
  SchedProcessExitFtraceEvent(SchedProcessExitFtraceEvent&&) noexcept;
  SchedProcessExitFtraceEvent& operator=(SchedProcessExitFtraceEvent&&);
  SchedProcessExitFtraceEvent(const SchedProcessExitFtraceEvent&);
  SchedProcessExitFtraceEvent& operator=(const SchedProcessExitFtraceEvent&);
  bool operator==(const SchedProcessExitFtraceEvent&) const;
  bool operator!=(const SchedProcessExitFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_comm() const { return _has_field_[1]; }
  const std::string& comm() const { return comm_; }
  void set_comm(const std::string& value) { comm_ = value; _has_field_.set(1); }

  bool has_pid() const { return _has_field_[2]; }
  int32_t pid() const { return pid_; }
  void set_pid(int32_t value) { pid_ = value; _has_field_.set(2); }

  bool has_tgid() const { return _has_field_[3]; }
  int32_t tgid() const { return tgid_; }
  void set_tgid(int32_t value) { tgid_ = value; _has_field_.set(3); }

  bool has_prio() const { return _has_field_[4]; }
  int32_t prio() const { return prio_; }
  void set_prio(int32_t value) { prio_ = value; _has_field_.set(4); }

 private:
  std::string comm_{};
  int32_t pid_{};
  int32_t tgid_{};
  int32_t prio_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT SchedProcessExecFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kFilenameFieldNumber = 1,
    kPidFieldNumber = 2,
    kOldPidFieldNumber = 3,
  };

  SchedProcessExecFtraceEvent();
  ~SchedProcessExecFtraceEvent() override;
  SchedProcessExecFtraceEvent(SchedProcessExecFtraceEvent&&) noexcept;
  SchedProcessExecFtraceEvent& operator=(SchedProcessExecFtraceEvent&&);
  SchedProcessExecFtraceEvent(const SchedProcessExecFtraceEvent&);
  SchedProcessExecFtraceEvent& operator=(const SchedProcessExecFtraceEvent&);
  bool operator==(const SchedProcessExecFtraceEvent&) const;
  bool operator!=(const SchedProcessExecFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_filename() const { return _has_field_[1]; }
  const std::string& filename() const { return filename_; }
  void set_filename(const std::string& value) { filename_ = value; _has_field_.set(1); }

  bool has_pid() const { return _has_field_[2]; }
  int32_t pid() const { return pid_; }
  void set_pid(int32_t value) { pid_ = value; _has_field_.set(2); }

  bool has_old_pid() const { return _has_field_[3]; }
  int32_t old_pid() const { return old_pid_; }
  void set_old_pid(int32_t value) { old_pid_ = value; _has_field_.set(3); }

 private:
  std::string filename_{};
  int32_t pid_{};
  int32_t old_pid_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT SchedWakeupNewFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
    kSuccessFieldNumber = 4,
    kTargetCpuFieldNumber = 5,
  };

  SchedWakeupNewFtraceEvent();
  ~SchedWakeupNewFtraceEvent() override;
  SchedWakeupNewFtraceEvent(SchedWakeupNewFtraceEvent&&) noexcept;
  SchedWakeupNewFtraceEvent& operator=(SchedWakeupNewFtraceEvent&&);
  SchedWakeupNewFtraceEvent(const SchedWakeupNewFtraceEvent&);
  SchedWakeupNewFtraceEvent& operator=(const SchedWakeupNewFtraceEvent&);
  bool operator==(const SchedWakeupNewFtraceEvent&) const;
  bool operator!=(const SchedWakeupNewFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_comm() const { return _has_field_[1]; }
  const std::string& comm() const { return comm_; }
  void set_comm(const std::string& value) { comm_ = value; _has_field_.set(1); }

  bool has_pid() const { return _has_field_[2]; }
  int32_t pid() const { return pid_; }
  void set_pid(int32_t value) { pid_ = value; _has_field_.set(2); }

  bool has_prio() const { return _has_field_[3]; }
  int32_t prio() const { return prio_; }
  void set_prio(int32_t value) { prio_ = value; _has_field_.set(3); }

  bool has_success() const { return _has_field_[4]; }
  int32_t success() const { return success_; }
  void set_success(int32_t value) { success_ = value; _has_field_.set(4); }

  bool has_target_cpu() const { return _has_field_[5]; }
  int32_t target_cpu() const { return target_cpu_; }
  void set_target_cpu(int32_t value) { target_cpu_ = value; _has_field_.set(5); }

 private:
  std::string comm_{};
  int32_t pid_{};
  int32_t prio_{};
  int32_t success_{};
  int32_t target_cpu_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT SchedWakingFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
    kSuccessFieldNumber = 4,
    kTargetCpuFieldNumber = 5,
  };

  SchedWakingFtraceEvent();
  ~SchedWakingFtraceEvent() override;
  SchedWakingFtraceEvent(SchedWakingFtraceEvent&&) noexcept;
  SchedWakingFtraceEvent& operator=(SchedWakingFtraceEvent&&);
  SchedWakingFtraceEvent(const SchedWakingFtraceEvent&);
  SchedWakingFtraceEvent& operator=(const SchedWakingFtraceEvent&);
  bool operator==(const SchedWakingFtraceEvent&) const;
  bool operator!=(const SchedWakingFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_comm() const { return _has_field_[1]; }
  const std::string& comm() const { return comm_; }
  void set_comm(const std::string& value) { comm_ = value; _has_field_.set(1); }

  bool has_pid() const { return _has_field_[2]; }
  int32_t pid() const { return pid_; }
  void set_pid(int32_t value) { pid_ = value; _has_field_.set(2); }

  bool has_prio() const { return _has_field_[3]; }
  int32_t prio() const { return prio_; }
  void set_prio(int32_t value) { prio_ = value; _has_field_.set(3); }

  bool has_success() const { return _has_field_[4]; }
  int32_t success() const { return success_; }
  void set_success(int32_t value) { success_ = value; _has_field_.set(4); }

  bool has_target_cpu() const { return _has_field_[5]; }
  int32_t target_cpu() const { return target_cpu_; }
  void set_target_cpu(int32_t value) { target_cpu_ = value; _has_field_.set(5); }

 private:
  std::string comm_{};
  int32_t pid_{};
  int32_t prio_{};
  int32_t success_{};
  int32_t target_cpu_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT SchedCpuHotplugFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kAffectedCpuFieldNumber = 1,
    kErrorFieldNumber = 2,
    kStatusFieldNumber = 3,
  };

  SchedCpuHotplugFtraceEvent();
  ~SchedCpuHotplugFtraceEvent() override;
  SchedCpuHotplugFtraceEvent(SchedCpuHotplugFtraceEvent&&) noexcept;
  SchedCpuHotplugFtraceEvent& operator=(SchedCpuHotplugFtraceEvent&&);
  SchedCpuHotplugFtraceEvent(const SchedCpuHotplugFtraceEvent&);
  SchedCpuHotplugFtraceEvent& operator=(const SchedCpuHotplugFtraceEvent&);
  bool operator==(const SchedCpuHotplugFtraceEvent&) const;
  bool operator!=(const SchedCpuHotplugFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_affected_cpu() const { return _has_field_[1]; }
  int32_t affected_cpu() const { return affected_cpu_; }
  void set_affected_cpu(int32_t value) { affected_cpu_ = value; _has_field_.set(1); }

  bool has_error() const { return _has_field_[2]; }
  int32_t error() const { return error_; }
  void set_error(int32_t value) { error_ = value; _has_field_.set(2); }

  bool has_status() const { return _has_field_[3]; }
  int32_t status() const { return status_; }
  void set_status(int32_t value) { status_ = value; _has_field_.set(3); }

 private:
  int32_t affected_cpu_{};
  int32_t error_{};
  int32_t status_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT SchedBlockedReasonFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kPidFieldNumber = 1,
    kCallerFieldNumber = 2,
    kIoWaitFieldNumber = 3,
  };

  SchedBlockedReasonFtraceEvent();
  ~SchedBlockedReasonFtraceEvent() override;
  SchedBlockedReasonFtraceEvent(SchedBlockedReasonFtraceEvent&&) noexcept;
  SchedBlockedReasonFtraceEvent& operator=(SchedBlockedReasonFtraceEvent&&);
  SchedBlockedReasonFtraceEvent(const SchedBlockedReasonFtraceEvent&);
  SchedBlockedReasonFtraceEvent& operator=(const SchedBlockedReasonFtraceEvent&);
  bool operator==(const SchedBlockedReasonFtraceEvent&) const;
  bool operator!=(const SchedBlockedReasonFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_pid() const { return _has_field_[1]; }
  int32_t pid() const { return pid_; }
  void set_pid(int32_t value) { pid_ = value; _has_field_.set(1); }

  bool has_caller() const { return _has_field_[2]; }
  uint64_t caller() const { return caller_; }
  void set_caller(uint64_t value) { caller_ = value; _has_field_.set(2); }

  bool has_io_wait() const { return _has_field_[3]; }
  uint32_t io_wait() const { return io_wait_; }
  void set_io_wait(uint32_t value) { io_wait_ = value; _has_field_.set(3); }

 private:
  int32_t pid_{};
  uint64_t caller_{};
  uint32_t io_wait_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT SchedWakeupFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
    kSuccessFieldNumber = 4,
    kTargetCpuFieldNumber = 5,
  };

  SchedWakeupFtraceEvent();
  ~SchedWakeupFtraceEvent() override;
  SchedWakeupFtraceEvent(SchedWakeupFtraceEvent&&) noexcept;
  SchedWakeupFtraceEvent& operator=(SchedWakeupFtraceEvent&&);
  SchedWakeupFtraceEvent(const SchedWakeupFtraceEvent&);
  SchedWakeupFtraceEvent& operator=(const SchedWakeupFtraceEvent&);
  bool operator==(const SchedWakeupFtraceEvent&) const;
  bool operator!=(const SchedWakeupFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_comm() const { return _has_field_[1]; }
  const std::string& comm() const { return comm_; }
  void set_comm(const std::string& value) { comm_ = value; _has_field_.set(1); }

  bool has_pid() const { return _has_field_[2]; }
  int32_t pid() const { return pid_; }
  void set_pid(int32_t value) { pid_ = value; _has_field_.set(2); }

  bool has_prio() const { return _has_field_[3]; }
  int32_t prio() const { return prio_; }
  void set_prio(int32_t value) { prio_ = value; _has_field_.set(3); }

  bool has_success() const { return _has_field_[4]; }
  int32_t success() const { return success_; }
  void set_success(int32_t value) { success_ = value; _has_field_.set(4); }

  bool has_target_cpu() const { return _has_field_[5]; }
  int32_t target_cpu() const { return target_cpu_; }
  void set_target_cpu(int32_t value) { target_cpu_ = value; _has_field_.set(5); }

 private:
  std::string comm_{};
  int32_t pid_{};
  int32_t prio_{};
  int32_t success_{};
  int32_t target_cpu_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT SchedSwitchFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kPrevCommFieldNumber = 1,
    kPrevPidFieldNumber = 2,
    kPrevPrioFieldNumber = 3,
    kPrevStateFieldNumber = 4,
    kNextCommFieldNumber = 5,
    kNextPidFieldNumber = 6,
    kNextPrioFieldNumber = 7,
  };

  SchedSwitchFtraceEvent();
  ~SchedSwitchFtraceEvent() override;
  SchedSwitchFtraceEvent(SchedSwitchFtraceEvent&&) noexcept;
  SchedSwitchFtraceEvent& operator=(SchedSwitchFtraceEvent&&);
  SchedSwitchFtraceEvent(const SchedSwitchFtraceEvent&);
  SchedSwitchFtraceEvent& operator=(const SchedSwitchFtraceEvent&);
  bool operator==(const SchedSwitchFtraceEvent&) const;
  bool operator!=(const SchedSwitchFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_prev_comm() const { return _has_field_[1]; }
  const std::string& prev_comm() const { return prev_comm_; }
  void set_prev_comm(const std::string& value) { prev_comm_ = value; _has_field_.set(1); }

  bool has_prev_pid() const { return _has_field_[2]; }
  int32_t prev_pid() const { return prev_pid_; }
  void set_prev_pid(int32_t value) { prev_pid_ = value; _has_field_.set(2); }

  bool has_prev_prio() const { return _has_field_[3]; }
  int32_t prev_prio() const { return prev_prio_; }
  void set_prev_prio(int32_t value) { prev_prio_ = value; _has_field_.set(3); }

  bool has_prev_state() const { return _has_field_[4]; }
  int64_t prev_state() const { return prev_state_; }
  void set_prev_state(int64_t value) { prev_state_ = value; _has_field_.set(4); }

  bool has_next_comm() const { return _has_field_[5]; }
  const std::string& next_comm() const { return next_comm_; }
  void set_next_comm(const std::string& value) { next_comm_ = value; _has_field_.set(5); }

  bool has_next_pid() const { return _has_field_[6]; }
  int32_t next_pid() const { return next_pid_; }
  void set_next_pid(int32_t value) { next_pid_ = value; _has_field_.set(6); }

  bool has_next_prio() const { return _has_field_[7]; }
  int32_t next_prio() const { return next_prio_; }
  void set_next_prio(int32_t value) { next_prio_ = value; _has_field_.set(7); }

 private:
  std::string prev_comm_{};
  int32_t prev_pid_{};
  int32_t prev_prio_{};
  int64_t prev_state_{};
  std::string next_comm_{};
  int32_t next_pid_{};
  int32_t next_prio_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<8> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_SCHED_PROTO_CPP_H_
