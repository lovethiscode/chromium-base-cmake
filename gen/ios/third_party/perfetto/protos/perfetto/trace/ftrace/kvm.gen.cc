#include "perfetto/protozero/gen_field_helpers.h"
#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/scattered_heap_buffer.h"
// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
#endif
#include "protos/perfetto/trace/ftrace/kvm.gen.h"

namespace perfetto {
namespace protos {
namespace gen {

VgicUpdateIrqPendingFtraceEvent::VgicUpdateIrqPendingFtraceEvent() = default;
VgicUpdateIrqPendingFtraceEvent::~VgicUpdateIrqPendingFtraceEvent() = default;
VgicUpdateIrqPendingFtraceEvent::VgicUpdateIrqPendingFtraceEvent(const VgicUpdateIrqPendingFtraceEvent&) = default;
VgicUpdateIrqPendingFtraceEvent& VgicUpdateIrqPendingFtraceEvent::operator=(const VgicUpdateIrqPendingFtraceEvent&) = default;
VgicUpdateIrqPendingFtraceEvent::VgicUpdateIrqPendingFtraceEvent(VgicUpdateIrqPendingFtraceEvent&&) noexcept = default;
VgicUpdateIrqPendingFtraceEvent& VgicUpdateIrqPendingFtraceEvent::operator=(VgicUpdateIrqPendingFtraceEvent&&) = default;

bool VgicUpdateIrqPendingFtraceEvent::operator==(const VgicUpdateIrqPendingFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(irq_, other.irq_)
   && ::protozero::internal::gen_helpers::EqualsField(level_, other.level_)
   && ::protozero::internal::gen_helpers::EqualsField(vcpu_id_, other.vcpu_id_);
}

bool VgicUpdateIrqPendingFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* irq */:
        field.get(&irq_);
        break;
      case 2 /* level */:
        field.get(&level_);
        break;
      case 3 /* vcpu_id */:
        field.get(&vcpu_id_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string VgicUpdateIrqPendingFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> VgicUpdateIrqPendingFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void VgicUpdateIrqPendingFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: irq
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, irq_, msg);
  }

  // Field 2: level
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, level_, msg);
  }

  // Field 3: vcpu_id
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, vcpu_id_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


TrapRegFtraceEvent::TrapRegFtraceEvent() = default;
TrapRegFtraceEvent::~TrapRegFtraceEvent() = default;
TrapRegFtraceEvent::TrapRegFtraceEvent(const TrapRegFtraceEvent&) = default;
TrapRegFtraceEvent& TrapRegFtraceEvent::operator=(const TrapRegFtraceEvent&) = default;
TrapRegFtraceEvent::TrapRegFtraceEvent(TrapRegFtraceEvent&&) noexcept = default;
TrapRegFtraceEvent& TrapRegFtraceEvent::operator=(TrapRegFtraceEvent&&) = default;

bool TrapRegFtraceEvent::operator==(const TrapRegFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(fn_, other.fn_)
   && ::protozero::internal::gen_helpers::EqualsField(is_write_, other.is_write_)
   && ::protozero::internal::gen_helpers::EqualsField(reg_, other.reg_)
   && ::protozero::internal::gen_helpers::EqualsField(write_value_, other.write_value_);
}

bool TrapRegFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* fn */:
        ::protozero::internal::gen_helpers::DeserializeString(field, &fn_);
        break;
      case 2 /* is_write */:
        field.get(&is_write_);
        break;
      case 3 /* reg */:
        field.get(&reg_);
        break;
      case 4 /* write_value */:
        field.get(&write_value_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string TrapRegFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> TrapRegFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void TrapRegFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: fn
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeString(1, fn_, msg);
  }

  // Field 2: is_write
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, is_write_, msg);
  }

  // Field 3: reg
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, reg_, msg);
  }

  // Field 4: write_value
  if (_has_field_[4]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(4, write_value_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


KvmWfxArm64FtraceEvent::KvmWfxArm64FtraceEvent() = default;
KvmWfxArm64FtraceEvent::~KvmWfxArm64FtraceEvent() = default;
KvmWfxArm64FtraceEvent::KvmWfxArm64FtraceEvent(const KvmWfxArm64FtraceEvent&) = default;
KvmWfxArm64FtraceEvent& KvmWfxArm64FtraceEvent::operator=(const KvmWfxArm64FtraceEvent&) = default;
KvmWfxArm64FtraceEvent::KvmWfxArm64FtraceEvent(KvmWfxArm64FtraceEvent&&) noexcept = default;
KvmWfxArm64FtraceEvent& KvmWfxArm64FtraceEvent::operator=(KvmWfxArm64FtraceEvent&&) = default;

bool KvmWfxArm64FtraceEvent::operator==(const KvmWfxArm64FtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(is_wfe_, other.is_wfe_)
   && ::protozero::internal::gen_helpers::EqualsField(vcpu_pc_, other.vcpu_pc_);
}

bool KvmWfxArm64FtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* is_wfe */:
        field.get(&is_wfe_);
        break;
      case 2 /* vcpu_pc */:
        field.get(&vcpu_pc_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KvmWfxArm64FtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KvmWfxArm64FtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KvmWfxArm64FtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: is_wfe
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, is_wfe_, msg);
  }

  // Field 2: vcpu_pc
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, vcpu_pc_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


KvmVcpuWakeupFtraceEvent::KvmVcpuWakeupFtraceEvent() = default;
KvmVcpuWakeupFtraceEvent::~KvmVcpuWakeupFtraceEvent() = default;
KvmVcpuWakeupFtraceEvent::KvmVcpuWakeupFtraceEvent(const KvmVcpuWakeupFtraceEvent&) = default;
KvmVcpuWakeupFtraceEvent& KvmVcpuWakeupFtraceEvent::operator=(const KvmVcpuWakeupFtraceEvent&) = default;
KvmVcpuWakeupFtraceEvent::KvmVcpuWakeupFtraceEvent(KvmVcpuWakeupFtraceEvent&&) noexcept = default;
KvmVcpuWakeupFtraceEvent& KvmVcpuWakeupFtraceEvent::operator=(KvmVcpuWakeupFtraceEvent&&) = default;

bool KvmVcpuWakeupFtraceEvent::operator==(const KvmVcpuWakeupFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(ns_, other.ns_)
   && ::protozero::internal::gen_helpers::EqualsField(valid_, other.valid_)
   && ::protozero::internal::gen_helpers::EqualsField(waited_, other.waited_);
}

bool KvmVcpuWakeupFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* ns */:
        field.get(&ns_);
        break;
      case 2 /* valid */:
        field.get(&valid_);
        break;
      case 3 /* waited */:
        field.get(&waited_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KvmVcpuWakeupFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KvmVcpuWakeupFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KvmVcpuWakeupFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: ns
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, ns_, msg);
  }

  // Field 2: valid
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, valid_, msg);
  }

  // Field 3: waited
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, waited_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


KvmUserspaceExitFtraceEvent::KvmUserspaceExitFtraceEvent() = default;
KvmUserspaceExitFtraceEvent::~KvmUserspaceExitFtraceEvent() = default;
KvmUserspaceExitFtraceEvent::KvmUserspaceExitFtraceEvent(const KvmUserspaceExitFtraceEvent&) = default;
KvmUserspaceExitFtraceEvent& KvmUserspaceExitFtraceEvent::operator=(const KvmUserspaceExitFtraceEvent&) = default;
KvmUserspaceExitFtraceEvent::KvmUserspaceExitFtraceEvent(KvmUserspaceExitFtraceEvent&&) noexcept = default;
KvmUserspaceExitFtraceEvent& KvmUserspaceExitFtraceEvent::operator=(KvmUserspaceExitFtraceEvent&&) = default;

bool KvmUserspaceExitFtraceEvent::operator==(const KvmUserspaceExitFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(reason_, other.reason_);
}

bool KvmUserspaceExitFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* reason */:
        field.get(&reason_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KvmUserspaceExitFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KvmUserspaceExitFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KvmUserspaceExitFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: reason
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, reason_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


KvmUnmapHvaRangeFtraceEvent::KvmUnmapHvaRangeFtraceEvent() = default;
KvmUnmapHvaRangeFtraceEvent::~KvmUnmapHvaRangeFtraceEvent() = default;
KvmUnmapHvaRangeFtraceEvent::KvmUnmapHvaRangeFtraceEvent(const KvmUnmapHvaRangeFtraceEvent&) = default;
KvmUnmapHvaRangeFtraceEvent& KvmUnmapHvaRangeFtraceEvent::operator=(const KvmUnmapHvaRangeFtraceEvent&) = default;
KvmUnmapHvaRangeFtraceEvent::KvmUnmapHvaRangeFtraceEvent(KvmUnmapHvaRangeFtraceEvent&&) noexcept = default;
KvmUnmapHvaRangeFtraceEvent& KvmUnmapHvaRangeFtraceEvent::operator=(KvmUnmapHvaRangeFtraceEvent&&) = default;

bool KvmUnmapHvaRangeFtraceEvent::operator==(const KvmUnmapHvaRangeFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(end_, other.end_)
   && ::protozero::internal::gen_helpers::EqualsField(start_, other.start_);
}

bool KvmUnmapHvaRangeFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* end */:
        field.get(&end_);
        break;
      case 2 /* start */:
        field.get(&start_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KvmUnmapHvaRangeFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KvmUnmapHvaRangeFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KvmUnmapHvaRangeFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: end
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, end_, msg);
  }

  // Field 2: start
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, start_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


KvmToggleCacheFtraceEvent::KvmToggleCacheFtraceEvent() = default;
KvmToggleCacheFtraceEvent::~KvmToggleCacheFtraceEvent() = default;
KvmToggleCacheFtraceEvent::KvmToggleCacheFtraceEvent(const KvmToggleCacheFtraceEvent&) = default;
KvmToggleCacheFtraceEvent& KvmToggleCacheFtraceEvent::operator=(const KvmToggleCacheFtraceEvent&) = default;
KvmToggleCacheFtraceEvent::KvmToggleCacheFtraceEvent(KvmToggleCacheFtraceEvent&&) noexcept = default;
KvmToggleCacheFtraceEvent& KvmToggleCacheFtraceEvent::operator=(KvmToggleCacheFtraceEvent&&) = default;

bool KvmToggleCacheFtraceEvent::operator==(const KvmToggleCacheFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(now_, other.now_)
   && ::protozero::internal::gen_helpers::EqualsField(vcpu_pc_, other.vcpu_pc_)
   && ::protozero::internal::gen_helpers::EqualsField(was_, other.was_);
}

bool KvmToggleCacheFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* now */:
        field.get(&now_);
        break;
      case 2 /* vcpu_pc */:
        field.get(&vcpu_pc_);
        break;
      case 3 /* was */:
        field.get(&was_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KvmToggleCacheFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KvmToggleCacheFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KvmToggleCacheFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: now
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, now_, msg);
  }

  // Field 2: vcpu_pc
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, vcpu_pc_, msg);
  }

  // Field 3: was
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, was_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


KvmTimerUpdateIrqFtraceEvent::KvmTimerUpdateIrqFtraceEvent() = default;
KvmTimerUpdateIrqFtraceEvent::~KvmTimerUpdateIrqFtraceEvent() = default;
KvmTimerUpdateIrqFtraceEvent::KvmTimerUpdateIrqFtraceEvent(const KvmTimerUpdateIrqFtraceEvent&) = default;
KvmTimerUpdateIrqFtraceEvent& KvmTimerUpdateIrqFtraceEvent::operator=(const KvmTimerUpdateIrqFtraceEvent&) = default;
KvmTimerUpdateIrqFtraceEvent::KvmTimerUpdateIrqFtraceEvent(KvmTimerUpdateIrqFtraceEvent&&) noexcept = default;
KvmTimerUpdateIrqFtraceEvent& KvmTimerUpdateIrqFtraceEvent::operator=(KvmTimerUpdateIrqFtraceEvent&&) = default;

bool KvmTimerUpdateIrqFtraceEvent::operator==(const KvmTimerUpdateIrqFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(irq_, other.irq_)
   && ::protozero::internal::gen_helpers::EqualsField(level_, other.level_)
   && ::protozero::internal::gen_helpers::EqualsField(vcpu_id_, other.vcpu_id_);
}

bool KvmTimerUpdateIrqFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* irq */:
        field.get(&irq_);
        break;
      case 2 /* level */:
        field.get(&level_);
        break;
      case 3 /* vcpu_id */:
        field.get(&vcpu_id_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KvmTimerUpdateIrqFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KvmTimerUpdateIrqFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KvmTimerUpdateIrqFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: irq
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, irq_, msg);
  }

  // Field 2: level
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, level_, msg);
  }

  // Field 3: vcpu_id
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, vcpu_id_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


KvmTimerSaveStateFtraceEvent::KvmTimerSaveStateFtraceEvent() = default;
KvmTimerSaveStateFtraceEvent::~KvmTimerSaveStateFtraceEvent() = default;
KvmTimerSaveStateFtraceEvent::KvmTimerSaveStateFtraceEvent(const KvmTimerSaveStateFtraceEvent&) = default;
KvmTimerSaveStateFtraceEvent& KvmTimerSaveStateFtraceEvent::operator=(const KvmTimerSaveStateFtraceEvent&) = default;
KvmTimerSaveStateFtraceEvent::KvmTimerSaveStateFtraceEvent(KvmTimerSaveStateFtraceEvent&&) noexcept = default;
KvmTimerSaveStateFtraceEvent& KvmTimerSaveStateFtraceEvent::operator=(KvmTimerSaveStateFtraceEvent&&) = default;

bool KvmTimerSaveStateFtraceEvent::operator==(const KvmTimerSaveStateFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(ctl_, other.ctl_)
   && ::protozero::internal::gen_helpers::EqualsField(cval_, other.cval_)
   && ::protozero::internal::gen_helpers::EqualsField(timer_idx_, other.timer_idx_);
}

bool KvmTimerSaveStateFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* ctl */:
        field.get(&ctl_);
        break;
      case 2 /* cval */:
        field.get(&cval_);
        break;
      case 3 /* timer_idx */:
        field.get(&timer_idx_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KvmTimerSaveStateFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KvmTimerSaveStateFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KvmTimerSaveStateFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: ctl
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, ctl_, msg);
  }

  // Field 2: cval
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, cval_, msg);
  }

  // Field 3: timer_idx
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, timer_idx_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


KvmTimerRestoreStateFtraceEvent::KvmTimerRestoreStateFtraceEvent() = default;
KvmTimerRestoreStateFtraceEvent::~KvmTimerRestoreStateFtraceEvent() = default;
KvmTimerRestoreStateFtraceEvent::KvmTimerRestoreStateFtraceEvent(const KvmTimerRestoreStateFtraceEvent&) = default;
KvmTimerRestoreStateFtraceEvent& KvmTimerRestoreStateFtraceEvent::operator=(const KvmTimerRestoreStateFtraceEvent&) = default;
KvmTimerRestoreStateFtraceEvent::KvmTimerRestoreStateFtraceEvent(KvmTimerRestoreStateFtraceEvent&&) noexcept = default;
KvmTimerRestoreStateFtraceEvent& KvmTimerRestoreStateFtraceEvent::operator=(KvmTimerRestoreStateFtraceEvent&&) = default;

bool KvmTimerRestoreStateFtraceEvent::operator==(const KvmTimerRestoreStateFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(ctl_, other.ctl_)
   && ::protozero::internal::gen_helpers::EqualsField(cval_, other.cval_)
   && ::protozero::internal::gen_helpers::EqualsField(timer_idx_, other.timer_idx_);
}

bool KvmTimerRestoreStateFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* ctl */:
        field.get(&ctl_);
        break;
      case 2 /* cval */:
        field.get(&cval_);
        break;
      case 3 /* timer_idx */:
        field.get(&timer_idx_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KvmTimerRestoreStateFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KvmTimerRestoreStateFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KvmTimerRestoreStateFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: ctl
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, ctl_, msg);
  }

  // Field 2: cval
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, cval_, msg);
  }

  // Field 3: timer_idx
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, timer_idx_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


KvmTimerHrtimerExpireFtraceEvent::KvmTimerHrtimerExpireFtraceEvent() = default;
KvmTimerHrtimerExpireFtraceEvent::~KvmTimerHrtimerExpireFtraceEvent() = default;
KvmTimerHrtimerExpireFtraceEvent::KvmTimerHrtimerExpireFtraceEvent(const KvmTimerHrtimerExpireFtraceEvent&) = default;
KvmTimerHrtimerExpireFtraceEvent& KvmTimerHrtimerExpireFtraceEvent::operator=(const KvmTimerHrtimerExpireFtraceEvent&) = default;
KvmTimerHrtimerExpireFtraceEvent::KvmTimerHrtimerExpireFtraceEvent(KvmTimerHrtimerExpireFtraceEvent&&) noexcept = default;
KvmTimerHrtimerExpireFtraceEvent& KvmTimerHrtimerExpireFtraceEvent::operator=(KvmTimerHrtimerExpireFtraceEvent&&) = default;

bool KvmTimerHrtimerExpireFtraceEvent::operator==(const KvmTimerHrtimerExpireFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(timer_idx_, other.timer_idx_);
}

bool KvmTimerHrtimerExpireFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* timer_idx */:
        field.get(&timer_idx_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KvmTimerHrtimerExpireFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KvmTimerHrtimerExpireFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KvmTimerHrtimerExpireFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: timer_idx
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, timer_idx_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


KvmTimerEmulateFtraceEvent::KvmTimerEmulateFtraceEvent() = default;
KvmTimerEmulateFtraceEvent::~KvmTimerEmulateFtraceEvent() = default;
KvmTimerEmulateFtraceEvent::KvmTimerEmulateFtraceEvent(const KvmTimerEmulateFtraceEvent&) = default;
KvmTimerEmulateFtraceEvent& KvmTimerEmulateFtraceEvent::operator=(const KvmTimerEmulateFtraceEvent&) = default;
KvmTimerEmulateFtraceEvent::KvmTimerEmulateFtraceEvent(KvmTimerEmulateFtraceEvent&&) noexcept = default;
KvmTimerEmulateFtraceEvent& KvmTimerEmulateFtraceEvent::operator=(KvmTimerEmulateFtraceEvent&&) = default;

bool KvmTimerEmulateFtraceEvent::operator==(const KvmTimerEmulateFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(should_fire_, other.should_fire_)
   && ::protozero::internal::gen_helpers::EqualsField(timer_idx_, other.timer_idx_);
}

bool KvmTimerEmulateFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* should_fire */:
        field.get(&should_fire_);
        break;
      case 2 /* timer_idx */:
        field.get(&timer_idx_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KvmTimerEmulateFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KvmTimerEmulateFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KvmTimerEmulateFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: should_fire
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, should_fire_, msg);
  }

  // Field 2: timer_idx
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, timer_idx_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


KvmTestAgeHvaFtraceEvent::KvmTestAgeHvaFtraceEvent() = default;
KvmTestAgeHvaFtraceEvent::~KvmTestAgeHvaFtraceEvent() = default;
KvmTestAgeHvaFtraceEvent::KvmTestAgeHvaFtraceEvent(const KvmTestAgeHvaFtraceEvent&) = default;
KvmTestAgeHvaFtraceEvent& KvmTestAgeHvaFtraceEvent::operator=(const KvmTestAgeHvaFtraceEvent&) = default;
KvmTestAgeHvaFtraceEvent::KvmTestAgeHvaFtraceEvent(KvmTestAgeHvaFtraceEvent&&) noexcept = default;
KvmTestAgeHvaFtraceEvent& KvmTestAgeHvaFtraceEvent::operator=(KvmTestAgeHvaFtraceEvent&&) = default;

bool KvmTestAgeHvaFtraceEvent::operator==(const KvmTestAgeHvaFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(hva_, other.hva_);
}

bool KvmTestAgeHvaFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* hva */:
        field.get(&hva_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KvmTestAgeHvaFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KvmTestAgeHvaFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KvmTestAgeHvaFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: hva
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, hva_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


KvmSysAccessFtraceEvent::KvmSysAccessFtraceEvent() = default;
KvmSysAccessFtraceEvent::~KvmSysAccessFtraceEvent() = default;
KvmSysAccessFtraceEvent::KvmSysAccessFtraceEvent(const KvmSysAccessFtraceEvent&) = default;
KvmSysAccessFtraceEvent& KvmSysAccessFtraceEvent::operator=(const KvmSysAccessFtraceEvent&) = default;
KvmSysAccessFtraceEvent::KvmSysAccessFtraceEvent(KvmSysAccessFtraceEvent&&) noexcept = default;
KvmSysAccessFtraceEvent& KvmSysAccessFtraceEvent::operator=(KvmSysAccessFtraceEvent&&) = default;

bool KvmSysAccessFtraceEvent::operator==(const KvmSysAccessFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(crm_, other.crm_)
   && ::protozero::internal::gen_helpers::EqualsField(crn_, other.crn_)
   && ::protozero::internal::gen_helpers::EqualsField(op0_, other.op0_)
   && ::protozero::internal::gen_helpers::EqualsField(op1_, other.op1_)
   && ::protozero::internal::gen_helpers::EqualsField(op2_, other.op2_)
   && ::protozero::internal::gen_helpers::EqualsField(is_write_, other.is_write_)
   && ::protozero::internal::gen_helpers::EqualsField(name_, other.name_)
   && ::protozero::internal::gen_helpers::EqualsField(vcpu_pc_, other.vcpu_pc_);
}

bool KvmSysAccessFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* crm */:
        field.get(&crm_);
        break;
      case 2 /* crn */:
        field.get(&crn_);
        break;
      case 3 /* op0 */:
        field.get(&op0_);
        break;
      case 4 /* op1 */:
        field.get(&op1_);
        break;
      case 5 /* op2 */:
        field.get(&op2_);
        break;
      case 6 /* is_write */:
        field.get(&is_write_);
        break;
      case 7 /* name */:
        ::protozero::internal::gen_helpers::DeserializeString(field, &name_);
        break;
      case 8 /* vcpu_pc */:
        field.get(&vcpu_pc_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KvmSysAccessFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KvmSysAccessFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KvmSysAccessFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: crm
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, crm_, msg);
  }

  // Field 2: crn
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, crn_, msg);
  }

  // Field 3: op0
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, op0_, msg);
  }

  // Field 4: op1
  if (_has_field_[4]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(4, op1_, msg);
  }

  // Field 5: op2
  if (_has_field_[5]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(5, op2_, msg);
  }

  // Field 6: is_write
  if (_has_field_[6]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(6, is_write_, msg);
  }

  // Field 7: name
  if (_has_field_[7]) {
    ::protozero::internal::gen_helpers::SerializeString(7, name_, msg);
  }

  // Field 8: vcpu_pc
  if (_has_field_[8]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(8, vcpu_pc_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


KvmSetWayFlushFtraceEvent::KvmSetWayFlushFtraceEvent() = default;
KvmSetWayFlushFtraceEvent::~KvmSetWayFlushFtraceEvent() = default;
KvmSetWayFlushFtraceEvent::KvmSetWayFlushFtraceEvent(const KvmSetWayFlushFtraceEvent&) = default;
KvmSetWayFlushFtraceEvent& KvmSetWayFlushFtraceEvent::operator=(const KvmSetWayFlushFtraceEvent&) = default;
KvmSetWayFlushFtraceEvent::KvmSetWayFlushFtraceEvent(KvmSetWayFlushFtraceEvent&&) noexcept = default;
KvmSetWayFlushFtraceEvent& KvmSetWayFlushFtraceEvent::operator=(KvmSetWayFlushFtraceEvent&&) = default;

bool KvmSetWayFlushFtraceEvent::operator==(const KvmSetWayFlushFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(cache_, other.cache_)
   && ::protozero::internal::gen_helpers::EqualsField(vcpu_pc_, other.vcpu_pc_);
}

bool KvmSetWayFlushFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* cache */:
        field.get(&cache_);
        break;
      case 2 /* vcpu_pc */:
        field.get(&vcpu_pc_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KvmSetWayFlushFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KvmSetWayFlushFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KvmSetWayFlushFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: cache
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, cache_, msg);
  }

  // Field 2: vcpu_pc
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, vcpu_pc_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


KvmSetSpteHvaFtraceEvent::KvmSetSpteHvaFtraceEvent() = default;
KvmSetSpteHvaFtraceEvent::~KvmSetSpteHvaFtraceEvent() = default;
KvmSetSpteHvaFtraceEvent::KvmSetSpteHvaFtraceEvent(const KvmSetSpteHvaFtraceEvent&) = default;
KvmSetSpteHvaFtraceEvent& KvmSetSpteHvaFtraceEvent::operator=(const KvmSetSpteHvaFtraceEvent&) = default;
KvmSetSpteHvaFtraceEvent::KvmSetSpteHvaFtraceEvent(KvmSetSpteHvaFtraceEvent&&) noexcept = default;
KvmSetSpteHvaFtraceEvent& KvmSetSpteHvaFtraceEvent::operator=(KvmSetSpteHvaFtraceEvent&&) = default;

bool KvmSetSpteHvaFtraceEvent::operator==(const KvmSetSpteHvaFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(hva_, other.hva_);
}

bool KvmSetSpteHvaFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* hva */:
        field.get(&hva_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KvmSetSpteHvaFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KvmSetSpteHvaFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KvmSetSpteHvaFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: hva
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, hva_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


KvmSetIrqFtraceEvent::KvmSetIrqFtraceEvent() = default;
KvmSetIrqFtraceEvent::~KvmSetIrqFtraceEvent() = default;
KvmSetIrqFtraceEvent::KvmSetIrqFtraceEvent(const KvmSetIrqFtraceEvent&) = default;
KvmSetIrqFtraceEvent& KvmSetIrqFtraceEvent::operator=(const KvmSetIrqFtraceEvent&) = default;
KvmSetIrqFtraceEvent::KvmSetIrqFtraceEvent(KvmSetIrqFtraceEvent&&) noexcept = default;
KvmSetIrqFtraceEvent& KvmSetIrqFtraceEvent::operator=(KvmSetIrqFtraceEvent&&) = default;

bool KvmSetIrqFtraceEvent::operator==(const KvmSetIrqFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(gsi_, other.gsi_)
   && ::protozero::internal::gen_helpers::EqualsField(irq_source_id_, other.irq_source_id_)
   && ::protozero::internal::gen_helpers::EqualsField(level_, other.level_);
}

bool KvmSetIrqFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* gsi */:
        field.get(&gsi_);
        break;
      case 2 /* irq_source_id */:
        field.get(&irq_source_id_);
        break;
      case 3 /* level */:
        field.get(&level_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KvmSetIrqFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KvmSetIrqFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KvmSetIrqFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: gsi
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, gsi_, msg);
  }

  // Field 2: irq_source_id
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, irq_source_id_, msg);
  }

  // Field 3: level
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, level_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


KvmSetGuestDebugFtraceEvent::KvmSetGuestDebugFtraceEvent() = default;
KvmSetGuestDebugFtraceEvent::~KvmSetGuestDebugFtraceEvent() = default;
KvmSetGuestDebugFtraceEvent::KvmSetGuestDebugFtraceEvent(const KvmSetGuestDebugFtraceEvent&) = default;
KvmSetGuestDebugFtraceEvent& KvmSetGuestDebugFtraceEvent::operator=(const KvmSetGuestDebugFtraceEvent&) = default;
KvmSetGuestDebugFtraceEvent::KvmSetGuestDebugFtraceEvent(KvmSetGuestDebugFtraceEvent&&) noexcept = default;
KvmSetGuestDebugFtraceEvent& KvmSetGuestDebugFtraceEvent::operator=(KvmSetGuestDebugFtraceEvent&&) = default;

bool KvmSetGuestDebugFtraceEvent::operator==(const KvmSetGuestDebugFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(guest_debug_, other.guest_debug_)
   && ::protozero::internal::gen_helpers::EqualsField(vcpu_, other.vcpu_);
}

bool KvmSetGuestDebugFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* guest_debug */:
        field.get(&guest_debug_);
        break;
      case 2 /* vcpu */:
        field.get(&vcpu_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KvmSetGuestDebugFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KvmSetGuestDebugFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KvmSetGuestDebugFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: guest_debug
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, guest_debug_, msg);
  }

  // Field 2: vcpu
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, vcpu_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


KvmMmioEmulateFtraceEvent::KvmMmioEmulateFtraceEvent() = default;
KvmMmioEmulateFtraceEvent::~KvmMmioEmulateFtraceEvent() = default;
KvmMmioEmulateFtraceEvent::KvmMmioEmulateFtraceEvent(const KvmMmioEmulateFtraceEvent&) = default;
KvmMmioEmulateFtraceEvent& KvmMmioEmulateFtraceEvent::operator=(const KvmMmioEmulateFtraceEvent&) = default;
KvmMmioEmulateFtraceEvent::KvmMmioEmulateFtraceEvent(KvmMmioEmulateFtraceEvent&&) noexcept = default;
KvmMmioEmulateFtraceEvent& KvmMmioEmulateFtraceEvent::operator=(KvmMmioEmulateFtraceEvent&&) = default;

bool KvmMmioEmulateFtraceEvent::operator==(const KvmMmioEmulateFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(cpsr_, other.cpsr_)
   && ::protozero::internal::gen_helpers::EqualsField(instr_, other.instr_)
   && ::protozero::internal::gen_helpers::EqualsField(vcpu_pc_, other.vcpu_pc_);
}

bool KvmMmioEmulateFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* cpsr */:
        field.get(&cpsr_);
        break;
      case 2 /* instr */:
        field.get(&instr_);
        break;
      case 3 /* vcpu_pc */:
        field.get(&vcpu_pc_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KvmMmioEmulateFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KvmMmioEmulateFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KvmMmioEmulateFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: cpsr
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, cpsr_, msg);
  }

  // Field 2: instr
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, instr_, msg);
  }

  // Field 3: vcpu_pc
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, vcpu_pc_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


KvmMmioFtraceEvent::KvmMmioFtraceEvent() = default;
KvmMmioFtraceEvent::~KvmMmioFtraceEvent() = default;
KvmMmioFtraceEvent::KvmMmioFtraceEvent(const KvmMmioFtraceEvent&) = default;
KvmMmioFtraceEvent& KvmMmioFtraceEvent::operator=(const KvmMmioFtraceEvent&) = default;
KvmMmioFtraceEvent::KvmMmioFtraceEvent(KvmMmioFtraceEvent&&) noexcept = default;
KvmMmioFtraceEvent& KvmMmioFtraceEvent::operator=(KvmMmioFtraceEvent&&) = default;

bool KvmMmioFtraceEvent::operator==(const KvmMmioFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(gpa_, other.gpa_)
   && ::protozero::internal::gen_helpers::EqualsField(len_, other.len_)
   && ::protozero::internal::gen_helpers::EqualsField(type_, other.type_)
   && ::protozero::internal::gen_helpers::EqualsField(val_, other.val_);
}

bool KvmMmioFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* gpa */:
        field.get(&gpa_);
        break;
      case 2 /* len */:
        field.get(&len_);
        break;
      case 3 /* type */:
        field.get(&type_);
        break;
      case 4 /* val */:
        field.get(&val_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KvmMmioFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KvmMmioFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KvmMmioFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: gpa
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, gpa_, msg);
  }

  // Field 2: len
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, len_, msg);
  }

  // Field 3: type
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, type_, msg);
  }

  // Field 4: val
  if (_has_field_[4]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(4, val_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


KvmIrqLineFtraceEvent::KvmIrqLineFtraceEvent() = default;
KvmIrqLineFtraceEvent::~KvmIrqLineFtraceEvent() = default;
KvmIrqLineFtraceEvent::KvmIrqLineFtraceEvent(const KvmIrqLineFtraceEvent&) = default;
KvmIrqLineFtraceEvent& KvmIrqLineFtraceEvent::operator=(const KvmIrqLineFtraceEvent&) = default;
KvmIrqLineFtraceEvent::KvmIrqLineFtraceEvent(KvmIrqLineFtraceEvent&&) noexcept = default;
KvmIrqLineFtraceEvent& KvmIrqLineFtraceEvent::operator=(KvmIrqLineFtraceEvent&&) = default;

bool KvmIrqLineFtraceEvent::operator==(const KvmIrqLineFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(irq_num_, other.irq_num_)
   && ::protozero::internal::gen_helpers::EqualsField(level_, other.level_)
   && ::protozero::internal::gen_helpers::EqualsField(type_, other.type_)
   && ::protozero::internal::gen_helpers::EqualsField(vcpu_idx_, other.vcpu_idx_);
}

bool KvmIrqLineFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* irq_num */:
        field.get(&irq_num_);
        break;
      case 2 /* level */:
        field.get(&level_);
        break;
      case 3 /* type */:
        field.get(&type_);
        break;
      case 4 /* vcpu_idx */:
        field.get(&vcpu_idx_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KvmIrqLineFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KvmIrqLineFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KvmIrqLineFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: irq_num
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, irq_num_, msg);
  }

  // Field 2: level
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, level_, msg);
  }

  // Field 3: type
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, type_, msg);
  }

  // Field 4: vcpu_idx
  if (_has_field_[4]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(4, vcpu_idx_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


KvmHvcArm64FtraceEvent::KvmHvcArm64FtraceEvent() = default;
KvmHvcArm64FtraceEvent::~KvmHvcArm64FtraceEvent() = default;
KvmHvcArm64FtraceEvent::KvmHvcArm64FtraceEvent(const KvmHvcArm64FtraceEvent&) = default;
KvmHvcArm64FtraceEvent& KvmHvcArm64FtraceEvent::operator=(const KvmHvcArm64FtraceEvent&) = default;
KvmHvcArm64FtraceEvent::KvmHvcArm64FtraceEvent(KvmHvcArm64FtraceEvent&&) noexcept = default;
KvmHvcArm64FtraceEvent& KvmHvcArm64FtraceEvent::operator=(KvmHvcArm64FtraceEvent&&) = default;

bool KvmHvcArm64FtraceEvent::operator==(const KvmHvcArm64FtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(imm_, other.imm_)
   && ::protozero::internal::gen_helpers::EqualsField(r0_, other.r0_)
   && ::protozero::internal::gen_helpers::EqualsField(vcpu_pc_, other.vcpu_pc_);
}

bool KvmHvcArm64FtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* imm */:
        field.get(&imm_);
        break;
      case 2 /* r0 */:
        field.get(&r0_);
        break;
      case 3 /* vcpu_pc */:
        field.get(&vcpu_pc_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KvmHvcArm64FtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KvmHvcArm64FtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KvmHvcArm64FtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: imm
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, imm_, msg);
  }

  // Field 2: r0
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, r0_, msg);
  }

  // Field 3: vcpu_pc
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, vcpu_pc_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


KvmHandleSysRegFtraceEvent::KvmHandleSysRegFtraceEvent() = default;
KvmHandleSysRegFtraceEvent::~KvmHandleSysRegFtraceEvent() = default;
KvmHandleSysRegFtraceEvent::KvmHandleSysRegFtraceEvent(const KvmHandleSysRegFtraceEvent&) = default;
KvmHandleSysRegFtraceEvent& KvmHandleSysRegFtraceEvent::operator=(const KvmHandleSysRegFtraceEvent&) = default;
KvmHandleSysRegFtraceEvent::KvmHandleSysRegFtraceEvent(KvmHandleSysRegFtraceEvent&&) noexcept = default;
KvmHandleSysRegFtraceEvent& KvmHandleSysRegFtraceEvent::operator=(KvmHandleSysRegFtraceEvent&&) = default;

bool KvmHandleSysRegFtraceEvent::operator==(const KvmHandleSysRegFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(hsr_, other.hsr_);
}

bool KvmHandleSysRegFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* hsr */:
        field.get(&hsr_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KvmHandleSysRegFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KvmHandleSysRegFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KvmHandleSysRegFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: hsr
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, hsr_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


KvmGuestFaultFtraceEvent::KvmGuestFaultFtraceEvent() = default;
KvmGuestFaultFtraceEvent::~KvmGuestFaultFtraceEvent() = default;
KvmGuestFaultFtraceEvent::KvmGuestFaultFtraceEvent(const KvmGuestFaultFtraceEvent&) = default;
KvmGuestFaultFtraceEvent& KvmGuestFaultFtraceEvent::operator=(const KvmGuestFaultFtraceEvent&) = default;
KvmGuestFaultFtraceEvent::KvmGuestFaultFtraceEvent(KvmGuestFaultFtraceEvent&&) noexcept = default;
KvmGuestFaultFtraceEvent& KvmGuestFaultFtraceEvent::operator=(KvmGuestFaultFtraceEvent&&) = default;

bool KvmGuestFaultFtraceEvent::operator==(const KvmGuestFaultFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(hsr_, other.hsr_)
   && ::protozero::internal::gen_helpers::EqualsField(hxfar_, other.hxfar_)
   && ::protozero::internal::gen_helpers::EqualsField(ipa_, other.ipa_)
   && ::protozero::internal::gen_helpers::EqualsField(vcpu_pc_, other.vcpu_pc_);
}

bool KvmGuestFaultFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* hsr */:
        field.get(&hsr_);
        break;
      case 2 /* hxfar */:
        field.get(&hxfar_);
        break;
      case 3 /* ipa */:
        field.get(&ipa_);
        break;
      case 4 /* vcpu_pc */:
        field.get(&vcpu_pc_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KvmGuestFaultFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KvmGuestFaultFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KvmGuestFaultFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: hsr
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, hsr_, msg);
  }

  // Field 2: hxfar
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, hxfar_, msg);
  }

  // Field 3: ipa
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, ipa_, msg);
  }

  // Field 4: vcpu_pc
  if (_has_field_[4]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(4, vcpu_pc_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


KvmGetTimerMapFtraceEvent::KvmGetTimerMapFtraceEvent() = default;
KvmGetTimerMapFtraceEvent::~KvmGetTimerMapFtraceEvent() = default;
KvmGetTimerMapFtraceEvent::KvmGetTimerMapFtraceEvent(const KvmGetTimerMapFtraceEvent&) = default;
KvmGetTimerMapFtraceEvent& KvmGetTimerMapFtraceEvent::operator=(const KvmGetTimerMapFtraceEvent&) = default;
KvmGetTimerMapFtraceEvent::KvmGetTimerMapFtraceEvent(KvmGetTimerMapFtraceEvent&&) noexcept = default;
KvmGetTimerMapFtraceEvent& KvmGetTimerMapFtraceEvent::operator=(KvmGetTimerMapFtraceEvent&&) = default;

bool KvmGetTimerMapFtraceEvent::operator==(const KvmGetTimerMapFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(direct_ptimer_, other.direct_ptimer_)
   && ::protozero::internal::gen_helpers::EqualsField(direct_vtimer_, other.direct_vtimer_)
   && ::protozero::internal::gen_helpers::EqualsField(emul_ptimer_, other.emul_ptimer_)
   && ::protozero::internal::gen_helpers::EqualsField(vcpu_id_, other.vcpu_id_);
}

bool KvmGetTimerMapFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* direct_ptimer */:
        field.get(&direct_ptimer_);
        break;
      case 2 /* direct_vtimer */:
        field.get(&direct_vtimer_);
        break;
      case 3 /* emul_ptimer */:
        field.get(&emul_ptimer_);
        break;
      case 4 /* vcpu_id */:
        field.get(&vcpu_id_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KvmGetTimerMapFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KvmGetTimerMapFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KvmGetTimerMapFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: direct_ptimer
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, direct_ptimer_, msg);
  }

  // Field 2: direct_vtimer
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, direct_vtimer_, msg);
  }

  // Field 3: emul_ptimer
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, emul_ptimer_, msg);
  }

  // Field 4: vcpu_id
  if (_has_field_[4]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(4, vcpu_id_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


KvmFpuFtraceEvent::KvmFpuFtraceEvent() = default;
KvmFpuFtraceEvent::~KvmFpuFtraceEvent() = default;
KvmFpuFtraceEvent::KvmFpuFtraceEvent(const KvmFpuFtraceEvent&) = default;
KvmFpuFtraceEvent& KvmFpuFtraceEvent::operator=(const KvmFpuFtraceEvent&) = default;
KvmFpuFtraceEvent::KvmFpuFtraceEvent(KvmFpuFtraceEvent&&) noexcept = default;
KvmFpuFtraceEvent& KvmFpuFtraceEvent::operator=(KvmFpuFtraceEvent&&) = default;

bool KvmFpuFtraceEvent::operator==(const KvmFpuFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(load_, other.load_);
}

bool KvmFpuFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* load */:
        field.get(&load_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KvmFpuFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KvmFpuFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KvmFpuFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: load
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, load_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


KvmExitFtraceEvent::KvmExitFtraceEvent() = default;
KvmExitFtraceEvent::~KvmExitFtraceEvent() = default;
KvmExitFtraceEvent::KvmExitFtraceEvent(const KvmExitFtraceEvent&) = default;
KvmExitFtraceEvent& KvmExitFtraceEvent::operator=(const KvmExitFtraceEvent&) = default;
KvmExitFtraceEvent::KvmExitFtraceEvent(KvmExitFtraceEvent&&) noexcept = default;
KvmExitFtraceEvent& KvmExitFtraceEvent::operator=(KvmExitFtraceEvent&&) = default;

bool KvmExitFtraceEvent::operator==(const KvmExitFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(esr_ec_, other.esr_ec_)
   && ::protozero::internal::gen_helpers::EqualsField(ret_, other.ret_)
   && ::protozero::internal::gen_helpers::EqualsField(vcpu_pc_, other.vcpu_pc_);
}

bool KvmExitFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* esr_ec */:
        field.get(&esr_ec_);
        break;
      case 2 /* ret */:
        field.get(&ret_);
        break;
      case 3 /* vcpu_pc */:
        field.get(&vcpu_pc_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KvmExitFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KvmExitFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KvmExitFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: esr_ec
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, esr_ec_, msg);
  }

  // Field 2: ret
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, ret_, msg);
  }

  // Field 3: vcpu_pc
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, vcpu_pc_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


KvmEntryFtraceEvent::KvmEntryFtraceEvent() = default;
KvmEntryFtraceEvent::~KvmEntryFtraceEvent() = default;
KvmEntryFtraceEvent::KvmEntryFtraceEvent(const KvmEntryFtraceEvent&) = default;
KvmEntryFtraceEvent& KvmEntryFtraceEvent::operator=(const KvmEntryFtraceEvent&) = default;
KvmEntryFtraceEvent::KvmEntryFtraceEvent(KvmEntryFtraceEvent&&) noexcept = default;
KvmEntryFtraceEvent& KvmEntryFtraceEvent::operator=(KvmEntryFtraceEvent&&) = default;

bool KvmEntryFtraceEvent::operator==(const KvmEntryFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(vcpu_pc_, other.vcpu_pc_);
}

bool KvmEntryFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* vcpu_pc */:
        field.get(&vcpu_pc_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KvmEntryFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KvmEntryFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KvmEntryFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: vcpu_pc
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, vcpu_pc_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


KvmArmSetupDebugFtraceEvent::KvmArmSetupDebugFtraceEvent() = default;
KvmArmSetupDebugFtraceEvent::~KvmArmSetupDebugFtraceEvent() = default;
KvmArmSetupDebugFtraceEvent::KvmArmSetupDebugFtraceEvent(const KvmArmSetupDebugFtraceEvent&) = default;
KvmArmSetupDebugFtraceEvent& KvmArmSetupDebugFtraceEvent::operator=(const KvmArmSetupDebugFtraceEvent&) = default;
KvmArmSetupDebugFtraceEvent::KvmArmSetupDebugFtraceEvent(KvmArmSetupDebugFtraceEvent&&) noexcept = default;
KvmArmSetupDebugFtraceEvent& KvmArmSetupDebugFtraceEvent::operator=(KvmArmSetupDebugFtraceEvent&&) = default;

bool KvmArmSetupDebugFtraceEvent::operator==(const KvmArmSetupDebugFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(guest_debug_, other.guest_debug_)
   && ::protozero::internal::gen_helpers::EqualsField(vcpu_, other.vcpu_);
}

bool KvmArmSetupDebugFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* guest_debug */:
        field.get(&guest_debug_);
        break;
      case 2 /* vcpu */:
        field.get(&vcpu_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KvmArmSetupDebugFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KvmArmSetupDebugFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KvmArmSetupDebugFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: guest_debug
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, guest_debug_, msg);
  }

  // Field 2: vcpu
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, vcpu_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


KvmArmSetRegsetFtraceEvent::KvmArmSetRegsetFtraceEvent() = default;
KvmArmSetRegsetFtraceEvent::~KvmArmSetRegsetFtraceEvent() = default;
KvmArmSetRegsetFtraceEvent::KvmArmSetRegsetFtraceEvent(const KvmArmSetRegsetFtraceEvent&) = default;
KvmArmSetRegsetFtraceEvent& KvmArmSetRegsetFtraceEvent::operator=(const KvmArmSetRegsetFtraceEvent&) = default;
KvmArmSetRegsetFtraceEvent::KvmArmSetRegsetFtraceEvent(KvmArmSetRegsetFtraceEvent&&) noexcept = default;
KvmArmSetRegsetFtraceEvent& KvmArmSetRegsetFtraceEvent::operator=(KvmArmSetRegsetFtraceEvent&&) = default;

bool KvmArmSetRegsetFtraceEvent::operator==(const KvmArmSetRegsetFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(len_, other.len_)
   && ::protozero::internal::gen_helpers::EqualsField(name_, other.name_);
}

bool KvmArmSetRegsetFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* len */:
        field.get(&len_);
        break;
      case 2 /* name */:
        ::protozero::internal::gen_helpers::DeserializeString(field, &name_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KvmArmSetRegsetFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KvmArmSetRegsetFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KvmArmSetRegsetFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: len
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, len_, msg);
  }

  // Field 2: name
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeString(2, name_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


KvmArmSetDreg32FtraceEvent::KvmArmSetDreg32FtraceEvent() = default;
KvmArmSetDreg32FtraceEvent::~KvmArmSetDreg32FtraceEvent() = default;
KvmArmSetDreg32FtraceEvent::KvmArmSetDreg32FtraceEvent(const KvmArmSetDreg32FtraceEvent&) = default;
KvmArmSetDreg32FtraceEvent& KvmArmSetDreg32FtraceEvent::operator=(const KvmArmSetDreg32FtraceEvent&) = default;
KvmArmSetDreg32FtraceEvent::KvmArmSetDreg32FtraceEvent(KvmArmSetDreg32FtraceEvent&&) noexcept = default;
KvmArmSetDreg32FtraceEvent& KvmArmSetDreg32FtraceEvent::operator=(KvmArmSetDreg32FtraceEvent&&) = default;

bool KvmArmSetDreg32FtraceEvent::operator==(const KvmArmSetDreg32FtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(name_, other.name_)
   && ::protozero::internal::gen_helpers::EqualsField(value_, other.value_);
}

bool KvmArmSetDreg32FtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* name */:
        ::protozero::internal::gen_helpers::DeserializeString(field, &name_);
        break;
      case 2 /* value */:
        field.get(&value_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KvmArmSetDreg32FtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KvmArmSetDreg32FtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KvmArmSetDreg32FtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: name
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeString(1, name_, msg);
  }

  // Field 2: value
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, value_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


KvmArmClearDebugFtraceEvent::KvmArmClearDebugFtraceEvent() = default;
KvmArmClearDebugFtraceEvent::~KvmArmClearDebugFtraceEvent() = default;
KvmArmClearDebugFtraceEvent::KvmArmClearDebugFtraceEvent(const KvmArmClearDebugFtraceEvent&) = default;
KvmArmClearDebugFtraceEvent& KvmArmClearDebugFtraceEvent::operator=(const KvmArmClearDebugFtraceEvent&) = default;
KvmArmClearDebugFtraceEvent::KvmArmClearDebugFtraceEvent(KvmArmClearDebugFtraceEvent&&) noexcept = default;
KvmArmClearDebugFtraceEvent& KvmArmClearDebugFtraceEvent::operator=(KvmArmClearDebugFtraceEvent&&) = default;

bool KvmArmClearDebugFtraceEvent::operator==(const KvmArmClearDebugFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(guest_debug_, other.guest_debug_);
}

bool KvmArmClearDebugFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* guest_debug */:
        field.get(&guest_debug_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KvmArmClearDebugFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KvmArmClearDebugFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KvmArmClearDebugFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: guest_debug
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, guest_debug_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


KvmAgePageFtraceEvent::KvmAgePageFtraceEvent() = default;
KvmAgePageFtraceEvent::~KvmAgePageFtraceEvent() = default;
KvmAgePageFtraceEvent::KvmAgePageFtraceEvent(const KvmAgePageFtraceEvent&) = default;
KvmAgePageFtraceEvent& KvmAgePageFtraceEvent::operator=(const KvmAgePageFtraceEvent&) = default;
KvmAgePageFtraceEvent::KvmAgePageFtraceEvent(KvmAgePageFtraceEvent&&) noexcept = default;
KvmAgePageFtraceEvent& KvmAgePageFtraceEvent::operator=(KvmAgePageFtraceEvent&&) = default;

bool KvmAgePageFtraceEvent::operator==(const KvmAgePageFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(gfn_, other.gfn_)
   && ::protozero::internal::gen_helpers::EqualsField(hva_, other.hva_)
   && ::protozero::internal::gen_helpers::EqualsField(level_, other.level_)
   && ::protozero::internal::gen_helpers::EqualsField(referenced_, other.referenced_);
}

bool KvmAgePageFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* gfn */:
        field.get(&gfn_);
        break;
      case 2 /* hva */:
        field.get(&hva_);
        break;
      case 3 /* level */:
        field.get(&level_);
        break;
      case 4 /* referenced */:
        field.get(&referenced_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KvmAgePageFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KvmAgePageFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KvmAgePageFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: gfn
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, gfn_, msg);
  }

  // Field 2: hva
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, hva_, msg);
  }

  // Field 3: level
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, level_, msg);
  }

  // Field 4: referenced
  if (_has_field_[4]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(4, referenced_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


KvmAgeHvaFtraceEvent::KvmAgeHvaFtraceEvent() = default;
KvmAgeHvaFtraceEvent::~KvmAgeHvaFtraceEvent() = default;
KvmAgeHvaFtraceEvent::KvmAgeHvaFtraceEvent(const KvmAgeHvaFtraceEvent&) = default;
KvmAgeHvaFtraceEvent& KvmAgeHvaFtraceEvent::operator=(const KvmAgeHvaFtraceEvent&) = default;
KvmAgeHvaFtraceEvent::KvmAgeHvaFtraceEvent(KvmAgeHvaFtraceEvent&&) noexcept = default;
KvmAgeHvaFtraceEvent& KvmAgeHvaFtraceEvent::operator=(KvmAgeHvaFtraceEvent&&) = default;

bool KvmAgeHvaFtraceEvent::operator==(const KvmAgeHvaFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(end_, other.end_)
   && ::protozero::internal::gen_helpers::EqualsField(start_, other.start_);
}

bool KvmAgeHvaFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* end */:
        field.get(&end_);
        break;
      case 2 /* start */:
        field.get(&start_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KvmAgeHvaFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KvmAgeHvaFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KvmAgeHvaFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: end
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, end_, msg);
  }

  // Field 2: start
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, start_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


KvmAckIrqFtraceEvent::KvmAckIrqFtraceEvent() = default;
KvmAckIrqFtraceEvent::~KvmAckIrqFtraceEvent() = default;
KvmAckIrqFtraceEvent::KvmAckIrqFtraceEvent(const KvmAckIrqFtraceEvent&) = default;
KvmAckIrqFtraceEvent& KvmAckIrqFtraceEvent::operator=(const KvmAckIrqFtraceEvent&) = default;
KvmAckIrqFtraceEvent::KvmAckIrqFtraceEvent(KvmAckIrqFtraceEvent&&) noexcept = default;
KvmAckIrqFtraceEvent& KvmAckIrqFtraceEvent::operator=(KvmAckIrqFtraceEvent&&) = default;

bool KvmAckIrqFtraceEvent::operator==(const KvmAckIrqFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(irqchip_, other.irqchip_)
   && ::protozero::internal::gen_helpers::EqualsField(pin_, other.pin_);
}

bool KvmAckIrqFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* irqchip */:
        field.get(&irqchip_);
        break;
      case 2 /* pin */:
        field.get(&pin_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KvmAckIrqFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KvmAckIrqFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KvmAckIrqFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: irqchip
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, irqchip_, msg);
  }

  // Field 2: pin
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, pin_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


KvmAccessFaultFtraceEvent::KvmAccessFaultFtraceEvent() = default;
KvmAccessFaultFtraceEvent::~KvmAccessFaultFtraceEvent() = default;
KvmAccessFaultFtraceEvent::KvmAccessFaultFtraceEvent(const KvmAccessFaultFtraceEvent&) = default;
KvmAccessFaultFtraceEvent& KvmAccessFaultFtraceEvent::operator=(const KvmAccessFaultFtraceEvent&) = default;
KvmAccessFaultFtraceEvent::KvmAccessFaultFtraceEvent(KvmAccessFaultFtraceEvent&&) noexcept = default;
KvmAccessFaultFtraceEvent& KvmAccessFaultFtraceEvent::operator=(KvmAccessFaultFtraceEvent&&) = default;

bool KvmAccessFaultFtraceEvent::operator==(const KvmAccessFaultFtraceEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(ipa_, other.ipa_);
}

bool KvmAccessFaultFtraceEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* ipa */:
        field.get(&ipa_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string KvmAccessFaultFtraceEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> KvmAccessFaultFtraceEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void KvmAccessFaultFtraceEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: ipa
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, ipa_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}

}  // namespace perfetto
}  // namespace protos
}  // namespace gen
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif
