// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PROCESSOR_SERIALIZATION_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PROCESSOR_SERIALIZATION_PROTO_H_

#include <stddef.h>
#include <stdint.h>

#include "perfetto/protozero/field_writer.h"
#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {
class SerializedColumn;
class SerializedColumn_BitVector;
class SerializedColumn_Storage;
class SerializedColumn_Storage_ArrangementOverlay;
class SerializedColumn_Storage_DenseNullOverlay;
class SerializedColumn_Storage_DummyStorage;
class SerializedColumn_Storage_IdStorage;
class SerializedColumn_Storage_NullOverlay;
class SerializedColumn_Storage_NumericStorage;
class SerializedColumn_Storage_SelectorOverlay;
class SerializedColumn_Storage_SetIdStorage;
class SerializedColumn_Storage_StringStorage;
class SerializedTraceProcessorPacket;
} // Namespace pbzero.
} // Namespace protos.
} // Namespace perfetto.

namespace perfetto {
namespace protos {
namespace pbzero {

class SerializedColumn_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SerializedColumn_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SerializedColumn_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SerializedColumn_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_table_name() const { return at<1>().valid(); }
  ::protozero::ConstChars table_name() const { return at<1>().as_string(); }
  bool has_column_name() const { return at<2>().valid(); }
  ::protozero::ConstChars column_name() const { return at<2>().as_string(); }
  bool has_storage() const { return at<3>().valid(); }
  ::protozero::ConstBytes storage() const { return at<3>().as_bytes(); }
};

class SerializedColumn : public ::protozero::Message {
 public:
  using Decoder = SerializedColumn_Decoder;
  enum : int32_t {
    kTableNameFieldNumber = 1,
    kColumnNameFieldNumber = 2,
    kStorageFieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.SerializedColumn"; }

  using BitVector = ::perfetto::protos::pbzero::SerializedColumn_BitVector;
  using Storage = ::perfetto::protos::pbzero::SerializedColumn_Storage;

  using FieldMetadata_TableName =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      SerializedColumn>;

  static constexpr FieldMetadata_TableName kTableName{};
  void set_table_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_TableName::kFieldId, data, size);
  }
  void set_table_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_TableName::kFieldId, chars.data, chars.size);
  }
  void set_table_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_TableName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ColumnName =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      SerializedColumn>;

  static constexpr FieldMetadata_ColumnName kColumnName{};
  void set_column_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_ColumnName::kFieldId, data, size);
  }
  void set_column_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_ColumnName::kFieldId, chars.data, chars.size);
  }
  void set_column_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_ColumnName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Storage =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SerializedColumn_Storage,
      SerializedColumn>;

  static constexpr FieldMetadata_Storage kStorage{};
  template <typename T = SerializedColumn_Storage> T* set_storage() {
    return BeginNestedMessage<T>(3);
  }

};

class SerializedColumn_Storage_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/9, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SerializedColumn_Storage_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SerializedColumn_Storage_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SerializedColumn_Storage_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dummy_storage() const { return at<1>().valid(); }
  ::protozero::ConstBytes dummy_storage() const { return at<1>().as_bytes(); }
  bool has_id_storage() const { return at<2>().valid(); }
  ::protozero::ConstBytes id_storage() const { return at<2>().as_bytes(); }
  bool has_numeric_storage() const { return at<3>().valid(); }
  ::protozero::ConstBytes numeric_storage() const { return at<3>().as_bytes(); }
  bool has_set_id_storage() const { return at<4>().valid(); }
  ::protozero::ConstBytes set_id_storage() const { return at<4>().as_bytes(); }
  bool has_string_storage() const { return at<5>().valid(); }
  ::protozero::ConstBytes string_storage() const { return at<5>().as_bytes(); }
  bool has_null_overlay() const { return at<6>().valid(); }
  ::protozero::ConstBytes null_overlay() const { return at<6>().as_bytes(); }
  bool has_arrangement_overlay() const { return at<7>().valid(); }
  ::protozero::ConstBytes arrangement_overlay() const { return at<7>().as_bytes(); }
  bool has_selector_overlay() const { return at<8>().valid(); }
  ::protozero::ConstBytes selector_overlay() const { return at<8>().as_bytes(); }
  bool has_dense_null_overlay() const { return at<9>().valid(); }
  ::protozero::ConstBytes dense_null_overlay() const { return at<9>().as_bytes(); }
};

class SerializedColumn_Storage : public ::protozero::Message {
 public:
  using Decoder = SerializedColumn_Storage_Decoder;
  enum : int32_t {
    kDummyStorageFieldNumber = 1,
    kIdStorageFieldNumber = 2,
    kNumericStorageFieldNumber = 3,
    kSetIdStorageFieldNumber = 4,
    kStringStorageFieldNumber = 5,
    kNullOverlayFieldNumber = 6,
    kArrangementOverlayFieldNumber = 7,
    kSelectorOverlayFieldNumber = 8,
    kDenseNullOverlayFieldNumber = 9,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.SerializedColumn.Storage"; }

  using DummyStorage = ::perfetto::protos::pbzero::SerializedColumn_Storage_DummyStorage;
  using IdStorage = ::perfetto::protos::pbzero::SerializedColumn_Storage_IdStorage;
  using NumericStorage = ::perfetto::protos::pbzero::SerializedColumn_Storage_NumericStorage;
  using SetIdStorage = ::perfetto::protos::pbzero::SerializedColumn_Storage_SetIdStorage;
  using StringStorage = ::perfetto::protos::pbzero::SerializedColumn_Storage_StringStorage;
  using NullOverlay = ::perfetto::protos::pbzero::SerializedColumn_Storage_NullOverlay;
  using ArrangementOverlay = ::perfetto::protos::pbzero::SerializedColumn_Storage_ArrangementOverlay;
  using SelectorOverlay = ::perfetto::protos::pbzero::SerializedColumn_Storage_SelectorOverlay;
  using DenseNullOverlay = ::perfetto::protos::pbzero::SerializedColumn_Storage_DenseNullOverlay;

  using FieldMetadata_DummyStorage =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SerializedColumn_Storage_DummyStorage,
      SerializedColumn_Storage>;

  static constexpr FieldMetadata_DummyStorage kDummyStorage{};
  template <typename T = SerializedColumn_Storage_DummyStorage> T* set_dummy_storage() {
    return BeginNestedMessage<T>(1);
  }


  using FieldMetadata_IdStorage =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SerializedColumn_Storage_IdStorage,
      SerializedColumn_Storage>;

  static constexpr FieldMetadata_IdStorage kIdStorage{};
  template <typename T = SerializedColumn_Storage_IdStorage> T* set_id_storage() {
    return BeginNestedMessage<T>(2);
  }


  using FieldMetadata_NumericStorage =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SerializedColumn_Storage_NumericStorage,
      SerializedColumn_Storage>;

  static constexpr FieldMetadata_NumericStorage kNumericStorage{};
  template <typename T = SerializedColumn_Storage_NumericStorage> T* set_numeric_storage() {
    return BeginNestedMessage<T>(3);
  }


  using FieldMetadata_SetIdStorage =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SerializedColumn_Storage_SetIdStorage,
      SerializedColumn_Storage>;

  static constexpr FieldMetadata_SetIdStorage kSetIdStorage{};
  template <typename T = SerializedColumn_Storage_SetIdStorage> T* set_set_id_storage() {
    return BeginNestedMessage<T>(4);
  }


  using FieldMetadata_StringStorage =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SerializedColumn_Storage_StringStorage,
      SerializedColumn_Storage>;

  static constexpr FieldMetadata_StringStorage kStringStorage{};
  template <typename T = SerializedColumn_Storage_StringStorage> T* set_string_storage() {
    return BeginNestedMessage<T>(5);
  }


  using FieldMetadata_NullOverlay =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SerializedColumn_Storage_NullOverlay,
      SerializedColumn_Storage>;

  static constexpr FieldMetadata_NullOverlay kNullOverlay{};
  template <typename T = SerializedColumn_Storage_NullOverlay> T* set_null_overlay() {
    return BeginNestedMessage<T>(6);
  }


  using FieldMetadata_ArrangementOverlay =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SerializedColumn_Storage_ArrangementOverlay,
      SerializedColumn_Storage>;

  static constexpr FieldMetadata_ArrangementOverlay kArrangementOverlay{};
  template <typename T = SerializedColumn_Storage_ArrangementOverlay> T* set_arrangement_overlay() {
    return BeginNestedMessage<T>(7);
  }


  using FieldMetadata_SelectorOverlay =
    ::protozero::proto_utils::FieldMetadata<
      8,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SerializedColumn_Storage_SelectorOverlay,
      SerializedColumn_Storage>;

  static constexpr FieldMetadata_SelectorOverlay kSelectorOverlay{};
  template <typename T = SerializedColumn_Storage_SelectorOverlay> T* set_selector_overlay() {
    return BeginNestedMessage<T>(8);
  }


  using FieldMetadata_DenseNullOverlay =
    ::protozero::proto_utils::FieldMetadata<
      9,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SerializedColumn_Storage_DenseNullOverlay,
      SerializedColumn_Storage>;

  static constexpr FieldMetadata_DenseNullOverlay kDenseNullOverlay{};
  template <typename T = SerializedColumn_Storage_DenseNullOverlay> T* set_dense_null_overlay() {
    return BeginNestedMessage<T>(9);
  }

};

class SerializedColumn_Storage_DenseNullOverlay_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SerializedColumn_Storage_DenseNullOverlay_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SerializedColumn_Storage_DenseNullOverlay_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SerializedColumn_Storage_DenseNullOverlay_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_bit_vector() const { return at<1>().valid(); }
  ::protozero::ConstBytes bit_vector() const { return at<1>().as_bytes(); }
  bool has_storage() const { return at<2>().valid(); }
  ::protozero::ConstBytes storage() const { return at<2>().as_bytes(); }
};

class SerializedColumn_Storage_DenseNullOverlay : public ::protozero::Message {
 public:
  using Decoder = SerializedColumn_Storage_DenseNullOverlay_Decoder;
  enum : int32_t {
    kBitVectorFieldNumber = 1,
    kStorageFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.SerializedColumn.Storage.DenseNullOverlay"; }


  using FieldMetadata_BitVector =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SerializedColumn_BitVector,
      SerializedColumn_Storage_DenseNullOverlay>;

  static constexpr FieldMetadata_BitVector kBitVector{};
  template <typename T = SerializedColumn_BitVector> T* set_bit_vector() {
    return BeginNestedMessage<T>(1);
  }


  using FieldMetadata_Storage =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SerializedColumn_Storage,
      SerializedColumn_Storage_DenseNullOverlay>;

  static constexpr FieldMetadata_Storage kStorage{};
  template <typename T = SerializedColumn_Storage> T* set_storage() {
    return BeginNestedMessage<T>(2);
  }

};

class SerializedColumn_Storage_SelectorOverlay_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SerializedColumn_Storage_SelectorOverlay_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SerializedColumn_Storage_SelectorOverlay_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SerializedColumn_Storage_SelectorOverlay_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_bit_vector() const { return at<1>().valid(); }
  ::protozero::ConstBytes bit_vector() const { return at<1>().as_bytes(); }
  bool has_storage() const { return at<2>().valid(); }
  ::protozero::ConstBytes storage() const { return at<2>().as_bytes(); }
};

class SerializedColumn_Storage_SelectorOverlay : public ::protozero::Message {
 public:
  using Decoder = SerializedColumn_Storage_SelectorOverlay_Decoder;
  enum : int32_t {
    kBitVectorFieldNumber = 1,
    kStorageFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.SerializedColumn.Storage.SelectorOverlay"; }


  using FieldMetadata_BitVector =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SerializedColumn_BitVector,
      SerializedColumn_Storage_SelectorOverlay>;

  static constexpr FieldMetadata_BitVector kBitVector{};
  template <typename T = SerializedColumn_BitVector> T* set_bit_vector() {
    return BeginNestedMessage<T>(1);
  }


  using FieldMetadata_Storage =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SerializedColumn_Storage,
      SerializedColumn_Storage_SelectorOverlay>;

  static constexpr FieldMetadata_Storage kStorage{};
  template <typename T = SerializedColumn_Storage> T* set_storage() {
    return BeginNestedMessage<T>(2);
  }

};

class SerializedColumn_Storage_ArrangementOverlay_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SerializedColumn_Storage_ArrangementOverlay_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SerializedColumn_Storage_ArrangementOverlay_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SerializedColumn_Storage_ArrangementOverlay_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_values() const { return at<1>().valid(); }
  ::protozero::ConstBytes values() const { return at<1>().as_bytes(); }
  bool has_storage() const { return at<2>().valid(); }
  ::protozero::ConstBytes storage() const { return at<2>().as_bytes(); }
};

class SerializedColumn_Storage_ArrangementOverlay : public ::protozero::Message {
 public:
  using Decoder = SerializedColumn_Storage_ArrangementOverlay_Decoder;
  enum : int32_t {
    kValuesFieldNumber = 1,
    kStorageFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.SerializedColumn.Storage.ArrangementOverlay"; }


  using FieldMetadata_Values =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBytes,
      std::string,
      SerializedColumn_Storage_ArrangementOverlay>;

  static constexpr FieldMetadata_Values kValues{};
  void set_values(const uint8_t* data, size_t size) {
    AppendBytes(FieldMetadata_Values::kFieldId, data, size);
  }
  void set_values(::protozero::ConstBytes bytes) {
    AppendBytes(FieldMetadata_Values::kFieldId, bytes.data, bytes.size);
  }
  void set_values(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Values::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBytes>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Storage =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SerializedColumn_Storage,
      SerializedColumn_Storage_ArrangementOverlay>;

  static constexpr FieldMetadata_Storage kStorage{};
  template <typename T = SerializedColumn_Storage> T* set_storage() {
    return BeginNestedMessage<T>(2);
  }

};

class SerializedColumn_Storage_NullOverlay_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SerializedColumn_Storage_NullOverlay_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SerializedColumn_Storage_NullOverlay_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SerializedColumn_Storage_NullOverlay_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_bit_vector() const { return at<1>().valid(); }
  ::protozero::ConstBytes bit_vector() const { return at<1>().as_bytes(); }
  bool has_storage() const { return at<2>().valid(); }
  ::protozero::ConstBytes storage() const { return at<2>().as_bytes(); }
};

class SerializedColumn_Storage_NullOverlay : public ::protozero::Message {
 public:
  using Decoder = SerializedColumn_Storage_NullOverlay_Decoder;
  enum : int32_t {
    kBitVectorFieldNumber = 1,
    kStorageFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.SerializedColumn.Storage.NullOverlay"; }


  using FieldMetadata_BitVector =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SerializedColumn_BitVector,
      SerializedColumn_Storage_NullOverlay>;

  static constexpr FieldMetadata_BitVector kBitVector{};
  template <typename T = SerializedColumn_BitVector> T* set_bit_vector() {
    return BeginNestedMessage<T>(1);
  }


  using FieldMetadata_Storage =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SerializedColumn_Storage,
      SerializedColumn_Storage_NullOverlay>;

  static constexpr FieldMetadata_Storage kStorage{};
  template <typename T = SerializedColumn_Storage> T* set_storage() {
    return BeginNestedMessage<T>(2);
  }

};

class SerializedColumn_Storage_StringStorage_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SerializedColumn_Storage_StringStorage_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SerializedColumn_Storage_StringStorage_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SerializedColumn_Storage_StringStorage_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_values() const { return at<1>().valid(); }
  ::protozero::ConstBytes values() const { return at<1>().as_bytes(); }
  bool has_is_sorted() const { return at<2>().valid(); }
  bool is_sorted() const { return at<2>().as_bool(); }
};

class SerializedColumn_Storage_StringStorage : public ::protozero::Message {
 public:
  using Decoder = SerializedColumn_Storage_StringStorage_Decoder;
  enum : int32_t {
    kValuesFieldNumber = 1,
    kIsSortedFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.SerializedColumn.Storage.StringStorage"; }


  using FieldMetadata_Values =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBytes,
      std::string,
      SerializedColumn_Storage_StringStorage>;

  static constexpr FieldMetadata_Values kValues{};
  void set_values(const uint8_t* data, size_t size) {
    AppendBytes(FieldMetadata_Values::kFieldId, data, size);
  }
  void set_values(::protozero::ConstBytes bytes) {
    AppendBytes(FieldMetadata_Values::kFieldId, bytes.data, bytes.size);
  }
  void set_values(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Values::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBytes>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IsSorted =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      SerializedColumn_Storage_StringStorage>;

  static constexpr FieldMetadata_IsSorted kIsSorted{};
  void set_is_sorted(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsSorted::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }
};

class SerializedColumn_Storage_SetIdStorage_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SerializedColumn_Storage_SetIdStorage_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SerializedColumn_Storage_SetIdStorage_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SerializedColumn_Storage_SetIdStorage_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_values() const { return at<1>().valid(); }
  ::protozero::ConstBytes values() const { return at<1>().as_bytes(); }
};

class SerializedColumn_Storage_SetIdStorage : public ::protozero::Message {
 public:
  using Decoder = SerializedColumn_Storage_SetIdStorage_Decoder;
  enum : int32_t {
    kValuesFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.SerializedColumn.Storage.SetIdStorage"; }


  using FieldMetadata_Values =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBytes,
      std::string,
      SerializedColumn_Storage_SetIdStorage>;

  static constexpr FieldMetadata_Values kValues{};
  void set_values(const uint8_t* data, size_t size) {
    AppendBytes(FieldMetadata_Values::kFieldId, data, size);
  }
  void set_values(::protozero::ConstBytes bytes) {
    AppendBytes(FieldMetadata_Values::kFieldId, bytes.data, bytes.size);
  }
  void set_values(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Values::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBytes>
        ::Append(*this, field_id, value);
  }
};

class SerializedColumn_Storage_NumericStorage_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SerializedColumn_Storage_NumericStorage_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SerializedColumn_Storage_NumericStorage_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SerializedColumn_Storage_NumericStorage_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_values() const { return at<1>().valid(); }
  ::protozero::ConstBytes values() const { return at<1>().as_bytes(); }
  bool has_is_sorted() const { return at<2>().valid(); }
  bool is_sorted() const { return at<2>().as_bool(); }
  bool has_column_type() const { return at<3>().valid(); }
  uint32_t column_type() const { return at<3>().as_uint32(); }
};

class SerializedColumn_Storage_NumericStorage : public ::protozero::Message {
 public:
  using Decoder = SerializedColumn_Storage_NumericStorage_Decoder;
  enum : int32_t {
    kValuesFieldNumber = 1,
    kIsSortedFieldNumber = 2,
    kColumnTypeFieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.SerializedColumn.Storage.NumericStorage"; }


  using FieldMetadata_Values =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBytes,
      std::string,
      SerializedColumn_Storage_NumericStorage>;

  static constexpr FieldMetadata_Values kValues{};
  void set_values(const uint8_t* data, size_t size) {
    AppendBytes(FieldMetadata_Values::kFieldId, data, size);
  }
  void set_values(::protozero::ConstBytes bytes) {
    AppendBytes(FieldMetadata_Values::kFieldId, bytes.data, bytes.size);
  }
  void set_values(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Values::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBytes>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IsSorted =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      SerializedColumn_Storage_NumericStorage>;

  static constexpr FieldMetadata_IsSorted kIsSorted{};
  void set_is_sorted(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsSorted::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ColumnType =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      SerializedColumn_Storage_NumericStorage>;

  static constexpr FieldMetadata_ColumnType kColumnType{};
  void set_column_type(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ColumnType::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }
};

class SerializedColumn_Storage_IdStorage_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SerializedColumn_Storage_IdStorage_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SerializedColumn_Storage_IdStorage_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SerializedColumn_Storage_IdStorage_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_size() const { return at<1>().valid(); }
  uint64_t size() const { return at<1>().as_uint64(); }
};

class SerializedColumn_Storage_IdStorage : public ::protozero::Message {
 public:
  using Decoder = SerializedColumn_Storage_IdStorage_Decoder;
  enum : int32_t {
    kSizeFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.SerializedColumn.Storage.IdStorage"; }


  using FieldMetadata_Size =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      SerializedColumn_Storage_IdStorage>;

  static constexpr FieldMetadata_Size kSize{};
  void set_size(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Size::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }
};

class SerializedColumn_Storage_DummyStorage_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/0, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SerializedColumn_Storage_DummyStorage_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SerializedColumn_Storage_DummyStorage_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SerializedColumn_Storage_DummyStorage_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
};

class SerializedColumn_Storage_DummyStorage : public ::protozero::Message {
 public:
  using Decoder = SerializedColumn_Storage_DummyStorage_Decoder;
  static constexpr const char* GetName() { return ".perfetto.protos.SerializedColumn.Storage.DummyStorage"; }

};

class SerializedColumn_BitVector_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SerializedColumn_BitVector_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SerializedColumn_BitVector_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SerializedColumn_BitVector_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_words() const { return at<1>().valid(); }
  ::protozero::ConstBytes words() const { return at<1>().as_bytes(); }
  bool has_counts() const { return at<2>().valid(); }
  ::protozero::ConstBytes counts() const { return at<2>().as_bytes(); }
  bool has_size() const { return at<3>().valid(); }
  uint32_t size() const { return at<3>().as_uint32(); }
};

class SerializedColumn_BitVector : public ::protozero::Message {
 public:
  using Decoder = SerializedColumn_BitVector_Decoder;
  enum : int32_t {
    kWordsFieldNumber = 1,
    kCountsFieldNumber = 2,
    kSizeFieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.SerializedColumn.BitVector"; }


  using FieldMetadata_Words =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBytes,
      std::string,
      SerializedColumn_BitVector>;

  static constexpr FieldMetadata_Words kWords{};
  void set_words(const uint8_t* data, size_t size) {
    AppendBytes(FieldMetadata_Words::kFieldId, data, size);
  }
  void set_words(::protozero::ConstBytes bytes) {
    AppendBytes(FieldMetadata_Words::kFieldId, bytes.data, bytes.size);
  }
  void set_words(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Words::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBytes>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Counts =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBytes,
      std::string,
      SerializedColumn_BitVector>;

  static constexpr FieldMetadata_Counts kCounts{};
  void set_counts(const uint8_t* data, size_t size) {
    AppendBytes(FieldMetadata_Counts::kFieldId, data, size);
  }
  void set_counts(::protozero::ConstBytes bytes) {
    AppendBytes(FieldMetadata_Counts::kFieldId, bytes.data, bytes.size);
  }
  void set_counts(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Counts::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBytes>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Size =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      SerializedColumn_BitVector>;

  static constexpr FieldMetadata_Size kSize{};
  void set_size(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Size::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }
};

class SerializedTraceProcessorPacket_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SerializedTraceProcessorPacket_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SerializedTraceProcessorPacket_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SerializedTraceProcessorPacket_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_column() const { return at<1>().valid(); }
  ::protozero::ConstBytes column() const { return at<1>().as_bytes(); }
};

class SerializedTraceProcessorPacket : public ::protozero::Message {
 public:
  using Decoder = SerializedTraceProcessorPacket_Decoder;
  enum : int32_t {
    kColumnFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.SerializedTraceProcessorPacket"; }


  using FieldMetadata_Column =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SerializedColumn,
      SerializedTraceProcessorPacket>;

  static constexpr FieldMetadata_Column kColumn{};
  template <typename T = SerializedColumn> T* set_column() {
    return BeginNestedMessage<T>(1);
  }

};

class SerializedTraceProcessor_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  SerializedTraceProcessor_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SerializedTraceProcessor_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SerializedTraceProcessor_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_packet() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> packet() const { return GetRepeated<::protozero::ConstBytes>(1); }
};

class SerializedTraceProcessor : public ::protozero::Message {
 public:
  using Decoder = SerializedTraceProcessor_Decoder;
  enum : int32_t {
    kPacketFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.SerializedTraceProcessor"; }


  using FieldMetadata_Packet =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SerializedTraceProcessorPacket,
      SerializedTraceProcessor>;

  static constexpr FieldMetadata_Packet kPacket{};
  template <typename T = SerializedTraceProcessorPacket> T* add_packet() {
    return BeginNestedMessage<T>(1);
  }

};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
