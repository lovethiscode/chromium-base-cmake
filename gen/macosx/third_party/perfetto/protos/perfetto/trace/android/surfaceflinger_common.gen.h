// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ANDROID_SURFACEFLINGER_COMMON_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ANDROID_SURFACEFLINGER_COMMON_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class ColorTransformProto;
class BlurRegion;
class InputWindowInfoProto;
class TransformProto;
class RectProto;
class RegionProto;
class ColorProto;
class SizeProto;
enum TrustedOverlay : int;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {
enum TrustedOverlay : int {
  UNSET = 0,
  DISABLED = 1,
  ENABLED = 2,
};

class PERFETTO_EXPORT_COMPONENT ColorTransformProto : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kValFieldNumber = 1,
  };

  ColorTransformProto();
  ~ColorTransformProto() override;
  ColorTransformProto(ColorTransformProto&&) noexcept;
  ColorTransformProto& operator=(ColorTransformProto&&);
  ColorTransformProto(const ColorTransformProto&);
  ColorTransformProto& operator=(const ColorTransformProto&);
  bool operator==(const ColorTransformProto&) const;
  bool operator!=(const ColorTransformProto& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  const std::vector<float>& val() const { return val_; }
  std::vector<float>* mutable_val() { return &val_; }
  int val_size() const { return static_cast<int>(val_.size()); }
  void clear_val() { val_.clear(); }
  void add_val(float value) { val_.emplace_back(value); }
  float* add_val() { val_.emplace_back(); return &val_.back(); }

 private:
  std::vector<float> val_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT BlurRegion : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kBlurRadiusFieldNumber = 1,
    kCornerRadiusTlFieldNumber = 2,
    kCornerRadiusTrFieldNumber = 3,
    kCornerRadiusBlFieldNumber = 4,
    kCornerRadiusBrFieldNumber = 5,
    kAlphaFieldNumber = 6,
    kLeftFieldNumber = 7,
    kTopFieldNumber = 8,
    kRightFieldNumber = 9,
    kBottomFieldNumber = 10,
  };

  BlurRegion();
  ~BlurRegion() override;
  BlurRegion(BlurRegion&&) noexcept;
  BlurRegion& operator=(BlurRegion&&);
  BlurRegion(const BlurRegion&);
  BlurRegion& operator=(const BlurRegion&);
  bool operator==(const BlurRegion&) const;
  bool operator!=(const BlurRegion& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_blur_radius() const { return _has_field_[1]; }
  uint32_t blur_radius() const { return blur_radius_; }
  void set_blur_radius(uint32_t value) { blur_radius_ = value; _has_field_.set(1); }

  bool has_corner_radius_tl() const { return _has_field_[2]; }
  uint32_t corner_radius_tl() const { return corner_radius_tl_; }
  void set_corner_radius_tl(uint32_t value) { corner_radius_tl_ = value; _has_field_.set(2); }

  bool has_corner_radius_tr() const { return _has_field_[3]; }
  uint32_t corner_radius_tr() const { return corner_radius_tr_; }
  void set_corner_radius_tr(uint32_t value) { corner_radius_tr_ = value; _has_field_.set(3); }

  bool has_corner_radius_bl() const { return _has_field_[4]; }
  uint32_t corner_radius_bl() const { return corner_radius_bl_; }
  void set_corner_radius_bl(uint32_t value) { corner_radius_bl_ = value; _has_field_.set(4); }

  bool has_corner_radius_br() const { return _has_field_[5]; }
  float corner_radius_br() const { return corner_radius_br_; }
  void set_corner_radius_br(float value) { corner_radius_br_ = value; _has_field_.set(5); }

  bool has_alpha() const { return _has_field_[6]; }
  float alpha() const { return alpha_; }
  void set_alpha(float value) { alpha_ = value; _has_field_.set(6); }

  bool has_left() const { return _has_field_[7]; }
  int32_t left() const { return left_; }
  void set_left(int32_t value) { left_ = value; _has_field_.set(7); }

  bool has_top() const { return _has_field_[8]; }
  int32_t top() const { return top_; }
  void set_top(int32_t value) { top_ = value; _has_field_.set(8); }

  bool has_right() const { return _has_field_[9]; }
  int32_t right() const { return right_; }
  void set_right(int32_t value) { right_ = value; _has_field_.set(9); }

  bool has_bottom() const { return _has_field_[10]; }
  int32_t bottom() const { return bottom_; }
  void set_bottom(int32_t value) { bottom_ = value; _has_field_.set(10); }

 private:
  uint32_t blur_radius_{};
  uint32_t corner_radius_tl_{};
  uint32_t corner_radius_tr_{};
  uint32_t corner_radius_bl_{};
  float corner_radius_br_{};
  float alpha_{};
  int32_t left_{};
  int32_t top_{};
  int32_t right_{};
  int32_t bottom_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<11> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT InputWindowInfoProto : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kLayoutParamsFlagsFieldNumber = 1,
    kLayoutParamsTypeFieldNumber = 2,
    kFrameFieldNumber = 3,
    kTouchableRegionFieldNumber = 4,
    kSurfaceInsetFieldNumber = 5,
    kVisibleFieldNumber = 6,
    kCanReceiveKeysFieldNumber = 7,
    kFocusableFieldNumber = 8,
    kHasWallpaperFieldNumber = 9,
    kGlobalScaleFactorFieldNumber = 10,
    kWindowXScaleFieldNumber = 11,
    kWindowYScaleFieldNumber = 12,
    kCropLayerIdFieldNumber = 13,
    kReplaceTouchableRegionWithCropFieldNumber = 14,
    kTouchableRegionCropFieldNumber = 15,
    kTransformFieldNumber = 16,
    kInputConfigFieldNumber = 17,
  };

  InputWindowInfoProto();
  ~InputWindowInfoProto() override;
  InputWindowInfoProto(InputWindowInfoProto&&) noexcept;
  InputWindowInfoProto& operator=(InputWindowInfoProto&&);
  InputWindowInfoProto(const InputWindowInfoProto&);
  InputWindowInfoProto& operator=(const InputWindowInfoProto&);
  bool operator==(const InputWindowInfoProto&) const;
  bool operator!=(const InputWindowInfoProto& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_layout_params_flags() const { return _has_field_[1]; }
  uint32_t layout_params_flags() const { return layout_params_flags_; }
  void set_layout_params_flags(uint32_t value) { layout_params_flags_ = value; _has_field_.set(1); }

  bool has_layout_params_type() const { return _has_field_[2]; }
  int32_t layout_params_type() const { return layout_params_type_; }
  void set_layout_params_type(int32_t value) { layout_params_type_ = value; _has_field_.set(2); }

  bool has_frame() const { return _has_field_[3]; }
  const RectProto& frame() const { return *frame_; }
  RectProto* mutable_frame() { _has_field_.set(3); return frame_.get(); }

  bool has_touchable_region() const { return _has_field_[4]; }
  const RegionProto& touchable_region() const { return *touchable_region_; }
  RegionProto* mutable_touchable_region() { _has_field_.set(4); return touchable_region_.get(); }

  bool has_surface_inset() const { return _has_field_[5]; }
  int32_t surface_inset() const { return surface_inset_; }
  void set_surface_inset(int32_t value) { surface_inset_ = value; _has_field_.set(5); }

  bool has_visible() const { return _has_field_[6]; }
  bool visible() const { return visible_; }
  void set_visible(bool value) { visible_ = value; _has_field_.set(6); }

  bool has_can_receive_keys() const { return _has_field_[7]; }
  bool can_receive_keys() const { return can_receive_keys_; }
  void set_can_receive_keys(bool value) { can_receive_keys_ = value; _has_field_.set(7); }

  bool has_focusable() const { return _has_field_[8]; }
  bool focusable() const { return focusable_; }
  void set_focusable(bool value) { focusable_ = value; _has_field_.set(8); }

  bool has_has_wallpaper() const { return _has_field_[9]; }
  bool has_wallpaper() const { return has_wallpaper_; }
  void set_has_wallpaper(bool value) { has_wallpaper_ = value; _has_field_.set(9); }

  bool has_global_scale_factor() const { return _has_field_[10]; }
  float global_scale_factor() const { return global_scale_factor_; }
  void set_global_scale_factor(float value) { global_scale_factor_ = value; _has_field_.set(10); }

  bool has_window_x_scale() const { return _has_field_[11]; }
  float window_x_scale() const { return window_x_scale_; }
  void set_window_x_scale(float value) { window_x_scale_ = value; _has_field_.set(11); }

  bool has_window_y_scale() const { return _has_field_[12]; }
  float window_y_scale() const { return window_y_scale_; }
  void set_window_y_scale(float value) { window_y_scale_ = value; _has_field_.set(12); }

  bool has_crop_layer_id() const { return _has_field_[13]; }
  int32_t crop_layer_id() const { return crop_layer_id_; }
  void set_crop_layer_id(int32_t value) { crop_layer_id_ = value; _has_field_.set(13); }

  bool has_replace_touchable_region_with_crop() const { return _has_field_[14]; }
  bool replace_touchable_region_with_crop() const { return replace_touchable_region_with_crop_; }
  void set_replace_touchable_region_with_crop(bool value) { replace_touchable_region_with_crop_ = value; _has_field_.set(14); }

  bool has_touchable_region_crop() const { return _has_field_[15]; }
  const RectProto& touchable_region_crop() const { return *touchable_region_crop_; }
  RectProto* mutable_touchable_region_crop() { _has_field_.set(15); return touchable_region_crop_.get(); }

  bool has_transform() const { return _has_field_[16]; }
  const TransformProto& transform() const { return *transform_; }
  TransformProto* mutable_transform() { _has_field_.set(16); return transform_.get(); }

  bool has_input_config() const { return _has_field_[17]; }
  uint32_t input_config() const { return input_config_; }
  void set_input_config(uint32_t value) { input_config_ = value; _has_field_.set(17); }

 private:
  uint32_t layout_params_flags_{};
  int32_t layout_params_type_{};
  ::protozero::CopyablePtr<RectProto> frame_;
  ::protozero::CopyablePtr<RegionProto> touchable_region_;
  int32_t surface_inset_{};
  bool visible_{};
  bool can_receive_keys_{};
  bool focusable_{};
  bool has_wallpaper_{};
  float global_scale_factor_{};
  float window_x_scale_{};
  float window_y_scale_{};
  int32_t crop_layer_id_{};
  bool replace_touchable_region_with_crop_{};
  ::protozero::CopyablePtr<RectProto> touchable_region_crop_;
  ::protozero::CopyablePtr<TransformProto> transform_;
  uint32_t input_config_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<18> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT TransformProto : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDsdxFieldNumber = 1,
    kDtdxFieldNumber = 2,
    kDsdyFieldNumber = 3,
    kDtdyFieldNumber = 4,
    kTypeFieldNumber = 5,
  };

  TransformProto();
  ~TransformProto() override;
  TransformProto(TransformProto&&) noexcept;
  TransformProto& operator=(TransformProto&&);
  TransformProto(const TransformProto&);
  TransformProto& operator=(const TransformProto&);
  bool operator==(const TransformProto&) const;
  bool operator!=(const TransformProto& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dsdx() const { return _has_field_[1]; }
  float dsdx() const { return dsdx_; }
  void set_dsdx(float value) { dsdx_ = value; _has_field_.set(1); }

  bool has_dtdx() const { return _has_field_[2]; }
  float dtdx() const { return dtdx_; }
  void set_dtdx(float value) { dtdx_ = value; _has_field_.set(2); }

  bool has_dsdy() const { return _has_field_[3]; }
  float dsdy() const { return dsdy_; }
  void set_dsdy(float value) { dsdy_ = value; _has_field_.set(3); }

  bool has_dtdy() const { return _has_field_[4]; }
  float dtdy() const { return dtdy_; }
  void set_dtdy(float value) { dtdy_ = value; _has_field_.set(4); }

  bool has_type() const { return _has_field_[5]; }
  int32_t type() const { return type_; }
  void set_type(int32_t value) { type_ = value; _has_field_.set(5); }

 private:
  float dsdx_{};
  float dtdx_{};
  float dsdy_{};
  float dtdy_{};
  int32_t type_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT RegionProto : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kRectFieldNumber = 2,
  };

  RegionProto();
  ~RegionProto() override;
  RegionProto(RegionProto&&) noexcept;
  RegionProto& operator=(RegionProto&&);
  RegionProto(const RegionProto&);
  RegionProto& operator=(const RegionProto&);
  bool operator==(const RegionProto&) const;
  bool operator!=(const RegionProto& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  const std::vector<RectProto>& rect() const { return rect_; }
  std::vector<RectProto>* mutable_rect() { return &rect_; }
  int rect_size() const;
  void clear_rect();
  RectProto* add_rect();

 private:
  std::vector<RectProto> rect_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT ColorProto : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kRFieldNumber = 1,
    kGFieldNumber = 2,
    kBFieldNumber = 3,
    kAFieldNumber = 4,
  };

  ColorProto();
  ~ColorProto() override;
  ColorProto(ColorProto&&) noexcept;
  ColorProto& operator=(ColorProto&&);
  ColorProto(const ColorProto&);
  ColorProto& operator=(const ColorProto&);
  bool operator==(const ColorProto&) const;
  bool operator!=(const ColorProto& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_r() const { return _has_field_[1]; }
  float r() const { return r_; }
  void set_r(float value) { r_ = value; _has_field_.set(1); }

  bool has_g() const { return _has_field_[2]; }
  float g() const { return g_; }
  void set_g(float value) { g_ = value; _has_field_.set(2); }

  bool has_b() const { return _has_field_[3]; }
  float b() const { return b_; }
  void set_b(float value) { b_ = value; _has_field_.set(3); }

  bool has_a() const { return _has_field_[4]; }
  float a() const { return a_; }
  void set_a(float value) { a_ = value; _has_field_.set(4); }

 private:
  float r_{};
  float g_{};
  float b_{};
  float a_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT SizeProto : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kWFieldNumber = 1,
    kHFieldNumber = 2,
  };

  SizeProto();
  ~SizeProto() override;
  SizeProto(SizeProto&&) noexcept;
  SizeProto& operator=(SizeProto&&);
  SizeProto(const SizeProto&);
  SizeProto& operator=(const SizeProto&);
  bool operator==(const SizeProto&) const;
  bool operator!=(const SizeProto& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_w() const { return _has_field_[1]; }
  int32_t w() const { return w_; }
  void set_w(int32_t value) { w_ = value; _has_field_.set(1); }

  bool has_h() const { return _has_field_[2]; }
  int32_t h() const { return h_; }
  void set_h(int32_t value) { h_ = value; _has_field_.set(2); }

 private:
  int32_t w_{};
  int32_t h_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ANDROID_SURFACEFLINGER_COMMON_PROTO_CPP_H_
