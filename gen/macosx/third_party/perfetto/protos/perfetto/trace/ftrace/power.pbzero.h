// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_POWER_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_POWER_PROTO_H_

#include <stddef.h>
#include <stdint.h>

#include "perfetto/protozero/field_writer.h"
#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/proto_utils.h"


namespace perfetto {
namespace protos {
namespace pbzero {

class DevicePmCallbackEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  DevicePmCallbackEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DevicePmCallbackEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DevicePmCallbackEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_device() const { return at<1>().valid(); }
  ::protozero::ConstChars device() const { return at<1>().as_string(); }
  bool has_driver() const { return at<2>().valid(); }
  ::protozero::ConstChars driver() const { return at<2>().as_string(); }
  bool has_error() const { return at<3>().valid(); }
  int32_t error() const { return at<3>().as_int32(); }
};

class DevicePmCallbackEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = DevicePmCallbackEndFtraceEvent_Decoder;
  enum : int32_t {
    kDeviceFieldNumber = 1,
    kDriverFieldNumber = 2,
    kErrorFieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.DevicePmCallbackEndFtraceEvent"; }


  using FieldMetadata_Device =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      DevicePmCallbackEndFtraceEvent>;

  static constexpr FieldMetadata_Device kDevice{};
  void set_device(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Device::kFieldId, data, size);
  }
  void set_device(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Device::kFieldId, chars.data, chars.size);
  }
  void set_device(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Device::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Driver =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      DevicePmCallbackEndFtraceEvent>;

  static constexpr FieldMetadata_Driver kDriver{};
  void set_driver(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Driver::kFieldId, data, size);
  }
  void set_driver(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Driver::kFieldId, chars.data, chars.size);
  }
  void set_driver(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Driver::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Error =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      DevicePmCallbackEndFtraceEvent>;

  static constexpr FieldMetadata_Error kError{};
  void set_error(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Error::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

class DevicePmCallbackStartFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  DevicePmCallbackStartFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DevicePmCallbackStartFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DevicePmCallbackStartFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_device() const { return at<1>().valid(); }
  ::protozero::ConstChars device() const { return at<1>().as_string(); }
  bool has_driver() const { return at<2>().valid(); }
  ::protozero::ConstChars driver() const { return at<2>().as_string(); }
  bool has_parent() const { return at<3>().valid(); }
  ::protozero::ConstChars parent() const { return at<3>().as_string(); }
  bool has_pm_ops() const { return at<4>().valid(); }
  ::protozero::ConstChars pm_ops() const { return at<4>().as_string(); }
  bool has_event() const { return at<5>().valid(); }
  int32_t event() const { return at<5>().as_int32(); }
};

class DevicePmCallbackStartFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = DevicePmCallbackStartFtraceEvent_Decoder;
  enum : int32_t {
    kDeviceFieldNumber = 1,
    kDriverFieldNumber = 2,
    kParentFieldNumber = 3,
    kPmOpsFieldNumber = 4,
    kEventFieldNumber = 5,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.DevicePmCallbackStartFtraceEvent"; }


  using FieldMetadata_Device =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      DevicePmCallbackStartFtraceEvent>;

  static constexpr FieldMetadata_Device kDevice{};
  void set_device(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Device::kFieldId, data, size);
  }
  void set_device(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Device::kFieldId, chars.data, chars.size);
  }
  void set_device(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Device::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Driver =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      DevicePmCallbackStartFtraceEvent>;

  static constexpr FieldMetadata_Driver kDriver{};
  void set_driver(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Driver::kFieldId, data, size);
  }
  void set_driver(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Driver::kFieldId, chars.data, chars.size);
  }
  void set_driver(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Driver::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Parent =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      DevicePmCallbackStartFtraceEvent>;

  static constexpr FieldMetadata_Parent kParent{};
  void set_parent(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Parent::kFieldId, data, size);
  }
  void set_parent(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Parent::kFieldId, chars.data, chars.size);
  }
  void set_parent(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Parent::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_PmOps =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      DevicePmCallbackStartFtraceEvent>;

  static constexpr FieldMetadata_PmOps kPmOps{};
  void set_pm_ops(const char* data, size_t size) {
    AppendBytes(FieldMetadata_PmOps::kFieldId, data, size);
  }
  void set_pm_ops(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_PmOps::kFieldId, chars.data, chars.size);
  }
  void set_pm_ops(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_PmOps::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Event =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      DevicePmCallbackStartFtraceEvent>;

  static constexpr FieldMetadata_Event kEvent{};
  void set_event(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Event::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

class GpuWorkPeriodFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  GpuWorkPeriodFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GpuWorkPeriodFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GpuWorkPeriodFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_gpu_id() const { return at<1>().valid(); }
  uint32_t gpu_id() const { return at<1>().as_uint32(); }
  bool has_uid() const { return at<2>().valid(); }
  uint32_t uid() const { return at<2>().as_uint32(); }
  bool has_start_time_ns() const { return at<3>().valid(); }
  uint64_t start_time_ns() const { return at<3>().as_uint64(); }
  bool has_end_time_ns() const { return at<4>().valid(); }
  uint64_t end_time_ns() const { return at<4>().as_uint64(); }
  bool has_total_active_duration_ns() const { return at<5>().valid(); }
  uint64_t total_active_duration_ns() const { return at<5>().as_uint64(); }
};

class GpuWorkPeriodFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = GpuWorkPeriodFtraceEvent_Decoder;
  enum : int32_t {
    kGpuIdFieldNumber = 1,
    kUidFieldNumber = 2,
    kStartTimeNsFieldNumber = 3,
    kEndTimeNsFieldNumber = 4,
    kTotalActiveDurationNsFieldNumber = 5,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.GpuWorkPeriodFtraceEvent"; }


  using FieldMetadata_GpuId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      GpuWorkPeriodFtraceEvent>;

  static constexpr FieldMetadata_GpuId kGpuId{};
  void set_gpu_id(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_GpuId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Uid =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      GpuWorkPeriodFtraceEvent>;

  static constexpr FieldMetadata_Uid kUid{};
  void set_uid(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Uid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_StartTimeNs =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      GpuWorkPeriodFtraceEvent>;

  static constexpr FieldMetadata_StartTimeNs kStartTimeNs{};
  void set_start_time_ns(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_StartTimeNs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_EndTimeNs =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      GpuWorkPeriodFtraceEvent>;

  static constexpr FieldMetadata_EndTimeNs kEndTimeNs{};
  void set_end_time_ns(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_EndTimeNs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_TotalActiveDurationNs =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      GpuWorkPeriodFtraceEvent>;

  static constexpr FieldMetadata_TotalActiveDurationNs kTotalActiveDurationNs{};
  void set_total_active_duration_ns(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_TotalActiveDurationNs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }
};

class WakeupSourceDeactivateFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  WakeupSourceDeactivateFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit WakeupSourceDeactivateFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit WakeupSourceDeactivateFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_state() const { return at<2>().valid(); }
  uint64_t state() const { return at<2>().as_uint64(); }
};

class WakeupSourceDeactivateFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = WakeupSourceDeactivateFtraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.WakeupSourceDeactivateFtraceEvent"; }


  using FieldMetadata_Name =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      WakeupSourceDeactivateFtraceEvent>;

  static constexpr FieldMetadata_Name kName{};
  void set_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Name::kFieldId, data, size);
  }
  void set_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Name::kFieldId, chars.data, chars.size);
  }
  void set_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Name::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_State =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      WakeupSourceDeactivateFtraceEvent>;

  static constexpr FieldMetadata_State kState{};
  void set_state(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_State::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }
};

class WakeupSourceActivateFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  WakeupSourceActivateFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit WakeupSourceActivateFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit WakeupSourceActivateFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_state() const { return at<2>().valid(); }
  uint64_t state() const { return at<2>().as_uint64(); }
};

class WakeupSourceActivateFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = WakeupSourceActivateFtraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.WakeupSourceActivateFtraceEvent"; }


  using FieldMetadata_Name =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      WakeupSourceActivateFtraceEvent>;

  static constexpr FieldMetadata_Name kName{};
  void set_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Name::kFieldId, data, size);
  }
  void set_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Name::kFieldId, chars.data, chars.size);
  }
  void set_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Name::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_State =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      WakeupSourceActivateFtraceEvent>;

  static constexpr FieldMetadata_State kState{};
  void set_state(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_State::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }
};

class GpuFrequencyFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  GpuFrequencyFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GpuFrequencyFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GpuFrequencyFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_gpu_id() const { return at<1>().valid(); }
  uint32_t gpu_id() const { return at<1>().as_uint32(); }
  bool has_state() const { return at<2>().valid(); }
  uint32_t state() const { return at<2>().as_uint32(); }
};

class GpuFrequencyFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = GpuFrequencyFtraceEvent_Decoder;
  enum : int32_t {
    kGpuIdFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.GpuFrequencyFtraceEvent"; }


  using FieldMetadata_GpuId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      GpuFrequencyFtraceEvent>;

  static constexpr FieldMetadata_GpuId kGpuId{};
  void set_gpu_id(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_GpuId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_State =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      GpuFrequencyFtraceEvent>;

  static constexpr FieldMetadata_State kState{};
  void set_state(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_State::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }
};

class SuspendResumeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SuspendResumeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SuspendResumeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SuspendResumeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_action() const { return at<1>().valid(); }
  ::protozero::ConstChars action() const { return at<1>().as_string(); }
  bool has_val() const { return at<2>().valid(); }
  int32_t val() const { return at<2>().as_int32(); }
  bool has_start() const { return at<3>().valid(); }
  uint32_t start() const { return at<3>().as_uint32(); }
};

class SuspendResumeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SuspendResumeFtraceEvent_Decoder;
  enum : int32_t {
    kActionFieldNumber = 1,
    kValFieldNumber = 2,
    kStartFieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.SuspendResumeFtraceEvent"; }


  using FieldMetadata_Action =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      SuspendResumeFtraceEvent>;

  static constexpr FieldMetadata_Action kAction{};
  void set_action(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Action::kFieldId, data, size);
  }
  void set_action(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Action::kFieldId, chars.data, chars.size);
  }
  void set_action(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Action::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Val =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      SuspendResumeFtraceEvent>;

  static constexpr FieldMetadata_Val kVal{};
  void set_val(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Val::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Start =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      SuspendResumeFtraceEvent>;

  static constexpr FieldMetadata_Start kStart{};
  void set_start(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Start::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }
};

class ClockSetRateFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ClockSetRateFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ClockSetRateFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ClockSetRateFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_state() const { return at<2>().valid(); }
  uint64_t state() const { return at<2>().as_uint64(); }
  bool has_cpu_id() const { return at<3>().valid(); }
  uint64_t cpu_id() const { return at<3>().as_uint64(); }
};

class ClockSetRateFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = ClockSetRateFtraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kStateFieldNumber = 2,
    kCpuIdFieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ClockSetRateFtraceEvent"; }


  using FieldMetadata_Name =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      ClockSetRateFtraceEvent>;

  static constexpr FieldMetadata_Name kName{};
  void set_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Name::kFieldId, data, size);
  }
  void set_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Name::kFieldId, chars.data, chars.size);
  }
  void set_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Name::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_State =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      ClockSetRateFtraceEvent>;

  static constexpr FieldMetadata_State kState{};
  void set_state(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_State::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_CpuId =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      ClockSetRateFtraceEvent>;

  static constexpr FieldMetadata_CpuId kCpuId{};
  void set_cpu_id(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_CpuId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }
};

class ClockDisableFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ClockDisableFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ClockDisableFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ClockDisableFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_state() const { return at<2>().valid(); }
  uint64_t state() const { return at<2>().as_uint64(); }
  bool has_cpu_id() const { return at<3>().valid(); }
  uint64_t cpu_id() const { return at<3>().as_uint64(); }
};

class ClockDisableFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = ClockDisableFtraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kStateFieldNumber = 2,
    kCpuIdFieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ClockDisableFtraceEvent"; }


  using FieldMetadata_Name =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      ClockDisableFtraceEvent>;

  static constexpr FieldMetadata_Name kName{};
  void set_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Name::kFieldId, data, size);
  }
  void set_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Name::kFieldId, chars.data, chars.size);
  }
  void set_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Name::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_State =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      ClockDisableFtraceEvent>;

  static constexpr FieldMetadata_State kState{};
  void set_state(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_State::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_CpuId =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      ClockDisableFtraceEvent>;

  static constexpr FieldMetadata_CpuId kCpuId{};
  void set_cpu_id(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_CpuId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }
};

class ClockEnableFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ClockEnableFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ClockEnableFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ClockEnableFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_state() const { return at<2>().valid(); }
  uint64_t state() const { return at<2>().as_uint64(); }
  bool has_cpu_id() const { return at<3>().valid(); }
  uint64_t cpu_id() const { return at<3>().as_uint64(); }
};

class ClockEnableFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = ClockEnableFtraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kStateFieldNumber = 2,
    kCpuIdFieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ClockEnableFtraceEvent"; }


  using FieldMetadata_Name =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      ClockEnableFtraceEvent>;

  static constexpr FieldMetadata_Name kName{};
  void set_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Name::kFieldId, data, size);
  }
  void set_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Name::kFieldId, chars.data, chars.size);
  }
  void set_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Name::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_State =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      ClockEnableFtraceEvent>;

  static constexpr FieldMetadata_State kState{};
  void set_state(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_State::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_CpuId =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      ClockEnableFtraceEvent>;

  static constexpr FieldMetadata_CpuId kCpuId{};
  void set_cpu_id(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_CpuId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }
};

class CpuIdleFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  CpuIdleFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit CpuIdleFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit CpuIdleFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_state() const { return at<1>().valid(); }
  uint32_t state() const { return at<1>().as_uint32(); }
  bool has_cpu_id() const { return at<2>().valid(); }
  uint32_t cpu_id() const { return at<2>().as_uint32(); }
};

class CpuIdleFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = CpuIdleFtraceEvent_Decoder;
  enum : int32_t {
    kStateFieldNumber = 1,
    kCpuIdFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.CpuIdleFtraceEvent"; }


  using FieldMetadata_State =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      CpuIdleFtraceEvent>;

  static constexpr FieldMetadata_State kState{};
  void set_state(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_State::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_CpuId =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      CpuIdleFtraceEvent>;

  static constexpr FieldMetadata_CpuId kCpuId{};
  void set_cpu_id(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_CpuId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }
};

class CpuFrequencyLimitsFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  CpuFrequencyLimitsFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit CpuFrequencyLimitsFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit CpuFrequencyLimitsFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_min_freq() const { return at<1>().valid(); }
  uint32_t min_freq() const { return at<1>().as_uint32(); }
  bool has_max_freq() const { return at<2>().valid(); }
  uint32_t max_freq() const { return at<2>().as_uint32(); }
  bool has_cpu_id() const { return at<3>().valid(); }
  uint32_t cpu_id() const { return at<3>().as_uint32(); }
};

class CpuFrequencyLimitsFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = CpuFrequencyLimitsFtraceEvent_Decoder;
  enum : int32_t {
    kMinFreqFieldNumber = 1,
    kMaxFreqFieldNumber = 2,
    kCpuIdFieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.CpuFrequencyLimitsFtraceEvent"; }


  using FieldMetadata_MinFreq =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      CpuFrequencyLimitsFtraceEvent>;

  static constexpr FieldMetadata_MinFreq kMinFreq{};
  void set_min_freq(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_MinFreq::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_MaxFreq =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      CpuFrequencyLimitsFtraceEvent>;

  static constexpr FieldMetadata_MaxFreq kMaxFreq{};
  void set_max_freq(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_MaxFreq::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_CpuId =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      CpuFrequencyLimitsFtraceEvent>;

  static constexpr FieldMetadata_CpuId kCpuId{};
  void set_cpu_id(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_CpuId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }
};

class CpuFrequencyFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  CpuFrequencyFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit CpuFrequencyFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit CpuFrequencyFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_state() const { return at<1>().valid(); }
  uint32_t state() const { return at<1>().as_uint32(); }
  bool has_cpu_id() const { return at<2>().valid(); }
  uint32_t cpu_id() const { return at<2>().as_uint32(); }
};

class CpuFrequencyFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = CpuFrequencyFtraceEvent_Decoder;
  enum : int32_t {
    kStateFieldNumber = 1,
    kCpuIdFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.CpuFrequencyFtraceEvent"; }


  using FieldMetadata_State =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      CpuFrequencyFtraceEvent>;

  static constexpr FieldMetadata_State kState{};
  void set_state(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_State::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_CpuId =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      CpuFrequencyFtraceEvent>;

  static constexpr FieldMetadata_CpuId kCpuId{};
  void set_cpu_id(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_CpuId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
