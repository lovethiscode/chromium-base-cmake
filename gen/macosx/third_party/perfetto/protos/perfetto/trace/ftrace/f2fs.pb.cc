// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/trace/ftrace/f2fs.proto

#include "protos/perfetto/trace/ftrace/f2fs.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace perfetto {
namespace protos {
PROTOBUF_CONSTEXPR F2fsDoSubmitBioFtraceEvent::F2fsDoSubmitBioFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/uint64_t{0u}
  , /*decltype(_impl_.btype_)*/0
  , /*decltype(_impl_.sync_)*/0u
  , /*decltype(_impl_.sector_)*/uint64_t{0u}
  , /*decltype(_impl_.size_)*/0u} {}
struct F2fsDoSubmitBioFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsDoSubmitBioFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsDoSubmitBioFtraceEventDefaultTypeInternal() {}
  union {
    F2fsDoSubmitBioFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsDoSubmitBioFtraceEventDefaultTypeInternal _F2fsDoSubmitBioFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsEvictInodeFtraceEvent::F2fsEvictInodeFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/uint64_t{0u}
  , /*decltype(_impl_.ino_)*/uint64_t{0u}
  , /*decltype(_impl_.pino_)*/uint64_t{0u}
  , /*decltype(_impl_.size_)*/int64_t{0}
  , /*decltype(_impl_.mode_)*/0u
  , /*decltype(_impl_.nlink_)*/0u
  , /*decltype(_impl_.blocks_)*/uint64_t{0u}
  , /*decltype(_impl_.advise_)*/0u} {}
struct F2fsEvictInodeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsEvictInodeFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsEvictInodeFtraceEventDefaultTypeInternal() {}
  union {
    F2fsEvictInodeFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsEvictInodeFtraceEventDefaultTypeInternal _F2fsEvictInodeFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsFallocateFtraceEvent::F2fsFallocateFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/uint64_t{0u}
  , /*decltype(_impl_.ino_)*/uint64_t{0u}
  , /*decltype(_impl_.offset_)*/int64_t{0}
  , /*decltype(_impl_.len_)*/int64_t{0}
  , /*decltype(_impl_.mode_)*/0
  , /*decltype(_impl_.ret_)*/0
  , /*decltype(_impl_.size_)*/int64_t{0}
  , /*decltype(_impl_.blocks_)*/uint64_t{0u}} {}
struct F2fsFallocateFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsFallocateFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsFallocateFtraceEventDefaultTypeInternal() {}
  union {
    F2fsFallocateFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsFallocateFtraceEventDefaultTypeInternal _F2fsFallocateFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsGetDataBlockFtraceEvent::F2fsGetDataBlockFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/uint64_t{0u}
  , /*decltype(_impl_.ino_)*/uint64_t{0u}
  , /*decltype(_impl_.iblock_)*/uint64_t{0u}
  , /*decltype(_impl_.bh_start_)*/uint64_t{0u}
  , /*decltype(_impl_.bh_size_)*/uint64_t{0u}
  , /*decltype(_impl_.ret_)*/0} {}
struct F2fsGetDataBlockFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsGetDataBlockFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsGetDataBlockFtraceEventDefaultTypeInternal() {}
  union {
    F2fsGetDataBlockFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsGetDataBlockFtraceEventDefaultTypeInternal _F2fsGetDataBlockFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsGetVictimFtraceEvent::F2fsGetVictimFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/uint64_t{0u}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.gc_type_)*/0
  , /*decltype(_impl_.alloc_mode_)*/0
  , /*decltype(_impl_.gc_mode_)*/0
  , /*decltype(_impl_.victim_)*/0u
  , /*decltype(_impl_.ofs_unit_)*/0u
  , /*decltype(_impl_.pre_victim_)*/0u
  , /*decltype(_impl_.prefree_)*/0u
  , /*decltype(_impl_.free_)*/0u
  , /*decltype(_impl_.cost_)*/0u} {}
struct F2fsGetVictimFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsGetVictimFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsGetVictimFtraceEventDefaultTypeInternal() {}
  union {
    F2fsGetVictimFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsGetVictimFtraceEventDefaultTypeInternal _F2fsGetVictimFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsIgetFtraceEvent::F2fsIgetFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/uint64_t{0u}
  , /*decltype(_impl_.ino_)*/uint64_t{0u}
  , /*decltype(_impl_.pino_)*/uint64_t{0u}
  , /*decltype(_impl_.size_)*/int64_t{0}
  , /*decltype(_impl_.mode_)*/0u
  , /*decltype(_impl_.nlink_)*/0u
  , /*decltype(_impl_.blocks_)*/uint64_t{0u}
  , /*decltype(_impl_.advise_)*/0u} {}
struct F2fsIgetFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsIgetFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsIgetFtraceEventDefaultTypeInternal() {}
  union {
    F2fsIgetFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsIgetFtraceEventDefaultTypeInternal _F2fsIgetFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsIgetExitFtraceEvent::F2fsIgetExitFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/uint64_t{0u}
  , /*decltype(_impl_.ino_)*/uint64_t{0u}
  , /*decltype(_impl_.ret_)*/0} {}
struct F2fsIgetExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsIgetExitFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsIgetExitFtraceEventDefaultTypeInternal() {}
  union {
    F2fsIgetExitFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsIgetExitFtraceEventDefaultTypeInternal _F2fsIgetExitFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsNewInodeFtraceEvent::F2fsNewInodeFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/uint64_t{0u}
  , /*decltype(_impl_.ino_)*/uint64_t{0u}
  , /*decltype(_impl_.ret_)*/0} {}
struct F2fsNewInodeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsNewInodeFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsNewInodeFtraceEventDefaultTypeInternal() {}
  union {
    F2fsNewInodeFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsNewInodeFtraceEventDefaultTypeInternal _F2fsNewInodeFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsReadpageFtraceEvent::F2fsReadpageFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/uint64_t{0u}
  , /*decltype(_impl_.ino_)*/uint64_t{0u}
  , /*decltype(_impl_.index_)*/uint64_t{0u}
  , /*decltype(_impl_.blkaddr_)*/uint64_t{0u}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.dir_)*/0
  , /*decltype(_impl_.dirty_)*/0
  , /*decltype(_impl_.uptodate_)*/0} {}
struct F2fsReadpageFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsReadpageFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsReadpageFtraceEventDefaultTypeInternal() {}
  union {
    F2fsReadpageFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsReadpageFtraceEventDefaultTypeInternal _F2fsReadpageFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsReserveNewBlockFtraceEvent::F2fsReserveNewBlockFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/uint64_t{0u}
  , /*decltype(_impl_.nid_)*/0u
  , /*decltype(_impl_.ofs_in_node_)*/0u} {}
struct F2fsReserveNewBlockFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsReserveNewBlockFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsReserveNewBlockFtraceEventDefaultTypeInternal() {}
  union {
    F2fsReserveNewBlockFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsReserveNewBlockFtraceEventDefaultTypeInternal _F2fsReserveNewBlockFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsSetPageDirtyFtraceEvent::F2fsSetPageDirtyFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/uint64_t{0u}
  , /*decltype(_impl_.ino_)*/uint64_t{0u}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.dir_)*/0
  , /*decltype(_impl_.index_)*/uint64_t{0u}
  , /*decltype(_impl_.dirty_)*/0
  , /*decltype(_impl_.uptodate_)*/0} {}
struct F2fsSetPageDirtyFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsSetPageDirtyFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsSetPageDirtyFtraceEventDefaultTypeInternal() {}
  union {
    F2fsSetPageDirtyFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsSetPageDirtyFtraceEventDefaultTypeInternal _F2fsSetPageDirtyFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsSubmitWritePageFtraceEvent::F2fsSubmitWritePageFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/uint64_t{0u}
  , /*decltype(_impl_.ino_)*/uint64_t{0u}
  , /*decltype(_impl_.index_)*/uint64_t{0u}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.block_)*/0u} {}
struct F2fsSubmitWritePageFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsSubmitWritePageFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsSubmitWritePageFtraceEventDefaultTypeInternal() {}
  union {
    F2fsSubmitWritePageFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsSubmitWritePageFtraceEventDefaultTypeInternal _F2fsSubmitWritePageFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsSyncFileEnterFtraceEvent::F2fsSyncFileEnterFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/uint64_t{0u}
  , /*decltype(_impl_.ino_)*/uint64_t{0u}
  , /*decltype(_impl_.pino_)*/uint64_t{0u}
  , /*decltype(_impl_.size_)*/int64_t{0}
  , /*decltype(_impl_.mode_)*/0u
  , /*decltype(_impl_.nlink_)*/0u
  , /*decltype(_impl_.blocks_)*/uint64_t{0u}
  , /*decltype(_impl_.advise_)*/0u} {}
struct F2fsSyncFileEnterFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsSyncFileEnterFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsSyncFileEnterFtraceEventDefaultTypeInternal() {}
  union {
    F2fsSyncFileEnterFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsSyncFileEnterFtraceEventDefaultTypeInternal _F2fsSyncFileEnterFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsSyncFileExitFtraceEvent::F2fsSyncFileExitFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/uint64_t{0u}
  , /*decltype(_impl_.ino_)*/uint64_t{0u}
  , /*decltype(_impl_.need_cp_)*/0u
  , /*decltype(_impl_.datasync_)*/0
  , /*decltype(_impl_.ret_)*/0
  , /*decltype(_impl_.cp_reason_)*/0} {}
struct F2fsSyncFileExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsSyncFileExitFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsSyncFileExitFtraceEventDefaultTypeInternal() {}
  union {
    F2fsSyncFileExitFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsSyncFileExitFtraceEventDefaultTypeInternal _F2fsSyncFileExitFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsSyncFsFtraceEvent::F2fsSyncFsFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/uint64_t{0u}
  , /*decltype(_impl_.dirty_)*/0
  , /*decltype(_impl_.wait_)*/0} {}
struct F2fsSyncFsFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsSyncFsFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsSyncFsFtraceEventDefaultTypeInternal() {}
  union {
    F2fsSyncFsFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsSyncFsFtraceEventDefaultTypeInternal _F2fsSyncFsFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsTruncateFtraceEvent::F2fsTruncateFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/uint64_t{0u}
  , /*decltype(_impl_.ino_)*/uint64_t{0u}
  , /*decltype(_impl_.pino_)*/uint64_t{0u}
  , /*decltype(_impl_.size_)*/int64_t{0}
  , /*decltype(_impl_.mode_)*/0u
  , /*decltype(_impl_.nlink_)*/0u
  , /*decltype(_impl_.blocks_)*/uint64_t{0u}
  , /*decltype(_impl_.advise_)*/0u} {}
struct F2fsTruncateFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsTruncateFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsTruncateFtraceEventDefaultTypeInternal() {}
  union {
    F2fsTruncateFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsTruncateFtraceEventDefaultTypeInternal _F2fsTruncateFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsTruncateBlocksEnterFtraceEvent::F2fsTruncateBlocksEnterFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/uint64_t{0u}
  , /*decltype(_impl_.ino_)*/uint64_t{0u}
  , /*decltype(_impl_.size_)*/int64_t{0}
  , /*decltype(_impl_.blocks_)*/uint64_t{0u}
  , /*decltype(_impl_.from_)*/uint64_t{0u}} {}
struct F2fsTruncateBlocksEnterFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsTruncateBlocksEnterFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsTruncateBlocksEnterFtraceEventDefaultTypeInternal() {}
  union {
    F2fsTruncateBlocksEnterFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsTruncateBlocksEnterFtraceEventDefaultTypeInternal _F2fsTruncateBlocksEnterFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsTruncateBlocksExitFtraceEvent::F2fsTruncateBlocksExitFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/uint64_t{0u}
  , /*decltype(_impl_.ino_)*/uint64_t{0u}
  , /*decltype(_impl_.ret_)*/0} {}
struct F2fsTruncateBlocksExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsTruncateBlocksExitFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsTruncateBlocksExitFtraceEventDefaultTypeInternal() {}
  union {
    F2fsTruncateBlocksExitFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsTruncateBlocksExitFtraceEventDefaultTypeInternal _F2fsTruncateBlocksExitFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsTruncateDataBlocksRangeFtraceEvent::F2fsTruncateDataBlocksRangeFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/uint64_t{0u}
  , /*decltype(_impl_.ino_)*/uint64_t{0u}
  , /*decltype(_impl_.nid_)*/0u
  , /*decltype(_impl_.ofs_)*/0u
  , /*decltype(_impl_.free_)*/0} {}
struct F2fsTruncateDataBlocksRangeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsTruncateDataBlocksRangeFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsTruncateDataBlocksRangeFtraceEventDefaultTypeInternal() {}
  union {
    F2fsTruncateDataBlocksRangeFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsTruncateDataBlocksRangeFtraceEventDefaultTypeInternal _F2fsTruncateDataBlocksRangeFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsTruncateInodeBlocksEnterFtraceEvent::F2fsTruncateInodeBlocksEnterFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/uint64_t{0u}
  , /*decltype(_impl_.ino_)*/uint64_t{0u}
  , /*decltype(_impl_.size_)*/int64_t{0}
  , /*decltype(_impl_.blocks_)*/uint64_t{0u}
  , /*decltype(_impl_.from_)*/uint64_t{0u}} {}
struct F2fsTruncateInodeBlocksEnterFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsTruncateInodeBlocksEnterFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsTruncateInodeBlocksEnterFtraceEventDefaultTypeInternal() {}
  union {
    F2fsTruncateInodeBlocksEnterFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsTruncateInodeBlocksEnterFtraceEventDefaultTypeInternal _F2fsTruncateInodeBlocksEnterFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsTruncateInodeBlocksExitFtraceEvent::F2fsTruncateInodeBlocksExitFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/uint64_t{0u}
  , /*decltype(_impl_.ino_)*/uint64_t{0u}
  , /*decltype(_impl_.ret_)*/0} {}
struct F2fsTruncateInodeBlocksExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsTruncateInodeBlocksExitFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsTruncateInodeBlocksExitFtraceEventDefaultTypeInternal() {}
  union {
    F2fsTruncateInodeBlocksExitFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsTruncateInodeBlocksExitFtraceEventDefaultTypeInternal _F2fsTruncateInodeBlocksExitFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsTruncateNodeFtraceEvent::F2fsTruncateNodeFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/uint64_t{0u}
  , /*decltype(_impl_.ino_)*/uint64_t{0u}
  , /*decltype(_impl_.nid_)*/0u
  , /*decltype(_impl_.blk_addr_)*/0u} {}
struct F2fsTruncateNodeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsTruncateNodeFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsTruncateNodeFtraceEventDefaultTypeInternal() {}
  union {
    F2fsTruncateNodeFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsTruncateNodeFtraceEventDefaultTypeInternal _F2fsTruncateNodeFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsTruncateNodesEnterFtraceEvent::F2fsTruncateNodesEnterFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/uint64_t{0u}
  , /*decltype(_impl_.ino_)*/uint64_t{0u}
  , /*decltype(_impl_.nid_)*/0u
  , /*decltype(_impl_.blk_addr_)*/0u} {}
struct F2fsTruncateNodesEnterFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsTruncateNodesEnterFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsTruncateNodesEnterFtraceEventDefaultTypeInternal() {}
  union {
    F2fsTruncateNodesEnterFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsTruncateNodesEnterFtraceEventDefaultTypeInternal _F2fsTruncateNodesEnterFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsTruncateNodesExitFtraceEvent::F2fsTruncateNodesExitFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/uint64_t{0u}
  , /*decltype(_impl_.ino_)*/uint64_t{0u}
  , /*decltype(_impl_.ret_)*/0} {}
struct F2fsTruncateNodesExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsTruncateNodesExitFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsTruncateNodesExitFtraceEventDefaultTypeInternal() {}
  union {
    F2fsTruncateNodesExitFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsTruncateNodesExitFtraceEventDefaultTypeInternal _F2fsTruncateNodesExitFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsTruncatePartialNodesFtraceEvent::F2fsTruncatePartialNodesFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/uint64_t{0u}
  , /*decltype(_impl_.ino_)*/uint64_t{0u}
  , /*decltype(_impl_.nid_)*/0u
  , /*decltype(_impl_.depth_)*/0
  , /*decltype(_impl_.err_)*/0} {}
struct F2fsTruncatePartialNodesFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsTruncatePartialNodesFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsTruncatePartialNodesFtraceEventDefaultTypeInternal() {}
  union {
    F2fsTruncatePartialNodesFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsTruncatePartialNodesFtraceEventDefaultTypeInternal _F2fsTruncatePartialNodesFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsUnlinkEnterFtraceEvent::F2fsUnlinkEnterFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dev_)*/uint64_t{0u}
  , /*decltype(_impl_.ino_)*/uint64_t{0u}
  , /*decltype(_impl_.size_)*/int64_t{0}
  , /*decltype(_impl_.blocks_)*/uint64_t{0u}} {}
struct F2fsUnlinkEnterFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsUnlinkEnterFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsUnlinkEnterFtraceEventDefaultTypeInternal() {}
  union {
    F2fsUnlinkEnterFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsUnlinkEnterFtraceEventDefaultTypeInternal _F2fsUnlinkEnterFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsUnlinkExitFtraceEvent::F2fsUnlinkExitFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/uint64_t{0u}
  , /*decltype(_impl_.ino_)*/uint64_t{0u}
  , /*decltype(_impl_.ret_)*/0} {}
struct F2fsUnlinkExitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsUnlinkExitFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsUnlinkExitFtraceEventDefaultTypeInternal() {}
  union {
    F2fsUnlinkExitFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsUnlinkExitFtraceEventDefaultTypeInternal _F2fsUnlinkExitFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsVmPageMkwriteFtraceEvent::F2fsVmPageMkwriteFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/uint64_t{0u}
  , /*decltype(_impl_.ino_)*/uint64_t{0u}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.dir_)*/0
  , /*decltype(_impl_.index_)*/uint64_t{0u}
  , /*decltype(_impl_.dirty_)*/0
  , /*decltype(_impl_.uptodate_)*/0} {}
struct F2fsVmPageMkwriteFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsVmPageMkwriteFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsVmPageMkwriteFtraceEventDefaultTypeInternal() {}
  union {
    F2fsVmPageMkwriteFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsVmPageMkwriteFtraceEventDefaultTypeInternal _F2fsVmPageMkwriteFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsWriteBeginFtraceEvent::F2fsWriteBeginFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/uint64_t{0u}
  , /*decltype(_impl_.ino_)*/uint64_t{0u}
  , /*decltype(_impl_.pos_)*/int64_t{0}
  , /*decltype(_impl_.len_)*/0u
  , /*decltype(_impl_.flags_)*/0u} {}
struct F2fsWriteBeginFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsWriteBeginFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsWriteBeginFtraceEventDefaultTypeInternal() {}
  union {
    F2fsWriteBeginFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsWriteBeginFtraceEventDefaultTypeInternal _F2fsWriteBeginFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsWriteCheckpointFtraceEvent::F2fsWriteCheckpointFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.msg_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dev_)*/uint64_t{0u}
  , /*decltype(_impl_.is_umount_)*/0u
  , /*decltype(_impl_.reason_)*/0} {}
struct F2fsWriteCheckpointFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsWriteCheckpointFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsWriteCheckpointFtraceEventDefaultTypeInternal() {}
  union {
    F2fsWriteCheckpointFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsWriteCheckpointFtraceEventDefaultTypeInternal _F2fsWriteCheckpointFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsWriteEndFtraceEvent::F2fsWriteEndFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/uint64_t{0u}
  , /*decltype(_impl_.ino_)*/uint64_t{0u}
  , /*decltype(_impl_.pos_)*/int64_t{0}
  , /*decltype(_impl_.len_)*/0u
  , /*decltype(_impl_.copied_)*/0u} {}
struct F2fsWriteEndFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsWriteEndFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsWriteEndFtraceEventDefaultTypeInternal() {}
  union {
    F2fsWriteEndFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsWriteEndFtraceEventDefaultTypeInternal _F2fsWriteEndFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsIostatFtraceEvent::F2fsIostatFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.app_bio_)*/uint64_t{0u}
  , /*decltype(_impl_.app_brio_)*/uint64_t{0u}
  , /*decltype(_impl_.app_dio_)*/uint64_t{0u}
  , /*decltype(_impl_.app_drio_)*/uint64_t{0u}
  , /*decltype(_impl_.app_mio_)*/uint64_t{0u}
  , /*decltype(_impl_.app_mrio_)*/uint64_t{0u}
  , /*decltype(_impl_.app_rio_)*/uint64_t{0u}
  , /*decltype(_impl_.app_wio_)*/uint64_t{0u}
  , /*decltype(_impl_.dev_)*/uint64_t{0u}
  , /*decltype(_impl_.fs_cdrio_)*/uint64_t{0u}
  , /*decltype(_impl_.fs_cp_dio_)*/uint64_t{0u}
  , /*decltype(_impl_.fs_cp_mio_)*/uint64_t{0u}
  , /*decltype(_impl_.fs_cp_nio_)*/uint64_t{0u}
  , /*decltype(_impl_.fs_dio_)*/uint64_t{0u}
  , /*decltype(_impl_.fs_discard_)*/uint64_t{0u}
  , /*decltype(_impl_.fs_drio_)*/uint64_t{0u}
  , /*decltype(_impl_.fs_gc_dio_)*/uint64_t{0u}
  , /*decltype(_impl_.fs_gc_nio_)*/uint64_t{0u}
  , /*decltype(_impl_.fs_gdrio_)*/uint64_t{0u}
  , /*decltype(_impl_.fs_mio_)*/uint64_t{0u}
  , /*decltype(_impl_.fs_mrio_)*/uint64_t{0u}
  , /*decltype(_impl_.fs_nio_)*/uint64_t{0u}
  , /*decltype(_impl_.fs_nrio_)*/uint64_t{0u}} {}
struct F2fsIostatFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsIostatFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsIostatFtraceEventDefaultTypeInternal() {}
  union {
    F2fsIostatFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsIostatFtraceEventDefaultTypeInternal _F2fsIostatFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsIostatLatencyFtraceEvent::F2fsIostatLatencyFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.d_rd_avg_)*/0u
  , /*decltype(_impl_.d_rd_cnt_)*/0u
  , /*decltype(_impl_.d_rd_peak_)*/0u
  , /*decltype(_impl_.d_wr_as_avg_)*/0u
  , /*decltype(_impl_.d_wr_as_cnt_)*/0u
  , /*decltype(_impl_.d_wr_as_peak_)*/0u
  , /*decltype(_impl_.d_wr_s_avg_)*/0u
  , /*decltype(_impl_.d_wr_s_cnt_)*/0u
  , /*decltype(_impl_.dev_)*/uint64_t{0u}
  , /*decltype(_impl_.d_wr_s_peak_)*/0u
  , /*decltype(_impl_.m_rd_avg_)*/0u
  , /*decltype(_impl_.m_rd_cnt_)*/0u
  , /*decltype(_impl_.m_rd_peak_)*/0u
  , /*decltype(_impl_.m_wr_as_avg_)*/0u
  , /*decltype(_impl_.m_wr_as_cnt_)*/0u
  , /*decltype(_impl_.m_wr_as_peak_)*/0u
  , /*decltype(_impl_.m_wr_s_avg_)*/0u
  , /*decltype(_impl_.m_wr_s_cnt_)*/0u
  , /*decltype(_impl_.m_wr_s_peak_)*/0u
  , /*decltype(_impl_.n_rd_avg_)*/0u
  , /*decltype(_impl_.n_rd_cnt_)*/0u
  , /*decltype(_impl_.n_rd_peak_)*/0u
  , /*decltype(_impl_.n_wr_as_avg_)*/0u
  , /*decltype(_impl_.n_wr_as_cnt_)*/0u
  , /*decltype(_impl_.n_wr_as_peak_)*/0u
  , /*decltype(_impl_.n_wr_s_avg_)*/0u
  , /*decltype(_impl_.n_wr_s_cnt_)*/0u
  , /*decltype(_impl_.n_wr_s_peak_)*/0u} {}
struct F2fsIostatLatencyFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsIostatLatencyFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsIostatLatencyFtraceEventDefaultTypeInternal() {}
  union {
    F2fsIostatLatencyFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsIostatLatencyFtraceEventDefaultTypeInternal _F2fsIostatLatencyFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsBackgroundGcFtraceEvent::F2fsBackgroundGcFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/uint64_t{0u}
  , /*decltype(_impl_.wait_ms_)*/0u
  , /*decltype(_impl_.prefree_)*/0u
  , /*decltype(_impl_.free_)*/0u} {}
struct F2fsBackgroundGcFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsBackgroundGcFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsBackgroundGcFtraceEventDefaultTypeInternal() {}
  union {
    F2fsBackgroundGcFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsBackgroundGcFtraceEventDefaultTypeInternal _F2fsBackgroundGcFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsGcBeginFtraceEvent::F2fsGcBeginFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/uint64_t{0u}
  , /*decltype(_impl_.sync_)*/0u
  , /*decltype(_impl_.background_)*/0u
  , /*decltype(_impl_.dirty_nodes_)*/int64_t{0}
  , /*decltype(_impl_.dirty_dents_)*/int64_t{0}
  , /*decltype(_impl_.dirty_imeta_)*/int64_t{0}
  , /*decltype(_impl_.free_sec_)*/0u
  , /*decltype(_impl_.free_seg_)*/0u
  , /*decltype(_impl_.reserved_seg_)*/0
  , /*decltype(_impl_.prefree_seg_)*/0u
  , /*decltype(_impl_.gc_type_)*/0
  , /*decltype(_impl_.no_bg_gc_)*/0u
  , /*decltype(_impl_.nr_free_secs_)*/0u} {}
struct F2fsGcBeginFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsGcBeginFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsGcBeginFtraceEventDefaultTypeInternal() {}
  union {
    F2fsGcBeginFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsGcBeginFtraceEventDefaultTypeInternal _F2fsGcBeginFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR F2fsGcEndFtraceEvent::F2fsGcEndFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dev_)*/uint64_t{0u}
  , /*decltype(_impl_.ret_)*/0
  , /*decltype(_impl_.seg_freed_)*/0
  , /*decltype(_impl_.dirty_nodes_)*/int64_t{0}
  , /*decltype(_impl_.dirty_dents_)*/int64_t{0}
  , /*decltype(_impl_.sec_freed_)*/0
  , /*decltype(_impl_.free_sec_)*/0u
  , /*decltype(_impl_.dirty_imeta_)*/int64_t{0}
  , /*decltype(_impl_.free_seg_)*/0u
  , /*decltype(_impl_.reserved_seg_)*/0
  , /*decltype(_impl_.prefree_seg_)*/0u} {}
struct F2fsGcEndFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR F2fsGcEndFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~F2fsGcEndFtraceEventDefaultTypeInternal() {}
  union {
    F2fsGcEndFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 F2fsGcEndFtraceEventDefaultTypeInternal _F2fsGcEndFtraceEvent_default_instance_;
}  // namespace protos
}  // namespace perfetto
namespace perfetto {
namespace protos {

// ===================================================================

class F2fsDoSubmitBioFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsDoSubmitBioFtraceEvent>()._impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_btype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sync(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sector(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

F2fsDoSubmitBioFtraceEvent::F2fsDoSubmitBioFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsDoSubmitBioFtraceEvent)
}
F2fsDoSubmitBioFtraceEvent::F2fsDoSubmitBioFtraceEvent(const F2fsDoSubmitBioFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  F2fsDoSubmitBioFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){}
    , decltype(_impl_.btype_){}
    , decltype(_impl_.sync_){}
    , decltype(_impl_.sector_){}
    , decltype(_impl_.size_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.dev_, &from._impl_.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.size_) -
    reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.size_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsDoSubmitBioFtraceEvent)
}

inline void F2fsDoSubmitBioFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){uint64_t{0u}}
    , decltype(_impl_.btype_){0}
    , decltype(_impl_.sync_){0u}
    , decltype(_impl_.sector_){uint64_t{0u}}
    , decltype(_impl_.size_){0u}
  };
}

F2fsDoSubmitBioFtraceEvent::~F2fsDoSubmitBioFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsDoSubmitBioFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsDoSubmitBioFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsDoSubmitBioFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void F2fsDoSubmitBioFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsDoSubmitBioFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.size_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.size_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsDoSubmitBioFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 btype = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_btype(&has_bits);
          _impl_.btype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 sync = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_sync(&has_bits);
          _impl_.sync_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 sector = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_sector(&has_bits);
          _impl_.sector_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 size = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsDoSubmitBioFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsDoSubmitBioFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional int32 btype = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_btype(), target);
  }

  // optional uint32 sync = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_sync(), target);
  }

  // optional uint64 sector = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_sector(), target);
  }

  // optional uint32 size = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsDoSubmitBioFtraceEvent)
  return target;
}

size_t F2fsDoSubmitBioFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsDoSubmitBioFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional int32 btype = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_btype());
    }

    // optional uint32 sync = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sync());
    }

    // optional uint64 sector = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_sector());
    }

    // optional uint32 size = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_size());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsDoSubmitBioFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsDoSubmitBioFtraceEvent*>(
      &from));
}

void F2fsDoSubmitBioFtraceEvent::MergeFrom(const F2fsDoSubmitBioFtraceEvent& from) {
  F2fsDoSubmitBioFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsDoSubmitBioFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.btype_ = from._impl_.btype_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.sync_ = from._impl_.sync_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.sector_ = from._impl_.sector_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsDoSubmitBioFtraceEvent::CopyFrom(const F2fsDoSubmitBioFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsDoSubmitBioFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsDoSubmitBioFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsDoSubmitBioFtraceEvent::InternalSwap(F2fsDoSubmitBioFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsDoSubmitBioFtraceEvent, _impl_.size_)
      + sizeof(F2fsDoSubmitBioFtraceEvent::_impl_.size_)
      - PROTOBUF_FIELD_OFFSET(F2fsDoSubmitBioFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

std::string F2fsDoSubmitBioFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsDoSubmitBioFtraceEvent";
}


// ===================================================================

class F2fsEvictInodeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsEvictInodeFtraceEvent>()._impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pino(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_nlink(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_advise(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

F2fsEvictInodeFtraceEvent::F2fsEvictInodeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsEvictInodeFtraceEvent)
}
F2fsEvictInodeFtraceEvent::F2fsEvictInodeFtraceEvent(const F2fsEvictInodeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  F2fsEvictInodeFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){}
    , decltype(_impl_.ino_){}
    , decltype(_impl_.pino_){}
    , decltype(_impl_.size_){}
    , decltype(_impl_.mode_){}
    , decltype(_impl_.nlink_){}
    , decltype(_impl_.blocks_){}
    , decltype(_impl_.advise_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.dev_, &from._impl_.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.advise_) -
    reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.advise_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsEvictInodeFtraceEvent)
}

inline void F2fsEvictInodeFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){uint64_t{0u}}
    , decltype(_impl_.ino_){uint64_t{0u}}
    , decltype(_impl_.pino_){uint64_t{0u}}
    , decltype(_impl_.size_){int64_t{0}}
    , decltype(_impl_.mode_){0u}
    , decltype(_impl_.nlink_){0u}
    , decltype(_impl_.blocks_){uint64_t{0u}}
    , decltype(_impl_.advise_){0u}
  };
}

F2fsEvictInodeFtraceEvent::~F2fsEvictInodeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsEvictInodeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsEvictInodeFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsEvictInodeFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void F2fsEvictInodeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsEvictInodeFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.advise_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.advise_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsEvictInodeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pino = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_pino(&has_bits);
          _impl_.pino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mode = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_mode(&has_bits);
          _impl_.mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 size = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 nlink = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_nlink(&has_bits);
          _impl_.nlink_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 blocks = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_blocks(&has_bits);
          _impl_.blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 advise = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_advise(&has_bits);
          _impl_.advise_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsEvictInodeFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsEvictInodeFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 pino = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_pino(), target);
  }

  // optional uint32 mode = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_mode(), target);
  }

  // optional int64 size = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_size(), target);
  }

  // optional uint32 nlink = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_nlink(), target);
  }

  // optional uint64 blocks = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_blocks(), target);
  }

  // optional uint32 advise = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_advise(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsEvictInodeFtraceEvent)
  return target;
}

size_t F2fsEvictInodeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsEvictInodeFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 pino = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pino());
    }

    // optional int64 size = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_size());
    }

    // optional uint32 mode = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mode());
    }

    // optional uint32 nlink = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nlink());
    }

    // optional uint64 blocks = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_blocks());
    }

    // optional uint32 advise = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_advise());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsEvictInodeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsEvictInodeFtraceEvent*>(
      &from));
}

void F2fsEvictInodeFtraceEvent::MergeFrom(const F2fsEvictInodeFtraceEvent& from) {
  F2fsEvictInodeFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsEvictInodeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pino_ = from._impl_.pino_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.mode_ = from._impl_.mode_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.nlink_ = from._impl_.nlink_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.blocks_ = from._impl_.blocks_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.advise_ = from._impl_.advise_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsEvictInodeFtraceEvent::CopyFrom(const F2fsEvictInodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsEvictInodeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsEvictInodeFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsEvictInodeFtraceEvent::InternalSwap(F2fsEvictInodeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsEvictInodeFtraceEvent, _impl_.advise_)
      + sizeof(F2fsEvictInodeFtraceEvent::_impl_.advise_)
      - PROTOBUF_FIELD_OFFSET(F2fsEvictInodeFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

std::string F2fsEvictInodeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsEvictInodeFtraceEvent";
}


// ===================================================================

class F2fsFallocateFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsFallocateFtraceEvent>()._impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

F2fsFallocateFtraceEvent::F2fsFallocateFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsFallocateFtraceEvent)
}
F2fsFallocateFtraceEvent::F2fsFallocateFtraceEvent(const F2fsFallocateFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  F2fsFallocateFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){}
    , decltype(_impl_.ino_){}
    , decltype(_impl_.offset_){}
    , decltype(_impl_.len_){}
    , decltype(_impl_.mode_){}
    , decltype(_impl_.ret_){}
    , decltype(_impl_.size_){}
    , decltype(_impl_.blocks_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.dev_, &from._impl_.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.blocks_) -
    reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.blocks_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsFallocateFtraceEvent)
}

inline void F2fsFallocateFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){uint64_t{0u}}
    , decltype(_impl_.ino_){uint64_t{0u}}
    , decltype(_impl_.offset_){int64_t{0}}
    , decltype(_impl_.len_){int64_t{0}}
    , decltype(_impl_.mode_){0}
    , decltype(_impl_.ret_){0}
    , decltype(_impl_.size_){int64_t{0}}
    , decltype(_impl_.blocks_){uint64_t{0u}}
  };
}

F2fsFallocateFtraceEvent::~F2fsFallocateFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsFallocateFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsFallocateFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsFallocateFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void F2fsFallocateFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsFallocateFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.blocks_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.blocks_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsFallocateFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_mode(&has_bits);
          _impl_.mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 offset = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_offset(&has_bits);
          _impl_.offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 len = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 size = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 blocks = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_blocks(&has_bits);
          _impl_.blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ret = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_ret(&has_bits);
          _impl_.ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsFallocateFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsFallocateFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int32 mode = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_mode(), target);
  }

  // optional int64 offset = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_offset(), target);
  }

  // optional int64 len = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_len(), target);
  }

  // optional int64 size = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_size(), target);
  }

  // optional uint64 blocks = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_blocks(), target);
  }

  // optional int32 ret = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsFallocateFtraceEvent)
  return target;
}

size_t F2fsFallocateFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsFallocateFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int64 offset = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_offset());
    }

    // optional int64 len = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_len());
    }

    // optional int32 mode = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mode());
    }

    // optional int32 ret = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ret());
    }

    // optional int64 size = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_size());
    }

    // optional uint64 blocks = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_blocks());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsFallocateFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsFallocateFtraceEvent*>(
      &from));
}

void F2fsFallocateFtraceEvent::MergeFrom(const F2fsFallocateFtraceEvent& from) {
  F2fsFallocateFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsFallocateFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.offset_ = from._impl_.offset_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.mode_ = from._impl_.mode_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.ret_ = from._impl_.ret_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.blocks_ = from._impl_.blocks_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsFallocateFtraceEvent::CopyFrom(const F2fsFallocateFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsFallocateFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsFallocateFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsFallocateFtraceEvent::InternalSwap(F2fsFallocateFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsFallocateFtraceEvent, _impl_.blocks_)
      + sizeof(F2fsFallocateFtraceEvent::_impl_.blocks_)
      - PROTOBUF_FIELD_OFFSET(F2fsFallocateFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

std::string F2fsFallocateFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsFallocateFtraceEvent";
}


// ===================================================================

class F2fsGetDataBlockFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsGetDataBlockFtraceEvent>()._impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_iblock(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_bh_start(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_bh_size(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

F2fsGetDataBlockFtraceEvent::F2fsGetDataBlockFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsGetDataBlockFtraceEvent)
}
F2fsGetDataBlockFtraceEvent::F2fsGetDataBlockFtraceEvent(const F2fsGetDataBlockFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  F2fsGetDataBlockFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){}
    , decltype(_impl_.ino_){}
    , decltype(_impl_.iblock_){}
    , decltype(_impl_.bh_start_){}
    , decltype(_impl_.bh_size_){}
    , decltype(_impl_.ret_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.dev_, &from._impl_.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ret_) -
    reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.ret_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsGetDataBlockFtraceEvent)
}

inline void F2fsGetDataBlockFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){uint64_t{0u}}
    , decltype(_impl_.ino_){uint64_t{0u}}
    , decltype(_impl_.iblock_){uint64_t{0u}}
    , decltype(_impl_.bh_start_){uint64_t{0u}}
    , decltype(_impl_.bh_size_){uint64_t{0u}}
    , decltype(_impl_.ret_){0}
  };
}

F2fsGetDataBlockFtraceEvent::~F2fsGetDataBlockFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsGetDataBlockFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsGetDataBlockFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsGetDataBlockFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void F2fsGetDataBlockFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsGetDataBlockFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ret_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.ret_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsGetDataBlockFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 iblock = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_iblock(&has_bits);
          _impl_.iblock_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 bh_start = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_bh_start(&has_bits);
          _impl_.bh_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 bh_size = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_bh_size(&has_bits);
          _impl_.bh_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ret = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_ret(&has_bits);
          _impl_.ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsGetDataBlockFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsGetDataBlockFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 iblock = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_iblock(), target);
  }

  // optional uint64 bh_start = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_bh_start(), target);
  }

  // optional uint64 bh_size = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_bh_size(), target);
  }

  // optional int32 ret = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsGetDataBlockFtraceEvent)
  return target;
}

size_t F2fsGetDataBlockFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsGetDataBlockFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 iblock = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_iblock());
    }

    // optional uint64 bh_start = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_bh_start());
    }

    // optional uint64 bh_size = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_bh_size());
    }

    // optional int32 ret = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ret());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsGetDataBlockFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsGetDataBlockFtraceEvent*>(
      &from));
}

void F2fsGetDataBlockFtraceEvent::MergeFrom(const F2fsGetDataBlockFtraceEvent& from) {
  F2fsGetDataBlockFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsGetDataBlockFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.iblock_ = from._impl_.iblock_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.bh_start_ = from._impl_.bh_start_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.bh_size_ = from._impl_.bh_size_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.ret_ = from._impl_.ret_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsGetDataBlockFtraceEvent::CopyFrom(const F2fsGetDataBlockFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsGetDataBlockFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsGetDataBlockFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsGetDataBlockFtraceEvent::InternalSwap(F2fsGetDataBlockFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsGetDataBlockFtraceEvent, _impl_.ret_)
      + sizeof(F2fsGetDataBlockFtraceEvent::_impl_.ret_)
      - PROTOBUF_FIELD_OFFSET(F2fsGetDataBlockFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

std::string F2fsGetDataBlockFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsGetDataBlockFtraceEvent";
}


// ===================================================================

class F2fsGetVictimFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsGetVictimFtraceEvent>()._impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_gc_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_alloc_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gc_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_victim(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_ofs_unit(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_pre_victim(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_prefree(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_free(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

F2fsGetVictimFtraceEvent::F2fsGetVictimFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsGetVictimFtraceEvent)
}
F2fsGetVictimFtraceEvent::F2fsGetVictimFtraceEvent(const F2fsGetVictimFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  F2fsGetVictimFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.gc_type_){}
    , decltype(_impl_.alloc_mode_){}
    , decltype(_impl_.gc_mode_){}
    , decltype(_impl_.victim_){}
    , decltype(_impl_.ofs_unit_){}
    , decltype(_impl_.pre_victim_){}
    , decltype(_impl_.prefree_){}
    , decltype(_impl_.free_){}
    , decltype(_impl_.cost_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.dev_, &from._impl_.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.cost_) -
    reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.cost_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsGetVictimFtraceEvent)
}

inline void F2fsGetVictimFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){uint64_t{0u}}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.gc_type_){0}
    , decltype(_impl_.alloc_mode_){0}
    , decltype(_impl_.gc_mode_){0}
    , decltype(_impl_.victim_){0u}
    , decltype(_impl_.ofs_unit_){0u}
    , decltype(_impl_.pre_victim_){0u}
    , decltype(_impl_.prefree_){0u}
    , decltype(_impl_.free_){0u}
    , decltype(_impl_.cost_){0u}
  };
}

F2fsGetVictimFtraceEvent::~F2fsGetVictimFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsGetVictimFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsGetVictimFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsGetVictimFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void F2fsGetVictimFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsGetVictimFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.pre_victim_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.pre_victim_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.prefree_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.cost_) -
        reinterpret_cast<char*>(&_impl_.prefree_)) + sizeof(_impl_.cost_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsGetVictimFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 gc_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_gc_type(&has_bits);
          _impl_.gc_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 alloc_mode = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_alloc_mode(&has_bits);
          _impl_.alloc_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 gc_mode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_gc_mode(&has_bits);
          _impl_.gc_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 victim = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_victim(&has_bits);
          _impl_.victim_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ofs_unit = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_ofs_unit(&has_bits);
          _impl_.ofs_unit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 pre_victim = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_pre_victim(&has_bits);
          _impl_.pre_victim_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 prefree = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_prefree(&has_bits);
          _impl_.prefree_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 free = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_free(&has_bits);
          _impl_.free_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 cost = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_cost(&has_bits);
          _impl_.cost_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsGetVictimFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsGetVictimFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional int32 type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_type(), target);
  }

  // optional int32 gc_type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_gc_type(), target);
  }

  // optional int32 alloc_mode = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_alloc_mode(), target);
  }

  // optional int32 gc_mode = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_gc_mode(), target);
  }

  // optional uint32 victim = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_victim(), target);
  }

  // optional uint32 ofs_unit = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_ofs_unit(), target);
  }

  // optional uint32 pre_victim = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_pre_victim(), target);
  }

  // optional uint32 prefree = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_prefree(), target);
  }

  // optional uint32 free = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_free(), target);
  }

  // optional uint32 cost = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_cost(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsGetVictimFtraceEvent)
  return target;
}

size_t F2fsGetVictimFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsGetVictimFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional int32 type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_type());
    }

    // optional int32 gc_type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_gc_type());
    }

    // optional int32 alloc_mode = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_alloc_mode());
    }

    // optional int32 gc_mode = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_gc_mode());
    }

    // optional uint32 victim = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_victim());
    }

    // optional uint32 ofs_unit = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ofs_unit());
    }

    // optional uint32 pre_victim = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_pre_victim());
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional uint32 prefree = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_prefree());
    }

    // optional uint32 free = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_free());
    }

    // optional uint32 cost = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_cost());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsGetVictimFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsGetVictimFtraceEvent*>(
      &from));
}

void F2fsGetVictimFtraceEvent::MergeFrom(const F2fsGetVictimFtraceEvent& from) {
  F2fsGetVictimFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsGetVictimFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.gc_type_ = from._impl_.gc_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.alloc_mode_ = from._impl_.alloc_mode_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.gc_mode_ = from._impl_.gc_mode_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.victim_ = from._impl_.victim_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.ofs_unit_ = from._impl_.ofs_unit_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.pre_victim_ = from._impl_.pre_victim_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.prefree_ = from._impl_.prefree_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.free_ = from._impl_.free_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.cost_ = from._impl_.cost_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsGetVictimFtraceEvent::CopyFrom(const F2fsGetVictimFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsGetVictimFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsGetVictimFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsGetVictimFtraceEvent::InternalSwap(F2fsGetVictimFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsGetVictimFtraceEvent, _impl_.cost_)
      + sizeof(F2fsGetVictimFtraceEvent::_impl_.cost_)
      - PROTOBUF_FIELD_OFFSET(F2fsGetVictimFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

std::string F2fsGetVictimFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsGetVictimFtraceEvent";
}


// ===================================================================

class F2fsIgetFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsIgetFtraceEvent>()._impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pino(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_nlink(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_advise(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

F2fsIgetFtraceEvent::F2fsIgetFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsIgetFtraceEvent)
}
F2fsIgetFtraceEvent::F2fsIgetFtraceEvent(const F2fsIgetFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  F2fsIgetFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){}
    , decltype(_impl_.ino_){}
    , decltype(_impl_.pino_){}
    , decltype(_impl_.size_){}
    , decltype(_impl_.mode_){}
    , decltype(_impl_.nlink_){}
    , decltype(_impl_.blocks_){}
    , decltype(_impl_.advise_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.dev_, &from._impl_.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.advise_) -
    reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.advise_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsIgetFtraceEvent)
}

inline void F2fsIgetFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){uint64_t{0u}}
    , decltype(_impl_.ino_){uint64_t{0u}}
    , decltype(_impl_.pino_){uint64_t{0u}}
    , decltype(_impl_.size_){int64_t{0}}
    , decltype(_impl_.mode_){0u}
    , decltype(_impl_.nlink_){0u}
    , decltype(_impl_.blocks_){uint64_t{0u}}
    , decltype(_impl_.advise_){0u}
  };
}

F2fsIgetFtraceEvent::~F2fsIgetFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsIgetFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsIgetFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsIgetFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void F2fsIgetFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsIgetFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.advise_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.advise_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsIgetFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pino = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_pino(&has_bits);
          _impl_.pino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mode = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_mode(&has_bits);
          _impl_.mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 size = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 nlink = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_nlink(&has_bits);
          _impl_.nlink_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 blocks = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_blocks(&has_bits);
          _impl_.blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 advise = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_advise(&has_bits);
          _impl_.advise_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsIgetFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsIgetFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 pino = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_pino(), target);
  }

  // optional uint32 mode = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_mode(), target);
  }

  // optional int64 size = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_size(), target);
  }

  // optional uint32 nlink = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_nlink(), target);
  }

  // optional uint64 blocks = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_blocks(), target);
  }

  // optional uint32 advise = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_advise(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsIgetFtraceEvent)
  return target;
}

size_t F2fsIgetFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsIgetFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 pino = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pino());
    }

    // optional int64 size = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_size());
    }

    // optional uint32 mode = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mode());
    }

    // optional uint32 nlink = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nlink());
    }

    // optional uint64 blocks = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_blocks());
    }

    // optional uint32 advise = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_advise());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsIgetFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsIgetFtraceEvent*>(
      &from));
}

void F2fsIgetFtraceEvent::MergeFrom(const F2fsIgetFtraceEvent& from) {
  F2fsIgetFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsIgetFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pino_ = from._impl_.pino_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.mode_ = from._impl_.mode_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.nlink_ = from._impl_.nlink_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.blocks_ = from._impl_.blocks_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.advise_ = from._impl_.advise_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsIgetFtraceEvent::CopyFrom(const F2fsIgetFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsIgetFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsIgetFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsIgetFtraceEvent::InternalSwap(F2fsIgetFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsIgetFtraceEvent, _impl_.advise_)
      + sizeof(F2fsIgetFtraceEvent::_impl_.advise_)
      - PROTOBUF_FIELD_OFFSET(F2fsIgetFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

std::string F2fsIgetFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsIgetFtraceEvent";
}


// ===================================================================

class F2fsIgetExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsIgetExitFtraceEvent>()._impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

F2fsIgetExitFtraceEvent::F2fsIgetExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsIgetExitFtraceEvent)
}
F2fsIgetExitFtraceEvent::F2fsIgetExitFtraceEvent(const F2fsIgetExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  F2fsIgetExitFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){}
    , decltype(_impl_.ino_){}
    , decltype(_impl_.ret_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.dev_, &from._impl_.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ret_) -
    reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.ret_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsIgetExitFtraceEvent)
}

inline void F2fsIgetExitFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){uint64_t{0u}}
    , decltype(_impl_.ino_){uint64_t{0u}}
    , decltype(_impl_.ret_){0}
  };
}

F2fsIgetExitFtraceEvent::~F2fsIgetExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsIgetExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsIgetExitFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsIgetExitFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void F2fsIgetExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsIgetExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ret_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.ret_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsIgetExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ret = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_ret(&has_bits);
          _impl_.ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsIgetExitFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsIgetExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int32 ret = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsIgetExitFtraceEvent)
  return target;
}

size_t F2fsIgetExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsIgetExitFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int32 ret = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ret());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsIgetExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsIgetExitFtraceEvent*>(
      &from));
}

void F2fsIgetExitFtraceEvent::MergeFrom(const F2fsIgetExitFtraceEvent& from) {
  F2fsIgetExitFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsIgetExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ret_ = from._impl_.ret_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsIgetExitFtraceEvent::CopyFrom(const F2fsIgetExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsIgetExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsIgetExitFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsIgetExitFtraceEvent::InternalSwap(F2fsIgetExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsIgetExitFtraceEvent, _impl_.ret_)
      + sizeof(F2fsIgetExitFtraceEvent::_impl_.ret_)
      - PROTOBUF_FIELD_OFFSET(F2fsIgetExitFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

std::string F2fsIgetExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsIgetExitFtraceEvent";
}


// ===================================================================

class F2fsNewInodeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsNewInodeFtraceEvent>()._impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

F2fsNewInodeFtraceEvent::F2fsNewInodeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsNewInodeFtraceEvent)
}
F2fsNewInodeFtraceEvent::F2fsNewInodeFtraceEvent(const F2fsNewInodeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  F2fsNewInodeFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){}
    , decltype(_impl_.ino_){}
    , decltype(_impl_.ret_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.dev_, &from._impl_.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ret_) -
    reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.ret_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsNewInodeFtraceEvent)
}

inline void F2fsNewInodeFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){uint64_t{0u}}
    , decltype(_impl_.ino_){uint64_t{0u}}
    , decltype(_impl_.ret_){0}
  };
}

F2fsNewInodeFtraceEvent::~F2fsNewInodeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsNewInodeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsNewInodeFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsNewInodeFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void F2fsNewInodeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsNewInodeFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ret_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.ret_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsNewInodeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ret = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_ret(&has_bits);
          _impl_.ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsNewInodeFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsNewInodeFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int32 ret = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsNewInodeFtraceEvent)
  return target;
}

size_t F2fsNewInodeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsNewInodeFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int32 ret = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ret());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsNewInodeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsNewInodeFtraceEvent*>(
      &from));
}

void F2fsNewInodeFtraceEvent::MergeFrom(const F2fsNewInodeFtraceEvent& from) {
  F2fsNewInodeFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsNewInodeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ret_ = from._impl_.ret_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsNewInodeFtraceEvent::CopyFrom(const F2fsNewInodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsNewInodeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsNewInodeFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsNewInodeFtraceEvent::InternalSwap(F2fsNewInodeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsNewInodeFtraceEvent, _impl_.ret_)
      + sizeof(F2fsNewInodeFtraceEvent::_impl_.ret_)
      - PROTOBUF_FIELD_OFFSET(F2fsNewInodeFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

std::string F2fsNewInodeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsNewInodeFtraceEvent";
}


// ===================================================================

class F2fsReadpageFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsReadpageFtraceEvent>()._impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_blkaddr(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_dir(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_dirty(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_uptodate(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

F2fsReadpageFtraceEvent::F2fsReadpageFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsReadpageFtraceEvent)
}
F2fsReadpageFtraceEvent::F2fsReadpageFtraceEvent(const F2fsReadpageFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  F2fsReadpageFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){}
    , decltype(_impl_.ino_){}
    , decltype(_impl_.index_){}
    , decltype(_impl_.blkaddr_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.dir_){}
    , decltype(_impl_.dirty_){}
    , decltype(_impl_.uptodate_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.dev_, &from._impl_.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.uptodate_) -
    reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.uptodate_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsReadpageFtraceEvent)
}

inline void F2fsReadpageFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){uint64_t{0u}}
    , decltype(_impl_.ino_){uint64_t{0u}}
    , decltype(_impl_.index_){uint64_t{0u}}
    , decltype(_impl_.blkaddr_){uint64_t{0u}}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.dir_){0}
    , decltype(_impl_.dirty_){0}
    , decltype(_impl_.uptodate_){0}
  };
}

F2fsReadpageFtraceEvent::~F2fsReadpageFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsReadpageFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsReadpageFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsReadpageFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void F2fsReadpageFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsReadpageFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.uptodate_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.uptodate_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsReadpageFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_index(&has_bits);
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 blkaddr = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_blkaddr(&has_bits);
          _impl_.blkaddr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 dir = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_dir(&has_bits);
          _impl_.dir_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 dirty = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_dirty(&has_bits);
          _impl_.dirty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 uptodate = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_uptodate(&has_bits);
          _impl_.uptodate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsReadpageFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsReadpageFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_index(), target);
  }

  // optional uint64 blkaddr = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_blkaddr(), target);
  }

  // optional int32 type = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_type(), target);
  }

  // optional int32 dir = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_dir(), target);
  }

  // optional int32 dirty = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_dirty(), target);
  }

  // optional int32 uptodate = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_uptodate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsReadpageFtraceEvent)
  return target;
}

size_t F2fsReadpageFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsReadpageFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_index());
    }

    // optional uint64 blkaddr = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_blkaddr());
    }

    // optional int32 type = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_type());
    }

    // optional int32 dir = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dir());
    }

    // optional int32 dirty = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dirty());
    }

    // optional int32 uptodate = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_uptodate());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsReadpageFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsReadpageFtraceEvent*>(
      &from));
}

void F2fsReadpageFtraceEvent::MergeFrom(const F2fsReadpageFtraceEvent& from) {
  F2fsReadpageFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsReadpageFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.index_ = from._impl_.index_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.blkaddr_ = from._impl_.blkaddr_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.dir_ = from._impl_.dir_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.dirty_ = from._impl_.dirty_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.uptodate_ = from._impl_.uptodate_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsReadpageFtraceEvent::CopyFrom(const F2fsReadpageFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsReadpageFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsReadpageFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsReadpageFtraceEvent::InternalSwap(F2fsReadpageFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsReadpageFtraceEvent, _impl_.uptodate_)
      + sizeof(F2fsReadpageFtraceEvent::_impl_.uptodate_)
      - PROTOBUF_FIELD_OFFSET(F2fsReadpageFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

std::string F2fsReadpageFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsReadpageFtraceEvent";
}


// ===================================================================

class F2fsReserveNewBlockFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsReserveNewBlockFtraceEvent>()._impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ofs_in_node(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

F2fsReserveNewBlockFtraceEvent::F2fsReserveNewBlockFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsReserveNewBlockFtraceEvent)
}
F2fsReserveNewBlockFtraceEvent::F2fsReserveNewBlockFtraceEvent(const F2fsReserveNewBlockFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  F2fsReserveNewBlockFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){}
    , decltype(_impl_.nid_){}
    , decltype(_impl_.ofs_in_node_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.dev_, &from._impl_.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ofs_in_node_) -
    reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.ofs_in_node_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsReserveNewBlockFtraceEvent)
}

inline void F2fsReserveNewBlockFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){uint64_t{0u}}
    , decltype(_impl_.nid_){0u}
    , decltype(_impl_.ofs_in_node_){0u}
  };
}

F2fsReserveNewBlockFtraceEvent::~F2fsReserveNewBlockFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsReserveNewBlockFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsReserveNewBlockFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsReserveNewBlockFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void F2fsReserveNewBlockFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsReserveNewBlockFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ofs_in_node_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.ofs_in_node_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsReserveNewBlockFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 nid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_nid(&has_bits);
          _impl_.nid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ofs_in_node = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_ofs_in_node(&has_bits);
          _impl_.ofs_in_node_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsReserveNewBlockFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsReserveNewBlockFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint32 nid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_nid(), target);
  }

  // optional uint32 ofs_in_node = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_ofs_in_node(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsReserveNewBlockFtraceEvent)
  return target;
}

size_t F2fsReserveNewBlockFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsReserveNewBlockFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint32 nid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nid());
    }

    // optional uint32 ofs_in_node = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ofs_in_node());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsReserveNewBlockFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsReserveNewBlockFtraceEvent*>(
      &from));
}

void F2fsReserveNewBlockFtraceEvent::MergeFrom(const F2fsReserveNewBlockFtraceEvent& from) {
  F2fsReserveNewBlockFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsReserveNewBlockFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.nid_ = from._impl_.nid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ofs_in_node_ = from._impl_.ofs_in_node_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsReserveNewBlockFtraceEvent::CopyFrom(const F2fsReserveNewBlockFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsReserveNewBlockFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsReserveNewBlockFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsReserveNewBlockFtraceEvent::InternalSwap(F2fsReserveNewBlockFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsReserveNewBlockFtraceEvent, _impl_.ofs_in_node_)
      + sizeof(F2fsReserveNewBlockFtraceEvent::_impl_.ofs_in_node_)
      - PROTOBUF_FIELD_OFFSET(F2fsReserveNewBlockFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

std::string F2fsReserveNewBlockFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsReserveNewBlockFtraceEvent";
}


// ===================================================================

class F2fsSetPageDirtyFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsSetPageDirtyFtraceEvent>()._impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_dir(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_dirty(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_uptodate(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

F2fsSetPageDirtyFtraceEvent::F2fsSetPageDirtyFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsSetPageDirtyFtraceEvent)
}
F2fsSetPageDirtyFtraceEvent::F2fsSetPageDirtyFtraceEvent(const F2fsSetPageDirtyFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  F2fsSetPageDirtyFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){}
    , decltype(_impl_.ino_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.dir_){}
    , decltype(_impl_.index_){}
    , decltype(_impl_.dirty_){}
    , decltype(_impl_.uptodate_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.dev_, &from._impl_.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.uptodate_) -
    reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.uptodate_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsSetPageDirtyFtraceEvent)
}

inline void F2fsSetPageDirtyFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){uint64_t{0u}}
    , decltype(_impl_.ino_){uint64_t{0u}}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.dir_){0}
    , decltype(_impl_.index_){uint64_t{0u}}
    , decltype(_impl_.dirty_){0}
    , decltype(_impl_.uptodate_){0}
  };
}

F2fsSetPageDirtyFtraceEvent::~F2fsSetPageDirtyFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsSetPageDirtyFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsSetPageDirtyFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsSetPageDirtyFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void F2fsSetPageDirtyFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsSetPageDirtyFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&_impl_.dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.uptodate_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.uptodate_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsSetPageDirtyFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 dir = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_dir(&has_bits);
          _impl_.dir_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 index = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_index(&has_bits);
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 dirty = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_dirty(&has_bits);
          _impl_.dirty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 uptodate = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_uptodate(&has_bits);
          _impl_.uptodate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsSetPageDirtyFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsSetPageDirtyFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int32 type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_type(), target);
  }

  // optional int32 dir = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_dir(), target);
  }

  // optional uint64 index = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_index(), target);
  }

  // optional int32 dirty = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_dirty(), target);
  }

  // optional int32 uptodate = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_uptodate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsSetPageDirtyFtraceEvent)
  return target;
}

size_t F2fsSetPageDirtyFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsSetPageDirtyFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int32 type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_type());
    }

    // optional int32 dir = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dir());
    }

    // optional uint64 index = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_index());
    }

    // optional int32 dirty = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dirty());
    }

    // optional int32 uptodate = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_uptodate());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsSetPageDirtyFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsSetPageDirtyFtraceEvent*>(
      &from));
}

void F2fsSetPageDirtyFtraceEvent::MergeFrom(const F2fsSetPageDirtyFtraceEvent& from) {
  F2fsSetPageDirtyFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsSetPageDirtyFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.dir_ = from._impl_.dir_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.index_ = from._impl_.index_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.dirty_ = from._impl_.dirty_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.uptodate_ = from._impl_.uptodate_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsSetPageDirtyFtraceEvent::CopyFrom(const F2fsSetPageDirtyFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsSetPageDirtyFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsSetPageDirtyFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsSetPageDirtyFtraceEvent::InternalSwap(F2fsSetPageDirtyFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsSetPageDirtyFtraceEvent, _impl_.uptodate_)
      + sizeof(F2fsSetPageDirtyFtraceEvent::_impl_.uptodate_)
      - PROTOBUF_FIELD_OFFSET(F2fsSetPageDirtyFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

std::string F2fsSetPageDirtyFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsSetPageDirtyFtraceEvent";
}


// ===================================================================

class F2fsSubmitWritePageFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsSubmitWritePageFtraceEvent>()._impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_block(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

F2fsSubmitWritePageFtraceEvent::F2fsSubmitWritePageFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsSubmitWritePageFtraceEvent)
}
F2fsSubmitWritePageFtraceEvent::F2fsSubmitWritePageFtraceEvent(const F2fsSubmitWritePageFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  F2fsSubmitWritePageFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){}
    , decltype(_impl_.ino_){}
    , decltype(_impl_.index_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.block_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.dev_, &from._impl_.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.block_) -
    reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.block_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsSubmitWritePageFtraceEvent)
}

inline void F2fsSubmitWritePageFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){uint64_t{0u}}
    , decltype(_impl_.ino_){uint64_t{0u}}
    , decltype(_impl_.index_){uint64_t{0u}}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.block_){0u}
  };
}

F2fsSubmitWritePageFtraceEvent::~F2fsSubmitWritePageFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsSubmitWritePageFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsSubmitWritePageFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsSubmitWritePageFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void F2fsSubmitWritePageFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsSubmitWritePageFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.block_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.block_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsSubmitWritePageFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 index = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_index(&has_bits);
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 block = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_block(&has_bits);
          _impl_.block_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsSubmitWritePageFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsSubmitWritePageFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int32 type = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_type(), target);
  }

  // optional uint64 index = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_index(), target);
  }

  // optional uint32 block = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_block(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsSubmitWritePageFtraceEvent)
  return target;
}

size_t F2fsSubmitWritePageFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsSubmitWritePageFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 index = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_index());
    }

    // optional int32 type = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_type());
    }

    // optional uint32 block = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_block());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsSubmitWritePageFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsSubmitWritePageFtraceEvent*>(
      &from));
}

void F2fsSubmitWritePageFtraceEvent::MergeFrom(const F2fsSubmitWritePageFtraceEvent& from) {
  F2fsSubmitWritePageFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsSubmitWritePageFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.index_ = from._impl_.index_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.block_ = from._impl_.block_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsSubmitWritePageFtraceEvent::CopyFrom(const F2fsSubmitWritePageFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsSubmitWritePageFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsSubmitWritePageFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsSubmitWritePageFtraceEvent::InternalSwap(F2fsSubmitWritePageFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsSubmitWritePageFtraceEvent, _impl_.block_)
      + sizeof(F2fsSubmitWritePageFtraceEvent::_impl_.block_)
      - PROTOBUF_FIELD_OFFSET(F2fsSubmitWritePageFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

std::string F2fsSubmitWritePageFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsSubmitWritePageFtraceEvent";
}


// ===================================================================

class F2fsSyncFileEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsSyncFileEnterFtraceEvent>()._impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pino(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_nlink(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_advise(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

F2fsSyncFileEnterFtraceEvent::F2fsSyncFileEnterFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsSyncFileEnterFtraceEvent)
}
F2fsSyncFileEnterFtraceEvent::F2fsSyncFileEnterFtraceEvent(const F2fsSyncFileEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  F2fsSyncFileEnterFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){}
    , decltype(_impl_.ino_){}
    , decltype(_impl_.pino_){}
    , decltype(_impl_.size_){}
    , decltype(_impl_.mode_){}
    , decltype(_impl_.nlink_){}
    , decltype(_impl_.blocks_){}
    , decltype(_impl_.advise_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.dev_, &from._impl_.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.advise_) -
    reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.advise_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsSyncFileEnterFtraceEvent)
}

inline void F2fsSyncFileEnterFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){uint64_t{0u}}
    , decltype(_impl_.ino_){uint64_t{0u}}
    , decltype(_impl_.pino_){uint64_t{0u}}
    , decltype(_impl_.size_){int64_t{0}}
    , decltype(_impl_.mode_){0u}
    , decltype(_impl_.nlink_){0u}
    , decltype(_impl_.blocks_){uint64_t{0u}}
    , decltype(_impl_.advise_){0u}
  };
}

F2fsSyncFileEnterFtraceEvent::~F2fsSyncFileEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsSyncFileEnterFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsSyncFileEnterFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsSyncFileEnterFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void F2fsSyncFileEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsSyncFileEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.advise_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.advise_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsSyncFileEnterFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pino = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_pino(&has_bits);
          _impl_.pino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mode = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_mode(&has_bits);
          _impl_.mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 size = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 nlink = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_nlink(&has_bits);
          _impl_.nlink_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 blocks = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_blocks(&has_bits);
          _impl_.blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 advise = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_advise(&has_bits);
          _impl_.advise_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsSyncFileEnterFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsSyncFileEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 pino = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_pino(), target);
  }

  // optional uint32 mode = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_mode(), target);
  }

  // optional int64 size = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_size(), target);
  }

  // optional uint32 nlink = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_nlink(), target);
  }

  // optional uint64 blocks = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_blocks(), target);
  }

  // optional uint32 advise = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_advise(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsSyncFileEnterFtraceEvent)
  return target;
}

size_t F2fsSyncFileEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsSyncFileEnterFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 pino = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pino());
    }

    // optional int64 size = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_size());
    }

    // optional uint32 mode = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mode());
    }

    // optional uint32 nlink = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nlink());
    }

    // optional uint64 blocks = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_blocks());
    }

    // optional uint32 advise = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_advise());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsSyncFileEnterFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsSyncFileEnterFtraceEvent*>(
      &from));
}

void F2fsSyncFileEnterFtraceEvent::MergeFrom(const F2fsSyncFileEnterFtraceEvent& from) {
  F2fsSyncFileEnterFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsSyncFileEnterFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pino_ = from._impl_.pino_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.mode_ = from._impl_.mode_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.nlink_ = from._impl_.nlink_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.blocks_ = from._impl_.blocks_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.advise_ = from._impl_.advise_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsSyncFileEnterFtraceEvent::CopyFrom(const F2fsSyncFileEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsSyncFileEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsSyncFileEnterFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsSyncFileEnterFtraceEvent::InternalSwap(F2fsSyncFileEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsSyncFileEnterFtraceEvent, _impl_.advise_)
      + sizeof(F2fsSyncFileEnterFtraceEvent::_impl_.advise_)
      - PROTOBUF_FIELD_OFFSET(F2fsSyncFileEnterFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

std::string F2fsSyncFileEnterFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsSyncFileEnterFtraceEvent";
}


// ===================================================================

class F2fsSyncFileExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsSyncFileExitFtraceEvent>()._impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_need_cp(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_datasync(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_cp_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

F2fsSyncFileExitFtraceEvent::F2fsSyncFileExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsSyncFileExitFtraceEvent)
}
F2fsSyncFileExitFtraceEvent::F2fsSyncFileExitFtraceEvent(const F2fsSyncFileExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  F2fsSyncFileExitFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){}
    , decltype(_impl_.ino_){}
    , decltype(_impl_.need_cp_){}
    , decltype(_impl_.datasync_){}
    , decltype(_impl_.ret_){}
    , decltype(_impl_.cp_reason_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.dev_, &from._impl_.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.cp_reason_) -
    reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.cp_reason_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsSyncFileExitFtraceEvent)
}

inline void F2fsSyncFileExitFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){uint64_t{0u}}
    , decltype(_impl_.ino_){uint64_t{0u}}
    , decltype(_impl_.need_cp_){0u}
    , decltype(_impl_.datasync_){0}
    , decltype(_impl_.ret_){0}
    , decltype(_impl_.cp_reason_){0}
  };
}

F2fsSyncFileExitFtraceEvent::~F2fsSyncFileExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsSyncFileExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsSyncFileExitFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsSyncFileExitFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void F2fsSyncFileExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsSyncFileExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.cp_reason_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.cp_reason_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsSyncFileExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 need_cp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_need_cp(&has_bits);
          _impl_.need_cp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 datasync = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_datasync(&has_bits);
          _impl_.datasync_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ret = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_ret(&has_bits);
          _impl_.ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 cp_reason = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_cp_reason(&has_bits);
          _impl_.cp_reason_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsSyncFileExitFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsSyncFileExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint32 need_cp = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_need_cp(), target);
  }

  // optional int32 datasync = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_datasync(), target);
  }

  // optional int32 ret = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_ret(), target);
  }

  // optional int32 cp_reason = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_cp_reason(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsSyncFileExitFtraceEvent)
  return target;
}

size_t F2fsSyncFileExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsSyncFileExitFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint32 need_cp = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_need_cp());
    }

    // optional int32 datasync = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_datasync());
    }

    // optional int32 ret = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ret());
    }

    // optional int32 cp_reason = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_cp_reason());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsSyncFileExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsSyncFileExitFtraceEvent*>(
      &from));
}

void F2fsSyncFileExitFtraceEvent::MergeFrom(const F2fsSyncFileExitFtraceEvent& from) {
  F2fsSyncFileExitFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsSyncFileExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.need_cp_ = from._impl_.need_cp_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.datasync_ = from._impl_.datasync_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.ret_ = from._impl_.ret_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.cp_reason_ = from._impl_.cp_reason_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsSyncFileExitFtraceEvent::CopyFrom(const F2fsSyncFileExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsSyncFileExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsSyncFileExitFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsSyncFileExitFtraceEvent::InternalSwap(F2fsSyncFileExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsSyncFileExitFtraceEvent, _impl_.cp_reason_)
      + sizeof(F2fsSyncFileExitFtraceEvent::_impl_.cp_reason_)
      - PROTOBUF_FIELD_OFFSET(F2fsSyncFileExitFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

std::string F2fsSyncFileExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsSyncFileExitFtraceEvent";
}


// ===================================================================

class F2fsSyncFsFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsSyncFsFtraceEvent>()._impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_dirty(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_wait(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

F2fsSyncFsFtraceEvent::F2fsSyncFsFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsSyncFsFtraceEvent)
}
F2fsSyncFsFtraceEvent::F2fsSyncFsFtraceEvent(const F2fsSyncFsFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  F2fsSyncFsFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){}
    , decltype(_impl_.dirty_){}
    , decltype(_impl_.wait_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.dev_, &from._impl_.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.wait_) -
    reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.wait_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsSyncFsFtraceEvent)
}

inline void F2fsSyncFsFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){uint64_t{0u}}
    , decltype(_impl_.dirty_){0}
    , decltype(_impl_.wait_){0}
  };
}

F2fsSyncFsFtraceEvent::~F2fsSyncFsFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsSyncFsFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsSyncFsFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsSyncFsFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void F2fsSyncFsFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsSyncFsFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.wait_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.wait_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsSyncFsFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 dirty = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_dirty(&has_bits);
          _impl_.dirty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 wait = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_wait(&has_bits);
          _impl_.wait_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsSyncFsFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsSyncFsFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional int32 dirty = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_dirty(), target);
  }

  // optional int32 wait = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_wait(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsSyncFsFtraceEvent)
  return target;
}

size_t F2fsSyncFsFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsSyncFsFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional int32 dirty = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dirty());
    }

    // optional int32 wait = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_wait());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsSyncFsFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsSyncFsFtraceEvent*>(
      &from));
}

void F2fsSyncFsFtraceEvent::MergeFrom(const F2fsSyncFsFtraceEvent& from) {
  F2fsSyncFsFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsSyncFsFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.dirty_ = from._impl_.dirty_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.wait_ = from._impl_.wait_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsSyncFsFtraceEvent::CopyFrom(const F2fsSyncFsFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsSyncFsFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsSyncFsFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsSyncFsFtraceEvent::InternalSwap(F2fsSyncFsFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsSyncFsFtraceEvent, _impl_.wait_)
      + sizeof(F2fsSyncFsFtraceEvent::_impl_.wait_)
      - PROTOBUF_FIELD_OFFSET(F2fsSyncFsFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

std::string F2fsSyncFsFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsSyncFsFtraceEvent";
}


// ===================================================================

class F2fsTruncateFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsTruncateFtraceEvent>()._impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pino(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_nlink(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_advise(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

F2fsTruncateFtraceEvent::F2fsTruncateFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsTruncateFtraceEvent)
}
F2fsTruncateFtraceEvent::F2fsTruncateFtraceEvent(const F2fsTruncateFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  F2fsTruncateFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){}
    , decltype(_impl_.ino_){}
    , decltype(_impl_.pino_){}
    , decltype(_impl_.size_){}
    , decltype(_impl_.mode_){}
    , decltype(_impl_.nlink_){}
    , decltype(_impl_.blocks_){}
    , decltype(_impl_.advise_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.dev_, &from._impl_.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.advise_) -
    reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.advise_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsTruncateFtraceEvent)
}

inline void F2fsTruncateFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){uint64_t{0u}}
    , decltype(_impl_.ino_){uint64_t{0u}}
    , decltype(_impl_.pino_){uint64_t{0u}}
    , decltype(_impl_.size_){int64_t{0}}
    , decltype(_impl_.mode_){0u}
    , decltype(_impl_.nlink_){0u}
    , decltype(_impl_.blocks_){uint64_t{0u}}
    , decltype(_impl_.advise_){0u}
  };
}

F2fsTruncateFtraceEvent::~F2fsTruncateFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsTruncateFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsTruncateFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsTruncateFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void F2fsTruncateFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsTruncateFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.advise_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.advise_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsTruncateFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pino = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_pino(&has_bits);
          _impl_.pino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mode = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_mode(&has_bits);
          _impl_.mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 size = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 nlink = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_nlink(&has_bits);
          _impl_.nlink_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 blocks = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_blocks(&has_bits);
          _impl_.blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 advise = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_advise(&has_bits);
          _impl_.advise_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsTruncateFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsTruncateFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint64 pino = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_pino(), target);
  }

  // optional uint32 mode = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_mode(), target);
  }

  // optional int64 size = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_size(), target);
  }

  // optional uint32 nlink = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_nlink(), target);
  }

  // optional uint64 blocks = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_blocks(), target);
  }

  // optional uint32 advise = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_advise(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsTruncateFtraceEvent)
  return target;
}

size_t F2fsTruncateFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsTruncateFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint64 pino = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pino());
    }

    // optional int64 size = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_size());
    }

    // optional uint32 mode = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mode());
    }

    // optional uint32 nlink = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nlink());
    }

    // optional uint64 blocks = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_blocks());
    }

    // optional uint32 advise = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_advise());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsTruncateFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsTruncateFtraceEvent*>(
      &from));
}

void F2fsTruncateFtraceEvent::MergeFrom(const F2fsTruncateFtraceEvent& from) {
  F2fsTruncateFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsTruncateFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pino_ = from._impl_.pino_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.mode_ = from._impl_.mode_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.nlink_ = from._impl_.nlink_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.blocks_ = from._impl_.blocks_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.advise_ = from._impl_.advise_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsTruncateFtraceEvent::CopyFrom(const F2fsTruncateFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsTruncateFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsTruncateFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsTruncateFtraceEvent::InternalSwap(F2fsTruncateFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsTruncateFtraceEvent, _impl_.advise_)
      + sizeof(F2fsTruncateFtraceEvent::_impl_.advise_)
      - PROTOBUF_FIELD_OFFSET(F2fsTruncateFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

std::string F2fsTruncateFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsTruncateFtraceEvent";
}


// ===================================================================

class F2fsTruncateBlocksEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsTruncateBlocksEnterFtraceEvent>()._impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_from(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

F2fsTruncateBlocksEnterFtraceEvent::F2fsTruncateBlocksEnterFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsTruncateBlocksEnterFtraceEvent)
}
F2fsTruncateBlocksEnterFtraceEvent::F2fsTruncateBlocksEnterFtraceEvent(const F2fsTruncateBlocksEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  F2fsTruncateBlocksEnterFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){}
    , decltype(_impl_.ino_){}
    , decltype(_impl_.size_){}
    , decltype(_impl_.blocks_){}
    , decltype(_impl_.from_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.dev_, &from._impl_.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.from_) -
    reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.from_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsTruncateBlocksEnterFtraceEvent)
}

inline void F2fsTruncateBlocksEnterFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){uint64_t{0u}}
    , decltype(_impl_.ino_){uint64_t{0u}}
    , decltype(_impl_.size_){int64_t{0}}
    , decltype(_impl_.blocks_){uint64_t{0u}}
    , decltype(_impl_.from_){uint64_t{0u}}
  };
}

F2fsTruncateBlocksEnterFtraceEvent::~F2fsTruncateBlocksEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsTruncateBlocksEnterFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsTruncateBlocksEnterFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsTruncateBlocksEnterFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void F2fsTruncateBlocksEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsTruncateBlocksEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.from_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.from_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsTruncateBlocksEnterFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 blocks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_blocks(&has_bits);
          _impl_.blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 from = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_from(&has_bits);
          _impl_.from_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsTruncateBlocksEnterFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsTruncateBlocksEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int64 size = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_size(), target);
  }

  // optional uint64 blocks = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_blocks(), target);
  }

  // optional uint64 from = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_from(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsTruncateBlocksEnterFtraceEvent)
  return target;
}

size_t F2fsTruncateBlocksEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsTruncateBlocksEnterFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int64 size = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_size());
    }

    // optional uint64 blocks = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_blocks());
    }

    // optional uint64 from = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_from());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsTruncateBlocksEnterFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsTruncateBlocksEnterFtraceEvent*>(
      &from));
}

void F2fsTruncateBlocksEnterFtraceEvent::MergeFrom(const F2fsTruncateBlocksEnterFtraceEvent& from) {
  F2fsTruncateBlocksEnterFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsTruncateBlocksEnterFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.blocks_ = from._impl_.blocks_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.from_ = from._impl_.from_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsTruncateBlocksEnterFtraceEvent::CopyFrom(const F2fsTruncateBlocksEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsTruncateBlocksEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsTruncateBlocksEnterFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsTruncateBlocksEnterFtraceEvent::InternalSwap(F2fsTruncateBlocksEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsTruncateBlocksEnterFtraceEvent, _impl_.from_)
      + sizeof(F2fsTruncateBlocksEnterFtraceEvent::_impl_.from_)
      - PROTOBUF_FIELD_OFFSET(F2fsTruncateBlocksEnterFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

std::string F2fsTruncateBlocksEnterFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsTruncateBlocksEnterFtraceEvent";
}


// ===================================================================

class F2fsTruncateBlocksExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsTruncateBlocksExitFtraceEvent>()._impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

F2fsTruncateBlocksExitFtraceEvent::F2fsTruncateBlocksExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsTruncateBlocksExitFtraceEvent)
}
F2fsTruncateBlocksExitFtraceEvent::F2fsTruncateBlocksExitFtraceEvent(const F2fsTruncateBlocksExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  F2fsTruncateBlocksExitFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){}
    , decltype(_impl_.ino_){}
    , decltype(_impl_.ret_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.dev_, &from._impl_.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ret_) -
    reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.ret_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsTruncateBlocksExitFtraceEvent)
}

inline void F2fsTruncateBlocksExitFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){uint64_t{0u}}
    , decltype(_impl_.ino_){uint64_t{0u}}
    , decltype(_impl_.ret_){0}
  };
}

F2fsTruncateBlocksExitFtraceEvent::~F2fsTruncateBlocksExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsTruncateBlocksExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsTruncateBlocksExitFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsTruncateBlocksExitFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void F2fsTruncateBlocksExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsTruncateBlocksExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ret_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.ret_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsTruncateBlocksExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ret = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_ret(&has_bits);
          _impl_.ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsTruncateBlocksExitFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsTruncateBlocksExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int32 ret = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsTruncateBlocksExitFtraceEvent)
  return target;
}

size_t F2fsTruncateBlocksExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsTruncateBlocksExitFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int32 ret = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ret());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsTruncateBlocksExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsTruncateBlocksExitFtraceEvent*>(
      &from));
}

void F2fsTruncateBlocksExitFtraceEvent::MergeFrom(const F2fsTruncateBlocksExitFtraceEvent& from) {
  F2fsTruncateBlocksExitFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsTruncateBlocksExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ret_ = from._impl_.ret_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsTruncateBlocksExitFtraceEvent::CopyFrom(const F2fsTruncateBlocksExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsTruncateBlocksExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsTruncateBlocksExitFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsTruncateBlocksExitFtraceEvent::InternalSwap(F2fsTruncateBlocksExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsTruncateBlocksExitFtraceEvent, _impl_.ret_)
      + sizeof(F2fsTruncateBlocksExitFtraceEvent::_impl_.ret_)
      - PROTOBUF_FIELD_OFFSET(F2fsTruncateBlocksExitFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

std::string F2fsTruncateBlocksExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsTruncateBlocksExitFtraceEvent";
}


// ===================================================================

class F2fsTruncateDataBlocksRangeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsTruncateDataBlocksRangeFtraceEvent>()._impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_nid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ofs(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_free(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

F2fsTruncateDataBlocksRangeFtraceEvent::F2fsTruncateDataBlocksRangeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsTruncateDataBlocksRangeFtraceEvent)
}
F2fsTruncateDataBlocksRangeFtraceEvent::F2fsTruncateDataBlocksRangeFtraceEvent(const F2fsTruncateDataBlocksRangeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  F2fsTruncateDataBlocksRangeFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){}
    , decltype(_impl_.ino_){}
    , decltype(_impl_.nid_){}
    , decltype(_impl_.ofs_){}
    , decltype(_impl_.free_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.dev_, &from._impl_.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.free_) -
    reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.free_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsTruncateDataBlocksRangeFtraceEvent)
}

inline void F2fsTruncateDataBlocksRangeFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){uint64_t{0u}}
    , decltype(_impl_.ino_){uint64_t{0u}}
    , decltype(_impl_.nid_){0u}
    , decltype(_impl_.ofs_){0u}
    , decltype(_impl_.free_){0}
  };
}

F2fsTruncateDataBlocksRangeFtraceEvent::~F2fsTruncateDataBlocksRangeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsTruncateDataBlocksRangeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsTruncateDataBlocksRangeFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsTruncateDataBlocksRangeFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void F2fsTruncateDataBlocksRangeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsTruncateDataBlocksRangeFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.free_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.free_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsTruncateDataBlocksRangeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 nid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_nid(&has_bits);
          _impl_.nid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ofs = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_ofs(&has_bits);
          _impl_.ofs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 free = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_free(&has_bits);
          _impl_.free_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsTruncateDataBlocksRangeFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsTruncateDataBlocksRangeFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint32 nid = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_nid(), target);
  }

  // optional uint32 ofs = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_ofs(), target);
  }

  // optional int32 free = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_free(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsTruncateDataBlocksRangeFtraceEvent)
  return target;
}

size_t F2fsTruncateDataBlocksRangeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsTruncateDataBlocksRangeFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint32 nid = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nid());
    }

    // optional uint32 ofs = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ofs());
    }

    // optional int32 free = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_free());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsTruncateDataBlocksRangeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsTruncateDataBlocksRangeFtraceEvent*>(
      &from));
}

void F2fsTruncateDataBlocksRangeFtraceEvent::MergeFrom(const F2fsTruncateDataBlocksRangeFtraceEvent& from) {
  F2fsTruncateDataBlocksRangeFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsTruncateDataBlocksRangeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.nid_ = from._impl_.nid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.ofs_ = from._impl_.ofs_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.free_ = from._impl_.free_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsTruncateDataBlocksRangeFtraceEvent::CopyFrom(const F2fsTruncateDataBlocksRangeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsTruncateDataBlocksRangeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsTruncateDataBlocksRangeFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsTruncateDataBlocksRangeFtraceEvent::InternalSwap(F2fsTruncateDataBlocksRangeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsTruncateDataBlocksRangeFtraceEvent, _impl_.free_)
      + sizeof(F2fsTruncateDataBlocksRangeFtraceEvent::_impl_.free_)
      - PROTOBUF_FIELD_OFFSET(F2fsTruncateDataBlocksRangeFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

std::string F2fsTruncateDataBlocksRangeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsTruncateDataBlocksRangeFtraceEvent";
}


// ===================================================================

class F2fsTruncateInodeBlocksEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsTruncateInodeBlocksEnterFtraceEvent>()._impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_from(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

F2fsTruncateInodeBlocksEnterFtraceEvent::F2fsTruncateInodeBlocksEnterFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsTruncateInodeBlocksEnterFtraceEvent)
}
F2fsTruncateInodeBlocksEnterFtraceEvent::F2fsTruncateInodeBlocksEnterFtraceEvent(const F2fsTruncateInodeBlocksEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  F2fsTruncateInodeBlocksEnterFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){}
    , decltype(_impl_.ino_){}
    , decltype(_impl_.size_){}
    , decltype(_impl_.blocks_){}
    , decltype(_impl_.from_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.dev_, &from._impl_.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.from_) -
    reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.from_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsTruncateInodeBlocksEnterFtraceEvent)
}

inline void F2fsTruncateInodeBlocksEnterFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){uint64_t{0u}}
    , decltype(_impl_.ino_){uint64_t{0u}}
    , decltype(_impl_.size_){int64_t{0}}
    , decltype(_impl_.blocks_){uint64_t{0u}}
    , decltype(_impl_.from_){uint64_t{0u}}
  };
}

F2fsTruncateInodeBlocksEnterFtraceEvent::~F2fsTruncateInodeBlocksEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsTruncateInodeBlocksEnterFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsTruncateInodeBlocksEnterFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsTruncateInodeBlocksEnterFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void F2fsTruncateInodeBlocksEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsTruncateInodeBlocksEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.from_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.from_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsTruncateInodeBlocksEnterFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 blocks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_blocks(&has_bits);
          _impl_.blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 from = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_from(&has_bits);
          _impl_.from_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsTruncateInodeBlocksEnterFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsTruncateInodeBlocksEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int64 size = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_size(), target);
  }

  // optional uint64 blocks = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_blocks(), target);
  }

  // optional uint64 from = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_from(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsTruncateInodeBlocksEnterFtraceEvent)
  return target;
}

size_t F2fsTruncateInodeBlocksEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsTruncateInodeBlocksEnterFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int64 size = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_size());
    }

    // optional uint64 blocks = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_blocks());
    }

    // optional uint64 from = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_from());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsTruncateInodeBlocksEnterFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsTruncateInodeBlocksEnterFtraceEvent*>(
      &from));
}

void F2fsTruncateInodeBlocksEnterFtraceEvent::MergeFrom(const F2fsTruncateInodeBlocksEnterFtraceEvent& from) {
  F2fsTruncateInodeBlocksEnterFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsTruncateInodeBlocksEnterFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.blocks_ = from._impl_.blocks_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.from_ = from._impl_.from_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsTruncateInodeBlocksEnterFtraceEvent::CopyFrom(const F2fsTruncateInodeBlocksEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsTruncateInodeBlocksEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsTruncateInodeBlocksEnterFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsTruncateInodeBlocksEnterFtraceEvent::InternalSwap(F2fsTruncateInodeBlocksEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsTruncateInodeBlocksEnterFtraceEvent, _impl_.from_)
      + sizeof(F2fsTruncateInodeBlocksEnterFtraceEvent::_impl_.from_)
      - PROTOBUF_FIELD_OFFSET(F2fsTruncateInodeBlocksEnterFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

std::string F2fsTruncateInodeBlocksEnterFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsTruncateInodeBlocksEnterFtraceEvent";
}


// ===================================================================

class F2fsTruncateInodeBlocksExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsTruncateInodeBlocksExitFtraceEvent>()._impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

F2fsTruncateInodeBlocksExitFtraceEvent::F2fsTruncateInodeBlocksExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsTruncateInodeBlocksExitFtraceEvent)
}
F2fsTruncateInodeBlocksExitFtraceEvent::F2fsTruncateInodeBlocksExitFtraceEvent(const F2fsTruncateInodeBlocksExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  F2fsTruncateInodeBlocksExitFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){}
    , decltype(_impl_.ino_){}
    , decltype(_impl_.ret_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.dev_, &from._impl_.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ret_) -
    reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.ret_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsTruncateInodeBlocksExitFtraceEvent)
}

inline void F2fsTruncateInodeBlocksExitFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){uint64_t{0u}}
    , decltype(_impl_.ino_){uint64_t{0u}}
    , decltype(_impl_.ret_){0}
  };
}

F2fsTruncateInodeBlocksExitFtraceEvent::~F2fsTruncateInodeBlocksExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsTruncateInodeBlocksExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsTruncateInodeBlocksExitFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsTruncateInodeBlocksExitFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void F2fsTruncateInodeBlocksExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsTruncateInodeBlocksExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ret_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.ret_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsTruncateInodeBlocksExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ret = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_ret(&has_bits);
          _impl_.ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsTruncateInodeBlocksExitFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsTruncateInodeBlocksExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int32 ret = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsTruncateInodeBlocksExitFtraceEvent)
  return target;
}

size_t F2fsTruncateInodeBlocksExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsTruncateInodeBlocksExitFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int32 ret = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ret());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsTruncateInodeBlocksExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsTruncateInodeBlocksExitFtraceEvent*>(
      &from));
}

void F2fsTruncateInodeBlocksExitFtraceEvent::MergeFrom(const F2fsTruncateInodeBlocksExitFtraceEvent& from) {
  F2fsTruncateInodeBlocksExitFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsTruncateInodeBlocksExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ret_ = from._impl_.ret_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsTruncateInodeBlocksExitFtraceEvent::CopyFrom(const F2fsTruncateInodeBlocksExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsTruncateInodeBlocksExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsTruncateInodeBlocksExitFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsTruncateInodeBlocksExitFtraceEvent::InternalSwap(F2fsTruncateInodeBlocksExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsTruncateInodeBlocksExitFtraceEvent, _impl_.ret_)
      + sizeof(F2fsTruncateInodeBlocksExitFtraceEvent::_impl_.ret_)
      - PROTOBUF_FIELD_OFFSET(F2fsTruncateInodeBlocksExitFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

std::string F2fsTruncateInodeBlocksExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsTruncateInodeBlocksExitFtraceEvent";
}


// ===================================================================

class F2fsTruncateNodeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsTruncateNodeFtraceEvent>()._impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_nid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_blk_addr(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

F2fsTruncateNodeFtraceEvent::F2fsTruncateNodeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsTruncateNodeFtraceEvent)
}
F2fsTruncateNodeFtraceEvent::F2fsTruncateNodeFtraceEvent(const F2fsTruncateNodeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  F2fsTruncateNodeFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){}
    , decltype(_impl_.ino_){}
    , decltype(_impl_.nid_){}
    , decltype(_impl_.blk_addr_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.dev_, &from._impl_.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.blk_addr_) -
    reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.blk_addr_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsTruncateNodeFtraceEvent)
}

inline void F2fsTruncateNodeFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){uint64_t{0u}}
    , decltype(_impl_.ino_){uint64_t{0u}}
    , decltype(_impl_.nid_){0u}
    , decltype(_impl_.blk_addr_){0u}
  };
}

F2fsTruncateNodeFtraceEvent::~F2fsTruncateNodeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsTruncateNodeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsTruncateNodeFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsTruncateNodeFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void F2fsTruncateNodeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsTruncateNodeFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.blk_addr_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.blk_addr_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsTruncateNodeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 nid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_nid(&has_bits);
          _impl_.nid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 blk_addr = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_blk_addr(&has_bits);
          _impl_.blk_addr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsTruncateNodeFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsTruncateNodeFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint32 nid = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_nid(), target);
  }

  // optional uint32 blk_addr = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_blk_addr(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsTruncateNodeFtraceEvent)
  return target;
}

size_t F2fsTruncateNodeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsTruncateNodeFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint32 nid = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nid());
    }

    // optional uint32 blk_addr = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_blk_addr());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsTruncateNodeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsTruncateNodeFtraceEvent*>(
      &from));
}

void F2fsTruncateNodeFtraceEvent::MergeFrom(const F2fsTruncateNodeFtraceEvent& from) {
  F2fsTruncateNodeFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsTruncateNodeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.nid_ = from._impl_.nid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.blk_addr_ = from._impl_.blk_addr_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsTruncateNodeFtraceEvent::CopyFrom(const F2fsTruncateNodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsTruncateNodeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsTruncateNodeFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsTruncateNodeFtraceEvent::InternalSwap(F2fsTruncateNodeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsTruncateNodeFtraceEvent, _impl_.blk_addr_)
      + sizeof(F2fsTruncateNodeFtraceEvent::_impl_.blk_addr_)
      - PROTOBUF_FIELD_OFFSET(F2fsTruncateNodeFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

std::string F2fsTruncateNodeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsTruncateNodeFtraceEvent";
}


// ===================================================================

class F2fsTruncateNodesEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsTruncateNodesEnterFtraceEvent>()._impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_nid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_blk_addr(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

F2fsTruncateNodesEnterFtraceEvent::F2fsTruncateNodesEnterFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsTruncateNodesEnterFtraceEvent)
}
F2fsTruncateNodesEnterFtraceEvent::F2fsTruncateNodesEnterFtraceEvent(const F2fsTruncateNodesEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  F2fsTruncateNodesEnterFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){}
    , decltype(_impl_.ino_){}
    , decltype(_impl_.nid_){}
    , decltype(_impl_.blk_addr_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.dev_, &from._impl_.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.blk_addr_) -
    reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.blk_addr_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsTruncateNodesEnterFtraceEvent)
}

inline void F2fsTruncateNodesEnterFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){uint64_t{0u}}
    , decltype(_impl_.ino_){uint64_t{0u}}
    , decltype(_impl_.nid_){0u}
    , decltype(_impl_.blk_addr_){0u}
  };
}

F2fsTruncateNodesEnterFtraceEvent::~F2fsTruncateNodesEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsTruncateNodesEnterFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsTruncateNodesEnterFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsTruncateNodesEnterFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void F2fsTruncateNodesEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsTruncateNodesEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.blk_addr_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.blk_addr_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsTruncateNodesEnterFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 nid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_nid(&has_bits);
          _impl_.nid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 blk_addr = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_blk_addr(&has_bits);
          _impl_.blk_addr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsTruncateNodesEnterFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsTruncateNodesEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint32 nid = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_nid(), target);
  }

  // optional uint32 blk_addr = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_blk_addr(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsTruncateNodesEnterFtraceEvent)
  return target;
}

size_t F2fsTruncateNodesEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsTruncateNodesEnterFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint32 nid = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nid());
    }

    // optional uint32 blk_addr = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_blk_addr());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsTruncateNodesEnterFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsTruncateNodesEnterFtraceEvent*>(
      &from));
}

void F2fsTruncateNodesEnterFtraceEvent::MergeFrom(const F2fsTruncateNodesEnterFtraceEvent& from) {
  F2fsTruncateNodesEnterFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsTruncateNodesEnterFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.nid_ = from._impl_.nid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.blk_addr_ = from._impl_.blk_addr_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsTruncateNodesEnterFtraceEvent::CopyFrom(const F2fsTruncateNodesEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsTruncateNodesEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsTruncateNodesEnterFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsTruncateNodesEnterFtraceEvent::InternalSwap(F2fsTruncateNodesEnterFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsTruncateNodesEnterFtraceEvent, _impl_.blk_addr_)
      + sizeof(F2fsTruncateNodesEnterFtraceEvent::_impl_.blk_addr_)
      - PROTOBUF_FIELD_OFFSET(F2fsTruncateNodesEnterFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

std::string F2fsTruncateNodesEnterFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsTruncateNodesEnterFtraceEvent";
}


// ===================================================================

class F2fsTruncateNodesExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsTruncateNodesExitFtraceEvent>()._impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

F2fsTruncateNodesExitFtraceEvent::F2fsTruncateNodesExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsTruncateNodesExitFtraceEvent)
}
F2fsTruncateNodesExitFtraceEvent::F2fsTruncateNodesExitFtraceEvent(const F2fsTruncateNodesExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  F2fsTruncateNodesExitFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){}
    , decltype(_impl_.ino_){}
    , decltype(_impl_.ret_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.dev_, &from._impl_.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ret_) -
    reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.ret_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsTruncateNodesExitFtraceEvent)
}

inline void F2fsTruncateNodesExitFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){uint64_t{0u}}
    , decltype(_impl_.ino_){uint64_t{0u}}
    , decltype(_impl_.ret_){0}
  };
}

F2fsTruncateNodesExitFtraceEvent::~F2fsTruncateNodesExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsTruncateNodesExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsTruncateNodesExitFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsTruncateNodesExitFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void F2fsTruncateNodesExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsTruncateNodesExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ret_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.ret_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsTruncateNodesExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ret = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_ret(&has_bits);
          _impl_.ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsTruncateNodesExitFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsTruncateNodesExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int32 ret = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsTruncateNodesExitFtraceEvent)
  return target;
}

size_t F2fsTruncateNodesExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsTruncateNodesExitFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int32 ret = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ret());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsTruncateNodesExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsTruncateNodesExitFtraceEvent*>(
      &from));
}

void F2fsTruncateNodesExitFtraceEvent::MergeFrom(const F2fsTruncateNodesExitFtraceEvent& from) {
  F2fsTruncateNodesExitFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsTruncateNodesExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ret_ = from._impl_.ret_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsTruncateNodesExitFtraceEvent::CopyFrom(const F2fsTruncateNodesExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsTruncateNodesExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsTruncateNodesExitFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsTruncateNodesExitFtraceEvent::InternalSwap(F2fsTruncateNodesExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsTruncateNodesExitFtraceEvent, _impl_.ret_)
      + sizeof(F2fsTruncateNodesExitFtraceEvent::_impl_.ret_)
      - PROTOBUF_FIELD_OFFSET(F2fsTruncateNodesExitFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

std::string F2fsTruncateNodesExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsTruncateNodesExitFtraceEvent";
}


// ===================================================================

class F2fsTruncatePartialNodesFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsTruncatePartialNodesFtraceEvent>()._impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_nid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_depth(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_err(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

F2fsTruncatePartialNodesFtraceEvent::F2fsTruncatePartialNodesFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsTruncatePartialNodesFtraceEvent)
}
F2fsTruncatePartialNodesFtraceEvent::F2fsTruncatePartialNodesFtraceEvent(const F2fsTruncatePartialNodesFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  F2fsTruncatePartialNodesFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){}
    , decltype(_impl_.ino_){}
    , decltype(_impl_.nid_){}
    , decltype(_impl_.depth_){}
    , decltype(_impl_.err_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.dev_, &from._impl_.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.err_) -
    reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.err_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsTruncatePartialNodesFtraceEvent)
}

inline void F2fsTruncatePartialNodesFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){uint64_t{0u}}
    , decltype(_impl_.ino_){uint64_t{0u}}
    , decltype(_impl_.nid_){0u}
    , decltype(_impl_.depth_){0}
    , decltype(_impl_.err_){0}
  };
}

F2fsTruncatePartialNodesFtraceEvent::~F2fsTruncatePartialNodesFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsTruncatePartialNodesFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsTruncatePartialNodesFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsTruncatePartialNodesFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void F2fsTruncatePartialNodesFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsTruncatePartialNodesFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.err_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.err_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsTruncatePartialNodesFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 nid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_nid(&has_bits);
          _impl_.nid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 depth = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_depth(&has_bits);
          _impl_.depth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 err = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_err(&has_bits);
          _impl_.err_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsTruncatePartialNodesFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsTruncatePartialNodesFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional uint32 nid = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_nid(), target);
  }

  // optional int32 depth = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_depth(), target);
  }

  // optional int32 err = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_err(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsTruncatePartialNodesFtraceEvent)
  return target;
}

size_t F2fsTruncatePartialNodesFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsTruncatePartialNodesFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional uint32 nid = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nid());
    }

    // optional int32 depth = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_depth());
    }

    // optional int32 err = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_err());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsTruncatePartialNodesFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsTruncatePartialNodesFtraceEvent*>(
      &from));
}

void F2fsTruncatePartialNodesFtraceEvent::MergeFrom(const F2fsTruncatePartialNodesFtraceEvent& from) {
  F2fsTruncatePartialNodesFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsTruncatePartialNodesFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.nid_ = from._impl_.nid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.depth_ = from._impl_.depth_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.err_ = from._impl_.err_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsTruncatePartialNodesFtraceEvent::CopyFrom(const F2fsTruncatePartialNodesFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsTruncatePartialNodesFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsTruncatePartialNodesFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsTruncatePartialNodesFtraceEvent::InternalSwap(F2fsTruncatePartialNodesFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsTruncatePartialNodesFtraceEvent, _impl_.err_)
      + sizeof(F2fsTruncatePartialNodesFtraceEvent::_impl_.err_)
      - PROTOBUF_FIELD_OFFSET(F2fsTruncatePartialNodesFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

std::string F2fsTruncatePartialNodesFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsTruncatePartialNodesFtraceEvent";
}


// ===================================================================

class F2fsUnlinkEnterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsUnlinkEnterFtraceEvent>()._impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

F2fsUnlinkEnterFtraceEvent::F2fsUnlinkEnterFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsUnlinkEnterFtraceEvent)
}
F2fsUnlinkEnterFtraceEvent::F2fsUnlinkEnterFtraceEvent(const F2fsUnlinkEnterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  F2fsUnlinkEnterFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.dev_){}
    , decltype(_impl_.ino_){}
    , decltype(_impl_.size_){}
    , decltype(_impl_.blocks_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.dev_, &from._impl_.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.blocks_) -
    reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.blocks_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsUnlinkEnterFtraceEvent)
}

inline void F2fsUnlinkEnterFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.dev_){uint64_t{0u}}
    , decltype(_impl_.ino_){uint64_t{0u}}
    , decltype(_impl_.size_){int64_t{0}}
    , decltype(_impl_.blocks_){uint64_t{0u}}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

F2fsUnlinkEnterFtraceEvent::~F2fsUnlinkEnterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsUnlinkEnterFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsUnlinkEnterFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void F2fsUnlinkEnterFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void F2fsUnlinkEnterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsUnlinkEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.blocks_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.blocks_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsUnlinkEnterFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 blocks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_blocks(&has_bits);
          _impl_.blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsUnlinkEnterFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsUnlinkEnterFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int64 size = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_size(), target);
  }

  // optional uint64 blocks = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_blocks(), target);
  }

  // optional string name = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsUnlinkEnterFtraceEvent)
  return target;
}

size_t F2fsUnlinkEnterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsUnlinkEnterFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string name = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int64 size = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_size());
    }

    // optional uint64 blocks = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_blocks());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsUnlinkEnterFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsUnlinkEnterFtraceEvent*>(
      &from));
}

void F2fsUnlinkEnterFtraceEvent::MergeFrom(const F2fsUnlinkEnterFtraceEvent& from) {
  F2fsUnlinkEnterFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsUnlinkEnterFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.blocks_ = from._impl_.blocks_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsUnlinkEnterFtraceEvent::CopyFrom(const F2fsUnlinkEnterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsUnlinkEnterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsUnlinkEnterFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsUnlinkEnterFtraceEvent::InternalSwap(F2fsUnlinkEnterFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsUnlinkEnterFtraceEvent, _impl_.blocks_)
      + sizeof(F2fsUnlinkEnterFtraceEvent::_impl_.blocks_)
      - PROTOBUF_FIELD_OFFSET(F2fsUnlinkEnterFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

std::string F2fsUnlinkEnterFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsUnlinkEnterFtraceEvent";
}


// ===================================================================

class F2fsUnlinkExitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsUnlinkExitFtraceEvent>()._impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

F2fsUnlinkExitFtraceEvent::F2fsUnlinkExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsUnlinkExitFtraceEvent)
}
F2fsUnlinkExitFtraceEvent::F2fsUnlinkExitFtraceEvent(const F2fsUnlinkExitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  F2fsUnlinkExitFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){}
    , decltype(_impl_.ino_){}
    , decltype(_impl_.ret_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.dev_, &from._impl_.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ret_) -
    reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.ret_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsUnlinkExitFtraceEvent)
}

inline void F2fsUnlinkExitFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){uint64_t{0u}}
    , decltype(_impl_.ino_){uint64_t{0u}}
    , decltype(_impl_.ret_){0}
  };
}

F2fsUnlinkExitFtraceEvent::~F2fsUnlinkExitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsUnlinkExitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsUnlinkExitFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsUnlinkExitFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void F2fsUnlinkExitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsUnlinkExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ret_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.ret_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsUnlinkExitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ret = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_ret(&has_bits);
          _impl_.ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsUnlinkExitFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsUnlinkExitFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int32 ret = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_ret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsUnlinkExitFtraceEvent)
  return target;
}

size_t F2fsUnlinkExitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsUnlinkExitFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int32 ret = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ret());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsUnlinkExitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsUnlinkExitFtraceEvent*>(
      &from));
}

void F2fsUnlinkExitFtraceEvent::MergeFrom(const F2fsUnlinkExitFtraceEvent& from) {
  F2fsUnlinkExitFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsUnlinkExitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ret_ = from._impl_.ret_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsUnlinkExitFtraceEvent::CopyFrom(const F2fsUnlinkExitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsUnlinkExitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsUnlinkExitFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsUnlinkExitFtraceEvent::InternalSwap(F2fsUnlinkExitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsUnlinkExitFtraceEvent, _impl_.ret_)
      + sizeof(F2fsUnlinkExitFtraceEvent::_impl_.ret_)
      - PROTOBUF_FIELD_OFFSET(F2fsUnlinkExitFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

std::string F2fsUnlinkExitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsUnlinkExitFtraceEvent";
}


// ===================================================================

class F2fsVmPageMkwriteFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsVmPageMkwriteFtraceEvent>()._impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_dir(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_dirty(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_uptodate(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

F2fsVmPageMkwriteFtraceEvent::F2fsVmPageMkwriteFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsVmPageMkwriteFtraceEvent)
}
F2fsVmPageMkwriteFtraceEvent::F2fsVmPageMkwriteFtraceEvent(const F2fsVmPageMkwriteFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  F2fsVmPageMkwriteFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){}
    , decltype(_impl_.ino_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.dir_){}
    , decltype(_impl_.index_){}
    , decltype(_impl_.dirty_){}
    , decltype(_impl_.uptodate_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.dev_, &from._impl_.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.uptodate_) -
    reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.uptodate_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsVmPageMkwriteFtraceEvent)
}

inline void F2fsVmPageMkwriteFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){uint64_t{0u}}
    , decltype(_impl_.ino_){uint64_t{0u}}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.dir_){0}
    , decltype(_impl_.index_){uint64_t{0u}}
    , decltype(_impl_.dirty_){0}
    , decltype(_impl_.uptodate_){0}
  };
}

F2fsVmPageMkwriteFtraceEvent::~F2fsVmPageMkwriteFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsVmPageMkwriteFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsVmPageMkwriteFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsVmPageMkwriteFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void F2fsVmPageMkwriteFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsVmPageMkwriteFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&_impl_.dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.uptodate_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.uptodate_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsVmPageMkwriteFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 dir = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_dir(&has_bits);
          _impl_.dir_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 index = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_index(&has_bits);
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 dirty = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_dirty(&has_bits);
          _impl_.dirty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 uptodate = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_uptodate(&has_bits);
          _impl_.uptodate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsVmPageMkwriteFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsVmPageMkwriteFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int32 type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_type(), target);
  }

  // optional int32 dir = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_dir(), target);
  }

  // optional uint64 index = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_index(), target);
  }

  // optional int32 dirty = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_dirty(), target);
  }

  // optional int32 uptodate = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_uptodate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsVmPageMkwriteFtraceEvent)
  return target;
}

size_t F2fsVmPageMkwriteFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsVmPageMkwriteFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int32 type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_type());
    }

    // optional int32 dir = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dir());
    }

    // optional uint64 index = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_index());
    }

    // optional int32 dirty = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dirty());
    }

    // optional int32 uptodate = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_uptodate());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsVmPageMkwriteFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsVmPageMkwriteFtraceEvent*>(
      &from));
}

void F2fsVmPageMkwriteFtraceEvent::MergeFrom(const F2fsVmPageMkwriteFtraceEvent& from) {
  F2fsVmPageMkwriteFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsVmPageMkwriteFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.dir_ = from._impl_.dir_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.index_ = from._impl_.index_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.dirty_ = from._impl_.dirty_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.uptodate_ = from._impl_.uptodate_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsVmPageMkwriteFtraceEvent::CopyFrom(const F2fsVmPageMkwriteFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsVmPageMkwriteFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsVmPageMkwriteFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsVmPageMkwriteFtraceEvent::InternalSwap(F2fsVmPageMkwriteFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsVmPageMkwriteFtraceEvent, _impl_.uptodate_)
      + sizeof(F2fsVmPageMkwriteFtraceEvent::_impl_.uptodate_)
      - PROTOBUF_FIELD_OFFSET(F2fsVmPageMkwriteFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

std::string F2fsVmPageMkwriteFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsVmPageMkwriteFtraceEvent";
}


// ===================================================================

class F2fsWriteBeginFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsWriteBeginFtraceEvent>()._impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

F2fsWriteBeginFtraceEvent::F2fsWriteBeginFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsWriteBeginFtraceEvent)
}
F2fsWriteBeginFtraceEvent::F2fsWriteBeginFtraceEvent(const F2fsWriteBeginFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  F2fsWriteBeginFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){}
    , decltype(_impl_.ino_){}
    , decltype(_impl_.pos_){}
    , decltype(_impl_.len_){}
    , decltype(_impl_.flags_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.dev_, &from._impl_.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.flags_) -
    reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.flags_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsWriteBeginFtraceEvent)
}

inline void F2fsWriteBeginFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){uint64_t{0u}}
    , decltype(_impl_.ino_){uint64_t{0u}}
    , decltype(_impl_.pos_){int64_t{0}}
    , decltype(_impl_.len_){0u}
    , decltype(_impl_.flags_){0u}
  };
}

F2fsWriteBeginFtraceEvent::~F2fsWriteBeginFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsWriteBeginFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsWriteBeginFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsWriteBeginFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void F2fsWriteBeginFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsWriteBeginFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.flags_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.flags_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsWriteBeginFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 pos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_pos(&has_bits);
          _impl_.pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsWriteBeginFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsWriteBeginFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int64 pos = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_pos(), target);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_len(), target);
  }

  // optional uint32 flags = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsWriteBeginFtraceEvent)
  return target;
}

size_t F2fsWriteBeginFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsWriteBeginFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int64 pos = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_pos());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_len());
    }

    // optional uint32 flags = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsWriteBeginFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsWriteBeginFtraceEvent*>(
      &from));
}

void F2fsWriteBeginFtraceEvent::MergeFrom(const F2fsWriteBeginFtraceEvent& from) {
  F2fsWriteBeginFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsWriteBeginFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pos_ = from._impl_.pos_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsWriteBeginFtraceEvent::CopyFrom(const F2fsWriteBeginFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsWriteBeginFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsWriteBeginFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsWriteBeginFtraceEvent::InternalSwap(F2fsWriteBeginFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsWriteBeginFtraceEvent, _impl_.flags_)
      + sizeof(F2fsWriteBeginFtraceEvent::_impl_.flags_)
      - PROTOBUF_FIELD_OFFSET(F2fsWriteBeginFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

std::string F2fsWriteBeginFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsWriteBeginFtraceEvent";
}


// ===================================================================

class F2fsWriteCheckpointFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsWriteCheckpointFtraceEvent>()._impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_umount(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_msg(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

F2fsWriteCheckpointFtraceEvent::F2fsWriteCheckpointFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsWriteCheckpointFtraceEvent)
}
F2fsWriteCheckpointFtraceEvent::F2fsWriteCheckpointFtraceEvent(const F2fsWriteCheckpointFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  F2fsWriteCheckpointFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.msg_){}
    , decltype(_impl_.dev_){}
    , decltype(_impl_.is_umount_){}
    , decltype(_impl_.reason_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.msg_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.msg_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_msg()) {
    _this->_impl_.msg_.Set(from._internal_msg(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.dev_, &from._impl_.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.reason_) -
    reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.reason_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsWriteCheckpointFtraceEvent)
}

inline void F2fsWriteCheckpointFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.msg_){}
    , decltype(_impl_.dev_){uint64_t{0u}}
    , decltype(_impl_.is_umount_){0u}
    , decltype(_impl_.reason_){0}
  };
  _impl_.msg_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.msg_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

F2fsWriteCheckpointFtraceEvent::~F2fsWriteCheckpointFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsWriteCheckpointFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsWriteCheckpointFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.msg_.Destroy();
}

void F2fsWriteCheckpointFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void F2fsWriteCheckpointFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsWriteCheckpointFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.msg_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.reason_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.reason_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsWriteCheckpointFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 is_umount = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_is_umount(&has_bits);
          _impl_.is_umount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string msg = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_msg();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 reason = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_reason(&has_bits);
          _impl_.reason_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsWriteCheckpointFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsWriteCheckpointFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint32 is_umount = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_is_umount(), target);
  }

  // optional string msg = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_msg(), target);
  }

  // optional int32 reason = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_reason(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsWriteCheckpointFtraceEvent)
  return target;
}

size_t F2fsWriteCheckpointFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsWriteCheckpointFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string msg = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_msg());
    }

    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint32 is_umount = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_is_umount());
    }

    // optional int32 reason = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_reason());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsWriteCheckpointFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsWriteCheckpointFtraceEvent*>(
      &from));
}

void F2fsWriteCheckpointFtraceEvent::MergeFrom(const F2fsWriteCheckpointFtraceEvent& from) {
  F2fsWriteCheckpointFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsWriteCheckpointFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_msg(from._internal_msg());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.is_umount_ = from._impl_.is_umount_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.reason_ = from._impl_.reason_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsWriteCheckpointFtraceEvent::CopyFrom(const F2fsWriteCheckpointFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsWriteCheckpointFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsWriteCheckpointFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsWriteCheckpointFtraceEvent::InternalSwap(F2fsWriteCheckpointFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.msg_, lhs_arena,
      &other->_impl_.msg_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsWriteCheckpointFtraceEvent, _impl_.reason_)
      + sizeof(F2fsWriteCheckpointFtraceEvent::_impl_.reason_)
      - PROTOBUF_FIELD_OFFSET(F2fsWriteCheckpointFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

std::string F2fsWriteCheckpointFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsWriteCheckpointFtraceEvent";
}


// ===================================================================

class F2fsWriteEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsWriteEndFtraceEvent>()._impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ino(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_copied(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

F2fsWriteEndFtraceEvent::F2fsWriteEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsWriteEndFtraceEvent)
}
F2fsWriteEndFtraceEvent::F2fsWriteEndFtraceEvent(const F2fsWriteEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  F2fsWriteEndFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){}
    , decltype(_impl_.ino_){}
    , decltype(_impl_.pos_){}
    , decltype(_impl_.len_){}
    , decltype(_impl_.copied_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.dev_, &from._impl_.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.copied_) -
    reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.copied_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsWriteEndFtraceEvent)
}

inline void F2fsWriteEndFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){uint64_t{0u}}
    , decltype(_impl_.ino_){uint64_t{0u}}
    , decltype(_impl_.pos_){int64_t{0}}
    , decltype(_impl_.len_){0u}
    , decltype(_impl_.copied_){0u}
  };
}

F2fsWriteEndFtraceEvent::~F2fsWriteEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsWriteEndFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsWriteEndFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsWriteEndFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void F2fsWriteEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsWriteEndFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.copied_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.copied_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsWriteEndFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ino = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ino(&has_bits);
          _impl_.ino_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 pos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_pos(&has_bits);
          _impl_.pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 copied = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_copied(&has_bits);
          _impl_.copied_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsWriteEndFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsWriteEndFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint64 ino = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ino(), target);
  }

  // optional int64 pos = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_pos(), target);
  }

  // optional uint32 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_len(), target);
  }

  // optional uint32 copied = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_copied(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsWriteEndFtraceEvent)
  return target;
}

size_t F2fsWriteEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsWriteEndFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 ino = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ino());
    }

    // optional int64 pos = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_pos());
    }

    // optional uint32 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_len());
    }

    // optional uint32 copied = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_copied());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsWriteEndFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsWriteEndFtraceEvent*>(
      &from));
}

void F2fsWriteEndFtraceEvent::MergeFrom(const F2fsWriteEndFtraceEvent& from) {
  F2fsWriteEndFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsWriteEndFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ino_ = from._impl_.ino_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pos_ = from._impl_.pos_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.copied_ = from._impl_.copied_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsWriteEndFtraceEvent::CopyFrom(const F2fsWriteEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsWriteEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsWriteEndFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsWriteEndFtraceEvent::InternalSwap(F2fsWriteEndFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsWriteEndFtraceEvent, _impl_.copied_)
      + sizeof(F2fsWriteEndFtraceEvent::_impl_.copied_)
      - PROTOBUF_FIELD_OFFSET(F2fsWriteEndFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

std::string F2fsWriteEndFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsWriteEndFtraceEvent";
}


// ===================================================================

class F2fsIostatFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsIostatFtraceEvent>()._impl_._has_bits_);
  static void set_has_app_bio(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_app_brio(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_app_dio(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_app_drio(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_app_mio(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_app_mrio(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_app_rio(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_app_wio(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_fs_cdrio(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_fs_cp_dio(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_fs_cp_mio(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_fs_cp_nio(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_fs_dio(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_fs_discard(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_fs_drio(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_fs_gc_dio(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_fs_gc_nio(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_fs_gdrio(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_fs_mio(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_fs_mrio(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_fs_nio(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_fs_nrio(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
};

F2fsIostatFtraceEvent::F2fsIostatFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsIostatFtraceEvent)
}
F2fsIostatFtraceEvent::F2fsIostatFtraceEvent(const F2fsIostatFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  F2fsIostatFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.app_bio_){}
    , decltype(_impl_.app_brio_){}
    , decltype(_impl_.app_dio_){}
    , decltype(_impl_.app_drio_){}
    , decltype(_impl_.app_mio_){}
    , decltype(_impl_.app_mrio_){}
    , decltype(_impl_.app_rio_){}
    , decltype(_impl_.app_wio_){}
    , decltype(_impl_.dev_){}
    , decltype(_impl_.fs_cdrio_){}
    , decltype(_impl_.fs_cp_dio_){}
    , decltype(_impl_.fs_cp_mio_){}
    , decltype(_impl_.fs_cp_nio_){}
    , decltype(_impl_.fs_dio_){}
    , decltype(_impl_.fs_discard_){}
    , decltype(_impl_.fs_drio_){}
    , decltype(_impl_.fs_gc_dio_){}
    , decltype(_impl_.fs_gc_nio_){}
    , decltype(_impl_.fs_gdrio_){}
    , decltype(_impl_.fs_mio_){}
    , decltype(_impl_.fs_mrio_){}
    , decltype(_impl_.fs_nio_){}
    , decltype(_impl_.fs_nrio_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.app_bio_, &from._impl_.app_bio_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.fs_nrio_) -
    reinterpret_cast<char*>(&_impl_.app_bio_)) + sizeof(_impl_.fs_nrio_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsIostatFtraceEvent)
}

inline void F2fsIostatFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.app_bio_){uint64_t{0u}}
    , decltype(_impl_.app_brio_){uint64_t{0u}}
    , decltype(_impl_.app_dio_){uint64_t{0u}}
    , decltype(_impl_.app_drio_){uint64_t{0u}}
    , decltype(_impl_.app_mio_){uint64_t{0u}}
    , decltype(_impl_.app_mrio_){uint64_t{0u}}
    , decltype(_impl_.app_rio_){uint64_t{0u}}
    , decltype(_impl_.app_wio_){uint64_t{0u}}
    , decltype(_impl_.dev_){uint64_t{0u}}
    , decltype(_impl_.fs_cdrio_){uint64_t{0u}}
    , decltype(_impl_.fs_cp_dio_){uint64_t{0u}}
    , decltype(_impl_.fs_cp_mio_){uint64_t{0u}}
    , decltype(_impl_.fs_cp_nio_){uint64_t{0u}}
    , decltype(_impl_.fs_dio_){uint64_t{0u}}
    , decltype(_impl_.fs_discard_){uint64_t{0u}}
    , decltype(_impl_.fs_drio_){uint64_t{0u}}
    , decltype(_impl_.fs_gc_dio_){uint64_t{0u}}
    , decltype(_impl_.fs_gc_nio_){uint64_t{0u}}
    , decltype(_impl_.fs_gdrio_){uint64_t{0u}}
    , decltype(_impl_.fs_mio_){uint64_t{0u}}
    , decltype(_impl_.fs_mrio_){uint64_t{0u}}
    , decltype(_impl_.fs_nio_){uint64_t{0u}}
    , decltype(_impl_.fs_nrio_){uint64_t{0u}}
  };
}

F2fsIostatFtraceEvent::~F2fsIostatFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsIostatFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsIostatFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsIostatFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void F2fsIostatFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsIostatFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.app_bio_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.app_wio_) -
        reinterpret_cast<char*>(&_impl_.app_bio_)) + sizeof(_impl_.app_wio_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.fs_drio_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.fs_drio_));
  }
  if (cached_has_bits & 0x007f0000u) {
    ::memset(&_impl_.fs_gc_dio_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.fs_nrio_) -
        reinterpret_cast<char*>(&_impl_.fs_gc_dio_)) + sizeof(_impl_.fs_nrio_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsIostatFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 app_bio = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_app_bio(&has_bits);
          _impl_.app_bio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 app_brio = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_app_brio(&has_bits);
          _impl_.app_brio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 app_dio = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_app_dio(&has_bits);
          _impl_.app_dio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 app_drio = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_app_drio(&has_bits);
          _impl_.app_drio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 app_mio = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_app_mio(&has_bits);
          _impl_.app_mio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 app_mrio = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_app_mrio(&has_bits);
          _impl_.app_mrio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 app_rio = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_app_rio(&has_bits);
          _impl_.app_rio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 app_wio = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_app_wio(&has_bits);
          _impl_.app_wio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 dev = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 fs_cdrio = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_fs_cdrio(&has_bits);
          _impl_.fs_cdrio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 fs_cp_dio = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_fs_cp_dio(&has_bits);
          _impl_.fs_cp_dio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 fs_cp_mio = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_fs_cp_mio(&has_bits);
          _impl_.fs_cp_mio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 fs_cp_nio = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_fs_cp_nio(&has_bits);
          _impl_.fs_cp_nio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 fs_dio = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_fs_dio(&has_bits);
          _impl_.fs_dio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 fs_discard = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_fs_discard(&has_bits);
          _impl_.fs_discard_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 fs_drio = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_fs_drio(&has_bits);
          _impl_.fs_drio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 fs_gc_dio = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_fs_gc_dio(&has_bits);
          _impl_.fs_gc_dio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 fs_gc_nio = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_fs_gc_nio(&has_bits);
          _impl_.fs_gc_nio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 fs_gdrio = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_fs_gdrio(&has_bits);
          _impl_.fs_gdrio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 fs_mio = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_fs_mio(&has_bits);
          _impl_.fs_mio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 fs_mrio = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_fs_mrio(&has_bits);
          _impl_.fs_mrio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 fs_nio = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_fs_nio(&has_bits);
          _impl_.fs_nio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 fs_nrio = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_fs_nrio(&has_bits);
          _impl_.fs_nrio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsIostatFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsIostatFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 app_bio = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_app_bio(), target);
  }

  // optional uint64 app_brio = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_app_brio(), target);
  }

  // optional uint64 app_dio = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_app_dio(), target);
  }

  // optional uint64 app_drio = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_app_drio(), target);
  }

  // optional uint64 app_mio = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_app_mio(), target);
  }

  // optional uint64 app_mrio = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_app_mrio(), target);
  }

  // optional uint64 app_rio = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_app_rio(), target);
  }

  // optional uint64 app_wio = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(8, this->_internal_app_wio(), target);
  }

  // optional uint64 dev = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(9, this->_internal_dev(), target);
  }

  // optional uint64 fs_cdrio = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(10, this->_internal_fs_cdrio(), target);
  }

  // optional uint64 fs_cp_dio = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(11, this->_internal_fs_cp_dio(), target);
  }

  // optional uint64 fs_cp_mio = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(12, this->_internal_fs_cp_mio(), target);
  }

  // optional uint64 fs_cp_nio = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(13, this->_internal_fs_cp_nio(), target);
  }

  // optional uint64 fs_dio = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(14, this->_internal_fs_dio(), target);
  }

  // optional uint64 fs_discard = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(15, this->_internal_fs_discard(), target);
  }

  // optional uint64 fs_drio = 16;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(16, this->_internal_fs_drio(), target);
  }

  // optional uint64 fs_gc_dio = 17;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(17, this->_internal_fs_gc_dio(), target);
  }

  // optional uint64 fs_gc_nio = 18;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(18, this->_internal_fs_gc_nio(), target);
  }

  // optional uint64 fs_gdrio = 19;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(19, this->_internal_fs_gdrio(), target);
  }

  // optional uint64 fs_mio = 20;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(20, this->_internal_fs_mio(), target);
  }

  // optional uint64 fs_mrio = 21;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(21, this->_internal_fs_mrio(), target);
  }

  // optional uint64 fs_nio = 22;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(22, this->_internal_fs_nio(), target);
  }

  // optional uint64 fs_nrio = 23;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(23, this->_internal_fs_nrio(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsIostatFtraceEvent)
  return target;
}

size_t F2fsIostatFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsIostatFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 app_bio = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_app_bio());
    }

    // optional uint64 app_brio = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_app_brio());
    }

    // optional uint64 app_dio = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_app_dio());
    }

    // optional uint64 app_drio = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_app_drio());
    }

    // optional uint64 app_mio = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_app_mio());
    }

    // optional uint64 app_mrio = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_app_mrio());
    }

    // optional uint64 app_rio = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_app_rio());
    }

    // optional uint64 app_wio = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_app_wio());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint64 dev = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint64 fs_cdrio = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_fs_cdrio());
    }

    // optional uint64 fs_cp_dio = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_fs_cp_dio());
    }

    // optional uint64 fs_cp_mio = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_fs_cp_mio());
    }

    // optional uint64 fs_cp_nio = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_fs_cp_nio());
    }

    // optional uint64 fs_dio = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_fs_dio());
    }

    // optional uint64 fs_discard = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_fs_discard());
    }

    // optional uint64 fs_drio = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_fs_drio());
    }

  }
  if (cached_has_bits & 0x007f0000u) {
    // optional uint64 fs_gc_dio = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_fs_gc_dio());
    }

    // optional uint64 fs_gc_nio = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_fs_gc_nio());
    }

    // optional uint64 fs_gdrio = 19;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_fs_gdrio());
    }

    // optional uint64 fs_mio = 20;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_fs_mio());
    }

    // optional uint64 fs_mrio = 21;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_fs_mrio());
    }

    // optional uint64 fs_nio = 22;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_fs_nio());
    }

    // optional uint64 fs_nrio = 23;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_fs_nrio());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsIostatFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsIostatFtraceEvent*>(
      &from));
}

void F2fsIostatFtraceEvent::MergeFrom(const F2fsIostatFtraceEvent& from) {
  F2fsIostatFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsIostatFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.app_bio_ = from._impl_.app_bio_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.app_brio_ = from._impl_.app_brio_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.app_dio_ = from._impl_.app_dio_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.app_drio_ = from._impl_.app_drio_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.app_mio_ = from._impl_.app_mio_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.app_mrio_ = from._impl_.app_mrio_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.app_rio_ = from._impl_.app_rio_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.app_wio_ = from._impl_.app_wio_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.fs_cdrio_ = from._impl_.fs_cdrio_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.fs_cp_dio_ = from._impl_.fs_cp_dio_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.fs_cp_mio_ = from._impl_.fs_cp_mio_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.fs_cp_nio_ = from._impl_.fs_cp_nio_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.fs_dio_ = from._impl_.fs_dio_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.fs_discard_ = from._impl_.fs_discard_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.fs_drio_ = from._impl_.fs_drio_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x007f0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.fs_gc_dio_ = from._impl_.fs_gc_dio_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.fs_gc_nio_ = from._impl_.fs_gc_nio_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.fs_gdrio_ = from._impl_.fs_gdrio_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.fs_mio_ = from._impl_.fs_mio_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.fs_mrio_ = from._impl_.fs_mrio_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.fs_nio_ = from._impl_.fs_nio_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.fs_nrio_ = from._impl_.fs_nrio_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsIostatFtraceEvent::CopyFrom(const F2fsIostatFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsIostatFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsIostatFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsIostatFtraceEvent::InternalSwap(F2fsIostatFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsIostatFtraceEvent, _impl_.fs_nrio_)
      + sizeof(F2fsIostatFtraceEvent::_impl_.fs_nrio_)
      - PROTOBUF_FIELD_OFFSET(F2fsIostatFtraceEvent, _impl_.app_bio_)>(
          reinterpret_cast<char*>(&_impl_.app_bio_),
          reinterpret_cast<char*>(&other->_impl_.app_bio_));
}

std::string F2fsIostatFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsIostatFtraceEvent";
}


// ===================================================================

class F2fsIostatLatencyFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsIostatLatencyFtraceEvent>()._impl_._has_bits_);
  static void set_has_d_rd_avg(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_d_rd_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_d_rd_peak(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_d_wr_as_avg(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_d_wr_as_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_d_wr_as_peak(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_d_wr_s_avg(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_d_wr_s_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_d_wr_s_peak(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_m_rd_avg(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_m_rd_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_m_rd_peak(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_m_wr_as_avg(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_m_wr_as_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_m_wr_as_peak(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_m_wr_s_avg(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_m_wr_s_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_m_wr_s_peak(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_n_rd_avg(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_n_rd_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_n_rd_peak(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_n_wr_as_avg(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_n_wr_as_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_n_wr_as_peak(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_n_wr_s_avg(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_n_wr_s_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_n_wr_s_peak(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
};

F2fsIostatLatencyFtraceEvent::F2fsIostatLatencyFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsIostatLatencyFtraceEvent)
}
F2fsIostatLatencyFtraceEvent::F2fsIostatLatencyFtraceEvent(const F2fsIostatLatencyFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  F2fsIostatLatencyFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.d_rd_avg_){}
    , decltype(_impl_.d_rd_cnt_){}
    , decltype(_impl_.d_rd_peak_){}
    , decltype(_impl_.d_wr_as_avg_){}
    , decltype(_impl_.d_wr_as_cnt_){}
    , decltype(_impl_.d_wr_as_peak_){}
    , decltype(_impl_.d_wr_s_avg_){}
    , decltype(_impl_.d_wr_s_cnt_){}
    , decltype(_impl_.dev_){}
    , decltype(_impl_.d_wr_s_peak_){}
    , decltype(_impl_.m_rd_avg_){}
    , decltype(_impl_.m_rd_cnt_){}
    , decltype(_impl_.m_rd_peak_){}
    , decltype(_impl_.m_wr_as_avg_){}
    , decltype(_impl_.m_wr_as_cnt_){}
    , decltype(_impl_.m_wr_as_peak_){}
    , decltype(_impl_.m_wr_s_avg_){}
    , decltype(_impl_.m_wr_s_cnt_){}
    , decltype(_impl_.m_wr_s_peak_){}
    , decltype(_impl_.n_rd_avg_){}
    , decltype(_impl_.n_rd_cnt_){}
    , decltype(_impl_.n_rd_peak_){}
    , decltype(_impl_.n_wr_as_avg_){}
    , decltype(_impl_.n_wr_as_cnt_){}
    , decltype(_impl_.n_wr_as_peak_){}
    , decltype(_impl_.n_wr_s_avg_){}
    , decltype(_impl_.n_wr_s_cnt_){}
    , decltype(_impl_.n_wr_s_peak_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.d_rd_avg_, &from._impl_.d_rd_avg_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.n_wr_s_peak_) -
    reinterpret_cast<char*>(&_impl_.d_rd_avg_)) + sizeof(_impl_.n_wr_s_peak_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsIostatLatencyFtraceEvent)
}

inline void F2fsIostatLatencyFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.d_rd_avg_){0u}
    , decltype(_impl_.d_rd_cnt_){0u}
    , decltype(_impl_.d_rd_peak_){0u}
    , decltype(_impl_.d_wr_as_avg_){0u}
    , decltype(_impl_.d_wr_as_cnt_){0u}
    , decltype(_impl_.d_wr_as_peak_){0u}
    , decltype(_impl_.d_wr_s_avg_){0u}
    , decltype(_impl_.d_wr_s_cnt_){0u}
    , decltype(_impl_.dev_){uint64_t{0u}}
    , decltype(_impl_.d_wr_s_peak_){0u}
    , decltype(_impl_.m_rd_avg_){0u}
    , decltype(_impl_.m_rd_cnt_){0u}
    , decltype(_impl_.m_rd_peak_){0u}
    , decltype(_impl_.m_wr_as_avg_){0u}
    , decltype(_impl_.m_wr_as_cnt_){0u}
    , decltype(_impl_.m_wr_as_peak_){0u}
    , decltype(_impl_.m_wr_s_avg_){0u}
    , decltype(_impl_.m_wr_s_cnt_){0u}
    , decltype(_impl_.m_wr_s_peak_){0u}
    , decltype(_impl_.n_rd_avg_){0u}
    , decltype(_impl_.n_rd_cnt_){0u}
    , decltype(_impl_.n_rd_peak_){0u}
    , decltype(_impl_.n_wr_as_avg_){0u}
    , decltype(_impl_.n_wr_as_cnt_){0u}
    , decltype(_impl_.n_wr_as_peak_){0u}
    , decltype(_impl_.n_wr_s_avg_){0u}
    , decltype(_impl_.n_wr_s_cnt_){0u}
    , decltype(_impl_.n_wr_s_peak_){0u}
  };
}

F2fsIostatLatencyFtraceEvent::~F2fsIostatLatencyFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsIostatLatencyFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsIostatLatencyFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsIostatLatencyFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void F2fsIostatLatencyFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsIostatLatencyFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.d_rd_avg_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.d_wr_s_cnt_) -
        reinterpret_cast<char*>(&_impl_.d_rd_avg_)) + sizeof(_impl_.d_wr_s_cnt_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.m_wr_as_peak_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.m_wr_as_peak_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.m_wr_s_avg_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.n_wr_as_cnt_) -
        reinterpret_cast<char*>(&_impl_.m_wr_s_avg_)) + sizeof(_impl_.n_wr_as_cnt_));
  }
  if (cached_has_bits & 0x0f000000u) {
    ::memset(&_impl_.n_wr_as_peak_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.n_wr_s_peak_) -
        reinterpret_cast<char*>(&_impl_.n_wr_as_peak_)) + sizeof(_impl_.n_wr_s_peak_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsIostatLatencyFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 d_rd_avg = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_d_rd_avg(&has_bits);
          _impl_.d_rd_avg_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 d_rd_cnt = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_d_rd_cnt(&has_bits);
          _impl_.d_rd_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 d_rd_peak = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_d_rd_peak(&has_bits);
          _impl_.d_rd_peak_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 d_wr_as_avg = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_d_wr_as_avg(&has_bits);
          _impl_.d_wr_as_avg_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 d_wr_as_cnt = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_d_wr_as_cnt(&has_bits);
          _impl_.d_wr_as_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 d_wr_as_peak = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_d_wr_as_peak(&has_bits);
          _impl_.d_wr_as_peak_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 d_wr_s_avg = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_d_wr_s_avg(&has_bits);
          _impl_.d_wr_s_avg_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 d_wr_s_cnt = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_d_wr_s_cnt(&has_bits);
          _impl_.d_wr_s_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 d_wr_s_peak = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_d_wr_s_peak(&has_bits);
          _impl_.d_wr_s_peak_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 dev = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 m_rd_avg = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_m_rd_avg(&has_bits);
          _impl_.m_rd_avg_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 m_rd_cnt = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_m_rd_cnt(&has_bits);
          _impl_.m_rd_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 m_rd_peak = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_m_rd_peak(&has_bits);
          _impl_.m_rd_peak_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 m_wr_as_avg = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_m_wr_as_avg(&has_bits);
          _impl_.m_wr_as_avg_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 m_wr_as_cnt = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_m_wr_as_cnt(&has_bits);
          _impl_.m_wr_as_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 m_wr_as_peak = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_m_wr_as_peak(&has_bits);
          _impl_.m_wr_as_peak_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 m_wr_s_avg = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_m_wr_s_avg(&has_bits);
          _impl_.m_wr_s_avg_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 m_wr_s_cnt = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_m_wr_s_cnt(&has_bits);
          _impl_.m_wr_s_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 m_wr_s_peak = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_m_wr_s_peak(&has_bits);
          _impl_.m_wr_s_peak_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 n_rd_avg = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_n_rd_avg(&has_bits);
          _impl_.n_rd_avg_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 n_rd_cnt = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_n_rd_cnt(&has_bits);
          _impl_.n_rd_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 n_rd_peak = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_n_rd_peak(&has_bits);
          _impl_.n_rd_peak_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 n_wr_as_avg = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_n_wr_as_avg(&has_bits);
          _impl_.n_wr_as_avg_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 n_wr_as_cnt = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_n_wr_as_cnt(&has_bits);
          _impl_.n_wr_as_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 n_wr_as_peak = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _Internal::set_has_n_wr_as_peak(&has_bits);
          _impl_.n_wr_as_peak_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 n_wr_s_avg = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_n_wr_s_avg(&has_bits);
          _impl_.n_wr_s_avg_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 n_wr_s_cnt = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _Internal::set_has_n_wr_s_cnt(&has_bits);
          _impl_.n_wr_s_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 n_wr_s_peak = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_n_wr_s_peak(&has_bits);
          _impl_.n_wr_s_peak_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsIostatLatencyFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsIostatLatencyFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 d_rd_avg = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_d_rd_avg(), target);
  }

  // optional uint32 d_rd_cnt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_d_rd_cnt(), target);
  }

  // optional uint32 d_rd_peak = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_d_rd_peak(), target);
  }

  // optional uint32 d_wr_as_avg = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_d_wr_as_avg(), target);
  }

  // optional uint32 d_wr_as_cnt = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_d_wr_as_cnt(), target);
  }

  // optional uint32 d_wr_as_peak = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_d_wr_as_peak(), target);
  }

  // optional uint32 d_wr_s_avg = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_d_wr_s_avg(), target);
  }

  // optional uint32 d_wr_s_cnt = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_d_wr_s_cnt(), target);
  }

  // optional uint32 d_wr_s_peak = 9;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_d_wr_s_peak(), target);
  }

  // optional uint64 dev = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(10, this->_internal_dev(), target);
  }

  // optional uint32 m_rd_avg = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_m_rd_avg(), target);
  }

  // optional uint32 m_rd_cnt = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_m_rd_cnt(), target);
  }

  // optional uint32 m_rd_peak = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_m_rd_peak(), target);
  }

  // optional uint32 m_wr_as_avg = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_m_wr_as_avg(), target);
  }

  // optional uint32 m_wr_as_cnt = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_m_wr_as_cnt(), target);
  }

  // optional uint32 m_wr_as_peak = 16;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(16, this->_internal_m_wr_as_peak(), target);
  }

  // optional uint32 m_wr_s_avg = 17;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(17, this->_internal_m_wr_s_avg(), target);
  }

  // optional uint32 m_wr_s_cnt = 18;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(18, this->_internal_m_wr_s_cnt(), target);
  }

  // optional uint32 m_wr_s_peak = 19;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(19, this->_internal_m_wr_s_peak(), target);
  }

  // optional uint32 n_rd_avg = 20;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(20, this->_internal_n_rd_avg(), target);
  }

  // optional uint32 n_rd_cnt = 21;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_n_rd_cnt(), target);
  }

  // optional uint32 n_rd_peak = 22;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(22, this->_internal_n_rd_peak(), target);
  }

  // optional uint32 n_wr_as_avg = 23;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(23, this->_internal_n_wr_as_avg(), target);
  }

  // optional uint32 n_wr_as_cnt = 24;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(24, this->_internal_n_wr_as_cnt(), target);
  }

  // optional uint32 n_wr_as_peak = 25;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(25, this->_internal_n_wr_as_peak(), target);
  }

  // optional uint32 n_wr_s_avg = 26;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(26, this->_internal_n_wr_s_avg(), target);
  }

  // optional uint32 n_wr_s_cnt = 27;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(27, this->_internal_n_wr_s_cnt(), target);
  }

  // optional uint32 n_wr_s_peak = 28;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(28, this->_internal_n_wr_s_peak(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsIostatLatencyFtraceEvent)
  return target;
}

size_t F2fsIostatLatencyFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsIostatLatencyFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 d_rd_avg = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_d_rd_avg());
    }

    // optional uint32 d_rd_cnt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_d_rd_cnt());
    }

    // optional uint32 d_rd_peak = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_d_rd_peak());
    }

    // optional uint32 d_wr_as_avg = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_d_wr_as_avg());
    }

    // optional uint32 d_wr_as_cnt = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_d_wr_as_cnt());
    }

    // optional uint32 d_wr_as_peak = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_d_wr_as_peak());
    }

    // optional uint32 d_wr_s_avg = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_d_wr_s_avg());
    }

    // optional uint32 d_wr_s_cnt = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_d_wr_s_cnt());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint64 dev = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint32 d_wr_s_peak = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_d_wr_s_peak());
    }

    // optional uint32 m_rd_avg = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_m_rd_avg());
    }

    // optional uint32 m_rd_cnt = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_m_rd_cnt());
    }

    // optional uint32 m_rd_peak = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_m_rd_peak());
    }

    // optional uint32 m_wr_as_avg = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_m_wr_as_avg());
    }

    // optional uint32 m_wr_as_cnt = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_m_wr_as_cnt());
    }

    // optional uint32 m_wr_as_peak = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_m_wr_as_peak());
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional uint32 m_wr_s_avg = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_m_wr_s_avg());
    }

    // optional uint32 m_wr_s_cnt = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_m_wr_s_cnt());
    }

    // optional uint32 m_wr_s_peak = 19;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_m_wr_s_peak());
    }

    // optional uint32 n_rd_avg = 20;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_n_rd_avg());
    }

    // optional uint32 n_rd_cnt = 21;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_n_rd_cnt());
    }

    // optional uint32 n_rd_peak = 22;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_n_rd_peak());
    }

    // optional uint32 n_wr_as_avg = 23;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_n_wr_as_avg());
    }

    // optional uint32 n_wr_as_cnt = 24;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_n_wr_as_cnt());
    }

  }
  if (cached_has_bits & 0x0f000000u) {
    // optional uint32 n_wr_as_peak = 25;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_n_wr_as_peak());
    }

    // optional uint32 n_wr_s_avg = 26;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_n_wr_s_avg());
    }

    // optional uint32 n_wr_s_cnt = 27;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_n_wr_s_cnt());
    }

    // optional uint32 n_wr_s_peak = 28;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_n_wr_s_peak());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsIostatLatencyFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsIostatLatencyFtraceEvent*>(
      &from));
}

void F2fsIostatLatencyFtraceEvent::MergeFrom(const F2fsIostatLatencyFtraceEvent& from) {
  F2fsIostatLatencyFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsIostatLatencyFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.d_rd_avg_ = from._impl_.d_rd_avg_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.d_rd_cnt_ = from._impl_.d_rd_cnt_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.d_rd_peak_ = from._impl_.d_rd_peak_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.d_wr_as_avg_ = from._impl_.d_wr_as_avg_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.d_wr_as_cnt_ = from._impl_.d_wr_as_cnt_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.d_wr_as_peak_ = from._impl_.d_wr_as_peak_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.d_wr_s_avg_ = from._impl_.d_wr_s_avg_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.d_wr_s_cnt_ = from._impl_.d_wr_s_cnt_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.d_wr_s_peak_ = from._impl_.d_wr_s_peak_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.m_rd_avg_ = from._impl_.m_rd_avg_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.m_rd_cnt_ = from._impl_.m_rd_cnt_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.m_rd_peak_ = from._impl_.m_rd_peak_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.m_wr_as_avg_ = from._impl_.m_wr_as_avg_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.m_wr_as_cnt_ = from._impl_.m_wr_as_cnt_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.m_wr_as_peak_ = from._impl_.m_wr_as_peak_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.m_wr_s_avg_ = from._impl_.m_wr_s_avg_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.m_wr_s_cnt_ = from._impl_.m_wr_s_cnt_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.m_wr_s_peak_ = from._impl_.m_wr_s_peak_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.n_rd_avg_ = from._impl_.n_rd_avg_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.n_rd_cnt_ = from._impl_.n_rd_cnt_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.n_rd_peak_ = from._impl_.n_rd_peak_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.n_wr_as_avg_ = from._impl_.n_wr_as_avg_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.n_wr_as_cnt_ = from._impl_.n_wr_as_cnt_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0f000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.n_wr_as_peak_ = from._impl_.n_wr_as_peak_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.n_wr_s_avg_ = from._impl_.n_wr_s_avg_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.n_wr_s_cnt_ = from._impl_.n_wr_s_cnt_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.n_wr_s_peak_ = from._impl_.n_wr_s_peak_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsIostatLatencyFtraceEvent::CopyFrom(const F2fsIostatLatencyFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsIostatLatencyFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsIostatLatencyFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsIostatLatencyFtraceEvent::InternalSwap(F2fsIostatLatencyFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsIostatLatencyFtraceEvent, _impl_.n_wr_s_peak_)
      + sizeof(F2fsIostatLatencyFtraceEvent::_impl_.n_wr_s_peak_)
      - PROTOBUF_FIELD_OFFSET(F2fsIostatLatencyFtraceEvent, _impl_.d_rd_avg_)>(
          reinterpret_cast<char*>(&_impl_.d_rd_avg_),
          reinterpret_cast<char*>(&other->_impl_.d_rd_avg_));
}

std::string F2fsIostatLatencyFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsIostatLatencyFtraceEvent";
}


// ===================================================================

class F2fsBackgroundGcFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsBackgroundGcFtraceEvent>()._impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_wait_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_prefree(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_free(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

F2fsBackgroundGcFtraceEvent::F2fsBackgroundGcFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsBackgroundGcFtraceEvent)
}
F2fsBackgroundGcFtraceEvent::F2fsBackgroundGcFtraceEvent(const F2fsBackgroundGcFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  F2fsBackgroundGcFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){}
    , decltype(_impl_.wait_ms_){}
    , decltype(_impl_.prefree_){}
    , decltype(_impl_.free_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.dev_, &from._impl_.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.free_) -
    reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.free_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsBackgroundGcFtraceEvent)
}

inline void F2fsBackgroundGcFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){uint64_t{0u}}
    , decltype(_impl_.wait_ms_){0u}
    , decltype(_impl_.prefree_){0u}
    , decltype(_impl_.free_){0u}
  };
}

F2fsBackgroundGcFtraceEvent::~F2fsBackgroundGcFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsBackgroundGcFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsBackgroundGcFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsBackgroundGcFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void F2fsBackgroundGcFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsBackgroundGcFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.free_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.free_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsBackgroundGcFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 wait_ms = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_wait_ms(&has_bits);
          _impl_.wait_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 prefree = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_prefree(&has_bits);
          _impl_.prefree_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 free = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_free(&has_bits);
          _impl_.free_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsBackgroundGcFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsBackgroundGcFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint32 wait_ms = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_wait_ms(), target);
  }

  // optional uint32 prefree = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_prefree(), target);
  }

  // optional uint32 free = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_free(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsBackgroundGcFtraceEvent)
  return target;
}

size_t F2fsBackgroundGcFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsBackgroundGcFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint32 wait_ms = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_wait_ms());
    }

    // optional uint32 prefree = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_prefree());
    }

    // optional uint32 free = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_free());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsBackgroundGcFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsBackgroundGcFtraceEvent*>(
      &from));
}

void F2fsBackgroundGcFtraceEvent::MergeFrom(const F2fsBackgroundGcFtraceEvent& from) {
  F2fsBackgroundGcFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsBackgroundGcFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.wait_ms_ = from._impl_.wait_ms_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.prefree_ = from._impl_.prefree_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.free_ = from._impl_.free_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsBackgroundGcFtraceEvent::CopyFrom(const F2fsBackgroundGcFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsBackgroundGcFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsBackgroundGcFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsBackgroundGcFtraceEvent::InternalSwap(F2fsBackgroundGcFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsBackgroundGcFtraceEvent, _impl_.free_)
      + sizeof(F2fsBackgroundGcFtraceEvent::_impl_.free_)
      - PROTOBUF_FIELD_OFFSET(F2fsBackgroundGcFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

std::string F2fsBackgroundGcFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsBackgroundGcFtraceEvent";
}


// ===================================================================

class F2fsGcBeginFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsGcBeginFtraceEvent>()._impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sync(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_background(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_dirty_nodes(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_dirty_dents(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_dirty_imeta(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_free_sec(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_free_seg(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_reserved_seg(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_prefree_seg(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_gc_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_no_bg_gc(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_nr_free_secs(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
};

F2fsGcBeginFtraceEvent::F2fsGcBeginFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsGcBeginFtraceEvent)
}
F2fsGcBeginFtraceEvent::F2fsGcBeginFtraceEvent(const F2fsGcBeginFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  F2fsGcBeginFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){}
    , decltype(_impl_.sync_){}
    , decltype(_impl_.background_){}
    , decltype(_impl_.dirty_nodes_){}
    , decltype(_impl_.dirty_dents_){}
    , decltype(_impl_.dirty_imeta_){}
    , decltype(_impl_.free_sec_){}
    , decltype(_impl_.free_seg_){}
    , decltype(_impl_.reserved_seg_){}
    , decltype(_impl_.prefree_seg_){}
    , decltype(_impl_.gc_type_){}
    , decltype(_impl_.no_bg_gc_){}
    , decltype(_impl_.nr_free_secs_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.dev_, &from._impl_.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.nr_free_secs_) -
    reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.nr_free_secs_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsGcBeginFtraceEvent)
}

inline void F2fsGcBeginFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){uint64_t{0u}}
    , decltype(_impl_.sync_){0u}
    , decltype(_impl_.background_){0u}
    , decltype(_impl_.dirty_nodes_){int64_t{0}}
    , decltype(_impl_.dirty_dents_){int64_t{0}}
    , decltype(_impl_.dirty_imeta_){int64_t{0}}
    , decltype(_impl_.free_sec_){0u}
    , decltype(_impl_.free_seg_){0u}
    , decltype(_impl_.reserved_seg_){0}
    , decltype(_impl_.prefree_seg_){0u}
    , decltype(_impl_.gc_type_){0}
    , decltype(_impl_.no_bg_gc_){0u}
    , decltype(_impl_.nr_free_secs_){0u}
  };
}

F2fsGcBeginFtraceEvent::~F2fsGcBeginFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsGcBeginFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsGcBeginFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsGcBeginFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void F2fsGcBeginFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsGcBeginFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.free_seg_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.free_seg_));
  }
  if (cached_has_bits & 0x00001f00u) {
    ::memset(&_impl_.reserved_seg_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.nr_free_secs_) -
        reinterpret_cast<char*>(&_impl_.reserved_seg_)) + sizeof(_impl_.nr_free_secs_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsGcBeginFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 sync = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_sync(&has_bits);
          _impl_.sync_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 background = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_background(&has_bits);
          _impl_.background_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 dirty_nodes = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_dirty_nodes(&has_bits);
          _impl_.dirty_nodes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 dirty_dents = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_dirty_dents(&has_bits);
          _impl_.dirty_dents_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 dirty_imeta = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_dirty_imeta(&has_bits);
          _impl_.dirty_imeta_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 free_sec = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_free_sec(&has_bits);
          _impl_.free_sec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 free_seg = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_free_seg(&has_bits);
          _impl_.free_seg_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 reserved_seg = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_reserved_seg(&has_bits);
          _impl_.reserved_seg_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 prefree_seg = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_prefree_seg(&has_bits);
          _impl_.prefree_seg_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 gc_type = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_gc_type(&has_bits);
          _impl_.gc_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 no_bg_gc = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_no_bg_gc(&has_bits);
          _impl_.no_bg_gc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 nr_free_secs = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_nr_free_secs(&has_bits);
          _impl_.nr_free_secs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsGcBeginFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsGcBeginFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional uint32 sync = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_sync(), target);
  }

  // optional uint32 background = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_background(), target);
  }

  // optional int64 dirty_nodes = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_dirty_nodes(), target);
  }

  // optional int64 dirty_dents = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_dirty_dents(), target);
  }

  // optional int64 dirty_imeta = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_dirty_imeta(), target);
  }

  // optional uint32 free_sec = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_free_sec(), target);
  }

  // optional uint32 free_seg = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_free_seg(), target);
  }

  // optional int32 reserved_seg = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_reserved_seg(), target);
  }

  // optional uint32 prefree_seg = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_prefree_seg(), target);
  }

  // optional int32 gc_type = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(11, this->_internal_gc_type(), target);
  }

  // optional uint32 no_bg_gc = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_no_bg_gc(), target);
  }

  // optional uint32 nr_free_secs = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_nr_free_secs(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsGcBeginFtraceEvent)
  return target;
}

size_t F2fsGcBeginFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsGcBeginFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional uint32 sync = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sync());
    }

    // optional uint32 background = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_background());
    }

    // optional int64 dirty_nodes = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_dirty_nodes());
    }

    // optional int64 dirty_dents = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_dirty_dents());
    }

    // optional int64 dirty_imeta = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_dirty_imeta());
    }

    // optional uint32 free_sec = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_free_sec());
    }

    // optional uint32 free_seg = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_free_seg());
    }

  }
  if (cached_has_bits & 0x00001f00u) {
    // optional int32 reserved_seg = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_reserved_seg());
    }

    // optional uint32 prefree_seg = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_prefree_seg());
    }

    // optional int32 gc_type = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_gc_type());
    }

    // optional uint32 no_bg_gc = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_no_bg_gc());
    }

    // optional uint32 nr_free_secs = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nr_free_secs());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsGcBeginFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsGcBeginFtraceEvent*>(
      &from));
}

void F2fsGcBeginFtraceEvent::MergeFrom(const F2fsGcBeginFtraceEvent& from) {
  F2fsGcBeginFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsGcBeginFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.sync_ = from._impl_.sync_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.background_ = from._impl_.background_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.dirty_nodes_ = from._impl_.dirty_nodes_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.dirty_dents_ = from._impl_.dirty_dents_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.dirty_imeta_ = from._impl_.dirty_imeta_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.free_sec_ = from._impl_.free_sec_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.free_seg_ = from._impl_.free_seg_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.reserved_seg_ = from._impl_.reserved_seg_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.prefree_seg_ = from._impl_.prefree_seg_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.gc_type_ = from._impl_.gc_type_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.no_bg_gc_ = from._impl_.no_bg_gc_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.nr_free_secs_ = from._impl_.nr_free_secs_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsGcBeginFtraceEvent::CopyFrom(const F2fsGcBeginFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsGcBeginFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsGcBeginFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsGcBeginFtraceEvent::InternalSwap(F2fsGcBeginFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsGcBeginFtraceEvent, _impl_.nr_free_secs_)
      + sizeof(F2fsGcBeginFtraceEvent::_impl_.nr_free_secs_)
      - PROTOBUF_FIELD_OFFSET(F2fsGcBeginFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

std::string F2fsGcBeginFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsGcBeginFtraceEvent";
}


// ===================================================================

class F2fsGcEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<F2fsGcEndFtraceEvent>()._impl_._has_bits_);
  static void set_has_dev(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ret(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_seg_freed(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sec_freed(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_dirty_nodes(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_dirty_dents(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_dirty_imeta(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_free_sec(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_free_seg(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_reserved_seg(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_prefree_seg(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

F2fsGcEndFtraceEvent::F2fsGcEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.F2fsGcEndFtraceEvent)
}
F2fsGcEndFtraceEvent::F2fsGcEndFtraceEvent(const F2fsGcEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  F2fsGcEndFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){}
    , decltype(_impl_.ret_){}
    , decltype(_impl_.seg_freed_){}
    , decltype(_impl_.dirty_nodes_){}
    , decltype(_impl_.dirty_dents_){}
    , decltype(_impl_.sec_freed_){}
    , decltype(_impl_.free_sec_){}
    , decltype(_impl_.dirty_imeta_){}
    , decltype(_impl_.free_seg_){}
    , decltype(_impl_.reserved_seg_){}
    , decltype(_impl_.prefree_seg_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.dev_, &from._impl_.dev_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.prefree_seg_) -
    reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.prefree_seg_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.F2fsGcEndFtraceEvent)
}

inline void F2fsGcEndFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dev_){uint64_t{0u}}
    , decltype(_impl_.ret_){0}
    , decltype(_impl_.seg_freed_){0}
    , decltype(_impl_.dirty_nodes_){int64_t{0}}
    , decltype(_impl_.dirty_dents_){int64_t{0}}
    , decltype(_impl_.sec_freed_){0}
    , decltype(_impl_.free_sec_){0u}
    , decltype(_impl_.dirty_imeta_){int64_t{0}}
    , decltype(_impl_.free_seg_){0u}
    , decltype(_impl_.reserved_seg_){0}
    , decltype(_impl_.prefree_seg_){0u}
  };
}

F2fsGcEndFtraceEvent::~F2fsGcEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.F2fsGcEndFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void F2fsGcEndFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void F2fsGcEndFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void F2fsGcEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.F2fsGcEndFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.dev_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.dirty_imeta_) -
        reinterpret_cast<char*>(&_impl_.dev_)) + sizeof(_impl_.dirty_imeta_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.free_seg_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.prefree_seg_) -
        reinterpret_cast<char*>(&_impl_.free_seg_)) + sizeof(_impl_.prefree_seg_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* F2fsGcEndFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dev = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dev(&has_bits);
          _impl_.dev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ret = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ret(&has_bits);
          _impl_.ret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 seg_freed = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_seg_freed(&has_bits);
          _impl_.seg_freed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 sec_freed = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_sec_freed(&has_bits);
          _impl_.sec_freed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 dirty_nodes = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_dirty_nodes(&has_bits);
          _impl_.dirty_nodes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 dirty_dents = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_dirty_dents(&has_bits);
          _impl_.dirty_dents_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 dirty_imeta = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_dirty_imeta(&has_bits);
          _impl_.dirty_imeta_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 free_sec = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_free_sec(&has_bits);
          _impl_.free_sec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 free_seg = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_free_seg(&has_bits);
          _impl_.free_seg_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 reserved_seg = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_reserved_seg(&has_bits);
          _impl_.reserved_seg_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 prefree_seg = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_prefree_seg(&has_bits);
          _impl_.prefree_seg_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* F2fsGcEndFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.F2fsGcEndFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dev = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dev(), target);
  }

  // optional int32 ret = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_ret(), target);
  }

  // optional int32 seg_freed = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_seg_freed(), target);
  }

  // optional int32 sec_freed = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_sec_freed(), target);
  }

  // optional int64 dirty_nodes = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_dirty_nodes(), target);
  }

  // optional int64 dirty_dents = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_dirty_dents(), target);
  }

  // optional int64 dirty_imeta = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(7, this->_internal_dirty_imeta(), target);
  }

  // optional uint32 free_sec = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_free_sec(), target);
  }

  // optional uint32 free_seg = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_free_seg(), target);
  }

  // optional int32 reserved_seg = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_reserved_seg(), target);
  }

  // optional uint32 prefree_seg = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_prefree_seg(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.F2fsGcEndFtraceEvent)
  return target;
}

size_t F2fsGcEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.F2fsGcEndFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 dev = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dev());
    }

    // optional int32 ret = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ret());
    }

    // optional int32 seg_freed = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_seg_freed());
    }

    // optional int64 dirty_nodes = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_dirty_nodes());
    }

    // optional int64 dirty_dents = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_dirty_dents());
    }

    // optional int32 sec_freed = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sec_freed());
    }

    // optional uint32 free_sec = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_free_sec());
    }

    // optional int64 dirty_imeta = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_dirty_imeta());
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional uint32 free_seg = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_free_seg());
    }

    // optional int32 reserved_seg = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_reserved_seg());
    }

    // optional uint32 prefree_seg = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_prefree_seg());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void F2fsGcEndFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const F2fsGcEndFtraceEvent*>(
      &from));
}

void F2fsGcEndFtraceEvent::MergeFrom(const F2fsGcEndFtraceEvent& from) {
  F2fsGcEndFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.F2fsGcEndFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dev_ = from._impl_.dev_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ret_ = from._impl_.ret_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.seg_freed_ = from._impl_.seg_freed_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.dirty_nodes_ = from._impl_.dirty_nodes_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.dirty_dents_ = from._impl_.dirty_dents_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.sec_freed_ = from._impl_.sec_freed_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.free_sec_ = from._impl_.free_sec_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.dirty_imeta_ = from._impl_.dirty_imeta_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.free_seg_ = from._impl_.free_seg_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.reserved_seg_ = from._impl_.reserved_seg_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.prefree_seg_ = from._impl_.prefree_seg_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void F2fsGcEndFtraceEvent::CopyFrom(const F2fsGcEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.F2fsGcEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool F2fsGcEndFtraceEvent::IsInitialized() const {
  return true;
}

void F2fsGcEndFtraceEvent::InternalSwap(F2fsGcEndFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(F2fsGcEndFtraceEvent, _impl_.prefree_seg_)
      + sizeof(F2fsGcEndFtraceEvent::_impl_.prefree_seg_)
      - PROTOBUF_FIELD_OFFSET(F2fsGcEndFtraceEvent, _impl_.dev_)>(
          reinterpret_cast<char*>(&_impl_.dev_),
          reinterpret_cast<char*>(&other->_impl_.dev_));
}

std::string F2fsGcEndFtraceEvent::GetTypeName() const {
  return "perfetto.protos.F2fsGcEndFtraceEvent";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace protos
}  // namespace perfetto
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsDoSubmitBioFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsDoSubmitBioFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsDoSubmitBioFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsEvictInodeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsEvictInodeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsEvictInodeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsFallocateFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsFallocateFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsFallocateFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsGetDataBlockFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsGetDataBlockFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsGetDataBlockFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsGetVictimFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsGetVictimFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsGetVictimFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsIgetFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsIgetFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsIgetFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsIgetExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsIgetExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsIgetExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsNewInodeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsNewInodeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsNewInodeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsReadpageFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsReadpageFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsReadpageFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsReserveNewBlockFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsReserveNewBlockFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsReserveNewBlockFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsSetPageDirtyFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsSetPageDirtyFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsSetPageDirtyFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsSubmitWritePageFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsSubmitWritePageFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsSubmitWritePageFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsSyncFileEnterFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsSyncFileEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsSyncFileEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsSyncFileExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsSyncFileExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsSyncFileExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsSyncFsFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsSyncFsFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsSyncFsFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsTruncateFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsTruncateFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsTruncateFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsTruncateBlocksEnterFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsTruncateBlocksEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsTruncateBlocksEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsTruncateBlocksExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsTruncateBlocksExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsTruncateBlocksExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsTruncateDataBlocksRangeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsTruncateDataBlocksRangeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsTruncateDataBlocksRangeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsTruncateInodeBlocksEnterFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsTruncateInodeBlocksEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsTruncateInodeBlocksEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsTruncateInodeBlocksExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsTruncateInodeBlocksExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsTruncateInodeBlocksExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsTruncateNodeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsTruncateNodeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsTruncateNodeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsTruncateNodesEnterFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsTruncateNodesEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsTruncateNodesEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsTruncateNodesExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsTruncateNodesExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsTruncateNodesExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsTruncatePartialNodesFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsTruncatePartialNodesFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsTruncatePartialNodesFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsUnlinkEnterFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsUnlinkEnterFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsUnlinkEnterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsUnlinkExitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsUnlinkExitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsUnlinkExitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsVmPageMkwriteFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsVmPageMkwriteFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsVmPageMkwriteFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsWriteBeginFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsWriteBeginFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsWriteBeginFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsWriteCheckpointFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsWriteCheckpointFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsWriteCheckpointFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsWriteEndFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsWriteEndFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsWriteEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsIostatFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsIostatFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsIostatFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsIostatLatencyFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsIostatLatencyFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsIostatLatencyFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsBackgroundGcFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsBackgroundGcFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsBackgroundGcFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsGcBeginFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsGcBeginFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsGcBeginFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::F2fsGcEndFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::F2fsGcEndFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::F2fsGcEndFtraceEvent >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
