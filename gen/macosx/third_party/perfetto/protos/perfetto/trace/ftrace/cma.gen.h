// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_CMA_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_CMA_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class CmaAllocInfoFtraceEvent;
class CmaAllocStartFtraceEvent;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {

class PERFETTO_EXPORT_COMPONENT CmaAllocInfoFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kAlignFieldNumber = 1,
    kCountFieldNumber = 2,
    kErrIsoFieldNumber = 3,
    kErrMigFieldNumber = 4,
    kErrTestFieldNumber = 5,
    kNameFieldNumber = 6,
    kNrMappedFieldNumber = 7,
    kNrMigratedFieldNumber = 8,
    kNrReclaimedFieldNumber = 9,
    kPfnFieldNumber = 10,
  };

  CmaAllocInfoFtraceEvent();
  ~CmaAllocInfoFtraceEvent() override;
  CmaAllocInfoFtraceEvent(CmaAllocInfoFtraceEvent&&) noexcept;
  CmaAllocInfoFtraceEvent& operator=(CmaAllocInfoFtraceEvent&&);
  CmaAllocInfoFtraceEvent(const CmaAllocInfoFtraceEvent&);
  CmaAllocInfoFtraceEvent& operator=(const CmaAllocInfoFtraceEvent&);
  bool operator==(const CmaAllocInfoFtraceEvent&) const;
  bool operator!=(const CmaAllocInfoFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_align() const { return _has_field_[1]; }
  uint32_t align() const { return align_; }
  void set_align(uint32_t value) { align_ = value; _has_field_.set(1); }

  bool has_count() const { return _has_field_[2]; }
  uint32_t count() const { return count_; }
  void set_count(uint32_t value) { count_ = value; _has_field_.set(2); }

  bool has_err_iso() const { return _has_field_[3]; }
  uint32_t err_iso() const { return err_iso_; }
  void set_err_iso(uint32_t value) { err_iso_ = value; _has_field_.set(3); }

  bool has_err_mig() const { return _has_field_[4]; }
  uint32_t err_mig() const { return err_mig_; }
  void set_err_mig(uint32_t value) { err_mig_ = value; _has_field_.set(4); }

  bool has_err_test() const { return _has_field_[5]; }
  uint32_t err_test() const { return err_test_; }
  void set_err_test(uint32_t value) { err_test_ = value; _has_field_.set(5); }

  bool has_name() const { return _has_field_[6]; }
  const std::string& name() const { return name_; }
  void set_name(const std::string& value) { name_ = value; _has_field_.set(6); }

  bool has_nr_mapped() const { return _has_field_[7]; }
  uint64_t nr_mapped() const { return nr_mapped_; }
  void set_nr_mapped(uint64_t value) { nr_mapped_ = value; _has_field_.set(7); }

  bool has_nr_migrated() const { return _has_field_[8]; }
  uint64_t nr_migrated() const { return nr_migrated_; }
  void set_nr_migrated(uint64_t value) { nr_migrated_ = value; _has_field_.set(8); }

  bool has_nr_reclaimed() const { return _has_field_[9]; }
  uint64_t nr_reclaimed() const { return nr_reclaimed_; }
  void set_nr_reclaimed(uint64_t value) { nr_reclaimed_ = value; _has_field_.set(9); }

  bool has_pfn() const { return _has_field_[10]; }
  uint64_t pfn() const { return pfn_; }
  void set_pfn(uint64_t value) { pfn_ = value; _has_field_.set(10); }

 private:
  uint32_t align_{};
  uint32_t count_{};
  uint32_t err_iso_{};
  uint32_t err_mig_{};
  uint32_t err_test_{};
  std::string name_{};
  uint64_t nr_mapped_{};
  uint64_t nr_migrated_{};
  uint64_t nr_reclaimed_{};
  uint64_t pfn_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<11> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT CmaAllocStartFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kAlignFieldNumber = 1,
    kCountFieldNumber = 2,
    kNameFieldNumber = 3,
  };

  CmaAllocStartFtraceEvent();
  ~CmaAllocStartFtraceEvent() override;
  CmaAllocStartFtraceEvent(CmaAllocStartFtraceEvent&&) noexcept;
  CmaAllocStartFtraceEvent& operator=(CmaAllocStartFtraceEvent&&);
  CmaAllocStartFtraceEvent(const CmaAllocStartFtraceEvent&);
  CmaAllocStartFtraceEvent& operator=(const CmaAllocStartFtraceEvent&);
  bool operator==(const CmaAllocStartFtraceEvent&) const;
  bool operator!=(const CmaAllocStartFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_align() const { return _has_field_[1]; }
  uint32_t align() const { return align_; }
  void set_align(uint32_t value) { align_ = value; _has_field_.set(1); }

  bool has_count() const { return _has_field_[2]; }
  uint32_t count() const { return count_; }
  void set_count(uint32_t value) { count_ = value; _has_field_.set(2); }

  bool has_name() const { return _has_field_[3]; }
  const std::string& name() const { return name_; }
  void set_name(const std::string& value) { name_ = value; _has_field_.set(3); }

 private:
  uint32_t align_{};
  uint32_t count_{};
  std::string name_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_CMA_PROTO_CPP_H_
