// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_KVM_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_KVM_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class VgicUpdateIrqPendingFtraceEvent;
class TrapRegFtraceEvent;
class KvmWfxArm64FtraceEvent;
class KvmVcpuWakeupFtraceEvent;
class KvmUserspaceExitFtraceEvent;
class KvmUnmapHvaRangeFtraceEvent;
class KvmToggleCacheFtraceEvent;
class KvmTimerUpdateIrqFtraceEvent;
class KvmTimerSaveStateFtraceEvent;
class KvmTimerRestoreStateFtraceEvent;
class KvmTimerHrtimerExpireFtraceEvent;
class KvmTimerEmulateFtraceEvent;
class KvmTestAgeHvaFtraceEvent;
class KvmSysAccessFtraceEvent;
class KvmSetWayFlushFtraceEvent;
class KvmSetSpteHvaFtraceEvent;
class KvmSetIrqFtraceEvent;
class KvmSetGuestDebugFtraceEvent;
class KvmMmioEmulateFtraceEvent;
class KvmMmioFtraceEvent;
class KvmIrqLineFtraceEvent;
class KvmHvcArm64FtraceEvent;
class KvmHandleSysRegFtraceEvent;
class KvmGuestFaultFtraceEvent;
class KvmGetTimerMapFtraceEvent;
class KvmFpuFtraceEvent;
class KvmExitFtraceEvent;
class KvmEntryFtraceEvent;
class KvmArmSetupDebugFtraceEvent;
class KvmArmSetRegsetFtraceEvent;
class KvmArmSetDreg32FtraceEvent;
class KvmArmClearDebugFtraceEvent;
class KvmAgePageFtraceEvent;
class KvmAgeHvaFtraceEvent;
class KvmAckIrqFtraceEvent;
class KvmAccessFaultFtraceEvent;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {

class PERFETTO_EXPORT_COMPONENT VgicUpdateIrqPendingFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kIrqFieldNumber = 1,
    kLevelFieldNumber = 2,
    kVcpuIdFieldNumber = 3,
  };

  VgicUpdateIrqPendingFtraceEvent();
  ~VgicUpdateIrqPendingFtraceEvent() override;
  VgicUpdateIrqPendingFtraceEvent(VgicUpdateIrqPendingFtraceEvent&&) noexcept;
  VgicUpdateIrqPendingFtraceEvent& operator=(VgicUpdateIrqPendingFtraceEvent&&);
  VgicUpdateIrqPendingFtraceEvent(const VgicUpdateIrqPendingFtraceEvent&);
  VgicUpdateIrqPendingFtraceEvent& operator=(const VgicUpdateIrqPendingFtraceEvent&);
  bool operator==(const VgicUpdateIrqPendingFtraceEvent&) const;
  bool operator!=(const VgicUpdateIrqPendingFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_irq() const { return _has_field_[1]; }
  uint32_t irq() const { return irq_; }
  void set_irq(uint32_t value) { irq_ = value; _has_field_.set(1); }

  bool has_level() const { return _has_field_[2]; }
  uint32_t level() const { return level_; }
  void set_level(uint32_t value) { level_ = value; _has_field_.set(2); }

  bool has_vcpu_id() const { return _has_field_[3]; }
  uint64_t vcpu_id() const { return vcpu_id_; }
  void set_vcpu_id(uint64_t value) { vcpu_id_ = value; _has_field_.set(3); }

 private:
  uint32_t irq_{};
  uint32_t level_{};
  uint64_t vcpu_id_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT TrapRegFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kFnFieldNumber = 1,
    kIsWriteFieldNumber = 2,
    kRegFieldNumber = 3,
    kWriteValueFieldNumber = 4,
  };

  TrapRegFtraceEvent();
  ~TrapRegFtraceEvent() override;
  TrapRegFtraceEvent(TrapRegFtraceEvent&&) noexcept;
  TrapRegFtraceEvent& operator=(TrapRegFtraceEvent&&);
  TrapRegFtraceEvent(const TrapRegFtraceEvent&);
  TrapRegFtraceEvent& operator=(const TrapRegFtraceEvent&);
  bool operator==(const TrapRegFtraceEvent&) const;
  bool operator!=(const TrapRegFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_fn() const { return _has_field_[1]; }
  const std::string& fn() const { return fn_; }
  void set_fn(const std::string& value) { fn_ = value; _has_field_.set(1); }

  bool has_is_write() const { return _has_field_[2]; }
  uint32_t is_write() const { return is_write_; }
  void set_is_write(uint32_t value) { is_write_ = value; _has_field_.set(2); }

  bool has_reg() const { return _has_field_[3]; }
  int32_t reg() const { return reg_; }
  void set_reg(int32_t value) { reg_ = value; _has_field_.set(3); }

  bool has_write_value() const { return _has_field_[4]; }
  uint64_t write_value() const { return write_value_; }
  void set_write_value(uint64_t value) { write_value_ = value; _has_field_.set(4); }

 private:
  std::string fn_{};
  uint32_t is_write_{};
  int32_t reg_{};
  uint64_t write_value_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT KvmWfxArm64FtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kIsWfeFieldNumber = 1,
    kVcpuPcFieldNumber = 2,
  };

  KvmWfxArm64FtraceEvent();
  ~KvmWfxArm64FtraceEvent() override;
  KvmWfxArm64FtraceEvent(KvmWfxArm64FtraceEvent&&) noexcept;
  KvmWfxArm64FtraceEvent& operator=(KvmWfxArm64FtraceEvent&&);
  KvmWfxArm64FtraceEvent(const KvmWfxArm64FtraceEvent&);
  KvmWfxArm64FtraceEvent& operator=(const KvmWfxArm64FtraceEvent&);
  bool operator==(const KvmWfxArm64FtraceEvent&) const;
  bool operator!=(const KvmWfxArm64FtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_is_wfe() const { return _has_field_[1]; }
  uint32_t is_wfe() const { return is_wfe_; }
  void set_is_wfe(uint32_t value) { is_wfe_ = value; _has_field_.set(1); }

  bool has_vcpu_pc() const { return _has_field_[2]; }
  uint64_t vcpu_pc() const { return vcpu_pc_; }
  void set_vcpu_pc(uint64_t value) { vcpu_pc_ = value; _has_field_.set(2); }

 private:
  uint32_t is_wfe_{};
  uint64_t vcpu_pc_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT KvmVcpuWakeupFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kNsFieldNumber = 1,
    kValidFieldNumber = 2,
    kWaitedFieldNumber = 3,
  };

  KvmVcpuWakeupFtraceEvent();
  ~KvmVcpuWakeupFtraceEvent() override;
  KvmVcpuWakeupFtraceEvent(KvmVcpuWakeupFtraceEvent&&) noexcept;
  KvmVcpuWakeupFtraceEvent& operator=(KvmVcpuWakeupFtraceEvent&&);
  KvmVcpuWakeupFtraceEvent(const KvmVcpuWakeupFtraceEvent&);
  KvmVcpuWakeupFtraceEvent& operator=(const KvmVcpuWakeupFtraceEvent&);
  bool operator==(const KvmVcpuWakeupFtraceEvent&) const;
  bool operator!=(const KvmVcpuWakeupFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_ns() const { return _has_field_[1]; }
  uint64_t ns() const { return ns_; }
  void set_ns(uint64_t value) { ns_ = value; _has_field_.set(1); }

  bool has_valid() const { return _has_field_[2]; }
  uint32_t valid() const { return valid_; }
  void set_valid(uint32_t value) { valid_ = value; _has_field_.set(2); }

  bool has_waited() const { return _has_field_[3]; }
  uint32_t waited() const { return waited_; }
  void set_waited(uint32_t value) { waited_ = value; _has_field_.set(3); }

 private:
  uint64_t ns_{};
  uint32_t valid_{};
  uint32_t waited_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT KvmUserspaceExitFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kReasonFieldNumber = 1,
  };

  KvmUserspaceExitFtraceEvent();
  ~KvmUserspaceExitFtraceEvent() override;
  KvmUserspaceExitFtraceEvent(KvmUserspaceExitFtraceEvent&&) noexcept;
  KvmUserspaceExitFtraceEvent& operator=(KvmUserspaceExitFtraceEvent&&);
  KvmUserspaceExitFtraceEvent(const KvmUserspaceExitFtraceEvent&);
  KvmUserspaceExitFtraceEvent& operator=(const KvmUserspaceExitFtraceEvent&);
  bool operator==(const KvmUserspaceExitFtraceEvent&) const;
  bool operator!=(const KvmUserspaceExitFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_reason() const { return _has_field_[1]; }
  uint32_t reason() const { return reason_; }
  void set_reason(uint32_t value) { reason_ = value; _has_field_.set(1); }

 private:
  uint32_t reason_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT KvmUnmapHvaRangeFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kEndFieldNumber = 1,
    kStartFieldNumber = 2,
  };

  KvmUnmapHvaRangeFtraceEvent();
  ~KvmUnmapHvaRangeFtraceEvent() override;
  KvmUnmapHvaRangeFtraceEvent(KvmUnmapHvaRangeFtraceEvent&&) noexcept;
  KvmUnmapHvaRangeFtraceEvent& operator=(KvmUnmapHvaRangeFtraceEvent&&);
  KvmUnmapHvaRangeFtraceEvent(const KvmUnmapHvaRangeFtraceEvent&);
  KvmUnmapHvaRangeFtraceEvent& operator=(const KvmUnmapHvaRangeFtraceEvent&);
  bool operator==(const KvmUnmapHvaRangeFtraceEvent&) const;
  bool operator!=(const KvmUnmapHvaRangeFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_end() const { return _has_field_[1]; }
  uint64_t end() const { return end_; }
  void set_end(uint64_t value) { end_ = value; _has_field_.set(1); }

  bool has_start() const { return _has_field_[2]; }
  uint64_t start() const { return start_; }
  void set_start(uint64_t value) { start_ = value; _has_field_.set(2); }

 private:
  uint64_t end_{};
  uint64_t start_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT KvmToggleCacheFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kNowFieldNumber = 1,
    kVcpuPcFieldNumber = 2,
    kWasFieldNumber = 3,
  };

  KvmToggleCacheFtraceEvent();
  ~KvmToggleCacheFtraceEvent() override;
  KvmToggleCacheFtraceEvent(KvmToggleCacheFtraceEvent&&) noexcept;
  KvmToggleCacheFtraceEvent& operator=(KvmToggleCacheFtraceEvent&&);
  KvmToggleCacheFtraceEvent(const KvmToggleCacheFtraceEvent&);
  KvmToggleCacheFtraceEvent& operator=(const KvmToggleCacheFtraceEvent&);
  bool operator==(const KvmToggleCacheFtraceEvent&) const;
  bool operator!=(const KvmToggleCacheFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_now() const { return _has_field_[1]; }
  uint32_t now() const { return now_; }
  void set_now(uint32_t value) { now_ = value; _has_field_.set(1); }

  bool has_vcpu_pc() const { return _has_field_[2]; }
  uint64_t vcpu_pc() const { return vcpu_pc_; }
  void set_vcpu_pc(uint64_t value) { vcpu_pc_ = value; _has_field_.set(2); }

  bool has_was() const { return _has_field_[3]; }
  uint32_t was() const { return was_; }
  void set_was(uint32_t value) { was_ = value; _has_field_.set(3); }

 private:
  uint32_t now_{};
  uint64_t vcpu_pc_{};
  uint32_t was_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT KvmTimerUpdateIrqFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kIrqFieldNumber = 1,
    kLevelFieldNumber = 2,
    kVcpuIdFieldNumber = 3,
  };

  KvmTimerUpdateIrqFtraceEvent();
  ~KvmTimerUpdateIrqFtraceEvent() override;
  KvmTimerUpdateIrqFtraceEvent(KvmTimerUpdateIrqFtraceEvent&&) noexcept;
  KvmTimerUpdateIrqFtraceEvent& operator=(KvmTimerUpdateIrqFtraceEvent&&);
  KvmTimerUpdateIrqFtraceEvent(const KvmTimerUpdateIrqFtraceEvent&);
  KvmTimerUpdateIrqFtraceEvent& operator=(const KvmTimerUpdateIrqFtraceEvent&);
  bool operator==(const KvmTimerUpdateIrqFtraceEvent&) const;
  bool operator!=(const KvmTimerUpdateIrqFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_irq() const { return _has_field_[1]; }
  uint32_t irq() const { return irq_; }
  void set_irq(uint32_t value) { irq_ = value; _has_field_.set(1); }

  bool has_level() const { return _has_field_[2]; }
  int32_t level() const { return level_; }
  void set_level(int32_t value) { level_ = value; _has_field_.set(2); }

  bool has_vcpu_id() const { return _has_field_[3]; }
  uint64_t vcpu_id() const { return vcpu_id_; }
  void set_vcpu_id(uint64_t value) { vcpu_id_ = value; _has_field_.set(3); }

 private:
  uint32_t irq_{};
  int32_t level_{};
  uint64_t vcpu_id_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT KvmTimerSaveStateFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCtlFieldNumber = 1,
    kCvalFieldNumber = 2,
    kTimerIdxFieldNumber = 3,
  };

  KvmTimerSaveStateFtraceEvent();
  ~KvmTimerSaveStateFtraceEvent() override;
  KvmTimerSaveStateFtraceEvent(KvmTimerSaveStateFtraceEvent&&) noexcept;
  KvmTimerSaveStateFtraceEvent& operator=(KvmTimerSaveStateFtraceEvent&&);
  KvmTimerSaveStateFtraceEvent(const KvmTimerSaveStateFtraceEvent&);
  KvmTimerSaveStateFtraceEvent& operator=(const KvmTimerSaveStateFtraceEvent&);
  bool operator==(const KvmTimerSaveStateFtraceEvent&) const;
  bool operator!=(const KvmTimerSaveStateFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_ctl() const { return _has_field_[1]; }
  uint64_t ctl() const { return ctl_; }
  void set_ctl(uint64_t value) { ctl_ = value; _has_field_.set(1); }

  bool has_cval() const { return _has_field_[2]; }
  uint64_t cval() const { return cval_; }
  void set_cval(uint64_t value) { cval_ = value; _has_field_.set(2); }

  bool has_timer_idx() const { return _has_field_[3]; }
  int32_t timer_idx() const { return timer_idx_; }
  void set_timer_idx(int32_t value) { timer_idx_ = value; _has_field_.set(3); }

 private:
  uint64_t ctl_{};
  uint64_t cval_{};
  int32_t timer_idx_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT KvmTimerRestoreStateFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCtlFieldNumber = 1,
    kCvalFieldNumber = 2,
    kTimerIdxFieldNumber = 3,
  };

  KvmTimerRestoreStateFtraceEvent();
  ~KvmTimerRestoreStateFtraceEvent() override;
  KvmTimerRestoreStateFtraceEvent(KvmTimerRestoreStateFtraceEvent&&) noexcept;
  KvmTimerRestoreStateFtraceEvent& operator=(KvmTimerRestoreStateFtraceEvent&&);
  KvmTimerRestoreStateFtraceEvent(const KvmTimerRestoreStateFtraceEvent&);
  KvmTimerRestoreStateFtraceEvent& operator=(const KvmTimerRestoreStateFtraceEvent&);
  bool operator==(const KvmTimerRestoreStateFtraceEvent&) const;
  bool operator!=(const KvmTimerRestoreStateFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_ctl() const { return _has_field_[1]; }
  uint64_t ctl() const { return ctl_; }
  void set_ctl(uint64_t value) { ctl_ = value; _has_field_.set(1); }

  bool has_cval() const { return _has_field_[2]; }
  uint64_t cval() const { return cval_; }
  void set_cval(uint64_t value) { cval_ = value; _has_field_.set(2); }

  bool has_timer_idx() const { return _has_field_[3]; }
  int32_t timer_idx() const { return timer_idx_; }
  void set_timer_idx(int32_t value) { timer_idx_ = value; _has_field_.set(3); }

 private:
  uint64_t ctl_{};
  uint64_t cval_{};
  int32_t timer_idx_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT KvmTimerHrtimerExpireFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kTimerIdxFieldNumber = 1,
  };

  KvmTimerHrtimerExpireFtraceEvent();
  ~KvmTimerHrtimerExpireFtraceEvent() override;
  KvmTimerHrtimerExpireFtraceEvent(KvmTimerHrtimerExpireFtraceEvent&&) noexcept;
  KvmTimerHrtimerExpireFtraceEvent& operator=(KvmTimerHrtimerExpireFtraceEvent&&);
  KvmTimerHrtimerExpireFtraceEvent(const KvmTimerHrtimerExpireFtraceEvent&);
  KvmTimerHrtimerExpireFtraceEvent& operator=(const KvmTimerHrtimerExpireFtraceEvent&);
  bool operator==(const KvmTimerHrtimerExpireFtraceEvent&) const;
  bool operator!=(const KvmTimerHrtimerExpireFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_timer_idx() const { return _has_field_[1]; }
  int32_t timer_idx() const { return timer_idx_; }
  void set_timer_idx(int32_t value) { timer_idx_ = value; _has_field_.set(1); }

 private:
  int32_t timer_idx_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT KvmTimerEmulateFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kShouldFireFieldNumber = 1,
    kTimerIdxFieldNumber = 2,
  };

  KvmTimerEmulateFtraceEvent();
  ~KvmTimerEmulateFtraceEvent() override;
  KvmTimerEmulateFtraceEvent(KvmTimerEmulateFtraceEvent&&) noexcept;
  KvmTimerEmulateFtraceEvent& operator=(KvmTimerEmulateFtraceEvent&&);
  KvmTimerEmulateFtraceEvent(const KvmTimerEmulateFtraceEvent&);
  KvmTimerEmulateFtraceEvent& operator=(const KvmTimerEmulateFtraceEvent&);
  bool operator==(const KvmTimerEmulateFtraceEvent&) const;
  bool operator!=(const KvmTimerEmulateFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_should_fire() const { return _has_field_[1]; }
  uint32_t should_fire() const { return should_fire_; }
  void set_should_fire(uint32_t value) { should_fire_ = value; _has_field_.set(1); }

  bool has_timer_idx() const { return _has_field_[2]; }
  int32_t timer_idx() const { return timer_idx_; }
  void set_timer_idx(int32_t value) { timer_idx_ = value; _has_field_.set(2); }

 private:
  uint32_t should_fire_{};
  int32_t timer_idx_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT KvmTestAgeHvaFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kHvaFieldNumber = 1,
  };

  KvmTestAgeHvaFtraceEvent();
  ~KvmTestAgeHvaFtraceEvent() override;
  KvmTestAgeHvaFtraceEvent(KvmTestAgeHvaFtraceEvent&&) noexcept;
  KvmTestAgeHvaFtraceEvent& operator=(KvmTestAgeHvaFtraceEvent&&);
  KvmTestAgeHvaFtraceEvent(const KvmTestAgeHvaFtraceEvent&);
  KvmTestAgeHvaFtraceEvent& operator=(const KvmTestAgeHvaFtraceEvent&);
  bool operator==(const KvmTestAgeHvaFtraceEvent&) const;
  bool operator!=(const KvmTestAgeHvaFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_hva() const { return _has_field_[1]; }
  uint64_t hva() const { return hva_; }
  void set_hva(uint64_t value) { hva_ = value; _has_field_.set(1); }

 private:
  uint64_t hva_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT KvmSysAccessFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCRmFieldNumber = 1,
    kCRnFieldNumber = 2,
    kOp0FieldNumber = 3,
    kOp1FieldNumber = 4,
    kOp2FieldNumber = 5,
    kIsWriteFieldNumber = 6,
    kNameFieldNumber = 7,
    kVcpuPcFieldNumber = 8,
  };

  KvmSysAccessFtraceEvent();
  ~KvmSysAccessFtraceEvent() override;
  KvmSysAccessFtraceEvent(KvmSysAccessFtraceEvent&&) noexcept;
  KvmSysAccessFtraceEvent& operator=(KvmSysAccessFtraceEvent&&);
  KvmSysAccessFtraceEvent(const KvmSysAccessFtraceEvent&);
  KvmSysAccessFtraceEvent& operator=(const KvmSysAccessFtraceEvent&);
  bool operator==(const KvmSysAccessFtraceEvent&) const;
  bool operator!=(const KvmSysAccessFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_crm() const { return _has_field_[1]; }
  uint32_t crm() const { return crm_; }
  void set_crm(uint32_t value) { crm_ = value; _has_field_.set(1); }

  bool has_crn() const { return _has_field_[2]; }
  uint32_t crn() const { return crn_; }
  void set_crn(uint32_t value) { crn_ = value; _has_field_.set(2); }

  bool has_op0() const { return _has_field_[3]; }
  uint32_t op0() const { return op0_; }
  void set_op0(uint32_t value) { op0_ = value; _has_field_.set(3); }

  bool has_op1() const { return _has_field_[4]; }
  uint32_t op1() const { return op1_; }
  void set_op1(uint32_t value) { op1_ = value; _has_field_.set(4); }

  bool has_op2() const { return _has_field_[5]; }
  uint32_t op2() const { return op2_; }
  void set_op2(uint32_t value) { op2_ = value; _has_field_.set(5); }

  bool has_is_write() const { return _has_field_[6]; }
  uint32_t is_write() const { return is_write_; }
  void set_is_write(uint32_t value) { is_write_ = value; _has_field_.set(6); }

  bool has_name() const { return _has_field_[7]; }
  const std::string& name() const { return name_; }
  void set_name(const std::string& value) { name_ = value; _has_field_.set(7); }

  bool has_vcpu_pc() const { return _has_field_[8]; }
  uint64_t vcpu_pc() const { return vcpu_pc_; }
  void set_vcpu_pc(uint64_t value) { vcpu_pc_ = value; _has_field_.set(8); }

 private:
  uint32_t crm_{};
  uint32_t crn_{};
  uint32_t op0_{};
  uint32_t op1_{};
  uint32_t op2_{};
  uint32_t is_write_{};
  std::string name_{};
  uint64_t vcpu_pc_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<9> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT KvmSetWayFlushFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCacheFieldNumber = 1,
    kVcpuPcFieldNumber = 2,
  };

  KvmSetWayFlushFtraceEvent();
  ~KvmSetWayFlushFtraceEvent() override;
  KvmSetWayFlushFtraceEvent(KvmSetWayFlushFtraceEvent&&) noexcept;
  KvmSetWayFlushFtraceEvent& operator=(KvmSetWayFlushFtraceEvent&&);
  KvmSetWayFlushFtraceEvent(const KvmSetWayFlushFtraceEvent&);
  KvmSetWayFlushFtraceEvent& operator=(const KvmSetWayFlushFtraceEvent&);
  bool operator==(const KvmSetWayFlushFtraceEvent&) const;
  bool operator!=(const KvmSetWayFlushFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_cache() const { return _has_field_[1]; }
  uint32_t cache() const { return cache_; }
  void set_cache(uint32_t value) { cache_ = value; _has_field_.set(1); }

  bool has_vcpu_pc() const { return _has_field_[2]; }
  uint64_t vcpu_pc() const { return vcpu_pc_; }
  void set_vcpu_pc(uint64_t value) { vcpu_pc_ = value; _has_field_.set(2); }

 private:
  uint32_t cache_{};
  uint64_t vcpu_pc_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT KvmSetSpteHvaFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kHvaFieldNumber = 1,
  };

  KvmSetSpteHvaFtraceEvent();
  ~KvmSetSpteHvaFtraceEvent() override;
  KvmSetSpteHvaFtraceEvent(KvmSetSpteHvaFtraceEvent&&) noexcept;
  KvmSetSpteHvaFtraceEvent& operator=(KvmSetSpteHvaFtraceEvent&&);
  KvmSetSpteHvaFtraceEvent(const KvmSetSpteHvaFtraceEvent&);
  KvmSetSpteHvaFtraceEvent& operator=(const KvmSetSpteHvaFtraceEvent&);
  bool operator==(const KvmSetSpteHvaFtraceEvent&) const;
  bool operator!=(const KvmSetSpteHvaFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_hva() const { return _has_field_[1]; }
  uint64_t hva() const { return hva_; }
  void set_hva(uint64_t value) { hva_ = value; _has_field_.set(1); }

 private:
  uint64_t hva_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT KvmSetIrqFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kGsiFieldNumber = 1,
    kIrqSourceIdFieldNumber = 2,
    kLevelFieldNumber = 3,
  };

  KvmSetIrqFtraceEvent();
  ~KvmSetIrqFtraceEvent() override;
  KvmSetIrqFtraceEvent(KvmSetIrqFtraceEvent&&) noexcept;
  KvmSetIrqFtraceEvent& operator=(KvmSetIrqFtraceEvent&&);
  KvmSetIrqFtraceEvent(const KvmSetIrqFtraceEvent&);
  KvmSetIrqFtraceEvent& operator=(const KvmSetIrqFtraceEvent&);
  bool operator==(const KvmSetIrqFtraceEvent&) const;
  bool operator!=(const KvmSetIrqFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_gsi() const { return _has_field_[1]; }
  uint32_t gsi() const { return gsi_; }
  void set_gsi(uint32_t value) { gsi_ = value; _has_field_.set(1); }

  bool has_irq_source_id() const { return _has_field_[2]; }
  int32_t irq_source_id() const { return irq_source_id_; }
  void set_irq_source_id(int32_t value) { irq_source_id_ = value; _has_field_.set(2); }

  bool has_level() const { return _has_field_[3]; }
  int32_t level() const { return level_; }
  void set_level(int32_t value) { level_ = value; _has_field_.set(3); }

 private:
  uint32_t gsi_{};
  int32_t irq_source_id_{};
  int32_t level_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT KvmSetGuestDebugFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kGuestDebugFieldNumber = 1,
    kVcpuFieldNumber = 2,
  };

  KvmSetGuestDebugFtraceEvent();
  ~KvmSetGuestDebugFtraceEvent() override;
  KvmSetGuestDebugFtraceEvent(KvmSetGuestDebugFtraceEvent&&) noexcept;
  KvmSetGuestDebugFtraceEvent& operator=(KvmSetGuestDebugFtraceEvent&&);
  KvmSetGuestDebugFtraceEvent(const KvmSetGuestDebugFtraceEvent&);
  KvmSetGuestDebugFtraceEvent& operator=(const KvmSetGuestDebugFtraceEvent&);
  bool operator==(const KvmSetGuestDebugFtraceEvent&) const;
  bool operator!=(const KvmSetGuestDebugFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_guest_debug() const { return _has_field_[1]; }
  uint32_t guest_debug() const { return guest_debug_; }
  void set_guest_debug(uint32_t value) { guest_debug_ = value; _has_field_.set(1); }

  bool has_vcpu() const { return _has_field_[2]; }
  uint64_t vcpu() const { return vcpu_; }
  void set_vcpu(uint64_t value) { vcpu_ = value; _has_field_.set(2); }

 private:
  uint32_t guest_debug_{};
  uint64_t vcpu_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT KvmMmioEmulateFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kCpsrFieldNumber = 1,
    kInstrFieldNumber = 2,
    kVcpuPcFieldNumber = 3,
  };

  KvmMmioEmulateFtraceEvent();
  ~KvmMmioEmulateFtraceEvent() override;
  KvmMmioEmulateFtraceEvent(KvmMmioEmulateFtraceEvent&&) noexcept;
  KvmMmioEmulateFtraceEvent& operator=(KvmMmioEmulateFtraceEvent&&);
  KvmMmioEmulateFtraceEvent(const KvmMmioEmulateFtraceEvent&);
  KvmMmioEmulateFtraceEvent& operator=(const KvmMmioEmulateFtraceEvent&);
  bool operator==(const KvmMmioEmulateFtraceEvent&) const;
  bool operator!=(const KvmMmioEmulateFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_cpsr() const { return _has_field_[1]; }
  uint64_t cpsr() const { return cpsr_; }
  void set_cpsr(uint64_t value) { cpsr_ = value; _has_field_.set(1); }

  bool has_instr() const { return _has_field_[2]; }
  uint64_t instr() const { return instr_; }
  void set_instr(uint64_t value) { instr_ = value; _has_field_.set(2); }

  bool has_vcpu_pc() const { return _has_field_[3]; }
  uint64_t vcpu_pc() const { return vcpu_pc_; }
  void set_vcpu_pc(uint64_t value) { vcpu_pc_ = value; _has_field_.set(3); }

 private:
  uint64_t cpsr_{};
  uint64_t instr_{};
  uint64_t vcpu_pc_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT KvmMmioFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kGpaFieldNumber = 1,
    kLenFieldNumber = 2,
    kTypeFieldNumber = 3,
    kValFieldNumber = 4,
  };

  KvmMmioFtraceEvent();
  ~KvmMmioFtraceEvent() override;
  KvmMmioFtraceEvent(KvmMmioFtraceEvent&&) noexcept;
  KvmMmioFtraceEvent& operator=(KvmMmioFtraceEvent&&);
  KvmMmioFtraceEvent(const KvmMmioFtraceEvent&);
  KvmMmioFtraceEvent& operator=(const KvmMmioFtraceEvent&);
  bool operator==(const KvmMmioFtraceEvent&) const;
  bool operator!=(const KvmMmioFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_gpa() const { return _has_field_[1]; }
  uint64_t gpa() const { return gpa_; }
  void set_gpa(uint64_t value) { gpa_ = value; _has_field_.set(1); }

  bool has_len() const { return _has_field_[2]; }
  uint32_t len() const { return len_; }
  void set_len(uint32_t value) { len_ = value; _has_field_.set(2); }

  bool has_type() const { return _has_field_[3]; }
  uint32_t type() const { return type_; }
  void set_type(uint32_t value) { type_ = value; _has_field_.set(3); }

  bool has_val() const { return _has_field_[4]; }
  uint64_t val() const { return val_; }
  void set_val(uint64_t value) { val_ = value; _has_field_.set(4); }

 private:
  uint64_t gpa_{};
  uint32_t len_{};
  uint32_t type_{};
  uint64_t val_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT KvmIrqLineFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kIrqNumFieldNumber = 1,
    kLevelFieldNumber = 2,
    kTypeFieldNumber = 3,
    kVcpuIdxFieldNumber = 4,
  };

  KvmIrqLineFtraceEvent();
  ~KvmIrqLineFtraceEvent() override;
  KvmIrqLineFtraceEvent(KvmIrqLineFtraceEvent&&) noexcept;
  KvmIrqLineFtraceEvent& operator=(KvmIrqLineFtraceEvent&&);
  KvmIrqLineFtraceEvent(const KvmIrqLineFtraceEvent&);
  KvmIrqLineFtraceEvent& operator=(const KvmIrqLineFtraceEvent&);
  bool operator==(const KvmIrqLineFtraceEvent&) const;
  bool operator!=(const KvmIrqLineFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_irq_num() const { return _has_field_[1]; }
  int32_t irq_num() const { return irq_num_; }
  void set_irq_num(int32_t value) { irq_num_ = value; _has_field_.set(1); }

  bool has_level() const { return _has_field_[2]; }
  int32_t level() const { return level_; }
  void set_level(int32_t value) { level_ = value; _has_field_.set(2); }

  bool has_type() const { return _has_field_[3]; }
  uint32_t type() const { return type_; }
  void set_type(uint32_t value) { type_ = value; _has_field_.set(3); }

  bool has_vcpu_idx() const { return _has_field_[4]; }
  int32_t vcpu_idx() const { return vcpu_idx_; }
  void set_vcpu_idx(int32_t value) { vcpu_idx_ = value; _has_field_.set(4); }

 private:
  int32_t irq_num_{};
  int32_t level_{};
  uint32_t type_{};
  int32_t vcpu_idx_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT KvmHvcArm64FtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kImmFieldNumber = 1,
    kR0FieldNumber = 2,
    kVcpuPcFieldNumber = 3,
  };

  KvmHvcArm64FtraceEvent();
  ~KvmHvcArm64FtraceEvent() override;
  KvmHvcArm64FtraceEvent(KvmHvcArm64FtraceEvent&&) noexcept;
  KvmHvcArm64FtraceEvent& operator=(KvmHvcArm64FtraceEvent&&);
  KvmHvcArm64FtraceEvent(const KvmHvcArm64FtraceEvent&);
  KvmHvcArm64FtraceEvent& operator=(const KvmHvcArm64FtraceEvent&);
  bool operator==(const KvmHvcArm64FtraceEvent&) const;
  bool operator!=(const KvmHvcArm64FtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_imm() const { return _has_field_[1]; }
  uint64_t imm() const { return imm_; }
  void set_imm(uint64_t value) { imm_ = value; _has_field_.set(1); }

  bool has_r0() const { return _has_field_[2]; }
  uint64_t r0() const { return r0_; }
  void set_r0(uint64_t value) { r0_ = value; _has_field_.set(2); }

  bool has_vcpu_pc() const { return _has_field_[3]; }
  uint64_t vcpu_pc() const { return vcpu_pc_; }
  void set_vcpu_pc(uint64_t value) { vcpu_pc_ = value; _has_field_.set(3); }

 private:
  uint64_t imm_{};
  uint64_t r0_{};
  uint64_t vcpu_pc_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT KvmHandleSysRegFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kHsrFieldNumber = 1,
  };

  KvmHandleSysRegFtraceEvent();
  ~KvmHandleSysRegFtraceEvent() override;
  KvmHandleSysRegFtraceEvent(KvmHandleSysRegFtraceEvent&&) noexcept;
  KvmHandleSysRegFtraceEvent& operator=(KvmHandleSysRegFtraceEvent&&);
  KvmHandleSysRegFtraceEvent(const KvmHandleSysRegFtraceEvent&);
  KvmHandleSysRegFtraceEvent& operator=(const KvmHandleSysRegFtraceEvent&);
  bool operator==(const KvmHandleSysRegFtraceEvent&) const;
  bool operator!=(const KvmHandleSysRegFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_hsr() const { return _has_field_[1]; }
  uint64_t hsr() const { return hsr_; }
  void set_hsr(uint64_t value) { hsr_ = value; _has_field_.set(1); }

 private:
  uint64_t hsr_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT KvmGuestFaultFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kHsrFieldNumber = 1,
    kHxfarFieldNumber = 2,
    kIpaFieldNumber = 3,
    kVcpuPcFieldNumber = 4,
  };

  KvmGuestFaultFtraceEvent();
  ~KvmGuestFaultFtraceEvent() override;
  KvmGuestFaultFtraceEvent(KvmGuestFaultFtraceEvent&&) noexcept;
  KvmGuestFaultFtraceEvent& operator=(KvmGuestFaultFtraceEvent&&);
  KvmGuestFaultFtraceEvent(const KvmGuestFaultFtraceEvent&);
  KvmGuestFaultFtraceEvent& operator=(const KvmGuestFaultFtraceEvent&);
  bool operator==(const KvmGuestFaultFtraceEvent&) const;
  bool operator!=(const KvmGuestFaultFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_hsr() const { return _has_field_[1]; }
  uint64_t hsr() const { return hsr_; }
  void set_hsr(uint64_t value) { hsr_ = value; _has_field_.set(1); }

  bool has_hxfar() const { return _has_field_[2]; }
  uint64_t hxfar() const { return hxfar_; }
  void set_hxfar(uint64_t value) { hxfar_ = value; _has_field_.set(2); }

  bool has_ipa() const { return _has_field_[3]; }
  uint64_t ipa() const { return ipa_; }
  void set_ipa(uint64_t value) { ipa_ = value; _has_field_.set(3); }

  bool has_vcpu_pc() const { return _has_field_[4]; }
  uint64_t vcpu_pc() const { return vcpu_pc_; }
  void set_vcpu_pc(uint64_t value) { vcpu_pc_ = value; _has_field_.set(4); }

 private:
  uint64_t hsr_{};
  uint64_t hxfar_{};
  uint64_t ipa_{};
  uint64_t vcpu_pc_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT KvmGetTimerMapFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDirectPtimerFieldNumber = 1,
    kDirectVtimerFieldNumber = 2,
    kEmulPtimerFieldNumber = 3,
    kVcpuIdFieldNumber = 4,
  };

  KvmGetTimerMapFtraceEvent();
  ~KvmGetTimerMapFtraceEvent() override;
  KvmGetTimerMapFtraceEvent(KvmGetTimerMapFtraceEvent&&) noexcept;
  KvmGetTimerMapFtraceEvent& operator=(KvmGetTimerMapFtraceEvent&&);
  KvmGetTimerMapFtraceEvent(const KvmGetTimerMapFtraceEvent&);
  KvmGetTimerMapFtraceEvent& operator=(const KvmGetTimerMapFtraceEvent&);
  bool operator==(const KvmGetTimerMapFtraceEvent&) const;
  bool operator!=(const KvmGetTimerMapFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_direct_ptimer() const { return _has_field_[1]; }
  int32_t direct_ptimer() const { return direct_ptimer_; }
  void set_direct_ptimer(int32_t value) { direct_ptimer_ = value; _has_field_.set(1); }

  bool has_direct_vtimer() const { return _has_field_[2]; }
  int32_t direct_vtimer() const { return direct_vtimer_; }
  void set_direct_vtimer(int32_t value) { direct_vtimer_ = value; _has_field_.set(2); }

  bool has_emul_ptimer() const { return _has_field_[3]; }
  int32_t emul_ptimer() const { return emul_ptimer_; }
  void set_emul_ptimer(int32_t value) { emul_ptimer_ = value; _has_field_.set(3); }

  bool has_vcpu_id() const { return _has_field_[4]; }
  uint64_t vcpu_id() const { return vcpu_id_; }
  void set_vcpu_id(uint64_t value) { vcpu_id_ = value; _has_field_.set(4); }

 private:
  int32_t direct_ptimer_{};
  int32_t direct_vtimer_{};
  int32_t emul_ptimer_{};
  uint64_t vcpu_id_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT KvmFpuFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kLoadFieldNumber = 1,
  };

  KvmFpuFtraceEvent();
  ~KvmFpuFtraceEvent() override;
  KvmFpuFtraceEvent(KvmFpuFtraceEvent&&) noexcept;
  KvmFpuFtraceEvent& operator=(KvmFpuFtraceEvent&&);
  KvmFpuFtraceEvent(const KvmFpuFtraceEvent&);
  KvmFpuFtraceEvent& operator=(const KvmFpuFtraceEvent&);
  bool operator==(const KvmFpuFtraceEvent&) const;
  bool operator!=(const KvmFpuFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_load() const { return _has_field_[1]; }
  uint32_t load() const { return load_; }
  void set_load(uint32_t value) { load_ = value; _has_field_.set(1); }

 private:
  uint32_t load_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT KvmExitFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kEsrEcFieldNumber = 1,
    kRetFieldNumber = 2,
    kVcpuPcFieldNumber = 3,
  };

  KvmExitFtraceEvent();
  ~KvmExitFtraceEvent() override;
  KvmExitFtraceEvent(KvmExitFtraceEvent&&) noexcept;
  KvmExitFtraceEvent& operator=(KvmExitFtraceEvent&&);
  KvmExitFtraceEvent(const KvmExitFtraceEvent&);
  KvmExitFtraceEvent& operator=(const KvmExitFtraceEvent&);
  bool operator==(const KvmExitFtraceEvent&) const;
  bool operator!=(const KvmExitFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_esr_ec() const { return _has_field_[1]; }
  uint32_t esr_ec() const { return esr_ec_; }
  void set_esr_ec(uint32_t value) { esr_ec_ = value; _has_field_.set(1); }

  bool has_ret() const { return _has_field_[2]; }
  int32_t ret() const { return ret_; }
  void set_ret(int32_t value) { ret_ = value; _has_field_.set(2); }

  bool has_vcpu_pc() const { return _has_field_[3]; }
  uint64_t vcpu_pc() const { return vcpu_pc_; }
  void set_vcpu_pc(uint64_t value) { vcpu_pc_ = value; _has_field_.set(3); }

 private:
  uint32_t esr_ec_{};
  int32_t ret_{};
  uint64_t vcpu_pc_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT KvmEntryFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kVcpuPcFieldNumber = 1,
  };

  KvmEntryFtraceEvent();
  ~KvmEntryFtraceEvent() override;
  KvmEntryFtraceEvent(KvmEntryFtraceEvent&&) noexcept;
  KvmEntryFtraceEvent& operator=(KvmEntryFtraceEvent&&);
  KvmEntryFtraceEvent(const KvmEntryFtraceEvent&);
  KvmEntryFtraceEvent& operator=(const KvmEntryFtraceEvent&);
  bool operator==(const KvmEntryFtraceEvent&) const;
  bool operator!=(const KvmEntryFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_vcpu_pc() const { return _has_field_[1]; }
  uint64_t vcpu_pc() const { return vcpu_pc_; }
  void set_vcpu_pc(uint64_t value) { vcpu_pc_ = value; _has_field_.set(1); }

 private:
  uint64_t vcpu_pc_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT KvmArmSetupDebugFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kGuestDebugFieldNumber = 1,
    kVcpuFieldNumber = 2,
  };

  KvmArmSetupDebugFtraceEvent();
  ~KvmArmSetupDebugFtraceEvent() override;
  KvmArmSetupDebugFtraceEvent(KvmArmSetupDebugFtraceEvent&&) noexcept;
  KvmArmSetupDebugFtraceEvent& operator=(KvmArmSetupDebugFtraceEvent&&);
  KvmArmSetupDebugFtraceEvent(const KvmArmSetupDebugFtraceEvent&);
  KvmArmSetupDebugFtraceEvent& operator=(const KvmArmSetupDebugFtraceEvent&);
  bool operator==(const KvmArmSetupDebugFtraceEvent&) const;
  bool operator!=(const KvmArmSetupDebugFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_guest_debug() const { return _has_field_[1]; }
  uint32_t guest_debug() const { return guest_debug_; }
  void set_guest_debug(uint32_t value) { guest_debug_ = value; _has_field_.set(1); }

  bool has_vcpu() const { return _has_field_[2]; }
  uint64_t vcpu() const { return vcpu_; }
  void set_vcpu(uint64_t value) { vcpu_ = value; _has_field_.set(2); }

 private:
  uint32_t guest_debug_{};
  uint64_t vcpu_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT KvmArmSetRegsetFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kLenFieldNumber = 1,
    kNameFieldNumber = 2,
  };

  KvmArmSetRegsetFtraceEvent();
  ~KvmArmSetRegsetFtraceEvent() override;
  KvmArmSetRegsetFtraceEvent(KvmArmSetRegsetFtraceEvent&&) noexcept;
  KvmArmSetRegsetFtraceEvent& operator=(KvmArmSetRegsetFtraceEvent&&);
  KvmArmSetRegsetFtraceEvent(const KvmArmSetRegsetFtraceEvent&);
  KvmArmSetRegsetFtraceEvent& operator=(const KvmArmSetRegsetFtraceEvent&);
  bool operator==(const KvmArmSetRegsetFtraceEvent&) const;
  bool operator!=(const KvmArmSetRegsetFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_len() const { return _has_field_[1]; }
  int32_t len() const { return len_; }
  void set_len(int32_t value) { len_ = value; _has_field_.set(1); }

  bool has_name() const { return _has_field_[2]; }
  const std::string& name() const { return name_; }
  void set_name(const std::string& value) { name_ = value; _has_field_.set(2); }

 private:
  int32_t len_{};
  std::string name_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT KvmArmSetDreg32FtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };

  KvmArmSetDreg32FtraceEvent();
  ~KvmArmSetDreg32FtraceEvent() override;
  KvmArmSetDreg32FtraceEvent(KvmArmSetDreg32FtraceEvent&&) noexcept;
  KvmArmSetDreg32FtraceEvent& operator=(KvmArmSetDreg32FtraceEvent&&);
  KvmArmSetDreg32FtraceEvent(const KvmArmSetDreg32FtraceEvent&);
  KvmArmSetDreg32FtraceEvent& operator=(const KvmArmSetDreg32FtraceEvent&);
  bool operator==(const KvmArmSetDreg32FtraceEvent&) const;
  bool operator!=(const KvmArmSetDreg32FtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_name() const { return _has_field_[1]; }
  const std::string& name() const { return name_; }
  void set_name(const std::string& value) { name_ = value; _has_field_.set(1); }

  bool has_value() const { return _has_field_[2]; }
  uint32_t value() const { return value_; }
  void set_value(uint32_t value) { value_ = value; _has_field_.set(2); }

 private:
  std::string name_{};
  uint32_t value_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT KvmArmClearDebugFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kGuestDebugFieldNumber = 1,
  };

  KvmArmClearDebugFtraceEvent();
  ~KvmArmClearDebugFtraceEvent() override;
  KvmArmClearDebugFtraceEvent(KvmArmClearDebugFtraceEvent&&) noexcept;
  KvmArmClearDebugFtraceEvent& operator=(KvmArmClearDebugFtraceEvent&&);
  KvmArmClearDebugFtraceEvent(const KvmArmClearDebugFtraceEvent&);
  KvmArmClearDebugFtraceEvent& operator=(const KvmArmClearDebugFtraceEvent&);
  bool operator==(const KvmArmClearDebugFtraceEvent&) const;
  bool operator!=(const KvmArmClearDebugFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_guest_debug() const { return _has_field_[1]; }
  uint32_t guest_debug() const { return guest_debug_; }
  void set_guest_debug(uint32_t value) { guest_debug_ = value; _has_field_.set(1); }

 private:
  uint32_t guest_debug_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT KvmAgePageFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kGfnFieldNumber = 1,
    kHvaFieldNumber = 2,
    kLevelFieldNumber = 3,
    kReferencedFieldNumber = 4,
  };

  KvmAgePageFtraceEvent();
  ~KvmAgePageFtraceEvent() override;
  KvmAgePageFtraceEvent(KvmAgePageFtraceEvent&&) noexcept;
  KvmAgePageFtraceEvent& operator=(KvmAgePageFtraceEvent&&);
  KvmAgePageFtraceEvent(const KvmAgePageFtraceEvent&);
  KvmAgePageFtraceEvent& operator=(const KvmAgePageFtraceEvent&);
  bool operator==(const KvmAgePageFtraceEvent&) const;
  bool operator!=(const KvmAgePageFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_gfn() const { return _has_field_[1]; }
  uint64_t gfn() const { return gfn_; }
  void set_gfn(uint64_t value) { gfn_ = value; _has_field_.set(1); }

  bool has_hva() const { return _has_field_[2]; }
  uint64_t hva() const { return hva_; }
  void set_hva(uint64_t value) { hva_ = value; _has_field_.set(2); }

  bool has_level() const { return _has_field_[3]; }
  uint32_t level() const { return level_; }
  void set_level(uint32_t value) { level_ = value; _has_field_.set(3); }

  bool has_referenced() const { return _has_field_[4]; }
  uint32_t referenced() const { return referenced_; }
  void set_referenced(uint32_t value) { referenced_ = value; _has_field_.set(4); }

 private:
  uint64_t gfn_{};
  uint64_t hva_{};
  uint32_t level_{};
  uint32_t referenced_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT KvmAgeHvaFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kEndFieldNumber = 1,
    kStartFieldNumber = 2,
  };

  KvmAgeHvaFtraceEvent();
  ~KvmAgeHvaFtraceEvent() override;
  KvmAgeHvaFtraceEvent(KvmAgeHvaFtraceEvent&&) noexcept;
  KvmAgeHvaFtraceEvent& operator=(KvmAgeHvaFtraceEvent&&);
  KvmAgeHvaFtraceEvent(const KvmAgeHvaFtraceEvent&);
  KvmAgeHvaFtraceEvent& operator=(const KvmAgeHvaFtraceEvent&);
  bool operator==(const KvmAgeHvaFtraceEvent&) const;
  bool operator!=(const KvmAgeHvaFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_end() const { return _has_field_[1]; }
  uint64_t end() const { return end_; }
  void set_end(uint64_t value) { end_ = value; _has_field_.set(1); }

  bool has_start() const { return _has_field_[2]; }
  uint64_t start() const { return start_; }
  void set_start(uint64_t value) { start_ = value; _has_field_.set(2); }

 private:
  uint64_t end_{};
  uint64_t start_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT KvmAckIrqFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kIrqchipFieldNumber = 1,
    kPinFieldNumber = 2,
  };

  KvmAckIrqFtraceEvent();
  ~KvmAckIrqFtraceEvent() override;
  KvmAckIrqFtraceEvent(KvmAckIrqFtraceEvent&&) noexcept;
  KvmAckIrqFtraceEvent& operator=(KvmAckIrqFtraceEvent&&);
  KvmAckIrqFtraceEvent(const KvmAckIrqFtraceEvent&);
  KvmAckIrqFtraceEvent& operator=(const KvmAckIrqFtraceEvent&);
  bool operator==(const KvmAckIrqFtraceEvent&) const;
  bool operator!=(const KvmAckIrqFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_irqchip() const { return _has_field_[1]; }
  uint32_t irqchip() const { return irqchip_; }
  void set_irqchip(uint32_t value) { irqchip_ = value; _has_field_.set(1); }

  bool has_pin() const { return _has_field_[2]; }
  uint32_t pin() const { return pin_; }
  void set_pin(uint32_t value) { pin_ = value; _has_field_.set(2); }

 private:
  uint32_t irqchip_{};
  uint32_t pin_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT KvmAccessFaultFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kIpaFieldNumber = 1,
  };

  KvmAccessFaultFtraceEvent();
  ~KvmAccessFaultFtraceEvent() override;
  KvmAccessFaultFtraceEvent(KvmAccessFaultFtraceEvent&&) noexcept;
  KvmAccessFaultFtraceEvent& operator=(KvmAccessFaultFtraceEvent&&);
  KvmAccessFaultFtraceEvent(const KvmAccessFaultFtraceEvent&);
  KvmAccessFaultFtraceEvent& operator=(const KvmAccessFaultFtraceEvent&);
  bool operator==(const KvmAccessFaultFtraceEvent&) const;
  bool operator!=(const KvmAccessFaultFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_ipa() const { return _has_field_[1]; }
  uint64_t ipa() const { return ipa_; }
  void set_ipa(uint64_t value) { ipa_ = value; _has_field_.set(1); }

 private:
  uint64_t ipa_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_KVM_PROTO_CPP_H_
