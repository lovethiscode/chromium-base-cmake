// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_PERF_TRACE_COUNTERS_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_PERF_TRACE_COUNTERS_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class SchedSwitchWithCtrsFtraceEvent;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {

class PERFETTO_EXPORT_COMPONENT SchedSwitchWithCtrsFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kOldPidFieldNumber = 1,
    kNewPidFieldNumber = 2,
    kCctrFieldNumber = 3,
    kCtr0FieldNumber = 4,
    kCtr1FieldNumber = 5,
    kCtr2FieldNumber = 6,
    kCtr3FieldNumber = 7,
    kLctr0FieldNumber = 8,
    kLctr1FieldNumber = 9,
    kCtr4FieldNumber = 10,
    kCtr5FieldNumber = 11,
    kPrevCommFieldNumber = 12,
    kPrevPidFieldNumber = 13,
    kCycFieldNumber = 14,
    kInstFieldNumber = 15,
    kStallbmFieldNumber = 16,
    kL3dmFieldNumber = 17,
  };

  SchedSwitchWithCtrsFtraceEvent();
  ~SchedSwitchWithCtrsFtraceEvent() override;
  SchedSwitchWithCtrsFtraceEvent(SchedSwitchWithCtrsFtraceEvent&&) noexcept;
  SchedSwitchWithCtrsFtraceEvent& operator=(SchedSwitchWithCtrsFtraceEvent&&);
  SchedSwitchWithCtrsFtraceEvent(const SchedSwitchWithCtrsFtraceEvent&);
  SchedSwitchWithCtrsFtraceEvent& operator=(const SchedSwitchWithCtrsFtraceEvent&);
  bool operator==(const SchedSwitchWithCtrsFtraceEvent&) const;
  bool operator!=(const SchedSwitchWithCtrsFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_old_pid() const { return _has_field_[1]; }
  int32_t old_pid() const { return old_pid_; }
  void set_old_pid(int32_t value) { old_pid_ = value; _has_field_.set(1); }

  bool has_new_pid() const { return _has_field_[2]; }
  int32_t new_pid() const { return new_pid_; }
  void set_new_pid(int32_t value) { new_pid_ = value; _has_field_.set(2); }

  bool has_cctr() const { return _has_field_[3]; }
  uint32_t cctr() const { return cctr_; }
  void set_cctr(uint32_t value) { cctr_ = value; _has_field_.set(3); }

  bool has_ctr0() const { return _has_field_[4]; }
  uint32_t ctr0() const { return ctr0_; }
  void set_ctr0(uint32_t value) { ctr0_ = value; _has_field_.set(4); }

  bool has_ctr1() const { return _has_field_[5]; }
  uint32_t ctr1() const { return ctr1_; }
  void set_ctr1(uint32_t value) { ctr1_ = value; _has_field_.set(5); }

  bool has_ctr2() const { return _has_field_[6]; }
  uint32_t ctr2() const { return ctr2_; }
  void set_ctr2(uint32_t value) { ctr2_ = value; _has_field_.set(6); }

  bool has_ctr3() const { return _has_field_[7]; }
  uint32_t ctr3() const { return ctr3_; }
  void set_ctr3(uint32_t value) { ctr3_ = value; _has_field_.set(7); }

  bool has_lctr0() const { return _has_field_[8]; }
  uint32_t lctr0() const { return lctr0_; }
  void set_lctr0(uint32_t value) { lctr0_ = value; _has_field_.set(8); }

  bool has_lctr1() const { return _has_field_[9]; }
  uint32_t lctr1() const { return lctr1_; }
  void set_lctr1(uint32_t value) { lctr1_ = value; _has_field_.set(9); }

  bool has_ctr4() const { return _has_field_[10]; }
  uint32_t ctr4() const { return ctr4_; }
  void set_ctr4(uint32_t value) { ctr4_ = value; _has_field_.set(10); }

  bool has_ctr5() const { return _has_field_[11]; }
  uint32_t ctr5() const { return ctr5_; }
  void set_ctr5(uint32_t value) { ctr5_ = value; _has_field_.set(11); }

  bool has_prev_comm() const { return _has_field_[12]; }
  const std::string& prev_comm() const { return prev_comm_; }
  void set_prev_comm(const std::string& value) { prev_comm_ = value; _has_field_.set(12); }

  bool has_prev_pid() const { return _has_field_[13]; }
  int32_t prev_pid() const { return prev_pid_; }
  void set_prev_pid(int32_t value) { prev_pid_ = value; _has_field_.set(13); }

  bool has_cyc() const { return _has_field_[14]; }
  uint32_t cyc() const { return cyc_; }
  void set_cyc(uint32_t value) { cyc_ = value; _has_field_.set(14); }

  bool has_inst() const { return _has_field_[15]; }
  uint32_t inst() const { return inst_; }
  void set_inst(uint32_t value) { inst_ = value; _has_field_.set(15); }

  bool has_stallbm() const { return _has_field_[16]; }
  uint32_t stallbm() const { return stallbm_; }
  void set_stallbm(uint32_t value) { stallbm_ = value; _has_field_.set(16); }

  bool has_l3dm() const { return _has_field_[17]; }
  uint32_t l3dm() const { return l3dm_; }
  void set_l3dm(uint32_t value) { l3dm_ = value; _has_field_.set(17); }

 private:
  int32_t old_pid_{};
  int32_t new_pid_{};
  uint32_t cctr_{};
  uint32_t ctr0_{};
  uint32_t ctr1_{};
  uint32_t ctr2_{};
  uint32_t ctr3_{};
  uint32_t lctr0_{};
  uint32_t lctr1_{};
  uint32_t ctr4_{};
  uint32_t ctr5_{};
  std::string prev_comm_{};
  int32_t prev_pid_{};
  uint32_t cyc_{};
  uint32_t inst_{};
  uint32_t stallbm_{};
  uint32_t l3dm_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<18> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_PERF_TRACE_COUNTERS_PROTO_CPP_H_
