// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_V4L2_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_V4L2_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class Vb2V4l2DqbufFtraceEvent;
class Vb2V4l2QbufFtraceEvent;
class Vb2V4l2BufDoneFtraceEvent;
class Vb2V4l2BufQueueFtraceEvent;
class V4l2DqbufFtraceEvent;
class V4l2QbufFtraceEvent;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {

class PERFETTO_EXPORT_COMPONENT Vb2V4l2DqbufFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kFieldFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kMinorFieldNumber = 3,
    kSequenceFieldNumber = 4,
    kTimecodeFlagsFieldNumber = 5,
    kTimecodeFramesFieldNumber = 6,
    kTimecodeHoursFieldNumber = 7,
    kTimecodeMinutesFieldNumber = 8,
    kTimecodeSecondsFieldNumber = 9,
    kTimecodeTypeFieldNumber = 10,
    kTimecodeUserbits0FieldNumber = 11,
    kTimecodeUserbits1FieldNumber = 12,
    kTimecodeUserbits2FieldNumber = 13,
    kTimecodeUserbits3FieldNumber = 14,
    kTimestampFieldNumber = 15,
  };

  Vb2V4l2DqbufFtraceEvent();
  ~Vb2V4l2DqbufFtraceEvent() override;
  Vb2V4l2DqbufFtraceEvent(Vb2V4l2DqbufFtraceEvent&&) noexcept;
  Vb2V4l2DqbufFtraceEvent& operator=(Vb2V4l2DqbufFtraceEvent&&);
  Vb2V4l2DqbufFtraceEvent(const Vb2V4l2DqbufFtraceEvent&);
  Vb2V4l2DqbufFtraceEvent& operator=(const Vb2V4l2DqbufFtraceEvent&);
  bool operator==(const Vb2V4l2DqbufFtraceEvent&) const;
  bool operator!=(const Vb2V4l2DqbufFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_field() const { return _has_field_[1]; }
  uint32_t field() const { return field_; }
  void set_field(uint32_t value) { field_ = value; _has_field_.set(1); }

  bool has_flags() const { return _has_field_[2]; }
  uint32_t flags() const { return flags_; }
  void set_flags(uint32_t value) { flags_ = value; _has_field_.set(2); }

  bool has_minor() const { return _has_field_[3]; }
  int32_t minor() const { return minor_; }
  void set_minor(int32_t value) { minor_ = value; _has_field_.set(3); }

  bool has_sequence() const { return _has_field_[4]; }
  uint32_t sequence() const { return sequence_; }
  void set_sequence(uint32_t value) { sequence_ = value; _has_field_.set(4); }

  bool has_timecode_flags() const { return _has_field_[5]; }
  uint32_t timecode_flags() const { return timecode_flags_; }
  void set_timecode_flags(uint32_t value) { timecode_flags_ = value; _has_field_.set(5); }

  bool has_timecode_frames() const { return _has_field_[6]; }
  uint32_t timecode_frames() const { return timecode_frames_; }
  void set_timecode_frames(uint32_t value) { timecode_frames_ = value; _has_field_.set(6); }

  bool has_timecode_hours() const { return _has_field_[7]; }
  uint32_t timecode_hours() const { return timecode_hours_; }
  void set_timecode_hours(uint32_t value) { timecode_hours_ = value; _has_field_.set(7); }

  bool has_timecode_minutes() const { return _has_field_[8]; }
  uint32_t timecode_minutes() const { return timecode_minutes_; }
  void set_timecode_minutes(uint32_t value) { timecode_minutes_ = value; _has_field_.set(8); }

  bool has_timecode_seconds() const { return _has_field_[9]; }
  uint32_t timecode_seconds() const { return timecode_seconds_; }
  void set_timecode_seconds(uint32_t value) { timecode_seconds_ = value; _has_field_.set(9); }

  bool has_timecode_type() const { return _has_field_[10]; }
  uint32_t timecode_type() const { return timecode_type_; }
  void set_timecode_type(uint32_t value) { timecode_type_ = value; _has_field_.set(10); }

  bool has_timecode_userbits0() const { return _has_field_[11]; }
  uint32_t timecode_userbits0() const { return timecode_userbits0_; }
  void set_timecode_userbits0(uint32_t value) { timecode_userbits0_ = value; _has_field_.set(11); }

  bool has_timecode_userbits1() const { return _has_field_[12]; }
  uint32_t timecode_userbits1() const { return timecode_userbits1_; }
  void set_timecode_userbits1(uint32_t value) { timecode_userbits1_ = value; _has_field_.set(12); }

  bool has_timecode_userbits2() const { return _has_field_[13]; }
  uint32_t timecode_userbits2() const { return timecode_userbits2_; }
  void set_timecode_userbits2(uint32_t value) { timecode_userbits2_ = value; _has_field_.set(13); }

  bool has_timecode_userbits3() const { return _has_field_[14]; }
  uint32_t timecode_userbits3() const { return timecode_userbits3_; }
  void set_timecode_userbits3(uint32_t value) { timecode_userbits3_ = value; _has_field_.set(14); }

  bool has_timestamp() const { return _has_field_[15]; }
  int64_t timestamp() const { return timestamp_; }
  void set_timestamp(int64_t value) { timestamp_ = value; _has_field_.set(15); }

 private:
  uint32_t field_{};
  uint32_t flags_{};
  int32_t minor_{};
  uint32_t sequence_{};
  uint32_t timecode_flags_{};
  uint32_t timecode_frames_{};
  uint32_t timecode_hours_{};
  uint32_t timecode_minutes_{};
  uint32_t timecode_seconds_{};
  uint32_t timecode_type_{};
  uint32_t timecode_userbits0_{};
  uint32_t timecode_userbits1_{};
  uint32_t timecode_userbits2_{};
  uint32_t timecode_userbits3_{};
  int64_t timestamp_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<16> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT Vb2V4l2QbufFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kFieldFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kMinorFieldNumber = 3,
    kSequenceFieldNumber = 4,
    kTimecodeFlagsFieldNumber = 5,
    kTimecodeFramesFieldNumber = 6,
    kTimecodeHoursFieldNumber = 7,
    kTimecodeMinutesFieldNumber = 8,
    kTimecodeSecondsFieldNumber = 9,
    kTimecodeTypeFieldNumber = 10,
    kTimecodeUserbits0FieldNumber = 11,
    kTimecodeUserbits1FieldNumber = 12,
    kTimecodeUserbits2FieldNumber = 13,
    kTimecodeUserbits3FieldNumber = 14,
    kTimestampFieldNumber = 15,
  };

  Vb2V4l2QbufFtraceEvent();
  ~Vb2V4l2QbufFtraceEvent() override;
  Vb2V4l2QbufFtraceEvent(Vb2V4l2QbufFtraceEvent&&) noexcept;
  Vb2V4l2QbufFtraceEvent& operator=(Vb2V4l2QbufFtraceEvent&&);
  Vb2V4l2QbufFtraceEvent(const Vb2V4l2QbufFtraceEvent&);
  Vb2V4l2QbufFtraceEvent& operator=(const Vb2V4l2QbufFtraceEvent&);
  bool operator==(const Vb2V4l2QbufFtraceEvent&) const;
  bool operator!=(const Vb2V4l2QbufFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_field() const { return _has_field_[1]; }
  uint32_t field() const { return field_; }
  void set_field(uint32_t value) { field_ = value; _has_field_.set(1); }

  bool has_flags() const { return _has_field_[2]; }
  uint32_t flags() const { return flags_; }
  void set_flags(uint32_t value) { flags_ = value; _has_field_.set(2); }

  bool has_minor() const { return _has_field_[3]; }
  int32_t minor() const { return minor_; }
  void set_minor(int32_t value) { minor_ = value; _has_field_.set(3); }

  bool has_sequence() const { return _has_field_[4]; }
  uint32_t sequence() const { return sequence_; }
  void set_sequence(uint32_t value) { sequence_ = value; _has_field_.set(4); }

  bool has_timecode_flags() const { return _has_field_[5]; }
  uint32_t timecode_flags() const { return timecode_flags_; }
  void set_timecode_flags(uint32_t value) { timecode_flags_ = value; _has_field_.set(5); }

  bool has_timecode_frames() const { return _has_field_[6]; }
  uint32_t timecode_frames() const { return timecode_frames_; }
  void set_timecode_frames(uint32_t value) { timecode_frames_ = value; _has_field_.set(6); }

  bool has_timecode_hours() const { return _has_field_[7]; }
  uint32_t timecode_hours() const { return timecode_hours_; }
  void set_timecode_hours(uint32_t value) { timecode_hours_ = value; _has_field_.set(7); }

  bool has_timecode_minutes() const { return _has_field_[8]; }
  uint32_t timecode_minutes() const { return timecode_minutes_; }
  void set_timecode_minutes(uint32_t value) { timecode_minutes_ = value; _has_field_.set(8); }

  bool has_timecode_seconds() const { return _has_field_[9]; }
  uint32_t timecode_seconds() const { return timecode_seconds_; }
  void set_timecode_seconds(uint32_t value) { timecode_seconds_ = value; _has_field_.set(9); }

  bool has_timecode_type() const { return _has_field_[10]; }
  uint32_t timecode_type() const { return timecode_type_; }
  void set_timecode_type(uint32_t value) { timecode_type_ = value; _has_field_.set(10); }

  bool has_timecode_userbits0() const { return _has_field_[11]; }
  uint32_t timecode_userbits0() const { return timecode_userbits0_; }
  void set_timecode_userbits0(uint32_t value) { timecode_userbits0_ = value; _has_field_.set(11); }

  bool has_timecode_userbits1() const { return _has_field_[12]; }
  uint32_t timecode_userbits1() const { return timecode_userbits1_; }
  void set_timecode_userbits1(uint32_t value) { timecode_userbits1_ = value; _has_field_.set(12); }

  bool has_timecode_userbits2() const { return _has_field_[13]; }
  uint32_t timecode_userbits2() const { return timecode_userbits2_; }
  void set_timecode_userbits2(uint32_t value) { timecode_userbits2_ = value; _has_field_.set(13); }

  bool has_timecode_userbits3() const { return _has_field_[14]; }
  uint32_t timecode_userbits3() const { return timecode_userbits3_; }
  void set_timecode_userbits3(uint32_t value) { timecode_userbits3_ = value; _has_field_.set(14); }

  bool has_timestamp() const { return _has_field_[15]; }
  int64_t timestamp() const { return timestamp_; }
  void set_timestamp(int64_t value) { timestamp_ = value; _has_field_.set(15); }

 private:
  uint32_t field_{};
  uint32_t flags_{};
  int32_t minor_{};
  uint32_t sequence_{};
  uint32_t timecode_flags_{};
  uint32_t timecode_frames_{};
  uint32_t timecode_hours_{};
  uint32_t timecode_minutes_{};
  uint32_t timecode_seconds_{};
  uint32_t timecode_type_{};
  uint32_t timecode_userbits0_{};
  uint32_t timecode_userbits1_{};
  uint32_t timecode_userbits2_{};
  uint32_t timecode_userbits3_{};
  int64_t timestamp_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<16> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT Vb2V4l2BufDoneFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kFieldFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kMinorFieldNumber = 3,
    kSequenceFieldNumber = 4,
    kTimecodeFlagsFieldNumber = 5,
    kTimecodeFramesFieldNumber = 6,
    kTimecodeHoursFieldNumber = 7,
    kTimecodeMinutesFieldNumber = 8,
    kTimecodeSecondsFieldNumber = 9,
    kTimecodeTypeFieldNumber = 10,
    kTimecodeUserbits0FieldNumber = 11,
    kTimecodeUserbits1FieldNumber = 12,
    kTimecodeUserbits2FieldNumber = 13,
    kTimecodeUserbits3FieldNumber = 14,
    kTimestampFieldNumber = 15,
  };

  Vb2V4l2BufDoneFtraceEvent();
  ~Vb2V4l2BufDoneFtraceEvent() override;
  Vb2V4l2BufDoneFtraceEvent(Vb2V4l2BufDoneFtraceEvent&&) noexcept;
  Vb2V4l2BufDoneFtraceEvent& operator=(Vb2V4l2BufDoneFtraceEvent&&);
  Vb2V4l2BufDoneFtraceEvent(const Vb2V4l2BufDoneFtraceEvent&);
  Vb2V4l2BufDoneFtraceEvent& operator=(const Vb2V4l2BufDoneFtraceEvent&);
  bool operator==(const Vb2V4l2BufDoneFtraceEvent&) const;
  bool operator!=(const Vb2V4l2BufDoneFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_field() const { return _has_field_[1]; }
  uint32_t field() const { return field_; }
  void set_field(uint32_t value) { field_ = value; _has_field_.set(1); }

  bool has_flags() const { return _has_field_[2]; }
  uint32_t flags() const { return flags_; }
  void set_flags(uint32_t value) { flags_ = value; _has_field_.set(2); }

  bool has_minor() const { return _has_field_[3]; }
  int32_t minor() const { return minor_; }
  void set_minor(int32_t value) { minor_ = value; _has_field_.set(3); }

  bool has_sequence() const { return _has_field_[4]; }
  uint32_t sequence() const { return sequence_; }
  void set_sequence(uint32_t value) { sequence_ = value; _has_field_.set(4); }

  bool has_timecode_flags() const { return _has_field_[5]; }
  uint32_t timecode_flags() const { return timecode_flags_; }
  void set_timecode_flags(uint32_t value) { timecode_flags_ = value; _has_field_.set(5); }

  bool has_timecode_frames() const { return _has_field_[6]; }
  uint32_t timecode_frames() const { return timecode_frames_; }
  void set_timecode_frames(uint32_t value) { timecode_frames_ = value; _has_field_.set(6); }

  bool has_timecode_hours() const { return _has_field_[7]; }
  uint32_t timecode_hours() const { return timecode_hours_; }
  void set_timecode_hours(uint32_t value) { timecode_hours_ = value; _has_field_.set(7); }

  bool has_timecode_minutes() const { return _has_field_[8]; }
  uint32_t timecode_minutes() const { return timecode_minutes_; }
  void set_timecode_minutes(uint32_t value) { timecode_minutes_ = value; _has_field_.set(8); }

  bool has_timecode_seconds() const { return _has_field_[9]; }
  uint32_t timecode_seconds() const { return timecode_seconds_; }
  void set_timecode_seconds(uint32_t value) { timecode_seconds_ = value; _has_field_.set(9); }

  bool has_timecode_type() const { return _has_field_[10]; }
  uint32_t timecode_type() const { return timecode_type_; }
  void set_timecode_type(uint32_t value) { timecode_type_ = value; _has_field_.set(10); }

  bool has_timecode_userbits0() const { return _has_field_[11]; }
  uint32_t timecode_userbits0() const { return timecode_userbits0_; }
  void set_timecode_userbits0(uint32_t value) { timecode_userbits0_ = value; _has_field_.set(11); }

  bool has_timecode_userbits1() const { return _has_field_[12]; }
  uint32_t timecode_userbits1() const { return timecode_userbits1_; }
  void set_timecode_userbits1(uint32_t value) { timecode_userbits1_ = value; _has_field_.set(12); }

  bool has_timecode_userbits2() const { return _has_field_[13]; }
  uint32_t timecode_userbits2() const { return timecode_userbits2_; }
  void set_timecode_userbits2(uint32_t value) { timecode_userbits2_ = value; _has_field_.set(13); }

  bool has_timecode_userbits3() const { return _has_field_[14]; }
  uint32_t timecode_userbits3() const { return timecode_userbits3_; }
  void set_timecode_userbits3(uint32_t value) { timecode_userbits3_ = value; _has_field_.set(14); }

  bool has_timestamp() const { return _has_field_[15]; }
  int64_t timestamp() const { return timestamp_; }
  void set_timestamp(int64_t value) { timestamp_ = value; _has_field_.set(15); }

 private:
  uint32_t field_{};
  uint32_t flags_{};
  int32_t minor_{};
  uint32_t sequence_{};
  uint32_t timecode_flags_{};
  uint32_t timecode_frames_{};
  uint32_t timecode_hours_{};
  uint32_t timecode_minutes_{};
  uint32_t timecode_seconds_{};
  uint32_t timecode_type_{};
  uint32_t timecode_userbits0_{};
  uint32_t timecode_userbits1_{};
  uint32_t timecode_userbits2_{};
  uint32_t timecode_userbits3_{};
  int64_t timestamp_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<16> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT Vb2V4l2BufQueueFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kFieldFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kMinorFieldNumber = 3,
    kSequenceFieldNumber = 4,
    kTimecodeFlagsFieldNumber = 5,
    kTimecodeFramesFieldNumber = 6,
    kTimecodeHoursFieldNumber = 7,
    kTimecodeMinutesFieldNumber = 8,
    kTimecodeSecondsFieldNumber = 9,
    kTimecodeTypeFieldNumber = 10,
    kTimecodeUserbits0FieldNumber = 11,
    kTimecodeUserbits1FieldNumber = 12,
    kTimecodeUserbits2FieldNumber = 13,
    kTimecodeUserbits3FieldNumber = 14,
    kTimestampFieldNumber = 15,
  };

  Vb2V4l2BufQueueFtraceEvent();
  ~Vb2V4l2BufQueueFtraceEvent() override;
  Vb2V4l2BufQueueFtraceEvent(Vb2V4l2BufQueueFtraceEvent&&) noexcept;
  Vb2V4l2BufQueueFtraceEvent& operator=(Vb2V4l2BufQueueFtraceEvent&&);
  Vb2V4l2BufQueueFtraceEvent(const Vb2V4l2BufQueueFtraceEvent&);
  Vb2V4l2BufQueueFtraceEvent& operator=(const Vb2V4l2BufQueueFtraceEvent&);
  bool operator==(const Vb2V4l2BufQueueFtraceEvent&) const;
  bool operator!=(const Vb2V4l2BufQueueFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_field() const { return _has_field_[1]; }
  uint32_t field() const { return field_; }
  void set_field(uint32_t value) { field_ = value; _has_field_.set(1); }

  bool has_flags() const { return _has_field_[2]; }
  uint32_t flags() const { return flags_; }
  void set_flags(uint32_t value) { flags_ = value; _has_field_.set(2); }

  bool has_minor() const { return _has_field_[3]; }
  int32_t minor() const { return minor_; }
  void set_minor(int32_t value) { minor_ = value; _has_field_.set(3); }

  bool has_sequence() const { return _has_field_[4]; }
  uint32_t sequence() const { return sequence_; }
  void set_sequence(uint32_t value) { sequence_ = value; _has_field_.set(4); }

  bool has_timecode_flags() const { return _has_field_[5]; }
  uint32_t timecode_flags() const { return timecode_flags_; }
  void set_timecode_flags(uint32_t value) { timecode_flags_ = value; _has_field_.set(5); }

  bool has_timecode_frames() const { return _has_field_[6]; }
  uint32_t timecode_frames() const { return timecode_frames_; }
  void set_timecode_frames(uint32_t value) { timecode_frames_ = value; _has_field_.set(6); }

  bool has_timecode_hours() const { return _has_field_[7]; }
  uint32_t timecode_hours() const { return timecode_hours_; }
  void set_timecode_hours(uint32_t value) { timecode_hours_ = value; _has_field_.set(7); }

  bool has_timecode_minutes() const { return _has_field_[8]; }
  uint32_t timecode_minutes() const { return timecode_minutes_; }
  void set_timecode_minutes(uint32_t value) { timecode_minutes_ = value; _has_field_.set(8); }

  bool has_timecode_seconds() const { return _has_field_[9]; }
  uint32_t timecode_seconds() const { return timecode_seconds_; }
  void set_timecode_seconds(uint32_t value) { timecode_seconds_ = value; _has_field_.set(9); }

  bool has_timecode_type() const { return _has_field_[10]; }
  uint32_t timecode_type() const { return timecode_type_; }
  void set_timecode_type(uint32_t value) { timecode_type_ = value; _has_field_.set(10); }

  bool has_timecode_userbits0() const { return _has_field_[11]; }
  uint32_t timecode_userbits0() const { return timecode_userbits0_; }
  void set_timecode_userbits0(uint32_t value) { timecode_userbits0_ = value; _has_field_.set(11); }

  bool has_timecode_userbits1() const { return _has_field_[12]; }
  uint32_t timecode_userbits1() const { return timecode_userbits1_; }
  void set_timecode_userbits1(uint32_t value) { timecode_userbits1_ = value; _has_field_.set(12); }

  bool has_timecode_userbits2() const { return _has_field_[13]; }
  uint32_t timecode_userbits2() const { return timecode_userbits2_; }
  void set_timecode_userbits2(uint32_t value) { timecode_userbits2_ = value; _has_field_.set(13); }

  bool has_timecode_userbits3() const { return _has_field_[14]; }
  uint32_t timecode_userbits3() const { return timecode_userbits3_; }
  void set_timecode_userbits3(uint32_t value) { timecode_userbits3_ = value; _has_field_.set(14); }

  bool has_timestamp() const { return _has_field_[15]; }
  int64_t timestamp() const { return timestamp_; }
  void set_timestamp(int64_t value) { timestamp_ = value; _has_field_.set(15); }

 private:
  uint32_t field_{};
  uint32_t flags_{};
  int32_t minor_{};
  uint32_t sequence_{};
  uint32_t timecode_flags_{};
  uint32_t timecode_frames_{};
  uint32_t timecode_hours_{};
  uint32_t timecode_minutes_{};
  uint32_t timecode_seconds_{};
  uint32_t timecode_type_{};
  uint32_t timecode_userbits0_{};
  uint32_t timecode_userbits1_{};
  uint32_t timecode_userbits2_{};
  uint32_t timecode_userbits3_{};
  int64_t timestamp_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<16> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT V4l2DqbufFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kBytesusedFieldNumber = 1,
    kFieldFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kIndexFieldNumber = 4,
    kMinorFieldNumber = 5,
    kSequenceFieldNumber = 6,
    kTimecodeFlagsFieldNumber = 7,
    kTimecodeFramesFieldNumber = 8,
    kTimecodeHoursFieldNumber = 9,
    kTimecodeMinutesFieldNumber = 10,
    kTimecodeSecondsFieldNumber = 11,
    kTimecodeTypeFieldNumber = 12,
    kTimecodeUserbits0FieldNumber = 13,
    kTimecodeUserbits1FieldNumber = 14,
    kTimecodeUserbits2FieldNumber = 15,
    kTimecodeUserbits3FieldNumber = 16,
    kTimestampFieldNumber = 17,
    kTypeFieldNumber = 18,
  };

  V4l2DqbufFtraceEvent();
  ~V4l2DqbufFtraceEvent() override;
  V4l2DqbufFtraceEvent(V4l2DqbufFtraceEvent&&) noexcept;
  V4l2DqbufFtraceEvent& operator=(V4l2DqbufFtraceEvent&&);
  V4l2DqbufFtraceEvent(const V4l2DqbufFtraceEvent&);
  V4l2DqbufFtraceEvent& operator=(const V4l2DqbufFtraceEvent&);
  bool operator==(const V4l2DqbufFtraceEvent&) const;
  bool operator!=(const V4l2DqbufFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_bytesused() const { return _has_field_[1]; }
  uint32_t bytesused() const { return bytesused_; }
  void set_bytesused(uint32_t value) { bytesused_ = value; _has_field_.set(1); }

  bool has_field() const { return _has_field_[2]; }
  uint32_t field() const { return field_; }
  void set_field(uint32_t value) { field_ = value; _has_field_.set(2); }

  bool has_flags() const { return _has_field_[3]; }
  uint32_t flags() const { return flags_; }
  void set_flags(uint32_t value) { flags_ = value; _has_field_.set(3); }

  bool has_index() const { return _has_field_[4]; }
  uint32_t index() const { return index_; }
  void set_index(uint32_t value) { index_ = value; _has_field_.set(4); }

  bool has_minor() const { return _has_field_[5]; }
  int32_t minor() const { return minor_; }
  void set_minor(int32_t value) { minor_ = value; _has_field_.set(5); }

  bool has_sequence() const { return _has_field_[6]; }
  uint32_t sequence() const { return sequence_; }
  void set_sequence(uint32_t value) { sequence_ = value; _has_field_.set(6); }

  bool has_timecode_flags() const { return _has_field_[7]; }
  uint32_t timecode_flags() const { return timecode_flags_; }
  void set_timecode_flags(uint32_t value) { timecode_flags_ = value; _has_field_.set(7); }

  bool has_timecode_frames() const { return _has_field_[8]; }
  uint32_t timecode_frames() const { return timecode_frames_; }
  void set_timecode_frames(uint32_t value) { timecode_frames_ = value; _has_field_.set(8); }

  bool has_timecode_hours() const { return _has_field_[9]; }
  uint32_t timecode_hours() const { return timecode_hours_; }
  void set_timecode_hours(uint32_t value) { timecode_hours_ = value; _has_field_.set(9); }

  bool has_timecode_minutes() const { return _has_field_[10]; }
  uint32_t timecode_minutes() const { return timecode_minutes_; }
  void set_timecode_minutes(uint32_t value) { timecode_minutes_ = value; _has_field_.set(10); }

  bool has_timecode_seconds() const { return _has_field_[11]; }
  uint32_t timecode_seconds() const { return timecode_seconds_; }
  void set_timecode_seconds(uint32_t value) { timecode_seconds_ = value; _has_field_.set(11); }

  bool has_timecode_type() const { return _has_field_[12]; }
  uint32_t timecode_type() const { return timecode_type_; }
  void set_timecode_type(uint32_t value) { timecode_type_ = value; _has_field_.set(12); }

  bool has_timecode_userbits0() const { return _has_field_[13]; }
  uint32_t timecode_userbits0() const { return timecode_userbits0_; }
  void set_timecode_userbits0(uint32_t value) { timecode_userbits0_ = value; _has_field_.set(13); }

  bool has_timecode_userbits1() const { return _has_field_[14]; }
  uint32_t timecode_userbits1() const { return timecode_userbits1_; }
  void set_timecode_userbits1(uint32_t value) { timecode_userbits1_ = value; _has_field_.set(14); }

  bool has_timecode_userbits2() const { return _has_field_[15]; }
  uint32_t timecode_userbits2() const { return timecode_userbits2_; }
  void set_timecode_userbits2(uint32_t value) { timecode_userbits2_ = value; _has_field_.set(15); }

  bool has_timecode_userbits3() const { return _has_field_[16]; }
  uint32_t timecode_userbits3() const { return timecode_userbits3_; }
  void set_timecode_userbits3(uint32_t value) { timecode_userbits3_ = value; _has_field_.set(16); }

  bool has_timestamp() const { return _has_field_[17]; }
  int64_t timestamp() const { return timestamp_; }
  void set_timestamp(int64_t value) { timestamp_ = value; _has_field_.set(17); }

  bool has_type() const { return _has_field_[18]; }
  uint32_t type() const { return type_; }
  void set_type(uint32_t value) { type_ = value; _has_field_.set(18); }

 private:
  uint32_t bytesused_{};
  uint32_t field_{};
  uint32_t flags_{};
  uint32_t index_{};
  int32_t minor_{};
  uint32_t sequence_{};
  uint32_t timecode_flags_{};
  uint32_t timecode_frames_{};
  uint32_t timecode_hours_{};
  uint32_t timecode_minutes_{};
  uint32_t timecode_seconds_{};
  uint32_t timecode_type_{};
  uint32_t timecode_userbits0_{};
  uint32_t timecode_userbits1_{};
  uint32_t timecode_userbits2_{};
  uint32_t timecode_userbits3_{};
  int64_t timestamp_{};
  uint32_t type_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<19> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT V4l2QbufFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kBytesusedFieldNumber = 1,
    kFieldFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kIndexFieldNumber = 4,
    kMinorFieldNumber = 5,
    kSequenceFieldNumber = 6,
    kTimecodeFlagsFieldNumber = 7,
    kTimecodeFramesFieldNumber = 8,
    kTimecodeHoursFieldNumber = 9,
    kTimecodeMinutesFieldNumber = 10,
    kTimecodeSecondsFieldNumber = 11,
    kTimecodeTypeFieldNumber = 12,
    kTimecodeUserbits0FieldNumber = 13,
    kTimecodeUserbits1FieldNumber = 14,
    kTimecodeUserbits2FieldNumber = 15,
    kTimecodeUserbits3FieldNumber = 16,
    kTimestampFieldNumber = 17,
    kTypeFieldNumber = 18,
  };

  V4l2QbufFtraceEvent();
  ~V4l2QbufFtraceEvent() override;
  V4l2QbufFtraceEvent(V4l2QbufFtraceEvent&&) noexcept;
  V4l2QbufFtraceEvent& operator=(V4l2QbufFtraceEvent&&);
  V4l2QbufFtraceEvent(const V4l2QbufFtraceEvent&);
  V4l2QbufFtraceEvent& operator=(const V4l2QbufFtraceEvent&);
  bool operator==(const V4l2QbufFtraceEvent&) const;
  bool operator!=(const V4l2QbufFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_bytesused() const { return _has_field_[1]; }
  uint32_t bytesused() const { return bytesused_; }
  void set_bytesused(uint32_t value) { bytesused_ = value; _has_field_.set(1); }

  bool has_field() const { return _has_field_[2]; }
  uint32_t field() const { return field_; }
  void set_field(uint32_t value) { field_ = value; _has_field_.set(2); }

  bool has_flags() const { return _has_field_[3]; }
  uint32_t flags() const { return flags_; }
  void set_flags(uint32_t value) { flags_ = value; _has_field_.set(3); }

  bool has_index() const { return _has_field_[4]; }
  uint32_t index() const { return index_; }
  void set_index(uint32_t value) { index_ = value; _has_field_.set(4); }

  bool has_minor() const { return _has_field_[5]; }
  int32_t minor() const { return minor_; }
  void set_minor(int32_t value) { minor_ = value; _has_field_.set(5); }

  bool has_sequence() const { return _has_field_[6]; }
  uint32_t sequence() const { return sequence_; }
  void set_sequence(uint32_t value) { sequence_ = value; _has_field_.set(6); }

  bool has_timecode_flags() const { return _has_field_[7]; }
  uint32_t timecode_flags() const { return timecode_flags_; }
  void set_timecode_flags(uint32_t value) { timecode_flags_ = value; _has_field_.set(7); }

  bool has_timecode_frames() const { return _has_field_[8]; }
  uint32_t timecode_frames() const { return timecode_frames_; }
  void set_timecode_frames(uint32_t value) { timecode_frames_ = value; _has_field_.set(8); }

  bool has_timecode_hours() const { return _has_field_[9]; }
  uint32_t timecode_hours() const { return timecode_hours_; }
  void set_timecode_hours(uint32_t value) { timecode_hours_ = value; _has_field_.set(9); }

  bool has_timecode_minutes() const { return _has_field_[10]; }
  uint32_t timecode_minutes() const { return timecode_minutes_; }
  void set_timecode_minutes(uint32_t value) { timecode_minutes_ = value; _has_field_.set(10); }

  bool has_timecode_seconds() const { return _has_field_[11]; }
  uint32_t timecode_seconds() const { return timecode_seconds_; }
  void set_timecode_seconds(uint32_t value) { timecode_seconds_ = value; _has_field_.set(11); }

  bool has_timecode_type() const { return _has_field_[12]; }
  uint32_t timecode_type() const { return timecode_type_; }
  void set_timecode_type(uint32_t value) { timecode_type_ = value; _has_field_.set(12); }

  bool has_timecode_userbits0() const { return _has_field_[13]; }
  uint32_t timecode_userbits0() const { return timecode_userbits0_; }
  void set_timecode_userbits0(uint32_t value) { timecode_userbits0_ = value; _has_field_.set(13); }

  bool has_timecode_userbits1() const { return _has_field_[14]; }
  uint32_t timecode_userbits1() const { return timecode_userbits1_; }
  void set_timecode_userbits1(uint32_t value) { timecode_userbits1_ = value; _has_field_.set(14); }

  bool has_timecode_userbits2() const { return _has_field_[15]; }
  uint32_t timecode_userbits2() const { return timecode_userbits2_; }
  void set_timecode_userbits2(uint32_t value) { timecode_userbits2_ = value; _has_field_.set(15); }

  bool has_timecode_userbits3() const { return _has_field_[16]; }
  uint32_t timecode_userbits3() const { return timecode_userbits3_; }
  void set_timecode_userbits3(uint32_t value) { timecode_userbits3_ = value; _has_field_.set(16); }

  bool has_timestamp() const { return _has_field_[17]; }
  int64_t timestamp() const { return timestamp_; }
  void set_timestamp(int64_t value) { timestamp_ = value; _has_field_.set(17); }

  bool has_type() const { return _has_field_[18]; }
  uint32_t type() const { return type_; }
  void set_type(uint32_t value) { type_ = value; _has_field_.set(18); }

 private:
  uint32_t bytesused_{};
  uint32_t field_{};
  uint32_t flags_{};
  uint32_t index_{};
  int32_t minor_{};
  uint32_t sequence_{};
  uint32_t timecode_flags_{};
  uint32_t timecode_frames_{};
  uint32_t timecode_hours_{};
  uint32_t timecode_minutes_{};
  uint32_t timecode_seconds_{};
  uint32_t timecode_type_{};
  uint32_t timecode_userbits0_{};
  uint32_t timecode_userbits1_{};
  uint32_t timecode_userbits2_{};
  uint32_t timecode_userbits3_{};
  int64_t timestamp_{};
  uint32_t type_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<19> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_V4L2_PROTO_CPP_H_
