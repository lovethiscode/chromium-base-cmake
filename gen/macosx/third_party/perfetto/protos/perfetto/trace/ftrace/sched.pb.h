// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/trace/ftrace/sched.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto {
  static const uint32_t offsets[];
};
namespace perfetto {
namespace protos {
class SchedBlockedReasonFtraceEvent;
struct SchedBlockedReasonFtraceEventDefaultTypeInternal;
extern SchedBlockedReasonFtraceEventDefaultTypeInternal _SchedBlockedReasonFtraceEvent_default_instance_;
class SchedCpuHotplugFtraceEvent;
struct SchedCpuHotplugFtraceEventDefaultTypeInternal;
extern SchedCpuHotplugFtraceEventDefaultTypeInternal _SchedCpuHotplugFtraceEvent_default_instance_;
class SchedCpuUtilCfsFtraceEvent;
struct SchedCpuUtilCfsFtraceEventDefaultTypeInternal;
extern SchedCpuUtilCfsFtraceEventDefaultTypeInternal _SchedCpuUtilCfsFtraceEvent_default_instance_;
class SchedMigrateTaskFtraceEvent;
struct SchedMigrateTaskFtraceEventDefaultTypeInternal;
extern SchedMigrateTaskFtraceEventDefaultTypeInternal _SchedMigrateTaskFtraceEvent_default_instance_;
class SchedPiSetprioFtraceEvent;
struct SchedPiSetprioFtraceEventDefaultTypeInternal;
extern SchedPiSetprioFtraceEventDefaultTypeInternal _SchedPiSetprioFtraceEvent_default_instance_;
class SchedProcessExecFtraceEvent;
struct SchedProcessExecFtraceEventDefaultTypeInternal;
extern SchedProcessExecFtraceEventDefaultTypeInternal _SchedProcessExecFtraceEvent_default_instance_;
class SchedProcessExitFtraceEvent;
struct SchedProcessExitFtraceEventDefaultTypeInternal;
extern SchedProcessExitFtraceEventDefaultTypeInternal _SchedProcessExitFtraceEvent_default_instance_;
class SchedProcessForkFtraceEvent;
struct SchedProcessForkFtraceEventDefaultTypeInternal;
extern SchedProcessForkFtraceEventDefaultTypeInternal _SchedProcessForkFtraceEvent_default_instance_;
class SchedProcessFreeFtraceEvent;
struct SchedProcessFreeFtraceEventDefaultTypeInternal;
extern SchedProcessFreeFtraceEventDefaultTypeInternal _SchedProcessFreeFtraceEvent_default_instance_;
class SchedProcessHangFtraceEvent;
struct SchedProcessHangFtraceEventDefaultTypeInternal;
extern SchedProcessHangFtraceEventDefaultTypeInternal _SchedProcessHangFtraceEvent_default_instance_;
class SchedProcessWaitFtraceEvent;
struct SchedProcessWaitFtraceEventDefaultTypeInternal;
extern SchedProcessWaitFtraceEventDefaultTypeInternal _SchedProcessWaitFtraceEvent_default_instance_;
class SchedSwitchFtraceEvent;
struct SchedSwitchFtraceEventDefaultTypeInternal;
extern SchedSwitchFtraceEventDefaultTypeInternal _SchedSwitchFtraceEvent_default_instance_;
class SchedWakeupFtraceEvent;
struct SchedWakeupFtraceEventDefaultTypeInternal;
extern SchedWakeupFtraceEventDefaultTypeInternal _SchedWakeupFtraceEvent_default_instance_;
class SchedWakeupNewFtraceEvent;
struct SchedWakeupNewFtraceEventDefaultTypeInternal;
extern SchedWakeupNewFtraceEventDefaultTypeInternal _SchedWakeupNewFtraceEvent_default_instance_;
class SchedWakingFtraceEvent;
struct SchedWakingFtraceEventDefaultTypeInternal;
extern SchedWakingFtraceEventDefaultTypeInternal _SchedWakingFtraceEvent_default_instance_;
}  // namespace protos
}  // namespace perfetto
PROTOBUF_NAMESPACE_OPEN
template<> ::perfetto::protos::SchedBlockedReasonFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedBlockedReasonFtraceEvent>(Arena*);
template<> ::perfetto::protos::SchedCpuHotplugFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedCpuHotplugFtraceEvent>(Arena*);
template<> ::perfetto::protos::SchedCpuUtilCfsFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedCpuUtilCfsFtraceEvent>(Arena*);
template<> ::perfetto::protos::SchedMigrateTaskFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedMigrateTaskFtraceEvent>(Arena*);
template<> ::perfetto::protos::SchedPiSetprioFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedPiSetprioFtraceEvent>(Arena*);
template<> ::perfetto::protos::SchedProcessExecFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedProcessExecFtraceEvent>(Arena*);
template<> ::perfetto::protos::SchedProcessExitFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedProcessExitFtraceEvent>(Arena*);
template<> ::perfetto::protos::SchedProcessForkFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedProcessForkFtraceEvent>(Arena*);
template<> ::perfetto::protos::SchedProcessFreeFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedProcessFreeFtraceEvent>(Arena*);
template<> ::perfetto::protos::SchedProcessHangFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedProcessHangFtraceEvent>(Arena*);
template<> ::perfetto::protos::SchedProcessWaitFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedProcessWaitFtraceEvent>(Arena*);
template<> ::perfetto::protos::SchedSwitchFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedSwitchFtraceEvent>(Arena*);
template<> ::perfetto::protos::SchedWakeupFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedWakeupFtraceEvent>(Arena*);
template<> ::perfetto::protos::SchedWakeupNewFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedWakeupNewFtraceEvent>(Arena*);
template<> ::perfetto::protos::SchedWakingFtraceEvent* Arena::CreateMaybeMessage<::perfetto::protos::SchedWakingFtraceEvent>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace perfetto {
namespace protos {

// ===================================================================

class SchedSwitchFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedSwitchFtraceEvent) */ {
 public:
  inline SchedSwitchFtraceEvent() : SchedSwitchFtraceEvent(nullptr) {}
  ~SchedSwitchFtraceEvent() override;
  explicit PROTOBUF_CONSTEXPR SchedSwitchFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchedSwitchFtraceEvent(const SchedSwitchFtraceEvent& from);
  SchedSwitchFtraceEvent(SchedSwitchFtraceEvent&& from) noexcept
    : SchedSwitchFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedSwitchFtraceEvent& operator=(const SchedSwitchFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedSwitchFtraceEvent& operator=(SchedSwitchFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SchedSwitchFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchedSwitchFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedSwitchFtraceEvent*>(
               &_SchedSwitchFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SchedSwitchFtraceEvent& a, SchedSwitchFtraceEvent& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SchedSwitchFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchedSwitchFtraceEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchedSwitchFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchedSwitchFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SchedSwitchFtraceEvent& from);
  void MergeFrom(const SchedSwitchFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SchedSwitchFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.SchedSwitchFtraceEvent";
  }
  protected:
  explicit SchedSwitchFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrevCommFieldNumber = 1,
    kNextCommFieldNumber = 5,
    kPrevPidFieldNumber = 2,
    kPrevPrioFieldNumber = 3,
    kPrevStateFieldNumber = 4,
    kNextPidFieldNumber = 6,
    kNextPrioFieldNumber = 7,
  };
  // optional string prev_comm = 1;
  bool has_prev_comm() const;
  private:
  bool _internal_has_prev_comm() const;
  public:
  void clear_prev_comm();
  const std::string& prev_comm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prev_comm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prev_comm();
  PROTOBUF_NODISCARD std::string* release_prev_comm();
  void set_allocated_prev_comm(std::string* prev_comm);
  private:
  const std::string& _internal_prev_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prev_comm(const std::string& value);
  std::string* _internal_mutable_prev_comm();
  public:

  // optional string next_comm = 5;
  bool has_next_comm() const;
  private:
  bool _internal_has_next_comm() const;
  public:
  void clear_next_comm();
  const std::string& next_comm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_comm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_comm();
  PROTOBUF_NODISCARD std::string* release_next_comm();
  void set_allocated_next_comm(std::string* next_comm);
  private:
  const std::string& _internal_next_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_comm(const std::string& value);
  std::string* _internal_mutable_next_comm();
  public:

  // optional int32 prev_pid = 2;
  bool has_prev_pid() const;
  private:
  bool _internal_has_prev_pid() const;
  public:
  void clear_prev_pid();
  int32_t prev_pid() const;
  void set_prev_pid(int32_t value);
  private:
  int32_t _internal_prev_pid() const;
  void _internal_set_prev_pid(int32_t value);
  public:

  // optional int32 prev_prio = 3;
  bool has_prev_prio() const;
  private:
  bool _internal_has_prev_prio() const;
  public:
  void clear_prev_prio();
  int32_t prev_prio() const;
  void set_prev_prio(int32_t value);
  private:
  int32_t _internal_prev_prio() const;
  void _internal_set_prev_prio(int32_t value);
  public:

  // optional int64 prev_state = 4;
  bool has_prev_state() const;
  private:
  bool _internal_has_prev_state() const;
  public:
  void clear_prev_state();
  int64_t prev_state() const;
  void set_prev_state(int64_t value);
  private:
  int64_t _internal_prev_state() const;
  void _internal_set_prev_state(int64_t value);
  public:

  // optional int32 next_pid = 6;
  bool has_next_pid() const;
  private:
  bool _internal_has_next_pid() const;
  public:
  void clear_next_pid();
  int32_t next_pid() const;
  void set_next_pid(int32_t value);
  private:
  int32_t _internal_next_pid() const;
  void _internal_set_next_pid(int32_t value);
  public:

  // optional int32 next_prio = 7;
  bool has_next_prio() const;
  private:
  bool _internal_has_next_prio() const;
  public:
  void clear_next_prio();
  int32_t next_prio() const;
  void set_next_prio(int32_t value);
  private:
  int32_t _internal_next_prio() const;
  void _internal_set_next_prio(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedSwitchFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prev_comm_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_comm_;
    int32_t prev_pid_;
    int32_t prev_prio_;
    int64_t prev_state_;
    int32_t next_pid_;
    int32_t next_prio_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};
// -------------------------------------------------------------------

class SchedWakeupFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedWakeupFtraceEvent) */ {
 public:
  inline SchedWakeupFtraceEvent() : SchedWakeupFtraceEvent(nullptr) {}
  ~SchedWakeupFtraceEvent() override;
  explicit PROTOBUF_CONSTEXPR SchedWakeupFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchedWakeupFtraceEvent(const SchedWakeupFtraceEvent& from);
  SchedWakeupFtraceEvent(SchedWakeupFtraceEvent&& from) noexcept
    : SchedWakeupFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedWakeupFtraceEvent& operator=(const SchedWakeupFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedWakeupFtraceEvent& operator=(SchedWakeupFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SchedWakeupFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchedWakeupFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedWakeupFtraceEvent*>(
               &_SchedWakeupFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SchedWakeupFtraceEvent& a, SchedWakeupFtraceEvent& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SchedWakeupFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchedWakeupFtraceEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchedWakeupFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchedWakeupFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SchedWakeupFtraceEvent& from);
  void MergeFrom(const SchedWakeupFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SchedWakeupFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.SchedWakeupFtraceEvent";
  }
  protected:
  explicit SchedWakeupFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
    kSuccessFieldNumber = 4,
    kTargetCpuFieldNumber = 5,
  };
  // optional string comm = 1;
  bool has_comm() const;
  private:
  bool _internal_has_comm() const;
  public:
  void clear_comm();
  const std::string& comm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comm();
  PROTOBUF_NODISCARD std::string* release_comm();
  void set_allocated_comm(std::string* comm);
  private:
  const std::string& _internal_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comm(const std::string& value);
  std::string* _internal_mutable_comm();
  public:

  // optional int32 pid = 2;
  bool has_pid() const;
  private:
  bool _internal_has_pid() const;
  public:
  void clear_pid();
  int32_t pid() const;
  void set_pid(int32_t value);
  private:
  int32_t _internal_pid() const;
  void _internal_set_pid(int32_t value);
  public:

  // optional int32 prio = 3;
  bool has_prio() const;
  private:
  bool _internal_has_prio() const;
  public:
  void clear_prio();
  int32_t prio() const;
  void set_prio(int32_t value);
  private:
  int32_t _internal_prio() const;
  void _internal_set_prio(int32_t value);
  public:

  // optional int32 success = 4;
  bool has_success() const;
  private:
  bool _internal_has_success() const;
  public:
  void clear_success();
  int32_t success() const;
  void set_success(int32_t value);
  private:
  int32_t _internal_success() const;
  void _internal_set_success(int32_t value);
  public:

  // optional int32 target_cpu = 5;
  bool has_target_cpu() const;
  private:
  bool _internal_has_target_cpu() const;
  public:
  void clear_target_cpu();
  int32_t target_cpu() const;
  void set_target_cpu(int32_t value);
  private:
  int32_t _internal_target_cpu() const;
  void _internal_set_target_cpu(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedWakeupFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_;
    int32_t pid_;
    int32_t prio_;
    int32_t success_;
    int32_t target_cpu_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};
// -------------------------------------------------------------------

class SchedBlockedReasonFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedBlockedReasonFtraceEvent) */ {
 public:
  inline SchedBlockedReasonFtraceEvent() : SchedBlockedReasonFtraceEvent(nullptr) {}
  ~SchedBlockedReasonFtraceEvent() override;
  explicit PROTOBUF_CONSTEXPR SchedBlockedReasonFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchedBlockedReasonFtraceEvent(const SchedBlockedReasonFtraceEvent& from);
  SchedBlockedReasonFtraceEvent(SchedBlockedReasonFtraceEvent&& from) noexcept
    : SchedBlockedReasonFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedBlockedReasonFtraceEvent& operator=(const SchedBlockedReasonFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedBlockedReasonFtraceEvent& operator=(SchedBlockedReasonFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SchedBlockedReasonFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchedBlockedReasonFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedBlockedReasonFtraceEvent*>(
               &_SchedBlockedReasonFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SchedBlockedReasonFtraceEvent& a, SchedBlockedReasonFtraceEvent& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SchedBlockedReasonFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchedBlockedReasonFtraceEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchedBlockedReasonFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchedBlockedReasonFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SchedBlockedReasonFtraceEvent& from);
  void MergeFrom(const SchedBlockedReasonFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SchedBlockedReasonFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.SchedBlockedReasonFtraceEvent";
  }
  protected:
  explicit SchedBlockedReasonFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCallerFieldNumber = 2,
    kPidFieldNumber = 1,
    kIoWaitFieldNumber = 3,
  };
  // optional uint64 caller = 2;
  bool has_caller() const;
  private:
  bool _internal_has_caller() const;
  public:
  void clear_caller();
  uint64_t caller() const;
  void set_caller(uint64_t value);
  private:
  uint64_t _internal_caller() const;
  void _internal_set_caller(uint64_t value);
  public:

  // optional int32 pid = 1;
  bool has_pid() const;
  private:
  bool _internal_has_pid() const;
  public:
  void clear_pid();
  int32_t pid() const;
  void set_pid(int32_t value);
  private:
  int32_t _internal_pid() const;
  void _internal_set_pid(int32_t value);
  public:

  // optional uint32 io_wait = 3;
  bool has_io_wait() const;
  private:
  bool _internal_has_io_wait() const;
  public:
  void clear_io_wait();
  uint32_t io_wait() const;
  void set_io_wait(uint32_t value);
  private:
  uint32_t _internal_io_wait() const;
  void _internal_set_io_wait(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedBlockedReasonFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t caller_;
    int32_t pid_;
    uint32_t io_wait_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};
// -------------------------------------------------------------------

class SchedCpuHotplugFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedCpuHotplugFtraceEvent) */ {
 public:
  inline SchedCpuHotplugFtraceEvent() : SchedCpuHotplugFtraceEvent(nullptr) {}
  ~SchedCpuHotplugFtraceEvent() override;
  explicit PROTOBUF_CONSTEXPR SchedCpuHotplugFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchedCpuHotplugFtraceEvent(const SchedCpuHotplugFtraceEvent& from);
  SchedCpuHotplugFtraceEvent(SchedCpuHotplugFtraceEvent&& from) noexcept
    : SchedCpuHotplugFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedCpuHotplugFtraceEvent& operator=(const SchedCpuHotplugFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedCpuHotplugFtraceEvent& operator=(SchedCpuHotplugFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SchedCpuHotplugFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchedCpuHotplugFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedCpuHotplugFtraceEvent*>(
               &_SchedCpuHotplugFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SchedCpuHotplugFtraceEvent& a, SchedCpuHotplugFtraceEvent& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SchedCpuHotplugFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchedCpuHotplugFtraceEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchedCpuHotplugFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchedCpuHotplugFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SchedCpuHotplugFtraceEvent& from);
  void MergeFrom(const SchedCpuHotplugFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SchedCpuHotplugFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.SchedCpuHotplugFtraceEvent";
  }
  protected:
  explicit SchedCpuHotplugFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAffectedCpuFieldNumber = 1,
    kErrorFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // optional int32 affected_cpu = 1;
  bool has_affected_cpu() const;
  private:
  bool _internal_has_affected_cpu() const;
  public:
  void clear_affected_cpu();
  int32_t affected_cpu() const;
  void set_affected_cpu(int32_t value);
  private:
  int32_t _internal_affected_cpu() const;
  void _internal_set_affected_cpu(int32_t value);
  public:

  // optional int32 error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  int32_t error() const;
  void set_error(int32_t value);
  private:
  int32_t _internal_error() const;
  void _internal_set_error(int32_t value);
  public:

  // optional int32 status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  int32_t status() const;
  void set_status(int32_t value);
  private:
  int32_t _internal_status() const;
  void _internal_set_status(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedCpuHotplugFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t affected_cpu_;
    int32_t error_;
    int32_t status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};
// -------------------------------------------------------------------

class SchedWakingFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedWakingFtraceEvent) */ {
 public:
  inline SchedWakingFtraceEvent() : SchedWakingFtraceEvent(nullptr) {}
  ~SchedWakingFtraceEvent() override;
  explicit PROTOBUF_CONSTEXPR SchedWakingFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchedWakingFtraceEvent(const SchedWakingFtraceEvent& from);
  SchedWakingFtraceEvent(SchedWakingFtraceEvent&& from) noexcept
    : SchedWakingFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedWakingFtraceEvent& operator=(const SchedWakingFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedWakingFtraceEvent& operator=(SchedWakingFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SchedWakingFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchedWakingFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedWakingFtraceEvent*>(
               &_SchedWakingFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SchedWakingFtraceEvent& a, SchedWakingFtraceEvent& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SchedWakingFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchedWakingFtraceEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchedWakingFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchedWakingFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SchedWakingFtraceEvent& from);
  void MergeFrom(const SchedWakingFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SchedWakingFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.SchedWakingFtraceEvent";
  }
  protected:
  explicit SchedWakingFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
    kSuccessFieldNumber = 4,
    kTargetCpuFieldNumber = 5,
  };
  // optional string comm = 1;
  bool has_comm() const;
  private:
  bool _internal_has_comm() const;
  public:
  void clear_comm();
  const std::string& comm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comm();
  PROTOBUF_NODISCARD std::string* release_comm();
  void set_allocated_comm(std::string* comm);
  private:
  const std::string& _internal_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comm(const std::string& value);
  std::string* _internal_mutable_comm();
  public:

  // optional int32 pid = 2;
  bool has_pid() const;
  private:
  bool _internal_has_pid() const;
  public:
  void clear_pid();
  int32_t pid() const;
  void set_pid(int32_t value);
  private:
  int32_t _internal_pid() const;
  void _internal_set_pid(int32_t value);
  public:

  // optional int32 prio = 3;
  bool has_prio() const;
  private:
  bool _internal_has_prio() const;
  public:
  void clear_prio();
  int32_t prio() const;
  void set_prio(int32_t value);
  private:
  int32_t _internal_prio() const;
  void _internal_set_prio(int32_t value);
  public:

  // optional int32 success = 4;
  bool has_success() const;
  private:
  bool _internal_has_success() const;
  public:
  void clear_success();
  int32_t success() const;
  void set_success(int32_t value);
  private:
  int32_t _internal_success() const;
  void _internal_set_success(int32_t value);
  public:

  // optional int32 target_cpu = 5;
  bool has_target_cpu() const;
  private:
  bool _internal_has_target_cpu() const;
  public:
  void clear_target_cpu();
  int32_t target_cpu() const;
  void set_target_cpu(int32_t value);
  private:
  int32_t _internal_target_cpu() const;
  void _internal_set_target_cpu(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedWakingFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_;
    int32_t pid_;
    int32_t prio_;
    int32_t success_;
    int32_t target_cpu_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};
// -------------------------------------------------------------------

class SchedWakeupNewFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedWakeupNewFtraceEvent) */ {
 public:
  inline SchedWakeupNewFtraceEvent() : SchedWakeupNewFtraceEvent(nullptr) {}
  ~SchedWakeupNewFtraceEvent() override;
  explicit PROTOBUF_CONSTEXPR SchedWakeupNewFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchedWakeupNewFtraceEvent(const SchedWakeupNewFtraceEvent& from);
  SchedWakeupNewFtraceEvent(SchedWakeupNewFtraceEvent&& from) noexcept
    : SchedWakeupNewFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedWakeupNewFtraceEvent& operator=(const SchedWakeupNewFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedWakeupNewFtraceEvent& operator=(SchedWakeupNewFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SchedWakeupNewFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchedWakeupNewFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedWakeupNewFtraceEvent*>(
               &_SchedWakeupNewFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SchedWakeupNewFtraceEvent& a, SchedWakeupNewFtraceEvent& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SchedWakeupNewFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchedWakeupNewFtraceEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchedWakeupNewFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchedWakeupNewFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SchedWakeupNewFtraceEvent& from);
  void MergeFrom(const SchedWakeupNewFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SchedWakeupNewFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.SchedWakeupNewFtraceEvent";
  }
  protected:
  explicit SchedWakeupNewFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
    kSuccessFieldNumber = 4,
    kTargetCpuFieldNumber = 5,
  };
  // optional string comm = 1;
  bool has_comm() const;
  private:
  bool _internal_has_comm() const;
  public:
  void clear_comm();
  const std::string& comm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comm();
  PROTOBUF_NODISCARD std::string* release_comm();
  void set_allocated_comm(std::string* comm);
  private:
  const std::string& _internal_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comm(const std::string& value);
  std::string* _internal_mutable_comm();
  public:

  // optional int32 pid = 2;
  bool has_pid() const;
  private:
  bool _internal_has_pid() const;
  public:
  void clear_pid();
  int32_t pid() const;
  void set_pid(int32_t value);
  private:
  int32_t _internal_pid() const;
  void _internal_set_pid(int32_t value);
  public:

  // optional int32 prio = 3;
  bool has_prio() const;
  private:
  bool _internal_has_prio() const;
  public:
  void clear_prio();
  int32_t prio() const;
  void set_prio(int32_t value);
  private:
  int32_t _internal_prio() const;
  void _internal_set_prio(int32_t value);
  public:

  // optional int32 success = 4;
  bool has_success() const;
  private:
  bool _internal_has_success() const;
  public:
  void clear_success();
  int32_t success() const;
  void set_success(int32_t value);
  private:
  int32_t _internal_success() const;
  void _internal_set_success(int32_t value);
  public:

  // optional int32 target_cpu = 5;
  bool has_target_cpu() const;
  private:
  bool _internal_has_target_cpu() const;
  public:
  void clear_target_cpu();
  int32_t target_cpu() const;
  void set_target_cpu(int32_t value);
  private:
  int32_t _internal_target_cpu() const;
  void _internal_set_target_cpu(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedWakeupNewFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_;
    int32_t pid_;
    int32_t prio_;
    int32_t success_;
    int32_t target_cpu_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};
// -------------------------------------------------------------------

class SchedProcessExecFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedProcessExecFtraceEvent) */ {
 public:
  inline SchedProcessExecFtraceEvent() : SchedProcessExecFtraceEvent(nullptr) {}
  ~SchedProcessExecFtraceEvent() override;
  explicit PROTOBUF_CONSTEXPR SchedProcessExecFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchedProcessExecFtraceEvent(const SchedProcessExecFtraceEvent& from);
  SchedProcessExecFtraceEvent(SchedProcessExecFtraceEvent&& from) noexcept
    : SchedProcessExecFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedProcessExecFtraceEvent& operator=(const SchedProcessExecFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedProcessExecFtraceEvent& operator=(SchedProcessExecFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SchedProcessExecFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchedProcessExecFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedProcessExecFtraceEvent*>(
               &_SchedProcessExecFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SchedProcessExecFtraceEvent& a, SchedProcessExecFtraceEvent& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SchedProcessExecFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchedProcessExecFtraceEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchedProcessExecFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchedProcessExecFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SchedProcessExecFtraceEvent& from);
  void MergeFrom(const SchedProcessExecFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SchedProcessExecFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.SchedProcessExecFtraceEvent";
  }
  protected:
  explicit SchedProcessExecFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilenameFieldNumber = 1,
    kPidFieldNumber = 2,
    kOldPidFieldNumber = 3,
  };
  // optional string filename = 1;
  bool has_filename() const;
  private:
  bool _internal_has_filename() const;
  public:
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // optional int32 pid = 2;
  bool has_pid() const;
  private:
  bool _internal_has_pid() const;
  public:
  void clear_pid();
  int32_t pid() const;
  void set_pid(int32_t value);
  private:
  int32_t _internal_pid() const;
  void _internal_set_pid(int32_t value);
  public:

  // optional int32 old_pid = 3;
  bool has_old_pid() const;
  private:
  bool _internal_has_old_pid() const;
  public:
  void clear_old_pid();
  int32_t old_pid() const;
  void set_old_pid(int32_t value);
  private:
  int32_t _internal_old_pid() const;
  void _internal_set_old_pid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedProcessExecFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
    int32_t pid_;
    int32_t old_pid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};
// -------------------------------------------------------------------

class SchedProcessExitFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedProcessExitFtraceEvent) */ {
 public:
  inline SchedProcessExitFtraceEvent() : SchedProcessExitFtraceEvent(nullptr) {}
  ~SchedProcessExitFtraceEvent() override;
  explicit PROTOBUF_CONSTEXPR SchedProcessExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchedProcessExitFtraceEvent(const SchedProcessExitFtraceEvent& from);
  SchedProcessExitFtraceEvent(SchedProcessExitFtraceEvent&& from) noexcept
    : SchedProcessExitFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedProcessExitFtraceEvent& operator=(const SchedProcessExitFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedProcessExitFtraceEvent& operator=(SchedProcessExitFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SchedProcessExitFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchedProcessExitFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedProcessExitFtraceEvent*>(
               &_SchedProcessExitFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SchedProcessExitFtraceEvent& a, SchedProcessExitFtraceEvent& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SchedProcessExitFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchedProcessExitFtraceEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchedProcessExitFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchedProcessExitFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SchedProcessExitFtraceEvent& from);
  void MergeFrom(const SchedProcessExitFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SchedProcessExitFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.SchedProcessExitFtraceEvent";
  }
  protected:
  explicit SchedProcessExitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kTgidFieldNumber = 3,
    kPrioFieldNumber = 4,
  };
  // optional string comm = 1;
  bool has_comm() const;
  private:
  bool _internal_has_comm() const;
  public:
  void clear_comm();
  const std::string& comm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comm();
  PROTOBUF_NODISCARD std::string* release_comm();
  void set_allocated_comm(std::string* comm);
  private:
  const std::string& _internal_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comm(const std::string& value);
  std::string* _internal_mutable_comm();
  public:

  // optional int32 pid = 2;
  bool has_pid() const;
  private:
  bool _internal_has_pid() const;
  public:
  void clear_pid();
  int32_t pid() const;
  void set_pid(int32_t value);
  private:
  int32_t _internal_pid() const;
  void _internal_set_pid(int32_t value);
  public:

  // optional int32 tgid = 3;
  bool has_tgid() const;
  private:
  bool _internal_has_tgid() const;
  public:
  void clear_tgid();
  int32_t tgid() const;
  void set_tgid(int32_t value);
  private:
  int32_t _internal_tgid() const;
  void _internal_set_tgid(int32_t value);
  public:

  // optional int32 prio = 4;
  bool has_prio() const;
  private:
  bool _internal_has_prio() const;
  public:
  void clear_prio();
  int32_t prio() const;
  void set_prio(int32_t value);
  private:
  int32_t _internal_prio() const;
  void _internal_set_prio(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedProcessExitFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_;
    int32_t pid_;
    int32_t tgid_;
    int32_t prio_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};
// -------------------------------------------------------------------

class SchedProcessForkFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedProcessForkFtraceEvent) */ {
 public:
  inline SchedProcessForkFtraceEvent() : SchedProcessForkFtraceEvent(nullptr) {}
  ~SchedProcessForkFtraceEvent() override;
  explicit PROTOBUF_CONSTEXPR SchedProcessForkFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchedProcessForkFtraceEvent(const SchedProcessForkFtraceEvent& from);
  SchedProcessForkFtraceEvent(SchedProcessForkFtraceEvent&& from) noexcept
    : SchedProcessForkFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedProcessForkFtraceEvent& operator=(const SchedProcessForkFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedProcessForkFtraceEvent& operator=(SchedProcessForkFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SchedProcessForkFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchedProcessForkFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedProcessForkFtraceEvent*>(
               &_SchedProcessForkFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SchedProcessForkFtraceEvent& a, SchedProcessForkFtraceEvent& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SchedProcessForkFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchedProcessForkFtraceEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchedProcessForkFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchedProcessForkFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SchedProcessForkFtraceEvent& from);
  void MergeFrom(const SchedProcessForkFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SchedProcessForkFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.SchedProcessForkFtraceEvent";
  }
  protected:
  explicit SchedProcessForkFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentCommFieldNumber = 1,
    kChildCommFieldNumber = 3,
    kParentPidFieldNumber = 2,
    kChildPidFieldNumber = 4,
  };
  // optional string parent_comm = 1;
  bool has_parent_comm() const;
  private:
  bool _internal_has_parent_comm() const;
  public:
  void clear_parent_comm();
  const std::string& parent_comm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent_comm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent_comm();
  PROTOBUF_NODISCARD std::string* release_parent_comm();
  void set_allocated_parent_comm(std::string* parent_comm);
  private:
  const std::string& _internal_parent_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_comm(const std::string& value);
  std::string* _internal_mutable_parent_comm();
  public:

  // optional string child_comm = 3;
  bool has_child_comm() const;
  private:
  bool _internal_has_child_comm() const;
  public:
  void clear_child_comm();
  const std::string& child_comm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_child_comm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_child_comm();
  PROTOBUF_NODISCARD std::string* release_child_comm();
  void set_allocated_child_comm(std::string* child_comm);
  private:
  const std::string& _internal_child_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_child_comm(const std::string& value);
  std::string* _internal_mutable_child_comm();
  public:

  // optional int32 parent_pid = 2;
  bool has_parent_pid() const;
  private:
  bool _internal_has_parent_pid() const;
  public:
  void clear_parent_pid();
  int32_t parent_pid() const;
  void set_parent_pid(int32_t value);
  private:
  int32_t _internal_parent_pid() const;
  void _internal_set_parent_pid(int32_t value);
  public:

  // optional int32 child_pid = 4;
  bool has_child_pid() const;
  private:
  bool _internal_has_child_pid() const;
  public:
  void clear_child_pid();
  int32_t child_pid() const;
  void set_child_pid(int32_t value);
  private:
  int32_t _internal_child_pid() const;
  void _internal_set_child_pid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedProcessForkFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_comm_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr child_comm_;
    int32_t parent_pid_;
    int32_t child_pid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};
// -------------------------------------------------------------------

class SchedProcessFreeFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedProcessFreeFtraceEvent) */ {
 public:
  inline SchedProcessFreeFtraceEvent() : SchedProcessFreeFtraceEvent(nullptr) {}
  ~SchedProcessFreeFtraceEvent() override;
  explicit PROTOBUF_CONSTEXPR SchedProcessFreeFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchedProcessFreeFtraceEvent(const SchedProcessFreeFtraceEvent& from);
  SchedProcessFreeFtraceEvent(SchedProcessFreeFtraceEvent&& from) noexcept
    : SchedProcessFreeFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedProcessFreeFtraceEvent& operator=(const SchedProcessFreeFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedProcessFreeFtraceEvent& operator=(SchedProcessFreeFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SchedProcessFreeFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchedProcessFreeFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedProcessFreeFtraceEvent*>(
               &_SchedProcessFreeFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SchedProcessFreeFtraceEvent& a, SchedProcessFreeFtraceEvent& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SchedProcessFreeFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchedProcessFreeFtraceEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchedProcessFreeFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchedProcessFreeFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SchedProcessFreeFtraceEvent& from);
  void MergeFrom(const SchedProcessFreeFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SchedProcessFreeFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.SchedProcessFreeFtraceEvent";
  }
  protected:
  explicit SchedProcessFreeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
  };
  // optional string comm = 1;
  bool has_comm() const;
  private:
  bool _internal_has_comm() const;
  public:
  void clear_comm();
  const std::string& comm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comm();
  PROTOBUF_NODISCARD std::string* release_comm();
  void set_allocated_comm(std::string* comm);
  private:
  const std::string& _internal_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comm(const std::string& value);
  std::string* _internal_mutable_comm();
  public:

  // optional int32 pid = 2;
  bool has_pid() const;
  private:
  bool _internal_has_pid() const;
  public:
  void clear_pid();
  int32_t pid() const;
  void set_pid(int32_t value);
  private:
  int32_t _internal_pid() const;
  void _internal_set_pid(int32_t value);
  public:

  // optional int32 prio = 3;
  bool has_prio() const;
  private:
  bool _internal_has_prio() const;
  public:
  void clear_prio();
  int32_t prio() const;
  void set_prio(int32_t value);
  private:
  int32_t _internal_prio() const;
  void _internal_set_prio(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedProcessFreeFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_;
    int32_t pid_;
    int32_t prio_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};
// -------------------------------------------------------------------

class SchedProcessHangFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedProcessHangFtraceEvent) */ {
 public:
  inline SchedProcessHangFtraceEvent() : SchedProcessHangFtraceEvent(nullptr) {}
  ~SchedProcessHangFtraceEvent() override;
  explicit PROTOBUF_CONSTEXPR SchedProcessHangFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchedProcessHangFtraceEvent(const SchedProcessHangFtraceEvent& from);
  SchedProcessHangFtraceEvent(SchedProcessHangFtraceEvent&& from) noexcept
    : SchedProcessHangFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedProcessHangFtraceEvent& operator=(const SchedProcessHangFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedProcessHangFtraceEvent& operator=(SchedProcessHangFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SchedProcessHangFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchedProcessHangFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedProcessHangFtraceEvent*>(
               &_SchedProcessHangFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SchedProcessHangFtraceEvent& a, SchedProcessHangFtraceEvent& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SchedProcessHangFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchedProcessHangFtraceEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchedProcessHangFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchedProcessHangFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SchedProcessHangFtraceEvent& from);
  void MergeFrom(const SchedProcessHangFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SchedProcessHangFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.SchedProcessHangFtraceEvent";
  }
  protected:
  explicit SchedProcessHangFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
  };
  // optional string comm = 1;
  bool has_comm() const;
  private:
  bool _internal_has_comm() const;
  public:
  void clear_comm();
  const std::string& comm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comm();
  PROTOBUF_NODISCARD std::string* release_comm();
  void set_allocated_comm(std::string* comm);
  private:
  const std::string& _internal_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comm(const std::string& value);
  std::string* _internal_mutable_comm();
  public:

  // optional int32 pid = 2;
  bool has_pid() const;
  private:
  bool _internal_has_pid() const;
  public:
  void clear_pid();
  int32_t pid() const;
  void set_pid(int32_t value);
  private:
  int32_t _internal_pid() const;
  void _internal_set_pid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedProcessHangFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_;
    int32_t pid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};
// -------------------------------------------------------------------

class SchedProcessWaitFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedProcessWaitFtraceEvent) */ {
 public:
  inline SchedProcessWaitFtraceEvent() : SchedProcessWaitFtraceEvent(nullptr) {}
  ~SchedProcessWaitFtraceEvent() override;
  explicit PROTOBUF_CONSTEXPR SchedProcessWaitFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchedProcessWaitFtraceEvent(const SchedProcessWaitFtraceEvent& from);
  SchedProcessWaitFtraceEvent(SchedProcessWaitFtraceEvent&& from) noexcept
    : SchedProcessWaitFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedProcessWaitFtraceEvent& operator=(const SchedProcessWaitFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedProcessWaitFtraceEvent& operator=(SchedProcessWaitFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SchedProcessWaitFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchedProcessWaitFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedProcessWaitFtraceEvent*>(
               &_SchedProcessWaitFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SchedProcessWaitFtraceEvent& a, SchedProcessWaitFtraceEvent& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SchedProcessWaitFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchedProcessWaitFtraceEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchedProcessWaitFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchedProcessWaitFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SchedProcessWaitFtraceEvent& from);
  void MergeFrom(const SchedProcessWaitFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SchedProcessWaitFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.SchedProcessWaitFtraceEvent";
  }
  protected:
  explicit SchedProcessWaitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
  };
  // optional string comm = 1;
  bool has_comm() const;
  private:
  bool _internal_has_comm() const;
  public:
  void clear_comm();
  const std::string& comm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comm();
  PROTOBUF_NODISCARD std::string* release_comm();
  void set_allocated_comm(std::string* comm);
  private:
  const std::string& _internal_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comm(const std::string& value);
  std::string* _internal_mutable_comm();
  public:

  // optional int32 pid = 2;
  bool has_pid() const;
  private:
  bool _internal_has_pid() const;
  public:
  void clear_pid();
  int32_t pid() const;
  void set_pid(int32_t value);
  private:
  int32_t _internal_pid() const;
  void _internal_set_pid(int32_t value);
  public:

  // optional int32 prio = 3;
  bool has_prio() const;
  private:
  bool _internal_has_prio() const;
  public:
  void clear_prio();
  int32_t prio() const;
  void set_prio(int32_t value);
  private:
  int32_t _internal_prio() const;
  void _internal_set_prio(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedProcessWaitFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_;
    int32_t pid_;
    int32_t prio_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};
// -------------------------------------------------------------------

class SchedPiSetprioFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedPiSetprioFtraceEvent) */ {
 public:
  inline SchedPiSetprioFtraceEvent() : SchedPiSetprioFtraceEvent(nullptr) {}
  ~SchedPiSetprioFtraceEvent() override;
  explicit PROTOBUF_CONSTEXPR SchedPiSetprioFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchedPiSetprioFtraceEvent(const SchedPiSetprioFtraceEvent& from);
  SchedPiSetprioFtraceEvent(SchedPiSetprioFtraceEvent&& from) noexcept
    : SchedPiSetprioFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedPiSetprioFtraceEvent& operator=(const SchedPiSetprioFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedPiSetprioFtraceEvent& operator=(SchedPiSetprioFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SchedPiSetprioFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchedPiSetprioFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedPiSetprioFtraceEvent*>(
               &_SchedPiSetprioFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SchedPiSetprioFtraceEvent& a, SchedPiSetprioFtraceEvent& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SchedPiSetprioFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchedPiSetprioFtraceEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchedPiSetprioFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchedPiSetprioFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SchedPiSetprioFtraceEvent& from);
  void MergeFrom(const SchedPiSetprioFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SchedPiSetprioFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.SchedPiSetprioFtraceEvent";
  }
  protected:
  explicit SchedPiSetprioFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommFieldNumber = 1,
    kNewprioFieldNumber = 2,
    kOldprioFieldNumber = 3,
    kPidFieldNumber = 4,
  };
  // optional string comm = 1;
  bool has_comm() const;
  private:
  bool _internal_has_comm() const;
  public:
  void clear_comm();
  const std::string& comm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comm();
  PROTOBUF_NODISCARD std::string* release_comm();
  void set_allocated_comm(std::string* comm);
  private:
  const std::string& _internal_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comm(const std::string& value);
  std::string* _internal_mutable_comm();
  public:

  // optional int32 newprio = 2;
  bool has_newprio() const;
  private:
  bool _internal_has_newprio() const;
  public:
  void clear_newprio();
  int32_t newprio() const;
  void set_newprio(int32_t value);
  private:
  int32_t _internal_newprio() const;
  void _internal_set_newprio(int32_t value);
  public:

  // optional int32 oldprio = 3;
  bool has_oldprio() const;
  private:
  bool _internal_has_oldprio() const;
  public:
  void clear_oldprio();
  int32_t oldprio() const;
  void set_oldprio(int32_t value);
  private:
  int32_t _internal_oldprio() const;
  void _internal_set_oldprio(int32_t value);
  public:

  // optional int32 pid = 4;
  bool has_pid() const;
  private:
  bool _internal_has_pid() const;
  public:
  void clear_pid();
  int32_t pid() const;
  void set_pid(int32_t value);
  private:
  int32_t _internal_pid() const;
  void _internal_set_pid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedPiSetprioFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_;
    int32_t newprio_;
    int32_t oldprio_;
    int32_t pid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};
// -------------------------------------------------------------------

class SchedCpuUtilCfsFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedCpuUtilCfsFtraceEvent) */ {
 public:
  inline SchedCpuUtilCfsFtraceEvent() : SchedCpuUtilCfsFtraceEvent(nullptr) {}
  ~SchedCpuUtilCfsFtraceEvent() override;
  explicit PROTOBUF_CONSTEXPR SchedCpuUtilCfsFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchedCpuUtilCfsFtraceEvent(const SchedCpuUtilCfsFtraceEvent& from);
  SchedCpuUtilCfsFtraceEvent(SchedCpuUtilCfsFtraceEvent&& from) noexcept
    : SchedCpuUtilCfsFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedCpuUtilCfsFtraceEvent& operator=(const SchedCpuUtilCfsFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedCpuUtilCfsFtraceEvent& operator=(SchedCpuUtilCfsFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SchedCpuUtilCfsFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchedCpuUtilCfsFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedCpuUtilCfsFtraceEvent*>(
               &_SchedCpuUtilCfsFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SchedCpuUtilCfsFtraceEvent& a, SchedCpuUtilCfsFtraceEvent& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SchedCpuUtilCfsFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchedCpuUtilCfsFtraceEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchedCpuUtilCfsFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchedCpuUtilCfsFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SchedCpuUtilCfsFtraceEvent& from);
  void MergeFrom(const SchedCpuUtilCfsFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SchedCpuUtilCfsFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.SchedCpuUtilCfsFtraceEvent";
  }
  protected:
  explicit SchedCpuUtilCfsFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapacityFieldNumber = 2,
    kActiveFieldNumber = 1,
    kCpuFieldNumber = 4,
    kCapacityOrigFieldNumber = 3,
    kCpuImportanceFieldNumber = 5,
    kCpuUtilFieldNumber = 6,
    kGroupCapacityFieldNumber = 8,
    kExitLatFieldNumber = 7,
    kGrpOverutilizedFieldNumber = 9,
    kIdleCpuFieldNumber = 10,
    kNrRunningFieldNumber = 11,
    kSpareCapFieldNumber = 12,
    kWakeGroupUtilFieldNumber = 14,
    kWakeUtilFieldNumber = 15,
    kTaskFitsFieldNumber = 13,
  };
  // optional uint64 capacity = 2;
  bool has_capacity() const;
  private:
  bool _internal_has_capacity() const;
  public:
  void clear_capacity();
  uint64_t capacity() const;
  void set_capacity(uint64_t value);
  private:
  uint64_t _internal_capacity() const;
  void _internal_set_capacity(uint64_t value);
  public:

  // optional int32 active = 1;
  bool has_active() const;
  private:
  bool _internal_has_active() const;
  public:
  void clear_active();
  int32_t active() const;
  void set_active(int32_t value);
  private:
  int32_t _internal_active() const;
  void _internal_set_active(int32_t value);
  public:

  // optional uint32 cpu = 4;
  bool has_cpu() const;
  private:
  bool _internal_has_cpu() const;
  public:
  void clear_cpu();
  uint32_t cpu() const;
  void set_cpu(uint32_t value);
  private:
  uint32_t _internal_cpu() const;
  void _internal_set_cpu(uint32_t value);
  public:

  // optional uint64 capacity_orig = 3;
  bool has_capacity_orig() const;
  private:
  bool _internal_has_capacity_orig() const;
  public:
  void clear_capacity_orig();
  uint64_t capacity_orig() const;
  void set_capacity_orig(uint64_t value);
  private:
  uint64_t _internal_capacity_orig() const;
  void _internal_set_capacity_orig(uint64_t value);
  public:

  // optional uint64 cpu_importance = 5;
  bool has_cpu_importance() const;
  private:
  bool _internal_has_cpu_importance() const;
  public:
  void clear_cpu_importance();
  uint64_t cpu_importance() const;
  void set_cpu_importance(uint64_t value);
  private:
  uint64_t _internal_cpu_importance() const;
  void _internal_set_cpu_importance(uint64_t value);
  public:

  // optional uint64 cpu_util = 6;
  bool has_cpu_util() const;
  private:
  bool _internal_has_cpu_util() const;
  public:
  void clear_cpu_util();
  uint64_t cpu_util() const;
  void set_cpu_util(uint64_t value);
  private:
  uint64_t _internal_cpu_util() const;
  void _internal_set_cpu_util(uint64_t value);
  public:

  // optional uint64 group_capacity = 8;
  bool has_group_capacity() const;
  private:
  bool _internal_has_group_capacity() const;
  public:
  void clear_group_capacity();
  uint64_t group_capacity() const;
  void set_group_capacity(uint64_t value);
  private:
  uint64_t _internal_group_capacity() const;
  void _internal_set_group_capacity(uint64_t value);
  public:

  // optional uint32 exit_lat = 7;
  bool has_exit_lat() const;
  private:
  bool _internal_has_exit_lat() const;
  public:
  void clear_exit_lat();
  uint32_t exit_lat() const;
  void set_exit_lat(uint32_t value);
  private:
  uint32_t _internal_exit_lat() const;
  void _internal_set_exit_lat(uint32_t value);
  public:

  // optional uint32 grp_overutilized = 9;
  bool has_grp_overutilized() const;
  private:
  bool _internal_has_grp_overutilized() const;
  public:
  void clear_grp_overutilized();
  uint32_t grp_overutilized() const;
  void set_grp_overutilized(uint32_t value);
  private:
  uint32_t _internal_grp_overutilized() const;
  void _internal_set_grp_overutilized(uint32_t value);
  public:

  // optional uint32 idle_cpu = 10;
  bool has_idle_cpu() const;
  private:
  bool _internal_has_idle_cpu() const;
  public:
  void clear_idle_cpu();
  uint32_t idle_cpu() const;
  void set_idle_cpu(uint32_t value);
  private:
  uint32_t _internal_idle_cpu() const;
  void _internal_set_idle_cpu(uint32_t value);
  public:

  // optional uint32 nr_running = 11;
  bool has_nr_running() const;
  private:
  bool _internal_has_nr_running() const;
  public:
  void clear_nr_running();
  uint32_t nr_running() const;
  void set_nr_running(uint32_t value);
  private:
  uint32_t _internal_nr_running() const;
  void _internal_set_nr_running(uint32_t value);
  public:

  // optional int64 spare_cap = 12;
  bool has_spare_cap() const;
  private:
  bool _internal_has_spare_cap() const;
  public:
  void clear_spare_cap();
  int64_t spare_cap() const;
  void set_spare_cap(int64_t value);
  private:
  int64_t _internal_spare_cap() const;
  void _internal_set_spare_cap(int64_t value);
  public:

  // optional uint64 wake_group_util = 14;
  bool has_wake_group_util() const;
  private:
  bool _internal_has_wake_group_util() const;
  public:
  void clear_wake_group_util();
  uint64_t wake_group_util() const;
  void set_wake_group_util(uint64_t value);
  private:
  uint64_t _internal_wake_group_util() const;
  void _internal_set_wake_group_util(uint64_t value);
  public:

  // optional uint64 wake_util = 15;
  bool has_wake_util() const;
  private:
  bool _internal_has_wake_util() const;
  public:
  void clear_wake_util();
  uint64_t wake_util() const;
  void set_wake_util(uint64_t value);
  private:
  uint64_t _internal_wake_util() const;
  void _internal_set_wake_util(uint64_t value);
  public:

  // optional uint32 task_fits = 13;
  bool has_task_fits() const;
  private:
  bool _internal_has_task_fits() const;
  public:
  void clear_task_fits();
  uint32_t task_fits() const;
  void set_task_fits(uint32_t value);
  private:
  uint32_t _internal_task_fits() const;
  void _internal_set_task_fits(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedCpuUtilCfsFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t capacity_;
    int32_t active_;
    uint32_t cpu_;
    uint64_t capacity_orig_;
    uint64_t cpu_importance_;
    uint64_t cpu_util_;
    uint64_t group_capacity_;
    uint32_t exit_lat_;
    uint32_t grp_overutilized_;
    uint32_t idle_cpu_;
    uint32_t nr_running_;
    int64_t spare_cap_;
    uint64_t wake_group_util_;
    uint64_t wake_util_;
    uint32_t task_fits_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};
// -------------------------------------------------------------------

class SchedMigrateTaskFtraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.SchedMigrateTaskFtraceEvent) */ {
 public:
  inline SchedMigrateTaskFtraceEvent() : SchedMigrateTaskFtraceEvent(nullptr) {}
  ~SchedMigrateTaskFtraceEvent() override;
  explicit PROTOBUF_CONSTEXPR SchedMigrateTaskFtraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchedMigrateTaskFtraceEvent(const SchedMigrateTaskFtraceEvent& from);
  SchedMigrateTaskFtraceEvent(SchedMigrateTaskFtraceEvent&& from) noexcept
    : SchedMigrateTaskFtraceEvent() {
    *this = ::std::move(from);
  }

  inline SchedMigrateTaskFtraceEvent& operator=(const SchedMigrateTaskFtraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedMigrateTaskFtraceEvent& operator=(SchedMigrateTaskFtraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SchedMigrateTaskFtraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchedMigrateTaskFtraceEvent* internal_default_instance() {
    return reinterpret_cast<const SchedMigrateTaskFtraceEvent*>(
               &_SchedMigrateTaskFtraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SchedMigrateTaskFtraceEvent& a, SchedMigrateTaskFtraceEvent& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SchedMigrateTaskFtraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchedMigrateTaskFtraceEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchedMigrateTaskFtraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchedMigrateTaskFtraceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SchedMigrateTaskFtraceEvent& from);
  void MergeFrom(const SchedMigrateTaskFtraceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SchedMigrateTaskFtraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.SchedMigrateTaskFtraceEvent";
  }
  protected:
  explicit SchedMigrateTaskFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
    kOrigCpuFieldNumber = 4,
    kDestCpuFieldNumber = 5,
    kRunningFieldNumber = 6,
    kLoadFieldNumber = 7,
  };
  // optional string comm = 1;
  bool has_comm() const;
  private:
  bool _internal_has_comm() const;
  public:
  void clear_comm();
  const std::string& comm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comm();
  PROTOBUF_NODISCARD std::string* release_comm();
  void set_allocated_comm(std::string* comm);
  private:
  const std::string& _internal_comm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comm(const std::string& value);
  std::string* _internal_mutable_comm();
  public:

  // optional int32 pid = 2;
  bool has_pid() const;
  private:
  bool _internal_has_pid() const;
  public:
  void clear_pid();
  int32_t pid() const;
  void set_pid(int32_t value);
  private:
  int32_t _internal_pid() const;
  void _internal_set_pid(int32_t value);
  public:

  // optional int32 prio = 3;
  bool has_prio() const;
  private:
  bool _internal_has_prio() const;
  public:
  void clear_prio();
  int32_t prio() const;
  void set_prio(int32_t value);
  private:
  int32_t _internal_prio() const;
  void _internal_set_prio(int32_t value);
  public:

  // optional int32 orig_cpu = 4;
  bool has_orig_cpu() const;
  private:
  bool _internal_has_orig_cpu() const;
  public:
  void clear_orig_cpu();
  int32_t orig_cpu() const;
  void set_orig_cpu(int32_t value);
  private:
  int32_t _internal_orig_cpu() const;
  void _internal_set_orig_cpu(int32_t value);
  public:

  // optional int32 dest_cpu = 5;
  bool has_dest_cpu() const;
  private:
  bool _internal_has_dest_cpu() const;
  public:
  void clear_dest_cpu();
  int32_t dest_cpu() const;
  void set_dest_cpu(int32_t value);
  private:
  int32_t _internal_dest_cpu() const;
  void _internal_set_dest_cpu(int32_t value);
  public:

  // optional int32 running = 6;
  bool has_running() const;
  private:
  bool _internal_has_running() const;
  public:
  void clear_running();
  int32_t running() const;
  void set_running(int32_t value);
  private:
  int32_t _internal_running() const;
  void _internal_set_running(int32_t value);
  public:

  // optional uint32 load = 7;
  bool has_load() const;
  private:
  bool _internal_has_load() const;
  public:
  void clear_load();
  uint32_t load() const;
  void set_load(uint32_t value);
  private:
  uint32_t _internal_load() const;
  void _internal_set_load(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:perfetto.protos.SchedMigrateTaskFtraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_;
    int32_t pid_;
    int32_t prio_;
    int32_t orig_cpu_;
    int32_t dest_cpu_;
    int32_t running_;
    uint32_t load_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SchedSwitchFtraceEvent

// optional string prev_comm = 1;
inline bool SchedSwitchFtraceEvent::_internal_has_prev_comm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SchedSwitchFtraceEvent::has_prev_comm() const {
  return _internal_has_prev_comm();
}
inline void SchedSwitchFtraceEvent::clear_prev_comm() {
  _impl_.prev_comm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchedSwitchFtraceEvent::prev_comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedSwitchFtraceEvent.prev_comm)
  return _internal_prev_comm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchedSwitchFtraceEvent::set_prev_comm(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.prev_comm_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedSwitchFtraceEvent.prev_comm)
}
inline std::string* SchedSwitchFtraceEvent::mutable_prev_comm() {
  std::string* _s = _internal_mutable_prev_comm();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedSwitchFtraceEvent.prev_comm)
  return _s;
}
inline const std::string& SchedSwitchFtraceEvent::_internal_prev_comm() const {
  return _impl_.prev_comm_.Get();
}
inline void SchedSwitchFtraceEvent::_internal_set_prev_comm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.prev_comm_.Set(value, GetArenaForAllocation());
}
inline std::string* SchedSwitchFtraceEvent::_internal_mutable_prev_comm() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.prev_comm_.Mutable(GetArenaForAllocation());
}
inline std::string* SchedSwitchFtraceEvent::release_prev_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedSwitchFtraceEvent.prev_comm)
  if (!_internal_has_prev_comm()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.prev_comm_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.prev_comm_.IsDefault()) {
    _impl_.prev_comm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SchedSwitchFtraceEvent::set_allocated_prev_comm(std::string* prev_comm) {
  if (prev_comm != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.prev_comm_.SetAllocated(prev_comm, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.prev_comm_.IsDefault()) {
    _impl_.prev_comm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedSwitchFtraceEvent.prev_comm)
}

// optional int32 prev_pid = 2;
inline bool SchedSwitchFtraceEvent::_internal_has_prev_pid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SchedSwitchFtraceEvent::has_prev_pid() const {
  return _internal_has_prev_pid();
}
inline void SchedSwitchFtraceEvent::clear_prev_pid() {
  _impl_.prev_pid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t SchedSwitchFtraceEvent::_internal_prev_pid() const {
  return _impl_.prev_pid_;
}
inline int32_t SchedSwitchFtraceEvent::prev_pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedSwitchFtraceEvent.prev_pid)
  return _internal_prev_pid();
}
inline void SchedSwitchFtraceEvent::_internal_set_prev_pid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.prev_pid_ = value;
}
inline void SchedSwitchFtraceEvent::set_prev_pid(int32_t value) {
  _internal_set_prev_pid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedSwitchFtraceEvent.prev_pid)
}

// optional int32 prev_prio = 3;
inline bool SchedSwitchFtraceEvent::_internal_has_prev_prio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SchedSwitchFtraceEvent::has_prev_prio() const {
  return _internal_has_prev_prio();
}
inline void SchedSwitchFtraceEvent::clear_prev_prio() {
  _impl_.prev_prio_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t SchedSwitchFtraceEvent::_internal_prev_prio() const {
  return _impl_.prev_prio_;
}
inline int32_t SchedSwitchFtraceEvent::prev_prio() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedSwitchFtraceEvent.prev_prio)
  return _internal_prev_prio();
}
inline void SchedSwitchFtraceEvent::_internal_set_prev_prio(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.prev_prio_ = value;
}
inline void SchedSwitchFtraceEvent::set_prev_prio(int32_t value) {
  _internal_set_prev_prio(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedSwitchFtraceEvent.prev_prio)
}

// optional int64 prev_state = 4;
inline bool SchedSwitchFtraceEvent::_internal_has_prev_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SchedSwitchFtraceEvent::has_prev_state() const {
  return _internal_has_prev_state();
}
inline void SchedSwitchFtraceEvent::clear_prev_state() {
  _impl_.prev_state_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int64_t SchedSwitchFtraceEvent::_internal_prev_state() const {
  return _impl_.prev_state_;
}
inline int64_t SchedSwitchFtraceEvent::prev_state() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedSwitchFtraceEvent.prev_state)
  return _internal_prev_state();
}
inline void SchedSwitchFtraceEvent::_internal_set_prev_state(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.prev_state_ = value;
}
inline void SchedSwitchFtraceEvent::set_prev_state(int64_t value) {
  _internal_set_prev_state(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedSwitchFtraceEvent.prev_state)
}

// optional string next_comm = 5;
inline bool SchedSwitchFtraceEvent::_internal_has_next_comm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SchedSwitchFtraceEvent::has_next_comm() const {
  return _internal_has_next_comm();
}
inline void SchedSwitchFtraceEvent::clear_next_comm() {
  _impl_.next_comm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SchedSwitchFtraceEvent::next_comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedSwitchFtraceEvent.next_comm)
  return _internal_next_comm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchedSwitchFtraceEvent::set_next_comm(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.next_comm_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedSwitchFtraceEvent.next_comm)
}
inline std::string* SchedSwitchFtraceEvent::mutable_next_comm() {
  std::string* _s = _internal_mutable_next_comm();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedSwitchFtraceEvent.next_comm)
  return _s;
}
inline const std::string& SchedSwitchFtraceEvent::_internal_next_comm() const {
  return _impl_.next_comm_.Get();
}
inline void SchedSwitchFtraceEvent::_internal_set_next_comm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.next_comm_.Set(value, GetArenaForAllocation());
}
inline std::string* SchedSwitchFtraceEvent::_internal_mutable_next_comm() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.next_comm_.Mutable(GetArenaForAllocation());
}
inline std::string* SchedSwitchFtraceEvent::release_next_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedSwitchFtraceEvent.next_comm)
  if (!_internal_has_next_comm()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.next_comm_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_comm_.IsDefault()) {
    _impl_.next_comm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SchedSwitchFtraceEvent::set_allocated_next_comm(std::string* next_comm) {
  if (next_comm != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.next_comm_.SetAllocated(next_comm, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_comm_.IsDefault()) {
    _impl_.next_comm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedSwitchFtraceEvent.next_comm)
}

// optional int32 next_pid = 6;
inline bool SchedSwitchFtraceEvent::_internal_has_next_pid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SchedSwitchFtraceEvent::has_next_pid() const {
  return _internal_has_next_pid();
}
inline void SchedSwitchFtraceEvent::clear_next_pid() {
  _impl_.next_pid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t SchedSwitchFtraceEvent::_internal_next_pid() const {
  return _impl_.next_pid_;
}
inline int32_t SchedSwitchFtraceEvent::next_pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedSwitchFtraceEvent.next_pid)
  return _internal_next_pid();
}
inline void SchedSwitchFtraceEvent::_internal_set_next_pid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.next_pid_ = value;
}
inline void SchedSwitchFtraceEvent::set_next_pid(int32_t value) {
  _internal_set_next_pid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedSwitchFtraceEvent.next_pid)
}

// optional int32 next_prio = 7;
inline bool SchedSwitchFtraceEvent::_internal_has_next_prio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool SchedSwitchFtraceEvent::has_next_prio() const {
  return _internal_has_next_prio();
}
inline void SchedSwitchFtraceEvent::clear_next_prio() {
  _impl_.next_prio_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int32_t SchedSwitchFtraceEvent::_internal_next_prio() const {
  return _impl_.next_prio_;
}
inline int32_t SchedSwitchFtraceEvent::next_prio() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedSwitchFtraceEvent.next_prio)
  return _internal_next_prio();
}
inline void SchedSwitchFtraceEvent::_internal_set_next_prio(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.next_prio_ = value;
}
inline void SchedSwitchFtraceEvent::set_next_prio(int32_t value) {
  _internal_set_next_prio(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedSwitchFtraceEvent.next_prio)
}

// -------------------------------------------------------------------

// SchedWakeupFtraceEvent

// optional string comm = 1;
inline bool SchedWakeupFtraceEvent::_internal_has_comm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SchedWakeupFtraceEvent::has_comm() const {
  return _internal_has_comm();
}
inline void SchedWakeupFtraceEvent::clear_comm() {
  _impl_.comm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchedWakeupFtraceEvent::comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakeupFtraceEvent.comm)
  return _internal_comm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchedWakeupFtraceEvent::set_comm(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.comm_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakeupFtraceEvent.comm)
}
inline std::string* SchedWakeupFtraceEvent::mutable_comm() {
  std::string* _s = _internal_mutable_comm();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedWakeupFtraceEvent.comm)
  return _s;
}
inline const std::string& SchedWakeupFtraceEvent::_internal_comm() const {
  return _impl_.comm_.Get();
}
inline void SchedWakeupFtraceEvent::_internal_set_comm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.comm_.Set(value, GetArenaForAllocation());
}
inline std::string* SchedWakeupFtraceEvent::_internal_mutable_comm() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.comm_.Mutable(GetArenaForAllocation());
}
inline std::string* SchedWakeupFtraceEvent::release_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedWakeupFtraceEvent.comm)
  if (!_internal_has_comm()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.comm_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comm_.IsDefault()) {
    _impl_.comm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SchedWakeupFtraceEvent::set_allocated_comm(std::string* comm) {
  if (comm != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.comm_.SetAllocated(comm, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comm_.IsDefault()) {
    _impl_.comm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedWakeupFtraceEvent.comm)
}

// optional int32 pid = 2;
inline bool SchedWakeupFtraceEvent::_internal_has_pid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SchedWakeupFtraceEvent::has_pid() const {
  return _internal_has_pid();
}
inline void SchedWakeupFtraceEvent::clear_pid() {
  _impl_.pid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t SchedWakeupFtraceEvent::_internal_pid() const {
  return _impl_.pid_;
}
inline int32_t SchedWakeupFtraceEvent::pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakeupFtraceEvent.pid)
  return _internal_pid();
}
inline void SchedWakeupFtraceEvent::_internal_set_pid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pid_ = value;
}
inline void SchedWakeupFtraceEvent::set_pid(int32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakeupFtraceEvent.pid)
}

// optional int32 prio = 3;
inline bool SchedWakeupFtraceEvent::_internal_has_prio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SchedWakeupFtraceEvent::has_prio() const {
  return _internal_has_prio();
}
inline void SchedWakeupFtraceEvent::clear_prio() {
  _impl_.prio_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t SchedWakeupFtraceEvent::_internal_prio() const {
  return _impl_.prio_;
}
inline int32_t SchedWakeupFtraceEvent::prio() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakeupFtraceEvent.prio)
  return _internal_prio();
}
inline void SchedWakeupFtraceEvent::_internal_set_prio(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.prio_ = value;
}
inline void SchedWakeupFtraceEvent::set_prio(int32_t value) {
  _internal_set_prio(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakeupFtraceEvent.prio)
}

// optional int32 success = 4;
inline bool SchedWakeupFtraceEvent::_internal_has_success() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SchedWakeupFtraceEvent::has_success() const {
  return _internal_has_success();
}
inline void SchedWakeupFtraceEvent::clear_success() {
  _impl_.success_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t SchedWakeupFtraceEvent::_internal_success() const {
  return _impl_.success_;
}
inline int32_t SchedWakeupFtraceEvent::success() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakeupFtraceEvent.success)
  return _internal_success();
}
inline void SchedWakeupFtraceEvent::_internal_set_success(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.success_ = value;
}
inline void SchedWakeupFtraceEvent::set_success(int32_t value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakeupFtraceEvent.success)
}

// optional int32 target_cpu = 5;
inline bool SchedWakeupFtraceEvent::_internal_has_target_cpu() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SchedWakeupFtraceEvent::has_target_cpu() const {
  return _internal_has_target_cpu();
}
inline void SchedWakeupFtraceEvent::clear_target_cpu() {
  _impl_.target_cpu_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t SchedWakeupFtraceEvent::_internal_target_cpu() const {
  return _impl_.target_cpu_;
}
inline int32_t SchedWakeupFtraceEvent::target_cpu() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakeupFtraceEvent.target_cpu)
  return _internal_target_cpu();
}
inline void SchedWakeupFtraceEvent::_internal_set_target_cpu(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.target_cpu_ = value;
}
inline void SchedWakeupFtraceEvent::set_target_cpu(int32_t value) {
  _internal_set_target_cpu(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakeupFtraceEvent.target_cpu)
}

// -------------------------------------------------------------------

// SchedBlockedReasonFtraceEvent

// optional int32 pid = 1;
inline bool SchedBlockedReasonFtraceEvent::_internal_has_pid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SchedBlockedReasonFtraceEvent::has_pid() const {
  return _internal_has_pid();
}
inline void SchedBlockedReasonFtraceEvent::clear_pid() {
  _impl_.pid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t SchedBlockedReasonFtraceEvent::_internal_pid() const {
  return _impl_.pid_;
}
inline int32_t SchedBlockedReasonFtraceEvent::pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedBlockedReasonFtraceEvent.pid)
  return _internal_pid();
}
inline void SchedBlockedReasonFtraceEvent::_internal_set_pid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pid_ = value;
}
inline void SchedBlockedReasonFtraceEvent::set_pid(int32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedBlockedReasonFtraceEvent.pid)
}

// optional uint64 caller = 2;
inline bool SchedBlockedReasonFtraceEvent::_internal_has_caller() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SchedBlockedReasonFtraceEvent::has_caller() const {
  return _internal_has_caller();
}
inline void SchedBlockedReasonFtraceEvent::clear_caller() {
  _impl_.caller_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t SchedBlockedReasonFtraceEvent::_internal_caller() const {
  return _impl_.caller_;
}
inline uint64_t SchedBlockedReasonFtraceEvent::caller() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedBlockedReasonFtraceEvent.caller)
  return _internal_caller();
}
inline void SchedBlockedReasonFtraceEvent::_internal_set_caller(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.caller_ = value;
}
inline void SchedBlockedReasonFtraceEvent::set_caller(uint64_t value) {
  _internal_set_caller(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedBlockedReasonFtraceEvent.caller)
}

// optional uint32 io_wait = 3;
inline bool SchedBlockedReasonFtraceEvent::_internal_has_io_wait() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SchedBlockedReasonFtraceEvent::has_io_wait() const {
  return _internal_has_io_wait();
}
inline void SchedBlockedReasonFtraceEvent::clear_io_wait() {
  _impl_.io_wait_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t SchedBlockedReasonFtraceEvent::_internal_io_wait() const {
  return _impl_.io_wait_;
}
inline uint32_t SchedBlockedReasonFtraceEvent::io_wait() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedBlockedReasonFtraceEvent.io_wait)
  return _internal_io_wait();
}
inline void SchedBlockedReasonFtraceEvent::_internal_set_io_wait(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.io_wait_ = value;
}
inline void SchedBlockedReasonFtraceEvent::set_io_wait(uint32_t value) {
  _internal_set_io_wait(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedBlockedReasonFtraceEvent.io_wait)
}

// -------------------------------------------------------------------

// SchedCpuHotplugFtraceEvent

// optional int32 affected_cpu = 1;
inline bool SchedCpuHotplugFtraceEvent::_internal_has_affected_cpu() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SchedCpuHotplugFtraceEvent::has_affected_cpu() const {
  return _internal_has_affected_cpu();
}
inline void SchedCpuHotplugFtraceEvent::clear_affected_cpu() {
  _impl_.affected_cpu_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t SchedCpuHotplugFtraceEvent::_internal_affected_cpu() const {
  return _impl_.affected_cpu_;
}
inline int32_t SchedCpuHotplugFtraceEvent::affected_cpu() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuHotplugFtraceEvent.affected_cpu)
  return _internal_affected_cpu();
}
inline void SchedCpuHotplugFtraceEvent::_internal_set_affected_cpu(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.affected_cpu_ = value;
}
inline void SchedCpuHotplugFtraceEvent::set_affected_cpu(int32_t value) {
  _internal_set_affected_cpu(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuHotplugFtraceEvent.affected_cpu)
}

// optional int32 error = 2;
inline bool SchedCpuHotplugFtraceEvent::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SchedCpuHotplugFtraceEvent::has_error() const {
  return _internal_has_error();
}
inline void SchedCpuHotplugFtraceEvent::clear_error() {
  _impl_.error_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t SchedCpuHotplugFtraceEvent::_internal_error() const {
  return _impl_.error_;
}
inline int32_t SchedCpuHotplugFtraceEvent::error() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuHotplugFtraceEvent.error)
  return _internal_error();
}
inline void SchedCpuHotplugFtraceEvent::_internal_set_error(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.error_ = value;
}
inline void SchedCpuHotplugFtraceEvent::set_error(int32_t value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuHotplugFtraceEvent.error)
}

// optional int32 status = 3;
inline bool SchedCpuHotplugFtraceEvent::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SchedCpuHotplugFtraceEvent::has_status() const {
  return _internal_has_status();
}
inline void SchedCpuHotplugFtraceEvent::clear_status() {
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t SchedCpuHotplugFtraceEvent::_internal_status() const {
  return _impl_.status_;
}
inline int32_t SchedCpuHotplugFtraceEvent::status() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuHotplugFtraceEvent.status)
  return _internal_status();
}
inline void SchedCpuHotplugFtraceEvent::_internal_set_status(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.status_ = value;
}
inline void SchedCpuHotplugFtraceEvent::set_status(int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuHotplugFtraceEvent.status)
}

// -------------------------------------------------------------------

// SchedWakingFtraceEvent

// optional string comm = 1;
inline bool SchedWakingFtraceEvent::_internal_has_comm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SchedWakingFtraceEvent::has_comm() const {
  return _internal_has_comm();
}
inline void SchedWakingFtraceEvent::clear_comm() {
  _impl_.comm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchedWakingFtraceEvent::comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakingFtraceEvent.comm)
  return _internal_comm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchedWakingFtraceEvent::set_comm(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.comm_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakingFtraceEvent.comm)
}
inline std::string* SchedWakingFtraceEvent::mutable_comm() {
  std::string* _s = _internal_mutable_comm();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedWakingFtraceEvent.comm)
  return _s;
}
inline const std::string& SchedWakingFtraceEvent::_internal_comm() const {
  return _impl_.comm_.Get();
}
inline void SchedWakingFtraceEvent::_internal_set_comm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.comm_.Set(value, GetArenaForAllocation());
}
inline std::string* SchedWakingFtraceEvent::_internal_mutable_comm() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.comm_.Mutable(GetArenaForAllocation());
}
inline std::string* SchedWakingFtraceEvent::release_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedWakingFtraceEvent.comm)
  if (!_internal_has_comm()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.comm_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comm_.IsDefault()) {
    _impl_.comm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SchedWakingFtraceEvent::set_allocated_comm(std::string* comm) {
  if (comm != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.comm_.SetAllocated(comm, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comm_.IsDefault()) {
    _impl_.comm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedWakingFtraceEvent.comm)
}

// optional int32 pid = 2;
inline bool SchedWakingFtraceEvent::_internal_has_pid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SchedWakingFtraceEvent::has_pid() const {
  return _internal_has_pid();
}
inline void SchedWakingFtraceEvent::clear_pid() {
  _impl_.pid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t SchedWakingFtraceEvent::_internal_pid() const {
  return _impl_.pid_;
}
inline int32_t SchedWakingFtraceEvent::pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakingFtraceEvent.pid)
  return _internal_pid();
}
inline void SchedWakingFtraceEvent::_internal_set_pid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pid_ = value;
}
inline void SchedWakingFtraceEvent::set_pid(int32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakingFtraceEvent.pid)
}

// optional int32 prio = 3;
inline bool SchedWakingFtraceEvent::_internal_has_prio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SchedWakingFtraceEvent::has_prio() const {
  return _internal_has_prio();
}
inline void SchedWakingFtraceEvent::clear_prio() {
  _impl_.prio_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t SchedWakingFtraceEvent::_internal_prio() const {
  return _impl_.prio_;
}
inline int32_t SchedWakingFtraceEvent::prio() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakingFtraceEvent.prio)
  return _internal_prio();
}
inline void SchedWakingFtraceEvent::_internal_set_prio(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.prio_ = value;
}
inline void SchedWakingFtraceEvent::set_prio(int32_t value) {
  _internal_set_prio(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakingFtraceEvent.prio)
}

// optional int32 success = 4;
inline bool SchedWakingFtraceEvent::_internal_has_success() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SchedWakingFtraceEvent::has_success() const {
  return _internal_has_success();
}
inline void SchedWakingFtraceEvent::clear_success() {
  _impl_.success_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t SchedWakingFtraceEvent::_internal_success() const {
  return _impl_.success_;
}
inline int32_t SchedWakingFtraceEvent::success() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakingFtraceEvent.success)
  return _internal_success();
}
inline void SchedWakingFtraceEvent::_internal_set_success(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.success_ = value;
}
inline void SchedWakingFtraceEvent::set_success(int32_t value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakingFtraceEvent.success)
}

// optional int32 target_cpu = 5;
inline bool SchedWakingFtraceEvent::_internal_has_target_cpu() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SchedWakingFtraceEvent::has_target_cpu() const {
  return _internal_has_target_cpu();
}
inline void SchedWakingFtraceEvent::clear_target_cpu() {
  _impl_.target_cpu_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t SchedWakingFtraceEvent::_internal_target_cpu() const {
  return _impl_.target_cpu_;
}
inline int32_t SchedWakingFtraceEvent::target_cpu() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakingFtraceEvent.target_cpu)
  return _internal_target_cpu();
}
inline void SchedWakingFtraceEvent::_internal_set_target_cpu(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.target_cpu_ = value;
}
inline void SchedWakingFtraceEvent::set_target_cpu(int32_t value) {
  _internal_set_target_cpu(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakingFtraceEvent.target_cpu)
}

// -------------------------------------------------------------------

// SchedWakeupNewFtraceEvent

// optional string comm = 1;
inline bool SchedWakeupNewFtraceEvent::_internal_has_comm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SchedWakeupNewFtraceEvent::has_comm() const {
  return _internal_has_comm();
}
inline void SchedWakeupNewFtraceEvent::clear_comm() {
  _impl_.comm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchedWakeupNewFtraceEvent::comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakeupNewFtraceEvent.comm)
  return _internal_comm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchedWakeupNewFtraceEvent::set_comm(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.comm_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakeupNewFtraceEvent.comm)
}
inline std::string* SchedWakeupNewFtraceEvent::mutable_comm() {
  std::string* _s = _internal_mutable_comm();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedWakeupNewFtraceEvent.comm)
  return _s;
}
inline const std::string& SchedWakeupNewFtraceEvent::_internal_comm() const {
  return _impl_.comm_.Get();
}
inline void SchedWakeupNewFtraceEvent::_internal_set_comm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.comm_.Set(value, GetArenaForAllocation());
}
inline std::string* SchedWakeupNewFtraceEvent::_internal_mutable_comm() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.comm_.Mutable(GetArenaForAllocation());
}
inline std::string* SchedWakeupNewFtraceEvent::release_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedWakeupNewFtraceEvent.comm)
  if (!_internal_has_comm()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.comm_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comm_.IsDefault()) {
    _impl_.comm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SchedWakeupNewFtraceEvent::set_allocated_comm(std::string* comm) {
  if (comm != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.comm_.SetAllocated(comm, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comm_.IsDefault()) {
    _impl_.comm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedWakeupNewFtraceEvent.comm)
}

// optional int32 pid = 2;
inline bool SchedWakeupNewFtraceEvent::_internal_has_pid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SchedWakeupNewFtraceEvent::has_pid() const {
  return _internal_has_pid();
}
inline void SchedWakeupNewFtraceEvent::clear_pid() {
  _impl_.pid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t SchedWakeupNewFtraceEvent::_internal_pid() const {
  return _impl_.pid_;
}
inline int32_t SchedWakeupNewFtraceEvent::pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakeupNewFtraceEvent.pid)
  return _internal_pid();
}
inline void SchedWakeupNewFtraceEvent::_internal_set_pid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pid_ = value;
}
inline void SchedWakeupNewFtraceEvent::set_pid(int32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakeupNewFtraceEvent.pid)
}

// optional int32 prio = 3;
inline bool SchedWakeupNewFtraceEvent::_internal_has_prio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SchedWakeupNewFtraceEvent::has_prio() const {
  return _internal_has_prio();
}
inline void SchedWakeupNewFtraceEvent::clear_prio() {
  _impl_.prio_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t SchedWakeupNewFtraceEvent::_internal_prio() const {
  return _impl_.prio_;
}
inline int32_t SchedWakeupNewFtraceEvent::prio() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakeupNewFtraceEvent.prio)
  return _internal_prio();
}
inline void SchedWakeupNewFtraceEvent::_internal_set_prio(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.prio_ = value;
}
inline void SchedWakeupNewFtraceEvent::set_prio(int32_t value) {
  _internal_set_prio(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakeupNewFtraceEvent.prio)
}

// optional int32 success = 4;
inline bool SchedWakeupNewFtraceEvent::_internal_has_success() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SchedWakeupNewFtraceEvent::has_success() const {
  return _internal_has_success();
}
inline void SchedWakeupNewFtraceEvent::clear_success() {
  _impl_.success_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t SchedWakeupNewFtraceEvent::_internal_success() const {
  return _impl_.success_;
}
inline int32_t SchedWakeupNewFtraceEvent::success() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakeupNewFtraceEvent.success)
  return _internal_success();
}
inline void SchedWakeupNewFtraceEvent::_internal_set_success(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.success_ = value;
}
inline void SchedWakeupNewFtraceEvent::set_success(int32_t value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakeupNewFtraceEvent.success)
}

// optional int32 target_cpu = 5;
inline bool SchedWakeupNewFtraceEvent::_internal_has_target_cpu() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SchedWakeupNewFtraceEvent::has_target_cpu() const {
  return _internal_has_target_cpu();
}
inline void SchedWakeupNewFtraceEvent::clear_target_cpu() {
  _impl_.target_cpu_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t SchedWakeupNewFtraceEvent::_internal_target_cpu() const {
  return _impl_.target_cpu_;
}
inline int32_t SchedWakeupNewFtraceEvent::target_cpu() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedWakeupNewFtraceEvent.target_cpu)
  return _internal_target_cpu();
}
inline void SchedWakeupNewFtraceEvent::_internal_set_target_cpu(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.target_cpu_ = value;
}
inline void SchedWakeupNewFtraceEvent::set_target_cpu(int32_t value) {
  _internal_set_target_cpu(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedWakeupNewFtraceEvent.target_cpu)
}

// -------------------------------------------------------------------

// SchedProcessExecFtraceEvent

// optional string filename = 1;
inline bool SchedProcessExecFtraceEvent::_internal_has_filename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SchedProcessExecFtraceEvent::has_filename() const {
  return _internal_has_filename();
}
inline void SchedProcessExecFtraceEvent::clear_filename() {
  _impl_.filename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchedProcessExecFtraceEvent::filename() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessExecFtraceEvent.filename)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchedProcessExecFtraceEvent::set_filename(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessExecFtraceEvent.filename)
}
inline std::string* SchedProcessExecFtraceEvent::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedProcessExecFtraceEvent.filename)
  return _s;
}
inline const std::string& SchedProcessExecFtraceEvent::_internal_filename() const {
  return _impl_.filename_.Get();
}
inline void SchedProcessExecFtraceEvent::_internal_set_filename(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filename_.Set(value, GetArenaForAllocation());
}
inline std::string* SchedProcessExecFtraceEvent::_internal_mutable_filename() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.filename_.Mutable(GetArenaForAllocation());
}
inline std::string* SchedProcessExecFtraceEvent::release_filename() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedProcessExecFtraceEvent.filename)
  if (!_internal_has_filename()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.filename_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SchedProcessExecFtraceEvent::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.filename_.SetAllocated(filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedProcessExecFtraceEvent.filename)
}

// optional int32 pid = 2;
inline bool SchedProcessExecFtraceEvent::_internal_has_pid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SchedProcessExecFtraceEvent::has_pid() const {
  return _internal_has_pid();
}
inline void SchedProcessExecFtraceEvent::clear_pid() {
  _impl_.pid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t SchedProcessExecFtraceEvent::_internal_pid() const {
  return _impl_.pid_;
}
inline int32_t SchedProcessExecFtraceEvent::pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessExecFtraceEvent.pid)
  return _internal_pid();
}
inline void SchedProcessExecFtraceEvent::_internal_set_pid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pid_ = value;
}
inline void SchedProcessExecFtraceEvent::set_pid(int32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessExecFtraceEvent.pid)
}

// optional int32 old_pid = 3;
inline bool SchedProcessExecFtraceEvent::_internal_has_old_pid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SchedProcessExecFtraceEvent::has_old_pid() const {
  return _internal_has_old_pid();
}
inline void SchedProcessExecFtraceEvent::clear_old_pid() {
  _impl_.old_pid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t SchedProcessExecFtraceEvent::_internal_old_pid() const {
  return _impl_.old_pid_;
}
inline int32_t SchedProcessExecFtraceEvent::old_pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessExecFtraceEvent.old_pid)
  return _internal_old_pid();
}
inline void SchedProcessExecFtraceEvent::_internal_set_old_pid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.old_pid_ = value;
}
inline void SchedProcessExecFtraceEvent::set_old_pid(int32_t value) {
  _internal_set_old_pid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessExecFtraceEvent.old_pid)
}

// -------------------------------------------------------------------

// SchedProcessExitFtraceEvent

// optional string comm = 1;
inline bool SchedProcessExitFtraceEvent::_internal_has_comm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SchedProcessExitFtraceEvent::has_comm() const {
  return _internal_has_comm();
}
inline void SchedProcessExitFtraceEvent::clear_comm() {
  _impl_.comm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchedProcessExitFtraceEvent::comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessExitFtraceEvent.comm)
  return _internal_comm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchedProcessExitFtraceEvent::set_comm(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.comm_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessExitFtraceEvent.comm)
}
inline std::string* SchedProcessExitFtraceEvent::mutable_comm() {
  std::string* _s = _internal_mutable_comm();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedProcessExitFtraceEvent.comm)
  return _s;
}
inline const std::string& SchedProcessExitFtraceEvent::_internal_comm() const {
  return _impl_.comm_.Get();
}
inline void SchedProcessExitFtraceEvent::_internal_set_comm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.comm_.Set(value, GetArenaForAllocation());
}
inline std::string* SchedProcessExitFtraceEvent::_internal_mutable_comm() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.comm_.Mutable(GetArenaForAllocation());
}
inline std::string* SchedProcessExitFtraceEvent::release_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedProcessExitFtraceEvent.comm)
  if (!_internal_has_comm()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.comm_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comm_.IsDefault()) {
    _impl_.comm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SchedProcessExitFtraceEvent::set_allocated_comm(std::string* comm) {
  if (comm != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.comm_.SetAllocated(comm, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comm_.IsDefault()) {
    _impl_.comm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedProcessExitFtraceEvent.comm)
}

// optional int32 pid = 2;
inline bool SchedProcessExitFtraceEvent::_internal_has_pid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SchedProcessExitFtraceEvent::has_pid() const {
  return _internal_has_pid();
}
inline void SchedProcessExitFtraceEvent::clear_pid() {
  _impl_.pid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t SchedProcessExitFtraceEvent::_internal_pid() const {
  return _impl_.pid_;
}
inline int32_t SchedProcessExitFtraceEvent::pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessExitFtraceEvent.pid)
  return _internal_pid();
}
inline void SchedProcessExitFtraceEvent::_internal_set_pid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pid_ = value;
}
inline void SchedProcessExitFtraceEvent::set_pid(int32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessExitFtraceEvent.pid)
}

// optional int32 tgid = 3;
inline bool SchedProcessExitFtraceEvent::_internal_has_tgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SchedProcessExitFtraceEvent::has_tgid() const {
  return _internal_has_tgid();
}
inline void SchedProcessExitFtraceEvent::clear_tgid() {
  _impl_.tgid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t SchedProcessExitFtraceEvent::_internal_tgid() const {
  return _impl_.tgid_;
}
inline int32_t SchedProcessExitFtraceEvent::tgid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessExitFtraceEvent.tgid)
  return _internal_tgid();
}
inline void SchedProcessExitFtraceEvent::_internal_set_tgid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.tgid_ = value;
}
inline void SchedProcessExitFtraceEvent::set_tgid(int32_t value) {
  _internal_set_tgid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessExitFtraceEvent.tgid)
}

// optional int32 prio = 4;
inline bool SchedProcessExitFtraceEvent::_internal_has_prio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SchedProcessExitFtraceEvent::has_prio() const {
  return _internal_has_prio();
}
inline void SchedProcessExitFtraceEvent::clear_prio() {
  _impl_.prio_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t SchedProcessExitFtraceEvent::_internal_prio() const {
  return _impl_.prio_;
}
inline int32_t SchedProcessExitFtraceEvent::prio() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessExitFtraceEvent.prio)
  return _internal_prio();
}
inline void SchedProcessExitFtraceEvent::_internal_set_prio(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.prio_ = value;
}
inline void SchedProcessExitFtraceEvent::set_prio(int32_t value) {
  _internal_set_prio(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessExitFtraceEvent.prio)
}

// -------------------------------------------------------------------

// SchedProcessForkFtraceEvent

// optional string parent_comm = 1;
inline bool SchedProcessForkFtraceEvent::_internal_has_parent_comm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SchedProcessForkFtraceEvent::has_parent_comm() const {
  return _internal_has_parent_comm();
}
inline void SchedProcessForkFtraceEvent::clear_parent_comm() {
  _impl_.parent_comm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchedProcessForkFtraceEvent::parent_comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessForkFtraceEvent.parent_comm)
  return _internal_parent_comm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchedProcessForkFtraceEvent::set_parent_comm(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.parent_comm_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessForkFtraceEvent.parent_comm)
}
inline std::string* SchedProcessForkFtraceEvent::mutable_parent_comm() {
  std::string* _s = _internal_mutable_parent_comm();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedProcessForkFtraceEvent.parent_comm)
  return _s;
}
inline const std::string& SchedProcessForkFtraceEvent::_internal_parent_comm() const {
  return _impl_.parent_comm_.Get();
}
inline void SchedProcessForkFtraceEvent::_internal_set_parent_comm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.parent_comm_.Set(value, GetArenaForAllocation());
}
inline std::string* SchedProcessForkFtraceEvent::_internal_mutable_parent_comm() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.parent_comm_.Mutable(GetArenaForAllocation());
}
inline std::string* SchedProcessForkFtraceEvent::release_parent_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedProcessForkFtraceEvent.parent_comm)
  if (!_internal_has_parent_comm()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.parent_comm_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_comm_.IsDefault()) {
    _impl_.parent_comm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SchedProcessForkFtraceEvent::set_allocated_parent_comm(std::string* parent_comm) {
  if (parent_comm != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.parent_comm_.SetAllocated(parent_comm, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_comm_.IsDefault()) {
    _impl_.parent_comm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedProcessForkFtraceEvent.parent_comm)
}

// optional int32 parent_pid = 2;
inline bool SchedProcessForkFtraceEvent::_internal_has_parent_pid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SchedProcessForkFtraceEvent::has_parent_pid() const {
  return _internal_has_parent_pid();
}
inline void SchedProcessForkFtraceEvent::clear_parent_pid() {
  _impl_.parent_pid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t SchedProcessForkFtraceEvent::_internal_parent_pid() const {
  return _impl_.parent_pid_;
}
inline int32_t SchedProcessForkFtraceEvent::parent_pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessForkFtraceEvent.parent_pid)
  return _internal_parent_pid();
}
inline void SchedProcessForkFtraceEvent::_internal_set_parent_pid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.parent_pid_ = value;
}
inline void SchedProcessForkFtraceEvent::set_parent_pid(int32_t value) {
  _internal_set_parent_pid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessForkFtraceEvent.parent_pid)
}

// optional string child_comm = 3;
inline bool SchedProcessForkFtraceEvent::_internal_has_child_comm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SchedProcessForkFtraceEvent::has_child_comm() const {
  return _internal_has_child_comm();
}
inline void SchedProcessForkFtraceEvent::clear_child_comm() {
  _impl_.child_comm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SchedProcessForkFtraceEvent::child_comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessForkFtraceEvent.child_comm)
  return _internal_child_comm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchedProcessForkFtraceEvent::set_child_comm(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.child_comm_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessForkFtraceEvent.child_comm)
}
inline std::string* SchedProcessForkFtraceEvent::mutable_child_comm() {
  std::string* _s = _internal_mutable_child_comm();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedProcessForkFtraceEvent.child_comm)
  return _s;
}
inline const std::string& SchedProcessForkFtraceEvent::_internal_child_comm() const {
  return _impl_.child_comm_.Get();
}
inline void SchedProcessForkFtraceEvent::_internal_set_child_comm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.child_comm_.Set(value, GetArenaForAllocation());
}
inline std::string* SchedProcessForkFtraceEvent::_internal_mutable_child_comm() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.child_comm_.Mutable(GetArenaForAllocation());
}
inline std::string* SchedProcessForkFtraceEvent::release_child_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedProcessForkFtraceEvent.child_comm)
  if (!_internal_has_child_comm()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.child_comm_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.child_comm_.IsDefault()) {
    _impl_.child_comm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SchedProcessForkFtraceEvent::set_allocated_child_comm(std::string* child_comm) {
  if (child_comm != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.child_comm_.SetAllocated(child_comm, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.child_comm_.IsDefault()) {
    _impl_.child_comm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedProcessForkFtraceEvent.child_comm)
}

// optional int32 child_pid = 4;
inline bool SchedProcessForkFtraceEvent::_internal_has_child_pid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SchedProcessForkFtraceEvent::has_child_pid() const {
  return _internal_has_child_pid();
}
inline void SchedProcessForkFtraceEvent::clear_child_pid() {
  _impl_.child_pid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t SchedProcessForkFtraceEvent::_internal_child_pid() const {
  return _impl_.child_pid_;
}
inline int32_t SchedProcessForkFtraceEvent::child_pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessForkFtraceEvent.child_pid)
  return _internal_child_pid();
}
inline void SchedProcessForkFtraceEvent::_internal_set_child_pid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.child_pid_ = value;
}
inline void SchedProcessForkFtraceEvent::set_child_pid(int32_t value) {
  _internal_set_child_pid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessForkFtraceEvent.child_pid)
}

// -------------------------------------------------------------------

// SchedProcessFreeFtraceEvent

// optional string comm = 1;
inline bool SchedProcessFreeFtraceEvent::_internal_has_comm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SchedProcessFreeFtraceEvent::has_comm() const {
  return _internal_has_comm();
}
inline void SchedProcessFreeFtraceEvent::clear_comm() {
  _impl_.comm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchedProcessFreeFtraceEvent::comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessFreeFtraceEvent.comm)
  return _internal_comm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchedProcessFreeFtraceEvent::set_comm(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.comm_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessFreeFtraceEvent.comm)
}
inline std::string* SchedProcessFreeFtraceEvent::mutable_comm() {
  std::string* _s = _internal_mutable_comm();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedProcessFreeFtraceEvent.comm)
  return _s;
}
inline const std::string& SchedProcessFreeFtraceEvent::_internal_comm() const {
  return _impl_.comm_.Get();
}
inline void SchedProcessFreeFtraceEvent::_internal_set_comm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.comm_.Set(value, GetArenaForAllocation());
}
inline std::string* SchedProcessFreeFtraceEvent::_internal_mutable_comm() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.comm_.Mutable(GetArenaForAllocation());
}
inline std::string* SchedProcessFreeFtraceEvent::release_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedProcessFreeFtraceEvent.comm)
  if (!_internal_has_comm()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.comm_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comm_.IsDefault()) {
    _impl_.comm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SchedProcessFreeFtraceEvent::set_allocated_comm(std::string* comm) {
  if (comm != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.comm_.SetAllocated(comm, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comm_.IsDefault()) {
    _impl_.comm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedProcessFreeFtraceEvent.comm)
}

// optional int32 pid = 2;
inline bool SchedProcessFreeFtraceEvent::_internal_has_pid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SchedProcessFreeFtraceEvent::has_pid() const {
  return _internal_has_pid();
}
inline void SchedProcessFreeFtraceEvent::clear_pid() {
  _impl_.pid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t SchedProcessFreeFtraceEvent::_internal_pid() const {
  return _impl_.pid_;
}
inline int32_t SchedProcessFreeFtraceEvent::pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessFreeFtraceEvent.pid)
  return _internal_pid();
}
inline void SchedProcessFreeFtraceEvent::_internal_set_pid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pid_ = value;
}
inline void SchedProcessFreeFtraceEvent::set_pid(int32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessFreeFtraceEvent.pid)
}

// optional int32 prio = 3;
inline bool SchedProcessFreeFtraceEvent::_internal_has_prio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SchedProcessFreeFtraceEvent::has_prio() const {
  return _internal_has_prio();
}
inline void SchedProcessFreeFtraceEvent::clear_prio() {
  _impl_.prio_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t SchedProcessFreeFtraceEvent::_internal_prio() const {
  return _impl_.prio_;
}
inline int32_t SchedProcessFreeFtraceEvent::prio() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessFreeFtraceEvent.prio)
  return _internal_prio();
}
inline void SchedProcessFreeFtraceEvent::_internal_set_prio(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.prio_ = value;
}
inline void SchedProcessFreeFtraceEvent::set_prio(int32_t value) {
  _internal_set_prio(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessFreeFtraceEvent.prio)
}

// -------------------------------------------------------------------

// SchedProcessHangFtraceEvent

// optional string comm = 1;
inline bool SchedProcessHangFtraceEvent::_internal_has_comm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SchedProcessHangFtraceEvent::has_comm() const {
  return _internal_has_comm();
}
inline void SchedProcessHangFtraceEvent::clear_comm() {
  _impl_.comm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchedProcessHangFtraceEvent::comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessHangFtraceEvent.comm)
  return _internal_comm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchedProcessHangFtraceEvent::set_comm(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.comm_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessHangFtraceEvent.comm)
}
inline std::string* SchedProcessHangFtraceEvent::mutable_comm() {
  std::string* _s = _internal_mutable_comm();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedProcessHangFtraceEvent.comm)
  return _s;
}
inline const std::string& SchedProcessHangFtraceEvent::_internal_comm() const {
  return _impl_.comm_.Get();
}
inline void SchedProcessHangFtraceEvent::_internal_set_comm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.comm_.Set(value, GetArenaForAllocation());
}
inline std::string* SchedProcessHangFtraceEvent::_internal_mutable_comm() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.comm_.Mutable(GetArenaForAllocation());
}
inline std::string* SchedProcessHangFtraceEvent::release_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedProcessHangFtraceEvent.comm)
  if (!_internal_has_comm()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.comm_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comm_.IsDefault()) {
    _impl_.comm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SchedProcessHangFtraceEvent::set_allocated_comm(std::string* comm) {
  if (comm != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.comm_.SetAllocated(comm, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comm_.IsDefault()) {
    _impl_.comm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedProcessHangFtraceEvent.comm)
}

// optional int32 pid = 2;
inline bool SchedProcessHangFtraceEvent::_internal_has_pid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SchedProcessHangFtraceEvent::has_pid() const {
  return _internal_has_pid();
}
inline void SchedProcessHangFtraceEvent::clear_pid() {
  _impl_.pid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t SchedProcessHangFtraceEvent::_internal_pid() const {
  return _impl_.pid_;
}
inline int32_t SchedProcessHangFtraceEvent::pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessHangFtraceEvent.pid)
  return _internal_pid();
}
inline void SchedProcessHangFtraceEvent::_internal_set_pid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pid_ = value;
}
inline void SchedProcessHangFtraceEvent::set_pid(int32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessHangFtraceEvent.pid)
}

// -------------------------------------------------------------------

// SchedProcessWaitFtraceEvent

// optional string comm = 1;
inline bool SchedProcessWaitFtraceEvent::_internal_has_comm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SchedProcessWaitFtraceEvent::has_comm() const {
  return _internal_has_comm();
}
inline void SchedProcessWaitFtraceEvent::clear_comm() {
  _impl_.comm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchedProcessWaitFtraceEvent::comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessWaitFtraceEvent.comm)
  return _internal_comm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchedProcessWaitFtraceEvent::set_comm(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.comm_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessWaitFtraceEvent.comm)
}
inline std::string* SchedProcessWaitFtraceEvent::mutable_comm() {
  std::string* _s = _internal_mutable_comm();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedProcessWaitFtraceEvent.comm)
  return _s;
}
inline const std::string& SchedProcessWaitFtraceEvent::_internal_comm() const {
  return _impl_.comm_.Get();
}
inline void SchedProcessWaitFtraceEvent::_internal_set_comm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.comm_.Set(value, GetArenaForAllocation());
}
inline std::string* SchedProcessWaitFtraceEvent::_internal_mutable_comm() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.comm_.Mutable(GetArenaForAllocation());
}
inline std::string* SchedProcessWaitFtraceEvent::release_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedProcessWaitFtraceEvent.comm)
  if (!_internal_has_comm()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.comm_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comm_.IsDefault()) {
    _impl_.comm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SchedProcessWaitFtraceEvent::set_allocated_comm(std::string* comm) {
  if (comm != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.comm_.SetAllocated(comm, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comm_.IsDefault()) {
    _impl_.comm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedProcessWaitFtraceEvent.comm)
}

// optional int32 pid = 2;
inline bool SchedProcessWaitFtraceEvent::_internal_has_pid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SchedProcessWaitFtraceEvent::has_pid() const {
  return _internal_has_pid();
}
inline void SchedProcessWaitFtraceEvent::clear_pid() {
  _impl_.pid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t SchedProcessWaitFtraceEvent::_internal_pid() const {
  return _impl_.pid_;
}
inline int32_t SchedProcessWaitFtraceEvent::pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessWaitFtraceEvent.pid)
  return _internal_pid();
}
inline void SchedProcessWaitFtraceEvent::_internal_set_pid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pid_ = value;
}
inline void SchedProcessWaitFtraceEvent::set_pid(int32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessWaitFtraceEvent.pid)
}

// optional int32 prio = 3;
inline bool SchedProcessWaitFtraceEvent::_internal_has_prio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SchedProcessWaitFtraceEvent::has_prio() const {
  return _internal_has_prio();
}
inline void SchedProcessWaitFtraceEvent::clear_prio() {
  _impl_.prio_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t SchedProcessWaitFtraceEvent::_internal_prio() const {
  return _impl_.prio_;
}
inline int32_t SchedProcessWaitFtraceEvent::prio() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedProcessWaitFtraceEvent.prio)
  return _internal_prio();
}
inline void SchedProcessWaitFtraceEvent::_internal_set_prio(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.prio_ = value;
}
inline void SchedProcessWaitFtraceEvent::set_prio(int32_t value) {
  _internal_set_prio(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedProcessWaitFtraceEvent.prio)
}

// -------------------------------------------------------------------

// SchedPiSetprioFtraceEvent

// optional string comm = 1;
inline bool SchedPiSetprioFtraceEvent::_internal_has_comm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SchedPiSetprioFtraceEvent::has_comm() const {
  return _internal_has_comm();
}
inline void SchedPiSetprioFtraceEvent::clear_comm() {
  _impl_.comm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchedPiSetprioFtraceEvent::comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedPiSetprioFtraceEvent.comm)
  return _internal_comm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchedPiSetprioFtraceEvent::set_comm(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.comm_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedPiSetprioFtraceEvent.comm)
}
inline std::string* SchedPiSetprioFtraceEvent::mutable_comm() {
  std::string* _s = _internal_mutable_comm();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedPiSetprioFtraceEvent.comm)
  return _s;
}
inline const std::string& SchedPiSetprioFtraceEvent::_internal_comm() const {
  return _impl_.comm_.Get();
}
inline void SchedPiSetprioFtraceEvent::_internal_set_comm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.comm_.Set(value, GetArenaForAllocation());
}
inline std::string* SchedPiSetprioFtraceEvent::_internal_mutable_comm() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.comm_.Mutable(GetArenaForAllocation());
}
inline std::string* SchedPiSetprioFtraceEvent::release_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedPiSetprioFtraceEvent.comm)
  if (!_internal_has_comm()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.comm_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comm_.IsDefault()) {
    _impl_.comm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SchedPiSetprioFtraceEvent::set_allocated_comm(std::string* comm) {
  if (comm != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.comm_.SetAllocated(comm, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comm_.IsDefault()) {
    _impl_.comm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedPiSetprioFtraceEvent.comm)
}

// optional int32 newprio = 2;
inline bool SchedPiSetprioFtraceEvent::_internal_has_newprio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SchedPiSetprioFtraceEvent::has_newprio() const {
  return _internal_has_newprio();
}
inline void SchedPiSetprioFtraceEvent::clear_newprio() {
  _impl_.newprio_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t SchedPiSetprioFtraceEvent::_internal_newprio() const {
  return _impl_.newprio_;
}
inline int32_t SchedPiSetprioFtraceEvent::newprio() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedPiSetprioFtraceEvent.newprio)
  return _internal_newprio();
}
inline void SchedPiSetprioFtraceEvent::_internal_set_newprio(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.newprio_ = value;
}
inline void SchedPiSetprioFtraceEvent::set_newprio(int32_t value) {
  _internal_set_newprio(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedPiSetprioFtraceEvent.newprio)
}

// optional int32 oldprio = 3;
inline bool SchedPiSetprioFtraceEvent::_internal_has_oldprio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SchedPiSetprioFtraceEvent::has_oldprio() const {
  return _internal_has_oldprio();
}
inline void SchedPiSetprioFtraceEvent::clear_oldprio() {
  _impl_.oldprio_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t SchedPiSetprioFtraceEvent::_internal_oldprio() const {
  return _impl_.oldprio_;
}
inline int32_t SchedPiSetprioFtraceEvent::oldprio() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedPiSetprioFtraceEvent.oldprio)
  return _internal_oldprio();
}
inline void SchedPiSetprioFtraceEvent::_internal_set_oldprio(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.oldprio_ = value;
}
inline void SchedPiSetprioFtraceEvent::set_oldprio(int32_t value) {
  _internal_set_oldprio(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedPiSetprioFtraceEvent.oldprio)
}

// optional int32 pid = 4;
inline bool SchedPiSetprioFtraceEvent::_internal_has_pid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SchedPiSetprioFtraceEvent::has_pid() const {
  return _internal_has_pid();
}
inline void SchedPiSetprioFtraceEvent::clear_pid() {
  _impl_.pid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t SchedPiSetprioFtraceEvent::_internal_pid() const {
  return _impl_.pid_;
}
inline int32_t SchedPiSetprioFtraceEvent::pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedPiSetprioFtraceEvent.pid)
  return _internal_pid();
}
inline void SchedPiSetprioFtraceEvent::_internal_set_pid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.pid_ = value;
}
inline void SchedPiSetprioFtraceEvent::set_pid(int32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedPiSetprioFtraceEvent.pid)
}

// -------------------------------------------------------------------

// SchedCpuUtilCfsFtraceEvent

// optional int32 active = 1;
inline bool SchedCpuUtilCfsFtraceEvent::_internal_has_active() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SchedCpuUtilCfsFtraceEvent::has_active() const {
  return _internal_has_active();
}
inline void SchedCpuUtilCfsFtraceEvent::clear_active() {
  _impl_.active_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t SchedCpuUtilCfsFtraceEvent::_internal_active() const {
  return _impl_.active_;
}
inline int32_t SchedCpuUtilCfsFtraceEvent::active() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuUtilCfsFtraceEvent.active)
  return _internal_active();
}
inline void SchedCpuUtilCfsFtraceEvent::_internal_set_active(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.active_ = value;
}
inline void SchedCpuUtilCfsFtraceEvent::set_active(int32_t value) {
  _internal_set_active(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuUtilCfsFtraceEvent.active)
}

// optional uint64 capacity = 2;
inline bool SchedCpuUtilCfsFtraceEvent::_internal_has_capacity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SchedCpuUtilCfsFtraceEvent::has_capacity() const {
  return _internal_has_capacity();
}
inline void SchedCpuUtilCfsFtraceEvent::clear_capacity() {
  _impl_.capacity_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t SchedCpuUtilCfsFtraceEvent::_internal_capacity() const {
  return _impl_.capacity_;
}
inline uint64_t SchedCpuUtilCfsFtraceEvent::capacity() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuUtilCfsFtraceEvent.capacity)
  return _internal_capacity();
}
inline void SchedCpuUtilCfsFtraceEvent::_internal_set_capacity(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.capacity_ = value;
}
inline void SchedCpuUtilCfsFtraceEvent::set_capacity(uint64_t value) {
  _internal_set_capacity(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuUtilCfsFtraceEvent.capacity)
}

// optional uint64 capacity_orig = 3;
inline bool SchedCpuUtilCfsFtraceEvent::_internal_has_capacity_orig() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SchedCpuUtilCfsFtraceEvent::has_capacity_orig() const {
  return _internal_has_capacity_orig();
}
inline void SchedCpuUtilCfsFtraceEvent::clear_capacity_orig() {
  _impl_.capacity_orig_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t SchedCpuUtilCfsFtraceEvent::_internal_capacity_orig() const {
  return _impl_.capacity_orig_;
}
inline uint64_t SchedCpuUtilCfsFtraceEvent::capacity_orig() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuUtilCfsFtraceEvent.capacity_orig)
  return _internal_capacity_orig();
}
inline void SchedCpuUtilCfsFtraceEvent::_internal_set_capacity_orig(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.capacity_orig_ = value;
}
inline void SchedCpuUtilCfsFtraceEvent::set_capacity_orig(uint64_t value) {
  _internal_set_capacity_orig(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuUtilCfsFtraceEvent.capacity_orig)
}

// optional uint32 cpu = 4;
inline bool SchedCpuUtilCfsFtraceEvent::_internal_has_cpu() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SchedCpuUtilCfsFtraceEvent::has_cpu() const {
  return _internal_has_cpu();
}
inline void SchedCpuUtilCfsFtraceEvent::clear_cpu() {
  _impl_.cpu_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t SchedCpuUtilCfsFtraceEvent::_internal_cpu() const {
  return _impl_.cpu_;
}
inline uint32_t SchedCpuUtilCfsFtraceEvent::cpu() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuUtilCfsFtraceEvent.cpu)
  return _internal_cpu();
}
inline void SchedCpuUtilCfsFtraceEvent::_internal_set_cpu(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.cpu_ = value;
}
inline void SchedCpuUtilCfsFtraceEvent::set_cpu(uint32_t value) {
  _internal_set_cpu(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuUtilCfsFtraceEvent.cpu)
}

// optional uint64 cpu_importance = 5;
inline bool SchedCpuUtilCfsFtraceEvent::_internal_has_cpu_importance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SchedCpuUtilCfsFtraceEvent::has_cpu_importance() const {
  return _internal_has_cpu_importance();
}
inline void SchedCpuUtilCfsFtraceEvent::clear_cpu_importance() {
  _impl_.cpu_importance_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t SchedCpuUtilCfsFtraceEvent::_internal_cpu_importance() const {
  return _impl_.cpu_importance_;
}
inline uint64_t SchedCpuUtilCfsFtraceEvent::cpu_importance() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuUtilCfsFtraceEvent.cpu_importance)
  return _internal_cpu_importance();
}
inline void SchedCpuUtilCfsFtraceEvent::_internal_set_cpu_importance(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.cpu_importance_ = value;
}
inline void SchedCpuUtilCfsFtraceEvent::set_cpu_importance(uint64_t value) {
  _internal_set_cpu_importance(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuUtilCfsFtraceEvent.cpu_importance)
}

// optional uint64 cpu_util = 6;
inline bool SchedCpuUtilCfsFtraceEvent::_internal_has_cpu_util() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SchedCpuUtilCfsFtraceEvent::has_cpu_util() const {
  return _internal_has_cpu_util();
}
inline void SchedCpuUtilCfsFtraceEvent::clear_cpu_util() {
  _impl_.cpu_util_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint64_t SchedCpuUtilCfsFtraceEvent::_internal_cpu_util() const {
  return _impl_.cpu_util_;
}
inline uint64_t SchedCpuUtilCfsFtraceEvent::cpu_util() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuUtilCfsFtraceEvent.cpu_util)
  return _internal_cpu_util();
}
inline void SchedCpuUtilCfsFtraceEvent::_internal_set_cpu_util(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.cpu_util_ = value;
}
inline void SchedCpuUtilCfsFtraceEvent::set_cpu_util(uint64_t value) {
  _internal_set_cpu_util(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuUtilCfsFtraceEvent.cpu_util)
}

// optional uint32 exit_lat = 7;
inline bool SchedCpuUtilCfsFtraceEvent::_internal_has_exit_lat() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool SchedCpuUtilCfsFtraceEvent::has_exit_lat() const {
  return _internal_has_exit_lat();
}
inline void SchedCpuUtilCfsFtraceEvent::clear_exit_lat() {
  _impl_.exit_lat_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t SchedCpuUtilCfsFtraceEvent::_internal_exit_lat() const {
  return _impl_.exit_lat_;
}
inline uint32_t SchedCpuUtilCfsFtraceEvent::exit_lat() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuUtilCfsFtraceEvent.exit_lat)
  return _internal_exit_lat();
}
inline void SchedCpuUtilCfsFtraceEvent::_internal_set_exit_lat(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.exit_lat_ = value;
}
inline void SchedCpuUtilCfsFtraceEvent::set_exit_lat(uint32_t value) {
  _internal_set_exit_lat(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuUtilCfsFtraceEvent.exit_lat)
}

// optional uint64 group_capacity = 8;
inline bool SchedCpuUtilCfsFtraceEvent::_internal_has_group_capacity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool SchedCpuUtilCfsFtraceEvent::has_group_capacity() const {
  return _internal_has_group_capacity();
}
inline void SchedCpuUtilCfsFtraceEvent::clear_group_capacity() {
  _impl_.group_capacity_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint64_t SchedCpuUtilCfsFtraceEvent::_internal_group_capacity() const {
  return _impl_.group_capacity_;
}
inline uint64_t SchedCpuUtilCfsFtraceEvent::group_capacity() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuUtilCfsFtraceEvent.group_capacity)
  return _internal_group_capacity();
}
inline void SchedCpuUtilCfsFtraceEvent::_internal_set_group_capacity(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.group_capacity_ = value;
}
inline void SchedCpuUtilCfsFtraceEvent::set_group_capacity(uint64_t value) {
  _internal_set_group_capacity(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuUtilCfsFtraceEvent.group_capacity)
}

// optional uint32 grp_overutilized = 9;
inline bool SchedCpuUtilCfsFtraceEvent::_internal_has_grp_overutilized() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool SchedCpuUtilCfsFtraceEvent::has_grp_overutilized() const {
  return _internal_has_grp_overutilized();
}
inline void SchedCpuUtilCfsFtraceEvent::clear_grp_overutilized() {
  _impl_.grp_overutilized_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint32_t SchedCpuUtilCfsFtraceEvent::_internal_grp_overutilized() const {
  return _impl_.grp_overutilized_;
}
inline uint32_t SchedCpuUtilCfsFtraceEvent::grp_overutilized() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuUtilCfsFtraceEvent.grp_overutilized)
  return _internal_grp_overutilized();
}
inline void SchedCpuUtilCfsFtraceEvent::_internal_set_grp_overutilized(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.grp_overutilized_ = value;
}
inline void SchedCpuUtilCfsFtraceEvent::set_grp_overutilized(uint32_t value) {
  _internal_set_grp_overutilized(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuUtilCfsFtraceEvent.grp_overutilized)
}

// optional uint32 idle_cpu = 10;
inline bool SchedCpuUtilCfsFtraceEvent::_internal_has_idle_cpu() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool SchedCpuUtilCfsFtraceEvent::has_idle_cpu() const {
  return _internal_has_idle_cpu();
}
inline void SchedCpuUtilCfsFtraceEvent::clear_idle_cpu() {
  _impl_.idle_cpu_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint32_t SchedCpuUtilCfsFtraceEvent::_internal_idle_cpu() const {
  return _impl_.idle_cpu_;
}
inline uint32_t SchedCpuUtilCfsFtraceEvent::idle_cpu() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuUtilCfsFtraceEvent.idle_cpu)
  return _internal_idle_cpu();
}
inline void SchedCpuUtilCfsFtraceEvent::_internal_set_idle_cpu(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.idle_cpu_ = value;
}
inline void SchedCpuUtilCfsFtraceEvent::set_idle_cpu(uint32_t value) {
  _internal_set_idle_cpu(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuUtilCfsFtraceEvent.idle_cpu)
}

// optional uint32 nr_running = 11;
inline bool SchedCpuUtilCfsFtraceEvent::_internal_has_nr_running() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool SchedCpuUtilCfsFtraceEvent::has_nr_running() const {
  return _internal_has_nr_running();
}
inline void SchedCpuUtilCfsFtraceEvent::clear_nr_running() {
  _impl_.nr_running_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline uint32_t SchedCpuUtilCfsFtraceEvent::_internal_nr_running() const {
  return _impl_.nr_running_;
}
inline uint32_t SchedCpuUtilCfsFtraceEvent::nr_running() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuUtilCfsFtraceEvent.nr_running)
  return _internal_nr_running();
}
inline void SchedCpuUtilCfsFtraceEvent::_internal_set_nr_running(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.nr_running_ = value;
}
inline void SchedCpuUtilCfsFtraceEvent::set_nr_running(uint32_t value) {
  _internal_set_nr_running(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuUtilCfsFtraceEvent.nr_running)
}

// optional int64 spare_cap = 12;
inline bool SchedCpuUtilCfsFtraceEvent::_internal_has_spare_cap() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool SchedCpuUtilCfsFtraceEvent::has_spare_cap() const {
  return _internal_has_spare_cap();
}
inline void SchedCpuUtilCfsFtraceEvent::clear_spare_cap() {
  _impl_.spare_cap_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline int64_t SchedCpuUtilCfsFtraceEvent::_internal_spare_cap() const {
  return _impl_.spare_cap_;
}
inline int64_t SchedCpuUtilCfsFtraceEvent::spare_cap() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuUtilCfsFtraceEvent.spare_cap)
  return _internal_spare_cap();
}
inline void SchedCpuUtilCfsFtraceEvent::_internal_set_spare_cap(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.spare_cap_ = value;
}
inline void SchedCpuUtilCfsFtraceEvent::set_spare_cap(int64_t value) {
  _internal_set_spare_cap(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuUtilCfsFtraceEvent.spare_cap)
}

// optional uint32 task_fits = 13;
inline bool SchedCpuUtilCfsFtraceEvent::_internal_has_task_fits() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool SchedCpuUtilCfsFtraceEvent::has_task_fits() const {
  return _internal_has_task_fits();
}
inline void SchedCpuUtilCfsFtraceEvent::clear_task_fits() {
  _impl_.task_fits_ = 0u;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline uint32_t SchedCpuUtilCfsFtraceEvent::_internal_task_fits() const {
  return _impl_.task_fits_;
}
inline uint32_t SchedCpuUtilCfsFtraceEvent::task_fits() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuUtilCfsFtraceEvent.task_fits)
  return _internal_task_fits();
}
inline void SchedCpuUtilCfsFtraceEvent::_internal_set_task_fits(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.task_fits_ = value;
}
inline void SchedCpuUtilCfsFtraceEvent::set_task_fits(uint32_t value) {
  _internal_set_task_fits(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuUtilCfsFtraceEvent.task_fits)
}

// optional uint64 wake_group_util = 14;
inline bool SchedCpuUtilCfsFtraceEvent::_internal_has_wake_group_util() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool SchedCpuUtilCfsFtraceEvent::has_wake_group_util() const {
  return _internal_has_wake_group_util();
}
inline void SchedCpuUtilCfsFtraceEvent::clear_wake_group_util() {
  _impl_.wake_group_util_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline uint64_t SchedCpuUtilCfsFtraceEvent::_internal_wake_group_util() const {
  return _impl_.wake_group_util_;
}
inline uint64_t SchedCpuUtilCfsFtraceEvent::wake_group_util() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuUtilCfsFtraceEvent.wake_group_util)
  return _internal_wake_group_util();
}
inline void SchedCpuUtilCfsFtraceEvent::_internal_set_wake_group_util(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.wake_group_util_ = value;
}
inline void SchedCpuUtilCfsFtraceEvent::set_wake_group_util(uint64_t value) {
  _internal_set_wake_group_util(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuUtilCfsFtraceEvent.wake_group_util)
}

// optional uint64 wake_util = 15;
inline bool SchedCpuUtilCfsFtraceEvent::_internal_has_wake_util() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool SchedCpuUtilCfsFtraceEvent::has_wake_util() const {
  return _internal_has_wake_util();
}
inline void SchedCpuUtilCfsFtraceEvent::clear_wake_util() {
  _impl_.wake_util_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline uint64_t SchedCpuUtilCfsFtraceEvent::_internal_wake_util() const {
  return _impl_.wake_util_;
}
inline uint64_t SchedCpuUtilCfsFtraceEvent::wake_util() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedCpuUtilCfsFtraceEvent.wake_util)
  return _internal_wake_util();
}
inline void SchedCpuUtilCfsFtraceEvent::_internal_set_wake_util(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.wake_util_ = value;
}
inline void SchedCpuUtilCfsFtraceEvent::set_wake_util(uint64_t value) {
  _internal_set_wake_util(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedCpuUtilCfsFtraceEvent.wake_util)
}

// -------------------------------------------------------------------

// SchedMigrateTaskFtraceEvent

// optional string comm = 1;
inline bool SchedMigrateTaskFtraceEvent::_internal_has_comm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SchedMigrateTaskFtraceEvent::has_comm() const {
  return _internal_has_comm();
}
inline void SchedMigrateTaskFtraceEvent::clear_comm() {
  _impl_.comm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchedMigrateTaskFtraceEvent::comm() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedMigrateTaskFtraceEvent.comm)
  return _internal_comm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchedMigrateTaskFtraceEvent::set_comm(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.comm_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedMigrateTaskFtraceEvent.comm)
}
inline std::string* SchedMigrateTaskFtraceEvent::mutable_comm() {
  std::string* _s = _internal_mutable_comm();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SchedMigrateTaskFtraceEvent.comm)
  return _s;
}
inline const std::string& SchedMigrateTaskFtraceEvent::_internal_comm() const {
  return _impl_.comm_.Get();
}
inline void SchedMigrateTaskFtraceEvent::_internal_set_comm(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.comm_.Set(value, GetArenaForAllocation());
}
inline std::string* SchedMigrateTaskFtraceEvent::_internal_mutable_comm() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.comm_.Mutable(GetArenaForAllocation());
}
inline std::string* SchedMigrateTaskFtraceEvent::release_comm() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SchedMigrateTaskFtraceEvent.comm)
  if (!_internal_has_comm()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.comm_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comm_.IsDefault()) {
    _impl_.comm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SchedMigrateTaskFtraceEvent::set_allocated_comm(std::string* comm) {
  if (comm != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.comm_.SetAllocated(comm, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comm_.IsDefault()) {
    _impl_.comm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SchedMigrateTaskFtraceEvent.comm)
}

// optional int32 pid = 2;
inline bool SchedMigrateTaskFtraceEvent::_internal_has_pid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SchedMigrateTaskFtraceEvent::has_pid() const {
  return _internal_has_pid();
}
inline void SchedMigrateTaskFtraceEvent::clear_pid() {
  _impl_.pid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t SchedMigrateTaskFtraceEvent::_internal_pid() const {
  return _impl_.pid_;
}
inline int32_t SchedMigrateTaskFtraceEvent::pid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedMigrateTaskFtraceEvent.pid)
  return _internal_pid();
}
inline void SchedMigrateTaskFtraceEvent::_internal_set_pid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pid_ = value;
}
inline void SchedMigrateTaskFtraceEvent::set_pid(int32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedMigrateTaskFtraceEvent.pid)
}

// optional int32 prio = 3;
inline bool SchedMigrateTaskFtraceEvent::_internal_has_prio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SchedMigrateTaskFtraceEvent::has_prio() const {
  return _internal_has_prio();
}
inline void SchedMigrateTaskFtraceEvent::clear_prio() {
  _impl_.prio_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t SchedMigrateTaskFtraceEvent::_internal_prio() const {
  return _impl_.prio_;
}
inline int32_t SchedMigrateTaskFtraceEvent::prio() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedMigrateTaskFtraceEvent.prio)
  return _internal_prio();
}
inline void SchedMigrateTaskFtraceEvent::_internal_set_prio(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.prio_ = value;
}
inline void SchedMigrateTaskFtraceEvent::set_prio(int32_t value) {
  _internal_set_prio(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedMigrateTaskFtraceEvent.prio)
}

// optional int32 orig_cpu = 4;
inline bool SchedMigrateTaskFtraceEvent::_internal_has_orig_cpu() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SchedMigrateTaskFtraceEvent::has_orig_cpu() const {
  return _internal_has_orig_cpu();
}
inline void SchedMigrateTaskFtraceEvent::clear_orig_cpu() {
  _impl_.orig_cpu_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t SchedMigrateTaskFtraceEvent::_internal_orig_cpu() const {
  return _impl_.orig_cpu_;
}
inline int32_t SchedMigrateTaskFtraceEvent::orig_cpu() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedMigrateTaskFtraceEvent.orig_cpu)
  return _internal_orig_cpu();
}
inline void SchedMigrateTaskFtraceEvent::_internal_set_orig_cpu(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.orig_cpu_ = value;
}
inline void SchedMigrateTaskFtraceEvent::set_orig_cpu(int32_t value) {
  _internal_set_orig_cpu(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedMigrateTaskFtraceEvent.orig_cpu)
}

// optional int32 dest_cpu = 5;
inline bool SchedMigrateTaskFtraceEvent::_internal_has_dest_cpu() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SchedMigrateTaskFtraceEvent::has_dest_cpu() const {
  return _internal_has_dest_cpu();
}
inline void SchedMigrateTaskFtraceEvent::clear_dest_cpu() {
  _impl_.dest_cpu_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t SchedMigrateTaskFtraceEvent::_internal_dest_cpu() const {
  return _impl_.dest_cpu_;
}
inline int32_t SchedMigrateTaskFtraceEvent::dest_cpu() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedMigrateTaskFtraceEvent.dest_cpu)
  return _internal_dest_cpu();
}
inline void SchedMigrateTaskFtraceEvent::_internal_set_dest_cpu(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.dest_cpu_ = value;
}
inline void SchedMigrateTaskFtraceEvent::set_dest_cpu(int32_t value) {
  _internal_set_dest_cpu(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedMigrateTaskFtraceEvent.dest_cpu)
}

// optional int32 running = 6;
inline bool SchedMigrateTaskFtraceEvent::_internal_has_running() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SchedMigrateTaskFtraceEvent::has_running() const {
  return _internal_has_running();
}
inline void SchedMigrateTaskFtraceEvent::clear_running() {
  _impl_.running_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t SchedMigrateTaskFtraceEvent::_internal_running() const {
  return _impl_.running_;
}
inline int32_t SchedMigrateTaskFtraceEvent::running() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedMigrateTaskFtraceEvent.running)
  return _internal_running();
}
inline void SchedMigrateTaskFtraceEvent::_internal_set_running(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.running_ = value;
}
inline void SchedMigrateTaskFtraceEvent::set_running(int32_t value) {
  _internal_set_running(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedMigrateTaskFtraceEvent.running)
}

// optional uint32 load = 7;
inline bool SchedMigrateTaskFtraceEvent::_internal_has_load() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool SchedMigrateTaskFtraceEvent::has_load() const {
  return _internal_has_load();
}
inline void SchedMigrateTaskFtraceEvent::clear_load() {
  _impl_.load_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t SchedMigrateTaskFtraceEvent::_internal_load() const {
  return _impl_.load_;
}
inline uint32_t SchedMigrateTaskFtraceEvent::load() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SchedMigrateTaskFtraceEvent.load)
  return _internal_load();
}
inline void SchedMigrateTaskFtraceEvent::_internal_set_load(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.load_ = value;
}
inline void SchedMigrateTaskFtraceEvent::set_load(uint32_t value) {
  _internal_set_load(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SchedMigrateTaskFtraceEvent.load)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_protos_2fperfetto_2ftrace_2fftrace_2fsched_2eproto
