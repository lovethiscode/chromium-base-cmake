// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/trace/ftrace/kmem.proto

#include "protos/perfetto/trace/ftrace/kmem.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace perfetto {
namespace protos {
PROTOBUF_CONSTEXPR AllocPagesIommuEndFtraceEvent::AllocPagesIommuEndFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gfp_flags_)*/0u
  , /*decltype(_impl_.order_)*/0u} {}
struct AllocPagesIommuEndFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AllocPagesIommuEndFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AllocPagesIommuEndFtraceEventDefaultTypeInternal() {}
  union {
    AllocPagesIommuEndFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AllocPagesIommuEndFtraceEventDefaultTypeInternal _AllocPagesIommuEndFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR AllocPagesIommuFailFtraceEvent::AllocPagesIommuFailFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gfp_flags_)*/0u
  , /*decltype(_impl_.order_)*/0u} {}
struct AllocPagesIommuFailFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AllocPagesIommuFailFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AllocPagesIommuFailFtraceEventDefaultTypeInternal() {}
  union {
    AllocPagesIommuFailFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AllocPagesIommuFailFtraceEventDefaultTypeInternal _AllocPagesIommuFailFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR AllocPagesIommuStartFtraceEvent::AllocPagesIommuStartFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gfp_flags_)*/0u
  , /*decltype(_impl_.order_)*/0u} {}
struct AllocPagesIommuStartFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AllocPagesIommuStartFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AllocPagesIommuStartFtraceEventDefaultTypeInternal() {}
  union {
    AllocPagesIommuStartFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AllocPagesIommuStartFtraceEventDefaultTypeInternal _AllocPagesIommuStartFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR AllocPagesSysEndFtraceEvent::AllocPagesSysEndFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gfp_flags_)*/0u
  , /*decltype(_impl_.order_)*/0u} {}
struct AllocPagesSysEndFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AllocPagesSysEndFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AllocPagesSysEndFtraceEventDefaultTypeInternal() {}
  union {
    AllocPagesSysEndFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AllocPagesSysEndFtraceEventDefaultTypeInternal _AllocPagesSysEndFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR AllocPagesSysFailFtraceEvent::AllocPagesSysFailFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gfp_flags_)*/0u
  , /*decltype(_impl_.order_)*/0u} {}
struct AllocPagesSysFailFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AllocPagesSysFailFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AllocPagesSysFailFtraceEventDefaultTypeInternal() {}
  union {
    AllocPagesSysFailFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AllocPagesSysFailFtraceEventDefaultTypeInternal _AllocPagesSysFailFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR AllocPagesSysStartFtraceEvent::AllocPagesSysStartFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gfp_flags_)*/0u
  , /*decltype(_impl_.order_)*/0u} {}
struct AllocPagesSysStartFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AllocPagesSysStartFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AllocPagesSysStartFtraceEventDefaultTypeInternal() {}
  union {
    AllocPagesSysStartFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AllocPagesSysStartFtraceEventDefaultTypeInternal _AllocPagesSysStartFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR DmaAllocContiguousRetryFtraceEvent::DmaAllocContiguousRetryFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tries_)*/0} {}
struct DmaAllocContiguousRetryFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DmaAllocContiguousRetryFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DmaAllocContiguousRetryFtraceEventDefaultTypeInternal() {}
  union {
    DmaAllocContiguousRetryFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DmaAllocContiguousRetryFtraceEventDefaultTypeInternal _DmaAllocContiguousRetryFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR IommuMapRangeFtraceEvent::IommuMapRangeFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.chunk_size_)*/uint64_t{0u}
  , /*decltype(_impl_.len_)*/uint64_t{0u}
  , /*decltype(_impl_.pa_)*/uint64_t{0u}
  , /*decltype(_impl_.va_)*/uint64_t{0u}} {}
struct IommuMapRangeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IommuMapRangeFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IommuMapRangeFtraceEventDefaultTypeInternal() {}
  union {
    IommuMapRangeFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IommuMapRangeFtraceEventDefaultTypeInternal _IommuMapRangeFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR IommuSecPtblMapRangeEndFtraceEvent::IommuSecPtblMapRangeEndFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.len_)*/uint64_t{0u}
  , /*decltype(_impl_.num_)*/0
  , /*decltype(_impl_.pa_)*/0u
  , /*decltype(_impl_.va_)*/uint64_t{0u}
  , /*decltype(_impl_.sec_id_)*/0} {}
struct IommuSecPtblMapRangeEndFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IommuSecPtblMapRangeEndFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IommuSecPtblMapRangeEndFtraceEventDefaultTypeInternal() {}
  union {
    IommuSecPtblMapRangeEndFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IommuSecPtblMapRangeEndFtraceEventDefaultTypeInternal _IommuSecPtblMapRangeEndFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR IommuSecPtblMapRangeStartFtraceEvent::IommuSecPtblMapRangeStartFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.len_)*/uint64_t{0u}
  , /*decltype(_impl_.num_)*/0
  , /*decltype(_impl_.pa_)*/0u
  , /*decltype(_impl_.va_)*/uint64_t{0u}
  , /*decltype(_impl_.sec_id_)*/0} {}
struct IommuSecPtblMapRangeStartFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IommuSecPtblMapRangeStartFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IommuSecPtblMapRangeStartFtraceEventDefaultTypeInternal() {}
  union {
    IommuSecPtblMapRangeStartFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IommuSecPtblMapRangeStartFtraceEventDefaultTypeInternal _IommuSecPtblMapRangeStartFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR IonAllocBufferEndFtraceEvent::IonAllocBufferEndFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.client_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.heap_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.flags_)*/0u
  , /*decltype(_impl_.mask_)*/0u
  , /*decltype(_impl_.len_)*/uint64_t{0u}} {}
struct IonAllocBufferEndFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IonAllocBufferEndFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IonAllocBufferEndFtraceEventDefaultTypeInternal() {}
  union {
    IonAllocBufferEndFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IonAllocBufferEndFtraceEventDefaultTypeInternal _IonAllocBufferEndFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR IonAllocBufferFailFtraceEvent::IonAllocBufferFailFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.client_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.heap_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.error_)*/int64_t{0}
  , /*decltype(_impl_.flags_)*/0u
  , /*decltype(_impl_.mask_)*/0u
  , /*decltype(_impl_.len_)*/uint64_t{0u}} {}
struct IonAllocBufferFailFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IonAllocBufferFailFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IonAllocBufferFailFtraceEventDefaultTypeInternal() {}
  union {
    IonAllocBufferFailFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IonAllocBufferFailFtraceEventDefaultTypeInternal _IonAllocBufferFailFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR IonAllocBufferFallbackFtraceEvent::IonAllocBufferFallbackFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.client_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.heap_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.error_)*/int64_t{0}
  , /*decltype(_impl_.flags_)*/0u
  , /*decltype(_impl_.mask_)*/0u
  , /*decltype(_impl_.len_)*/uint64_t{0u}} {}
struct IonAllocBufferFallbackFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IonAllocBufferFallbackFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IonAllocBufferFallbackFtraceEventDefaultTypeInternal() {}
  union {
    IonAllocBufferFallbackFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IonAllocBufferFallbackFtraceEventDefaultTypeInternal _IonAllocBufferFallbackFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR IonAllocBufferStartFtraceEvent::IonAllocBufferStartFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.client_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.heap_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.flags_)*/0u
  , /*decltype(_impl_.mask_)*/0u
  , /*decltype(_impl_.len_)*/uint64_t{0u}} {}
struct IonAllocBufferStartFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IonAllocBufferStartFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IonAllocBufferStartFtraceEventDefaultTypeInternal() {}
  union {
    IonAllocBufferStartFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IonAllocBufferStartFtraceEventDefaultTypeInternal _IonAllocBufferStartFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR IonCpAllocRetryFtraceEvent::IonCpAllocRetryFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tries_)*/0} {}
struct IonCpAllocRetryFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IonCpAllocRetryFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IonCpAllocRetryFtraceEventDefaultTypeInternal() {}
  union {
    IonCpAllocRetryFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IonCpAllocRetryFtraceEventDefaultTypeInternal _IonCpAllocRetryFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR IonCpSecureBufferEndFtraceEvent::IonCpSecureBufferEndFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.heap_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.align_)*/uint64_t{0u}
  , /*decltype(_impl_.flags_)*/uint64_t{0u}
  , /*decltype(_impl_.len_)*/uint64_t{0u}} {}
struct IonCpSecureBufferEndFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IonCpSecureBufferEndFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IonCpSecureBufferEndFtraceEventDefaultTypeInternal() {}
  union {
    IonCpSecureBufferEndFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IonCpSecureBufferEndFtraceEventDefaultTypeInternal _IonCpSecureBufferEndFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR IonCpSecureBufferStartFtraceEvent::IonCpSecureBufferStartFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.heap_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.align_)*/uint64_t{0u}
  , /*decltype(_impl_.flags_)*/uint64_t{0u}
  , /*decltype(_impl_.len_)*/uint64_t{0u}} {}
struct IonCpSecureBufferStartFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IonCpSecureBufferStartFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IonCpSecureBufferStartFtraceEventDefaultTypeInternal() {}
  union {
    IonCpSecureBufferStartFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IonCpSecureBufferStartFtraceEventDefaultTypeInternal _IonCpSecureBufferStartFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR IonPrefetchingFtraceEvent::IonPrefetchingFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.len_)*/uint64_t{0u}} {}
struct IonPrefetchingFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IonPrefetchingFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IonPrefetchingFtraceEventDefaultTypeInternal() {}
  union {
    IonPrefetchingFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IonPrefetchingFtraceEventDefaultTypeInternal _IonPrefetchingFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR IonSecureCmaAddToPoolEndFtraceEvent::IonSecureCmaAddToPoolEndFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.len_)*/uint64_t{0u}
  , /*decltype(_impl_.is_prefetch_)*/0u
  , /*decltype(_impl_.pool_total_)*/0} {}
struct IonSecureCmaAddToPoolEndFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IonSecureCmaAddToPoolEndFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IonSecureCmaAddToPoolEndFtraceEventDefaultTypeInternal() {}
  union {
    IonSecureCmaAddToPoolEndFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IonSecureCmaAddToPoolEndFtraceEventDefaultTypeInternal _IonSecureCmaAddToPoolEndFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR IonSecureCmaAddToPoolStartFtraceEvent::IonSecureCmaAddToPoolStartFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.len_)*/uint64_t{0u}
  , /*decltype(_impl_.is_prefetch_)*/0u
  , /*decltype(_impl_.pool_total_)*/0} {}
struct IonSecureCmaAddToPoolStartFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IonSecureCmaAddToPoolStartFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IonSecureCmaAddToPoolStartFtraceEventDefaultTypeInternal() {}
  union {
    IonSecureCmaAddToPoolStartFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IonSecureCmaAddToPoolStartFtraceEventDefaultTypeInternal _IonSecureCmaAddToPoolStartFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR IonSecureCmaAllocateEndFtraceEvent::IonSecureCmaAllocateEndFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.heap_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.align_)*/uint64_t{0u}
  , /*decltype(_impl_.flags_)*/uint64_t{0u}
  , /*decltype(_impl_.len_)*/uint64_t{0u}} {}
struct IonSecureCmaAllocateEndFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IonSecureCmaAllocateEndFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IonSecureCmaAllocateEndFtraceEventDefaultTypeInternal() {}
  union {
    IonSecureCmaAllocateEndFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IonSecureCmaAllocateEndFtraceEventDefaultTypeInternal _IonSecureCmaAllocateEndFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR IonSecureCmaAllocateStartFtraceEvent::IonSecureCmaAllocateStartFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.heap_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.align_)*/uint64_t{0u}
  , /*decltype(_impl_.flags_)*/uint64_t{0u}
  , /*decltype(_impl_.len_)*/uint64_t{0u}} {}
struct IonSecureCmaAllocateStartFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IonSecureCmaAllocateStartFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IonSecureCmaAllocateStartFtraceEventDefaultTypeInternal() {}
  union {
    IonSecureCmaAllocateStartFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IonSecureCmaAllocateStartFtraceEventDefaultTypeInternal _IonSecureCmaAllocateStartFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR IonSecureCmaShrinkPoolEndFtraceEvent::IonSecureCmaShrinkPoolEndFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.drained_size_)*/uint64_t{0u}
  , /*decltype(_impl_.skipped_size_)*/uint64_t{0u}} {}
struct IonSecureCmaShrinkPoolEndFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IonSecureCmaShrinkPoolEndFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IonSecureCmaShrinkPoolEndFtraceEventDefaultTypeInternal() {}
  union {
    IonSecureCmaShrinkPoolEndFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IonSecureCmaShrinkPoolEndFtraceEventDefaultTypeInternal _IonSecureCmaShrinkPoolEndFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR IonSecureCmaShrinkPoolStartFtraceEvent::IonSecureCmaShrinkPoolStartFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.drained_size_)*/uint64_t{0u}
  , /*decltype(_impl_.skipped_size_)*/uint64_t{0u}} {}
struct IonSecureCmaShrinkPoolStartFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IonSecureCmaShrinkPoolStartFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IonSecureCmaShrinkPoolStartFtraceEventDefaultTypeInternal() {}
  union {
    IonSecureCmaShrinkPoolStartFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IonSecureCmaShrinkPoolStartFtraceEventDefaultTypeInternal _IonSecureCmaShrinkPoolStartFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KfreeFtraceEvent::KfreeFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.call_site_)*/uint64_t{0u}
  , /*decltype(_impl_.ptr_)*/uint64_t{0u}} {}
struct KfreeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KfreeFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KfreeFtraceEventDefaultTypeInternal() {}
  union {
    KfreeFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KfreeFtraceEventDefaultTypeInternal _KfreeFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KmallocFtraceEvent::KmallocFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.bytes_alloc_)*/uint64_t{0u}
  , /*decltype(_impl_.bytes_req_)*/uint64_t{0u}
  , /*decltype(_impl_.call_site_)*/uint64_t{0u}
  , /*decltype(_impl_.ptr_)*/uint64_t{0u}
  , /*decltype(_impl_.gfp_flags_)*/0u} {}
struct KmallocFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KmallocFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KmallocFtraceEventDefaultTypeInternal() {}
  union {
    KmallocFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KmallocFtraceEventDefaultTypeInternal _KmallocFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KmallocNodeFtraceEvent::KmallocNodeFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.bytes_alloc_)*/uint64_t{0u}
  , /*decltype(_impl_.bytes_req_)*/uint64_t{0u}
  , /*decltype(_impl_.call_site_)*/uint64_t{0u}
  , /*decltype(_impl_.gfp_flags_)*/0u
  , /*decltype(_impl_.node_)*/0
  , /*decltype(_impl_.ptr_)*/uint64_t{0u}} {}
struct KmallocNodeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KmallocNodeFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KmallocNodeFtraceEventDefaultTypeInternal() {}
  union {
    KmallocNodeFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KmallocNodeFtraceEventDefaultTypeInternal _KmallocNodeFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KmemCacheAllocFtraceEvent::KmemCacheAllocFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.bytes_alloc_)*/uint64_t{0u}
  , /*decltype(_impl_.bytes_req_)*/uint64_t{0u}
  , /*decltype(_impl_.call_site_)*/uint64_t{0u}
  , /*decltype(_impl_.ptr_)*/uint64_t{0u}
  , /*decltype(_impl_.gfp_flags_)*/0u} {}
struct KmemCacheAllocFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KmemCacheAllocFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KmemCacheAllocFtraceEventDefaultTypeInternal() {}
  union {
    KmemCacheAllocFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KmemCacheAllocFtraceEventDefaultTypeInternal _KmemCacheAllocFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KmemCacheAllocNodeFtraceEvent::KmemCacheAllocNodeFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.bytes_alloc_)*/uint64_t{0u}
  , /*decltype(_impl_.bytes_req_)*/uint64_t{0u}
  , /*decltype(_impl_.call_site_)*/uint64_t{0u}
  , /*decltype(_impl_.gfp_flags_)*/0u
  , /*decltype(_impl_.node_)*/0
  , /*decltype(_impl_.ptr_)*/uint64_t{0u}} {}
struct KmemCacheAllocNodeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KmemCacheAllocNodeFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KmemCacheAllocNodeFtraceEventDefaultTypeInternal() {}
  union {
    KmemCacheAllocNodeFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KmemCacheAllocNodeFtraceEventDefaultTypeInternal _KmemCacheAllocNodeFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR KmemCacheFreeFtraceEvent::KmemCacheFreeFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.call_site_)*/uint64_t{0u}
  , /*decltype(_impl_.ptr_)*/uint64_t{0u}} {}
struct KmemCacheFreeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KmemCacheFreeFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KmemCacheFreeFtraceEventDefaultTypeInternal() {}
  union {
    KmemCacheFreeFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KmemCacheFreeFtraceEventDefaultTypeInternal _KmemCacheFreeFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR MigratePagesEndFtraceEvent::MigratePagesEndFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.mode_)*/0} {}
struct MigratePagesEndFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MigratePagesEndFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MigratePagesEndFtraceEventDefaultTypeInternal() {}
  union {
    MigratePagesEndFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MigratePagesEndFtraceEventDefaultTypeInternal _MigratePagesEndFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR MigratePagesStartFtraceEvent::MigratePagesStartFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.mode_)*/0} {}
struct MigratePagesStartFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MigratePagesStartFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MigratePagesStartFtraceEventDefaultTypeInternal() {}
  union {
    MigratePagesStartFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MigratePagesStartFtraceEventDefaultTypeInternal _MigratePagesStartFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR MigrateRetryFtraceEvent::MigrateRetryFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tries_)*/0} {}
struct MigrateRetryFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MigrateRetryFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MigrateRetryFtraceEventDefaultTypeInternal() {}
  union {
    MigrateRetryFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MigrateRetryFtraceEventDefaultTypeInternal _MigrateRetryFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR MmPageAllocFtraceEvent::MmPageAllocFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gfp_flags_)*/0u
  , /*decltype(_impl_.migratetype_)*/0
  , /*decltype(_impl_.page_)*/uint64_t{0u}
  , /*decltype(_impl_.pfn_)*/uint64_t{0u}
  , /*decltype(_impl_.order_)*/0u} {}
struct MmPageAllocFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MmPageAllocFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MmPageAllocFtraceEventDefaultTypeInternal() {}
  union {
    MmPageAllocFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MmPageAllocFtraceEventDefaultTypeInternal _MmPageAllocFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR MmPageAllocExtfragFtraceEvent::MmPageAllocExtfragFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.alloc_migratetype_)*/0
  , /*decltype(_impl_.alloc_order_)*/0
  , /*decltype(_impl_.fallback_migratetype_)*/0
  , /*decltype(_impl_.fallback_order_)*/0
  , /*decltype(_impl_.page_)*/uint64_t{0u}
  , /*decltype(_impl_.pfn_)*/uint64_t{0u}
  , /*decltype(_impl_.change_ownership_)*/0} {}
struct MmPageAllocExtfragFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MmPageAllocExtfragFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MmPageAllocExtfragFtraceEventDefaultTypeInternal() {}
  union {
    MmPageAllocExtfragFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MmPageAllocExtfragFtraceEventDefaultTypeInternal _MmPageAllocExtfragFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR MmPageAllocZoneLockedFtraceEvent::MmPageAllocZoneLockedFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.migratetype_)*/0
  , /*decltype(_impl_.order_)*/0u
  , /*decltype(_impl_.page_)*/uint64_t{0u}
  , /*decltype(_impl_.pfn_)*/uint64_t{0u}} {}
struct MmPageAllocZoneLockedFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MmPageAllocZoneLockedFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MmPageAllocZoneLockedFtraceEventDefaultTypeInternal() {}
  union {
    MmPageAllocZoneLockedFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MmPageAllocZoneLockedFtraceEventDefaultTypeInternal _MmPageAllocZoneLockedFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR MmPageFreeFtraceEvent::MmPageFreeFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.page_)*/uint64_t{0u}
  , /*decltype(_impl_.pfn_)*/uint64_t{0u}
  , /*decltype(_impl_.order_)*/0u} {}
struct MmPageFreeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MmPageFreeFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MmPageFreeFtraceEventDefaultTypeInternal() {}
  union {
    MmPageFreeFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MmPageFreeFtraceEventDefaultTypeInternal _MmPageFreeFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR MmPageFreeBatchedFtraceEvent::MmPageFreeBatchedFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.page_)*/uint64_t{0u}
  , /*decltype(_impl_.pfn_)*/uint64_t{0u}
  , /*decltype(_impl_.cold_)*/0} {}
struct MmPageFreeBatchedFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MmPageFreeBatchedFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MmPageFreeBatchedFtraceEventDefaultTypeInternal() {}
  union {
    MmPageFreeBatchedFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MmPageFreeBatchedFtraceEventDefaultTypeInternal _MmPageFreeBatchedFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR MmPagePcpuDrainFtraceEvent::MmPagePcpuDrainFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.migratetype_)*/0
  , /*decltype(_impl_.order_)*/0u
  , /*decltype(_impl_.page_)*/uint64_t{0u}
  , /*decltype(_impl_.pfn_)*/uint64_t{0u}} {}
struct MmPagePcpuDrainFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MmPagePcpuDrainFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MmPagePcpuDrainFtraceEventDefaultTypeInternal() {}
  union {
    MmPagePcpuDrainFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MmPagePcpuDrainFtraceEventDefaultTypeInternal _MmPagePcpuDrainFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR RssStatFtraceEvent::RssStatFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.size_)*/int64_t{0}
  , /*decltype(_impl_.member_)*/0
  , /*decltype(_impl_.curr_)*/0u
  , /*decltype(_impl_.mm_id_)*/0u} {}
struct RssStatFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RssStatFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RssStatFtraceEventDefaultTypeInternal() {}
  union {
    RssStatFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RssStatFtraceEventDefaultTypeInternal _RssStatFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR IonHeapShrinkFtraceEvent::IonHeapShrinkFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.heap_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.len_)*/uint64_t{0u}
  , /*decltype(_impl_.total_allocated_)*/int64_t{0}} {}
struct IonHeapShrinkFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IonHeapShrinkFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IonHeapShrinkFtraceEventDefaultTypeInternal() {}
  union {
    IonHeapShrinkFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IonHeapShrinkFtraceEventDefaultTypeInternal _IonHeapShrinkFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR IonHeapGrowFtraceEvent::IonHeapGrowFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.heap_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.len_)*/uint64_t{0u}
  , /*decltype(_impl_.total_allocated_)*/int64_t{0}} {}
struct IonHeapGrowFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IonHeapGrowFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IonHeapGrowFtraceEventDefaultTypeInternal() {}
  union {
    IonHeapGrowFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IonHeapGrowFtraceEventDefaultTypeInternal _IonHeapGrowFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR IonBufferCreateFtraceEvent::IonBufferCreateFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.addr_)*/uint64_t{0u}
  , /*decltype(_impl_.len_)*/uint64_t{0u}} {}
struct IonBufferCreateFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IonBufferCreateFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IonBufferCreateFtraceEventDefaultTypeInternal() {}
  union {
    IonBufferCreateFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IonBufferCreateFtraceEventDefaultTypeInternal _IonBufferCreateFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR IonBufferDestroyFtraceEvent::IonBufferDestroyFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.addr_)*/uint64_t{0u}
  , /*decltype(_impl_.len_)*/uint64_t{0u}} {}
struct IonBufferDestroyFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IonBufferDestroyFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IonBufferDestroyFtraceEventDefaultTypeInternal() {}
  union {
    IonBufferDestroyFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IonBufferDestroyFtraceEventDefaultTypeInternal _IonBufferDestroyFtraceEvent_default_instance_;
}  // namespace protos
}  // namespace perfetto
namespace perfetto {
namespace protos {

// ===================================================================

class AllocPagesIommuEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<AllocPagesIommuEndFtraceEvent>()._impl_._has_bits_);
  static void set_has_gfp_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AllocPagesIommuEndFtraceEvent::AllocPagesIommuEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.AllocPagesIommuEndFtraceEvent)
}
AllocPagesIommuEndFtraceEvent::AllocPagesIommuEndFtraceEvent(const AllocPagesIommuEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  AllocPagesIommuEndFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gfp_flags_){}
    , decltype(_impl_.order_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.gfp_flags_, &from._impl_.gfp_flags_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.order_) -
    reinterpret_cast<char*>(&_impl_.gfp_flags_)) + sizeof(_impl_.order_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.AllocPagesIommuEndFtraceEvent)
}

inline void AllocPagesIommuEndFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gfp_flags_){0u}
    , decltype(_impl_.order_){0u}
  };
}

AllocPagesIommuEndFtraceEvent::~AllocPagesIommuEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.AllocPagesIommuEndFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AllocPagesIommuEndFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AllocPagesIommuEndFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AllocPagesIommuEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.AllocPagesIommuEndFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.gfp_flags_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.order_) -
        reinterpret_cast<char*>(&_impl_.gfp_flags_)) + sizeof(_impl_.order_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AllocPagesIommuEndFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 gfp_flags = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gfp_flags(&has_bits);
          _impl_.gfp_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 order = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_order(&has_bits);
          _impl_.order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AllocPagesIommuEndFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.AllocPagesIommuEndFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 gfp_flags = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gfp_flags(), target);
  }

  // optional uint32 order = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_order(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.AllocPagesIommuEndFtraceEvent)
  return target;
}

size_t AllocPagesIommuEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.AllocPagesIommuEndFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 gfp_flags = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gfp_flags());
    }

    // optional uint32 order = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_order());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AllocPagesIommuEndFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AllocPagesIommuEndFtraceEvent*>(
      &from));
}

void AllocPagesIommuEndFtraceEvent::MergeFrom(const AllocPagesIommuEndFtraceEvent& from) {
  AllocPagesIommuEndFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.AllocPagesIommuEndFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.gfp_flags_ = from._impl_.gfp_flags_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.order_ = from._impl_.order_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AllocPagesIommuEndFtraceEvent::CopyFrom(const AllocPagesIommuEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.AllocPagesIommuEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AllocPagesIommuEndFtraceEvent::IsInitialized() const {
  return true;
}

void AllocPagesIommuEndFtraceEvent::InternalSwap(AllocPagesIommuEndFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AllocPagesIommuEndFtraceEvent, _impl_.order_)
      + sizeof(AllocPagesIommuEndFtraceEvent::_impl_.order_)
      - PROTOBUF_FIELD_OFFSET(AllocPagesIommuEndFtraceEvent, _impl_.gfp_flags_)>(
          reinterpret_cast<char*>(&_impl_.gfp_flags_),
          reinterpret_cast<char*>(&other->_impl_.gfp_flags_));
}

std::string AllocPagesIommuEndFtraceEvent::GetTypeName() const {
  return "perfetto.protos.AllocPagesIommuEndFtraceEvent";
}


// ===================================================================

class AllocPagesIommuFailFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<AllocPagesIommuFailFtraceEvent>()._impl_._has_bits_);
  static void set_has_gfp_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AllocPagesIommuFailFtraceEvent::AllocPagesIommuFailFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.AllocPagesIommuFailFtraceEvent)
}
AllocPagesIommuFailFtraceEvent::AllocPagesIommuFailFtraceEvent(const AllocPagesIommuFailFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  AllocPagesIommuFailFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gfp_flags_){}
    , decltype(_impl_.order_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.gfp_flags_, &from._impl_.gfp_flags_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.order_) -
    reinterpret_cast<char*>(&_impl_.gfp_flags_)) + sizeof(_impl_.order_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.AllocPagesIommuFailFtraceEvent)
}

inline void AllocPagesIommuFailFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gfp_flags_){0u}
    , decltype(_impl_.order_){0u}
  };
}

AllocPagesIommuFailFtraceEvent::~AllocPagesIommuFailFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.AllocPagesIommuFailFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AllocPagesIommuFailFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AllocPagesIommuFailFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AllocPagesIommuFailFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.AllocPagesIommuFailFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.gfp_flags_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.order_) -
        reinterpret_cast<char*>(&_impl_.gfp_flags_)) + sizeof(_impl_.order_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AllocPagesIommuFailFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 gfp_flags = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gfp_flags(&has_bits);
          _impl_.gfp_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 order = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_order(&has_bits);
          _impl_.order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AllocPagesIommuFailFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.AllocPagesIommuFailFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 gfp_flags = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gfp_flags(), target);
  }

  // optional uint32 order = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_order(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.AllocPagesIommuFailFtraceEvent)
  return target;
}

size_t AllocPagesIommuFailFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.AllocPagesIommuFailFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 gfp_flags = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gfp_flags());
    }

    // optional uint32 order = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_order());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AllocPagesIommuFailFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AllocPagesIommuFailFtraceEvent*>(
      &from));
}

void AllocPagesIommuFailFtraceEvent::MergeFrom(const AllocPagesIommuFailFtraceEvent& from) {
  AllocPagesIommuFailFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.AllocPagesIommuFailFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.gfp_flags_ = from._impl_.gfp_flags_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.order_ = from._impl_.order_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AllocPagesIommuFailFtraceEvent::CopyFrom(const AllocPagesIommuFailFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.AllocPagesIommuFailFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AllocPagesIommuFailFtraceEvent::IsInitialized() const {
  return true;
}

void AllocPagesIommuFailFtraceEvent::InternalSwap(AllocPagesIommuFailFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AllocPagesIommuFailFtraceEvent, _impl_.order_)
      + sizeof(AllocPagesIommuFailFtraceEvent::_impl_.order_)
      - PROTOBUF_FIELD_OFFSET(AllocPagesIommuFailFtraceEvent, _impl_.gfp_flags_)>(
          reinterpret_cast<char*>(&_impl_.gfp_flags_),
          reinterpret_cast<char*>(&other->_impl_.gfp_flags_));
}

std::string AllocPagesIommuFailFtraceEvent::GetTypeName() const {
  return "perfetto.protos.AllocPagesIommuFailFtraceEvent";
}


// ===================================================================

class AllocPagesIommuStartFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<AllocPagesIommuStartFtraceEvent>()._impl_._has_bits_);
  static void set_has_gfp_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AllocPagesIommuStartFtraceEvent::AllocPagesIommuStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.AllocPagesIommuStartFtraceEvent)
}
AllocPagesIommuStartFtraceEvent::AllocPagesIommuStartFtraceEvent(const AllocPagesIommuStartFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  AllocPagesIommuStartFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gfp_flags_){}
    , decltype(_impl_.order_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.gfp_flags_, &from._impl_.gfp_flags_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.order_) -
    reinterpret_cast<char*>(&_impl_.gfp_flags_)) + sizeof(_impl_.order_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.AllocPagesIommuStartFtraceEvent)
}

inline void AllocPagesIommuStartFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gfp_flags_){0u}
    , decltype(_impl_.order_){0u}
  };
}

AllocPagesIommuStartFtraceEvent::~AllocPagesIommuStartFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.AllocPagesIommuStartFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AllocPagesIommuStartFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AllocPagesIommuStartFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AllocPagesIommuStartFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.AllocPagesIommuStartFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.gfp_flags_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.order_) -
        reinterpret_cast<char*>(&_impl_.gfp_flags_)) + sizeof(_impl_.order_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AllocPagesIommuStartFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 gfp_flags = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gfp_flags(&has_bits);
          _impl_.gfp_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 order = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_order(&has_bits);
          _impl_.order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AllocPagesIommuStartFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.AllocPagesIommuStartFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 gfp_flags = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gfp_flags(), target);
  }

  // optional uint32 order = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_order(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.AllocPagesIommuStartFtraceEvent)
  return target;
}

size_t AllocPagesIommuStartFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.AllocPagesIommuStartFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 gfp_flags = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gfp_flags());
    }

    // optional uint32 order = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_order());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AllocPagesIommuStartFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AllocPagesIommuStartFtraceEvent*>(
      &from));
}

void AllocPagesIommuStartFtraceEvent::MergeFrom(const AllocPagesIommuStartFtraceEvent& from) {
  AllocPagesIommuStartFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.AllocPagesIommuStartFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.gfp_flags_ = from._impl_.gfp_flags_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.order_ = from._impl_.order_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AllocPagesIommuStartFtraceEvent::CopyFrom(const AllocPagesIommuStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.AllocPagesIommuStartFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AllocPagesIommuStartFtraceEvent::IsInitialized() const {
  return true;
}

void AllocPagesIommuStartFtraceEvent::InternalSwap(AllocPagesIommuStartFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AllocPagesIommuStartFtraceEvent, _impl_.order_)
      + sizeof(AllocPagesIommuStartFtraceEvent::_impl_.order_)
      - PROTOBUF_FIELD_OFFSET(AllocPagesIommuStartFtraceEvent, _impl_.gfp_flags_)>(
          reinterpret_cast<char*>(&_impl_.gfp_flags_),
          reinterpret_cast<char*>(&other->_impl_.gfp_flags_));
}

std::string AllocPagesIommuStartFtraceEvent::GetTypeName() const {
  return "perfetto.protos.AllocPagesIommuStartFtraceEvent";
}


// ===================================================================

class AllocPagesSysEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<AllocPagesSysEndFtraceEvent>()._impl_._has_bits_);
  static void set_has_gfp_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AllocPagesSysEndFtraceEvent::AllocPagesSysEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.AllocPagesSysEndFtraceEvent)
}
AllocPagesSysEndFtraceEvent::AllocPagesSysEndFtraceEvent(const AllocPagesSysEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  AllocPagesSysEndFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gfp_flags_){}
    , decltype(_impl_.order_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.gfp_flags_, &from._impl_.gfp_flags_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.order_) -
    reinterpret_cast<char*>(&_impl_.gfp_flags_)) + sizeof(_impl_.order_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.AllocPagesSysEndFtraceEvent)
}

inline void AllocPagesSysEndFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gfp_flags_){0u}
    , decltype(_impl_.order_){0u}
  };
}

AllocPagesSysEndFtraceEvent::~AllocPagesSysEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.AllocPagesSysEndFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AllocPagesSysEndFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AllocPagesSysEndFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AllocPagesSysEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.AllocPagesSysEndFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.gfp_flags_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.order_) -
        reinterpret_cast<char*>(&_impl_.gfp_flags_)) + sizeof(_impl_.order_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AllocPagesSysEndFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 gfp_flags = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gfp_flags(&has_bits);
          _impl_.gfp_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 order = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_order(&has_bits);
          _impl_.order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AllocPagesSysEndFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.AllocPagesSysEndFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 gfp_flags = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gfp_flags(), target);
  }

  // optional uint32 order = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_order(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.AllocPagesSysEndFtraceEvent)
  return target;
}

size_t AllocPagesSysEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.AllocPagesSysEndFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 gfp_flags = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gfp_flags());
    }

    // optional uint32 order = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_order());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AllocPagesSysEndFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AllocPagesSysEndFtraceEvent*>(
      &from));
}

void AllocPagesSysEndFtraceEvent::MergeFrom(const AllocPagesSysEndFtraceEvent& from) {
  AllocPagesSysEndFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.AllocPagesSysEndFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.gfp_flags_ = from._impl_.gfp_flags_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.order_ = from._impl_.order_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AllocPagesSysEndFtraceEvent::CopyFrom(const AllocPagesSysEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.AllocPagesSysEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AllocPagesSysEndFtraceEvent::IsInitialized() const {
  return true;
}

void AllocPagesSysEndFtraceEvent::InternalSwap(AllocPagesSysEndFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AllocPagesSysEndFtraceEvent, _impl_.order_)
      + sizeof(AllocPagesSysEndFtraceEvent::_impl_.order_)
      - PROTOBUF_FIELD_OFFSET(AllocPagesSysEndFtraceEvent, _impl_.gfp_flags_)>(
          reinterpret_cast<char*>(&_impl_.gfp_flags_),
          reinterpret_cast<char*>(&other->_impl_.gfp_flags_));
}

std::string AllocPagesSysEndFtraceEvent::GetTypeName() const {
  return "perfetto.protos.AllocPagesSysEndFtraceEvent";
}


// ===================================================================

class AllocPagesSysFailFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<AllocPagesSysFailFtraceEvent>()._impl_._has_bits_);
  static void set_has_gfp_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AllocPagesSysFailFtraceEvent::AllocPagesSysFailFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.AllocPagesSysFailFtraceEvent)
}
AllocPagesSysFailFtraceEvent::AllocPagesSysFailFtraceEvent(const AllocPagesSysFailFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  AllocPagesSysFailFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gfp_flags_){}
    , decltype(_impl_.order_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.gfp_flags_, &from._impl_.gfp_flags_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.order_) -
    reinterpret_cast<char*>(&_impl_.gfp_flags_)) + sizeof(_impl_.order_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.AllocPagesSysFailFtraceEvent)
}

inline void AllocPagesSysFailFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gfp_flags_){0u}
    , decltype(_impl_.order_){0u}
  };
}

AllocPagesSysFailFtraceEvent::~AllocPagesSysFailFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.AllocPagesSysFailFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AllocPagesSysFailFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AllocPagesSysFailFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AllocPagesSysFailFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.AllocPagesSysFailFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.gfp_flags_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.order_) -
        reinterpret_cast<char*>(&_impl_.gfp_flags_)) + sizeof(_impl_.order_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AllocPagesSysFailFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 gfp_flags = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gfp_flags(&has_bits);
          _impl_.gfp_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 order = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_order(&has_bits);
          _impl_.order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AllocPagesSysFailFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.AllocPagesSysFailFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 gfp_flags = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gfp_flags(), target);
  }

  // optional uint32 order = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_order(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.AllocPagesSysFailFtraceEvent)
  return target;
}

size_t AllocPagesSysFailFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.AllocPagesSysFailFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 gfp_flags = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gfp_flags());
    }

    // optional uint32 order = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_order());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AllocPagesSysFailFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AllocPagesSysFailFtraceEvent*>(
      &from));
}

void AllocPagesSysFailFtraceEvent::MergeFrom(const AllocPagesSysFailFtraceEvent& from) {
  AllocPagesSysFailFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.AllocPagesSysFailFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.gfp_flags_ = from._impl_.gfp_flags_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.order_ = from._impl_.order_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AllocPagesSysFailFtraceEvent::CopyFrom(const AllocPagesSysFailFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.AllocPagesSysFailFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AllocPagesSysFailFtraceEvent::IsInitialized() const {
  return true;
}

void AllocPagesSysFailFtraceEvent::InternalSwap(AllocPagesSysFailFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AllocPagesSysFailFtraceEvent, _impl_.order_)
      + sizeof(AllocPagesSysFailFtraceEvent::_impl_.order_)
      - PROTOBUF_FIELD_OFFSET(AllocPagesSysFailFtraceEvent, _impl_.gfp_flags_)>(
          reinterpret_cast<char*>(&_impl_.gfp_flags_),
          reinterpret_cast<char*>(&other->_impl_.gfp_flags_));
}

std::string AllocPagesSysFailFtraceEvent::GetTypeName() const {
  return "perfetto.protos.AllocPagesSysFailFtraceEvent";
}


// ===================================================================

class AllocPagesSysStartFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<AllocPagesSysStartFtraceEvent>()._impl_._has_bits_);
  static void set_has_gfp_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AllocPagesSysStartFtraceEvent::AllocPagesSysStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.AllocPagesSysStartFtraceEvent)
}
AllocPagesSysStartFtraceEvent::AllocPagesSysStartFtraceEvent(const AllocPagesSysStartFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  AllocPagesSysStartFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gfp_flags_){}
    , decltype(_impl_.order_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.gfp_flags_, &from._impl_.gfp_flags_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.order_) -
    reinterpret_cast<char*>(&_impl_.gfp_flags_)) + sizeof(_impl_.order_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.AllocPagesSysStartFtraceEvent)
}

inline void AllocPagesSysStartFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gfp_flags_){0u}
    , decltype(_impl_.order_){0u}
  };
}

AllocPagesSysStartFtraceEvent::~AllocPagesSysStartFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.AllocPagesSysStartFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AllocPagesSysStartFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AllocPagesSysStartFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AllocPagesSysStartFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.AllocPagesSysStartFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.gfp_flags_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.order_) -
        reinterpret_cast<char*>(&_impl_.gfp_flags_)) + sizeof(_impl_.order_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AllocPagesSysStartFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 gfp_flags = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gfp_flags(&has_bits);
          _impl_.gfp_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 order = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_order(&has_bits);
          _impl_.order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AllocPagesSysStartFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.AllocPagesSysStartFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 gfp_flags = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gfp_flags(), target);
  }

  // optional uint32 order = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_order(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.AllocPagesSysStartFtraceEvent)
  return target;
}

size_t AllocPagesSysStartFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.AllocPagesSysStartFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 gfp_flags = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gfp_flags());
    }

    // optional uint32 order = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_order());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AllocPagesSysStartFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AllocPagesSysStartFtraceEvent*>(
      &from));
}

void AllocPagesSysStartFtraceEvent::MergeFrom(const AllocPagesSysStartFtraceEvent& from) {
  AllocPagesSysStartFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.AllocPagesSysStartFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.gfp_flags_ = from._impl_.gfp_flags_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.order_ = from._impl_.order_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AllocPagesSysStartFtraceEvent::CopyFrom(const AllocPagesSysStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.AllocPagesSysStartFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AllocPagesSysStartFtraceEvent::IsInitialized() const {
  return true;
}

void AllocPagesSysStartFtraceEvent::InternalSwap(AllocPagesSysStartFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AllocPagesSysStartFtraceEvent, _impl_.order_)
      + sizeof(AllocPagesSysStartFtraceEvent::_impl_.order_)
      - PROTOBUF_FIELD_OFFSET(AllocPagesSysStartFtraceEvent, _impl_.gfp_flags_)>(
          reinterpret_cast<char*>(&_impl_.gfp_flags_),
          reinterpret_cast<char*>(&other->_impl_.gfp_flags_));
}

std::string AllocPagesSysStartFtraceEvent::GetTypeName() const {
  return "perfetto.protos.AllocPagesSysStartFtraceEvent";
}


// ===================================================================

class DmaAllocContiguousRetryFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<DmaAllocContiguousRetryFtraceEvent>()._impl_._has_bits_);
  static void set_has_tries(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DmaAllocContiguousRetryFtraceEvent::DmaAllocContiguousRetryFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.DmaAllocContiguousRetryFtraceEvent)
}
DmaAllocContiguousRetryFtraceEvent::DmaAllocContiguousRetryFtraceEvent(const DmaAllocContiguousRetryFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DmaAllocContiguousRetryFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tries_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.tries_ = from._impl_.tries_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.DmaAllocContiguousRetryFtraceEvent)
}

inline void DmaAllocContiguousRetryFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tries_){0}
  };
}

DmaAllocContiguousRetryFtraceEvent::~DmaAllocContiguousRetryFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.DmaAllocContiguousRetryFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DmaAllocContiguousRetryFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DmaAllocContiguousRetryFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DmaAllocContiguousRetryFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.DmaAllocContiguousRetryFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tries_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DmaAllocContiguousRetryFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 tries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_tries(&has_bits);
          _impl_.tries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DmaAllocContiguousRetryFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.DmaAllocContiguousRetryFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 tries = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_tries(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.DmaAllocContiguousRetryFtraceEvent)
  return target;
}

size_t DmaAllocContiguousRetryFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.DmaAllocContiguousRetryFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 tries = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_tries());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DmaAllocContiguousRetryFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DmaAllocContiguousRetryFtraceEvent*>(
      &from));
}

void DmaAllocContiguousRetryFtraceEvent::MergeFrom(const DmaAllocContiguousRetryFtraceEvent& from) {
  DmaAllocContiguousRetryFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.DmaAllocContiguousRetryFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_tries()) {
    _this->_internal_set_tries(from._internal_tries());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DmaAllocContiguousRetryFtraceEvent::CopyFrom(const DmaAllocContiguousRetryFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.DmaAllocContiguousRetryFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DmaAllocContiguousRetryFtraceEvent::IsInitialized() const {
  return true;
}

void DmaAllocContiguousRetryFtraceEvent::InternalSwap(DmaAllocContiguousRetryFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.tries_, other->_impl_.tries_);
}

std::string DmaAllocContiguousRetryFtraceEvent::GetTypeName() const {
  return "perfetto.protos.DmaAllocContiguousRetryFtraceEvent";
}


// ===================================================================

class IommuMapRangeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IommuMapRangeFtraceEvent>()._impl_._has_bits_);
  static void set_has_chunk_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pa(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_va(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

IommuMapRangeFtraceEvent::IommuMapRangeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IommuMapRangeFtraceEvent)
}
IommuMapRangeFtraceEvent::IommuMapRangeFtraceEvent(const IommuMapRangeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IommuMapRangeFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.chunk_size_){}
    , decltype(_impl_.len_){}
    , decltype(_impl_.pa_){}
    , decltype(_impl_.va_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.chunk_size_, &from._impl_.chunk_size_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.va_) -
    reinterpret_cast<char*>(&_impl_.chunk_size_)) + sizeof(_impl_.va_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IommuMapRangeFtraceEvent)
}

inline void IommuMapRangeFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.chunk_size_){uint64_t{0u}}
    , decltype(_impl_.len_){uint64_t{0u}}
    , decltype(_impl_.pa_){uint64_t{0u}}
    , decltype(_impl_.va_){uint64_t{0u}}
  };
}

IommuMapRangeFtraceEvent::~IommuMapRangeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IommuMapRangeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IommuMapRangeFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void IommuMapRangeFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IommuMapRangeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IommuMapRangeFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.chunk_size_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.va_) -
        reinterpret_cast<char*>(&_impl_.chunk_size_)) + sizeof(_impl_.va_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IommuMapRangeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 chunk_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_chunk_size(&has_bits);
          _impl_.chunk_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 len = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pa = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_pa(&has_bits);
          _impl_.pa_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 va = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_va(&has_bits);
          _impl_.va_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IommuMapRangeFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IommuMapRangeFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 chunk_size = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_chunk_size(), target);
  }

  // optional uint64 len = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_len(), target);
  }

  // optional uint64 pa = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_pa(), target);
  }

  // optional uint64 va = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_va(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IommuMapRangeFtraceEvent)
  return target;
}

size_t IommuMapRangeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IommuMapRangeFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 chunk_size = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_chunk_size());
    }

    // optional uint64 len = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_len());
    }

    // optional uint64 pa = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pa());
    }

    // optional uint64 va = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_va());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IommuMapRangeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IommuMapRangeFtraceEvent*>(
      &from));
}

void IommuMapRangeFtraceEvent::MergeFrom(const IommuMapRangeFtraceEvent& from) {
  IommuMapRangeFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IommuMapRangeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.chunk_size_ = from._impl_.chunk_size_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pa_ = from._impl_.pa_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.va_ = from._impl_.va_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IommuMapRangeFtraceEvent::CopyFrom(const IommuMapRangeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IommuMapRangeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IommuMapRangeFtraceEvent::IsInitialized() const {
  return true;
}

void IommuMapRangeFtraceEvent::InternalSwap(IommuMapRangeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IommuMapRangeFtraceEvent, _impl_.va_)
      + sizeof(IommuMapRangeFtraceEvent::_impl_.va_)
      - PROTOBUF_FIELD_OFFSET(IommuMapRangeFtraceEvent, _impl_.chunk_size_)>(
          reinterpret_cast<char*>(&_impl_.chunk_size_),
          reinterpret_cast<char*>(&other->_impl_.chunk_size_));
}

std::string IommuMapRangeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IommuMapRangeFtraceEvent";
}


// ===================================================================

class IommuSecPtblMapRangeEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IommuSecPtblMapRangeEndFtraceEvent>()._impl_._has_bits_);
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pa(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sec_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_va(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

IommuSecPtblMapRangeEndFtraceEvent::IommuSecPtblMapRangeEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent)
}
IommuSecPtblMapRangeEndFtraceEvent::IommuSecPtblMapRangeEndFtraceEvent(const IommuSecPtblMapRangeEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IommuSecPtblMapRangeEndFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.len_){}
    , decltype(_impl_.num_){}
    , decltype(_impl_.pa_){}
    , decltype(_impl_.va_){}
    , decltype(_impl_.sec_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.len_, &from._impl_.len_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.sec_id_) -
    reinterpret_cast<char*>(&_impl_.len_)) + sizeof(_impl_.sec_id_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent)
}

inline void IommuSecPtblMapRangeEndFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.len_){uint64_t{0u}}
    , decltype(_impl_.num_){0}
    , decltype(_impl_.pa_){0u}
    , decltype(_impl_.va_){uint64_t{0u}}
    , decltype(_impl_.sec_id_){0}
  };
}

IommuSecPtblMapRangeEndFtraceEvent::~IommuSecPtblMapRangeEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IommuSecPtblMapRangeEndFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void IommuSecPtblMapRangeEndFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IommuSecPtblMapRangeEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.len_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.sec_id_) -
        reinterpret_cast<char*>(&_impl_.len_)) + sizeof(_impl_.sec_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IommuSecPtblMapRangeEndFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 len = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 num = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_num(&has_bits);
          _impl_.num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 pa = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_pa(&has_bits);
          _impl_.pa_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 sec_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_sec_id(&has_bits);
          _impl_.sec_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 va = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_va(&has_bits);
          _impl_.va_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IommuSecPtblMapRangeEndFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 len = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_len(), target);
  }

  // optional int32 num = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_num(), target);
  }

  // optional uint32 pa = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_pa(), target);
  }

  // optional int32 sec_id = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_sec_id(), target);
  }

  // optional uint64 va = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_va(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent)
  return target;
}

size_t IommuSecPtblMapRangeEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 len = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_len());
    }

    // optional int32 num = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num());
    }

    // optional uint32 pa = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_pa());
    }

    // optional uint64 va = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_va());
    }

    // optional int32 sec_id = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sec_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IommuSecPtblMapRangeEndFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IommuSecPtblMapRangeEndFtraceEvent*>(
      &from));
}

void IommuSecPtblMapRangeEndFtraceEvent::MergeFrom(const IommuSecPtblMapRangeEndFtraceEvent& from) {
  IommuSecPtblMapRangeEndFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.num_ = from._impl_.num_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pa_ = from._impl_.pa_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.va_ = from._impl_.va_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.sec_id_ = from._impl_.sec_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IommuSecPtblMapRangeEndFtraceEvent::CopyFrom(const IommuSecPtblMapRangeEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IommuSecPtblMapRangeEndFtraceEvent::IsInitialized() const {
  return true;
}

void IommuSecPtblMapRangeEndFtraceEvent::InternalSwap(IommuSecPtblMapRangeEndFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IommuSecPtblMapRangeEndFtraceEvent, _impl_.sec_id_)
      + sizeof(IommuSecPtblMapRangeEndFtraceEvent::_impl_.sec_id_)
      - PROTOBUF_FIELD_OFFSET(IommuSecPtblMapRangeEndFtraceEvent, _impl_.len_)>(
          reinterpret_cast<char*>(&_impl_.len_),
          reinterpret_cast<char*>(&other->_impl_.len_));
}

std::string IommuSecPtblMapRangeEndFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IommuSecPtblMapRangeEndFtraceEvent";
}


// ===================================================================

class IommuSecPtblMapRangeStartFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IommuSecPtblMapRangeStartFtraceEvent>()._impl_._has_bits_);
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pa(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sec_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_va(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

IommuSecPtblMapRangeStartFtraceEvent::IommuSecPtblMapRangeStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent)
}
IommuSecPtblMapRangeStartFtraceEvent::IommuSecPtblMapRangeStartFtraceEvent(const IommuSecPtblMapRangeStartFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IommuSecPtblMapRangeStartFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.len_){}
    , decltype(_impl_.num_){}
    , decltype(_impl_.pa_){}
    , decltype(_impl_.va_){}
    , decltype(_impl_.sec_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.len_, &from._impl_.len_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.sec_id_) -
    reinterpret_cast<char*>(&_impl_.len_)) + sizeof(_impl_.sec_id_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent)
}

inline void IommuSecPtblMapRangeStartFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.len_){uint64_t{0u}}
    , decltype(_impl_.num_){0}
    , decltype(_impl_.pa_){0u}
    , decltype(_impl_.va_){uint64_t{0u}}
    , decltype(_impl_.sec_id_){0}
  };
}

IommuSecPtblMapRangeStartFtraceEvent::~IommuSecPtblMapRangeStartFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IommuSecPtblMapRangeStartFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void IommuSecPtblMapRangeStartFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IommuSecPtblMapRangeStartFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.len_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.sec_id_) -
        reinterpret_cast<char*>(&_impl_.len_)) + sizeof(_impl_.sec_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IommuSecPtblMapRangeStartFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 len = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 num = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_num(&has_bits);
          _impl_.num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 pa = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_pa(&has_bits);
          _impl_.pa_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 sec_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_sec_id(&has_bits);
          _impl_.sec_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 va = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_va(&has_bits);
          _impl_.va_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IommuSecPtblMapRangeStartFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 len = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_len(), target);
  }

  // optional int32 num = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_num(), target);
  }

  // optional uint32 pa = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_pa(), target);
  }

  // optional int32 sec_id = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_sec_id(), target);
  }

  // optional uint64 va = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_va(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent)
  return target;
}

size_t IommuSecPtblMapRangeStartFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 len = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_len());
    }

    // optional int32 num = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num());
    }

    // optional uint32 pa = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_pa());
    }

    // optional uint64 va = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_va());
    }

    // optional int32 sec_id = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sec_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IommuSecPtblMapRangeStartFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IommuSecPtblMapRangeStartFtraceEvent*>(
      &from));
}

void IommuSecPtblMapRangeStartFtraceEvent::MergeFrom(const IommuSecPtblMapRangeStartFtraceEvent& from) {
  IommuSecPtblMapRangeStartFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.num_ = from._impl_.num_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pa_ = from._impl_.pa_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.va_ = from._impl_.va_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.sec_id_ = from._impl_.sec_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IommuSecPtblMapRangeStartFtraceEvent::CopyFrom(const IommuSecPtblMapRangeStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IommuSecPtblMapRangeStartFtraceEvent::IsInitialized() const {
  return true;
}

void IommuSecPtblMapRangeStartFtraceEvent::InternalSwap(IommuSecPtblMapRangeStartFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IommuSecPtblMapRangeStartFtraceEvent, _impl_.sec_id_)
      + sizeof(IommuSecPtblMapRangeStartFtraceEvent::_impl_.sec_id_)
      - PROTOBUF_FIELD_OFFSET(IommuSecPtblMapRangeStartFtraceEvent, _impl_.len_)>(
          reinterpret_cast<char*>(&_impl_.len_),
          reinterpret_cast<char*>(&other->_impl_.len_));
}

std::string IommuSecPtblMapRangeStartFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IommuSecPtblMapRangeStartFtraceEvent";
}


// ===================================================================

class IonAllocBufferEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonAllocBufferEndFtraceEvent>()._impl_._has_bits_);
  static void set_has_client_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_heap_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_mask(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

IonAllocBufferEndFtraceEvent::IonAllocBufferEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IonAllocBufferEndFtraceEvent)
}
IonAllocBufferEndFtraceEvent::IonAllocBufferEndFtraceEvent(const IonAllocBufferEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IonAllocBufferEndFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.client_name_){}
    , decltype(_impl_.heap_name_){}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.mask_){}
    , decltype(_impl_.len_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.client_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_client_name()) {
    _this->_impl_.client_name_.Set(from._internal_client_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_heap_name()) {
    _this->_impl_.heap_name_.Set(from._internal_heap_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.flags_, &from._impl_.flags_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.len_) -
    reinterpret_cast<char*>(&_impl_.flags_)) + sizeof(_impl_.len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonAllocBufferEndFtraceEvent)
}

inline void IonAllocBufferEndFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.client_name_){}
    , decltype(_impl_.heap_name_){}
    , decltype(_impl_.flags_){0u}
    , decltype(_impl_.mask_){0u}
    , decltype(_impl_.len_){uint64_t{0u}}
  };
  _impl_.client_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IonAllocBufferEndFtraceEvent::~IonAllocBufferEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonAllocBufferEndFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IonAllocBufferEndFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.client_name_.Destroy();
  _impl_.heap_name_.Destroy();
}

void IonAllocBufferEndFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IonAllocBufferEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonAllocBufferEndFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.client_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.heap_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.flags_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.len_) -
        reinterpret_cast<char*>(&_impl_.flags_)) + sizeof(_impl_.len_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IonAllocBufferEndFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string client_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_client_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string heap_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_heap_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mask = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_mask(&has_bits);
          _impl_.mask_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IonAllocBufferEndFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IonAllocBufferEndFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string client_name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_client_name(), target);
  }

  // optional uint32 flags = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_flags(), target);
  }

  // optional string heap_name = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_heap_name(), target);
  }

  // optional uint64 len = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_len(), target);
  }

  // optional uint32 mask = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_mask(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IonAllocBufferEndFtraceEvent)
  return target;
}

size_t IonAllocBufferEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonAllocBufferEndFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string client_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_client_name());
    }

    // optional string heap_name = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_heap_name());
    }

    // optional uint32 flags = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

    // optional uint32 mask = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mask());
    }

    // optional uint64 len = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_len());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IonAllocBufferEndFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IonAllocBufferEndFtraceEvent*>(
      &from));
}

void IonAllocBufferEndFtraceEvent::MergeFrom(const IonAllocBufferEndFtraceEvent& from) {
  IonAllocBufferEndFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonAllocBufferEndFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_client_name(from._internal_client_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_heap_name(from._internal_heap_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.mask_ = from._impl_.mask_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IonAllocBufferEndFtraceEvent::CopyFrom(const IonAllocBufferEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonAllocBufferEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonAllocBufferEndFtraceEvent::IsInitialized() const {
  return true;
}

void IonAllocBufferEndFtraceEvent::InternalSwap(IonAllocBufferEndFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.client_name_, lhs_arena,
      &other->_impl_.client_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.heap_name_, lhs_arena,
      &other->_impl_.heap_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IonAllocBufferEndFtraceEvent, _impl_.len_)
      + sizeof(IonAllocBufferEndFtraceEvent::_impl_.len_)
      - PROTOBUF_FIELD_OFFSET(IonAllocBufferEndFtraceEvent, _impl_.flags_)>(
          reinterpret_cast<char*>(&_impl_.flags_),
          reinterpret_cast<char*>(&other->_impl_.flags_));
}

std::string IonAllocBufferEndFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IonAllocBufferEndFtraceEvent";
}


// ===================================================================

class IonAllocBufferFailFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonAllocBufferFailFtraceEvent>()._impl_._has_bits_);
  static void set_has_client_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_heap_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_mask(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

IonAllocBufferFailFtraceEvent::IonAllocBufferFailFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IonAllocBufferFailFtraceEvent)
}
IonAllocBufferFailFtraceEvent::IonAllocBufferFailFtraceEvent(const IonAllocBufferFailFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IonAllocBufferFailFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.client_name_){}
    , decltype(_impl_.heap_name_){}
    , decltype(_impl_.error_){}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.mask_){}
    , decltype(_impl_.len_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.client_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_client_name()) {
    _this->_impl_.client_name_.Set(from._internal_client_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_heap_name()) {
    _this->_impl_.heap_name_.Set(from._internal_heap_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.error_, &from._impl_.error_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.len_) -
    reinterpret_cast<char*>(&_impl_.error_)) + sizeof(_impl_.len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonAllocBufferFailFtraceEvent)
}

inline void IonAllocBufferFailFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.client_name_){}
    , decltype(_impl_.heap_name_){}
    , decltype(_impl_.error_){int64_t{0}}
    , decltype(_impl_.flags_){0u}
    , decltype(_impl_.mask_){0u}
    , decltype(_impl_.len_){uint64_t{0u}}
  };
  _impl_.client_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IonAllocBufferFailFtraceEvent::~IonAllocBufferFailFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonAllocBufferFailFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IonAllocBufferFailFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.client_name_.Destroy();
  _impl_.heap_name_.Destroy();
}

void IonAllocBufferFailFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IonAllocBufferFailFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonAllocBufferFailFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.client_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.heap_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&_impl_.error_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.len_) -
        reinterpret_cast<char*>(&_impl_.error_)) + sizeof(_impl_.len_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IonAllocBufferFailFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string client_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_client_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 error = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_error(&has_bits);
          _impl_.error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string heap_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_heap_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 len = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mask = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_mask(&has_bits);
          _impl_.mask_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IonAllocBufferFailFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IonAllocBufferFailFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string client_name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_client_name(), target);
  }

  // optional int64 error = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_error(), target);
  }

  // optional uint32 flags = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_flags(), target);
  }

  // optional string heap_name = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_heap_name(), target);
  }

  // optional uint64 len = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_len(), target);
  }

  // optional uint32 mask = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_mask(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IonAllocBufferFailFtraceEvent)
  return target;
}

size_t IonAllocBufferFailFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonAllocBufferFailFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string client_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_client_name());
    }

    // optional string heap_name = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_heap_name());
    }

    // optional int64 error = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_error());
    }

    // optional uint32 flags = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

    // optional uint32 mask = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mask());
    }

    // optional uint64 len = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_len());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IonAllocBufferFailFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IonAllocBufferFailFtraceEvent*>(
      &from));
}

void IonAllocBufferFailFtraceEvent::MergeFrom(const IonAllocBufferFailFtraceEvent& from) {
  IonAllocBufferFailFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonAllocBufferFailFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_client_name(from._internal_client_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_heap_name(from._internal_heap_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.error_ = from._impl_.error_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.mask_ = from._impl_.mask_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IonAllocBufferFailFtraceEvent::CopyFrom(const IonAllocBufferFailFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonAllocBufferFailFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonAllocBufferFailFtraceEvent::IsInitialized() const {
  return true;
}

void IonAllocBufferFailFtraceEvent::InternalSwap(IonAllocBufferFailFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.client_name_, lhs_arena,
      &other->_impl_.client_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.heap_name_, lhs_arena,
      &other->_impl_.heap_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IonAllocBufferFailFtraceEvent, _impl_.len_)
      + sizeof(IonAllocBufferFailFtraceEvent::_impl_.len_)
      - PROTOBUF_FIELD_OFFSET(IonAllocBufferFailFtraceEvent, _impl_.error_)>(
          reinterpret_cast<char*>(&_impl_.error_),
          reinterpret_cast<char*>(&other->_impl_.error_));
}

std::string IonAllocBufferFailFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IonAllocBufferFailFtraceEvent";
}


// ===================================================================

class IonAllocBufferFallbackFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonAllocBufferFallbackFtraceEvent>()._impl_._has_bits_);
  static void set_has_client_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_heap_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_mask(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

IonAllocBufferFallbackFtraceEvent::IonAllocBufferFallbackFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IonAllocBufferFallbackFtraceEvent)
}
IonAllocBufferFallbackFtraceEvent::IonAllocBufferFallbackFtraceEvent(const IonAllocBufferFallbackFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IonAllocBufferFallbackFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.client_name_){}
    , decltype(_impl_.heap_name_){}
    , decltype(_impl_.error_){}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.mask_){}
    , decltype(_impl_.len_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.client_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_client_name()) {
    _this->_impl_.client_name_.Set(from._internal_client_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_heap_name()) {
    _this->_impl_.heap_name_.Set(from._internal_heap_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.error_, &from._impl_.error_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.len_) -
    reinterpret_cast<char*>(&_impl_.error_)) + sizeof(_impl_.len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonAllocBufferFallbackFtraceEvent)
}

inline void IonAllocBufferFallbackFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.client_name_){}
    , decltype(_impl_.heap_name_){}
    , decltype(_impl_.error_){int64_t{0}}
    , decltype(_impl_.flags_){0u}
    , decltype(_impl_.mask_){0u}
    , decltype(_impl_.len_){uint64_t{0u}}
  };
  _impl_.client_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IonAllocBufferFallbackFtraceEvent::~IonAllocBufferFallbackFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonAllocBufferFallbackFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IonAllocBufferFallbackFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.client_name_.Destroy();
  _impl_.heap_name_.Destroy();
}

void IonAllocBufferFallbackFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IonAllocBufferFallbackFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonAllocBufferFallbackFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.client_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.heap_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&_impl_.error_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.len_) -
        reinterpret_cast<char*>(&_impl_.error_)) + sizeof(_impl_.len_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IonAllocBufferFallbackFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string client_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_client_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 error = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_error(&has_bits);
          _impl_.error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string heap_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_heap_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 len = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mask = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_mask(&has_bits);
          _impl_.mask_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IonAllocBufferFallbackFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IonAllocBufferFallbackFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string client_name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_client_name(), target);
  }

  // optional int64 error = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_error(), target);
  }

  // optional uint32 flags = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_flags(), target);
  }

  // optional string heap_name = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_heap_name(), target);
  }

  // optional uint64 len = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_len(), target);
  }

  // optional uint32 mask = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_mask(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IonAllocBufferFallbackFtraceEvent)
  return target;
}

size_t IonAllocBufferFallbackFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonAllocBufferFallbackFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string client_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_client_name());
    }

    // optional string heap_name = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_heap_name());
    }

    // optional int64 error = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_error());
    }

    // optional uint32 flags = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

    // optional uint32 mask = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mask());
    }

    // optional uint64 len = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_len());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IonAllocBufferFallbackFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IonAllocBufferFallbackFtraceEvent*>(
      &from));
}

void IonAllocBufferFallbackFtraceEvent::MergeFrom(const IonAllocBufferFallbackFtraceEvent& from) {
  IonAllocBufferFallbackFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonAllocBufferFallbackFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_client_name(from._internal_client_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_heap_name(from._internal_heap_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.error_ = from._impl_.error_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.mask_ = from._impl_.mask_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IonAllocBufferFallbackFtraceEvent::CopyFrom(const IonAllocBufferFallbackFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonAllocBufferFallbackFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonAllocBufferFallbackFtraceEvent::IsInitialized() const {
  return true;
}

void IonAllocBufferFallbackFtraceEvent::InternalSwap(IonAllocBufferFallbackFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.client_name_, lhs_arena,
      &other->_impl_.client_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.heap_name_, lhs_arena,
      &other->_impl_.heap_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IonAllocBufferFallbackFtraceEvent, _impl_.len_)
      + sizeof(IonAllocBufferFallbackFtraceEvent::_impl_.len_)
      - PROTOBUF_FIELD_OFFSET(IonAllocBufferFallbackFtraceEvent, _impl_.error_)>(
          reinterpret_cast<char*>(&_impl_.error_),
          reinterpret_cast<char*>(&other->_impl_.error_));
}

std::string IonAllocBufferFallbackFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IonAllocBufferFallbackFtraceEvent";
}


// ===================================================================

class IonAllocBufferStartFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonAllocBufferStartFtraceEvent>()._impl_._has_bits_);
  static void set_has_client_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_heap_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_mask(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

IonAllocBufferStartFtraceEvent::IonAllocBufferStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IonAllocBufferStartFtraceEvent)
}
IonAllocBufferStartFtraceEvent::IonAllocBufferStartFtraceEvent(const IonAllocBufferStartFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IonAllocBufferStartFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.client_name_){}
    , decltype(_impl_.heap_name_){}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.mask_){}
    , decltype(_impl_.len_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.client_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_client_name()) {
    _this->_impl_.client_name_.Set(from._internal_client_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_heap_name()) {
    _this->_impl_.heap_name_.Set(from._internal_heap_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.flags_, &from._impl_.flags_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.len_) -
    reinterpret_cast<char*>(&_impl_.flags_)) + sizeof(_impl_.len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonAllocBufferStartFtraceEvent)
}

inline void IonAllocBufferStartFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.client_name_){}
    , decltype(_impl_.heap_name_){}
    , decltype(_impl_.flags_){0u}
    , decltype(_impl_.mask_){0u}
    , decltype(_impl_.len_){uint64_t{0u}}
  };
  _impl_.client_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IonAllocBufferStartFtraceEvent::~IonAllocBufferStartFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonAllocBufferStartFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IonAllocBufferStartFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.client_name_.Destroy();
  _impl_.heap_name_.Destroy();
}

void IonAllocBufferStartFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IonAllocBufferStartFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonAllocBufferStartFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.client_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.heap_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.flags_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.len_) -
        reinterpret_cast<char*>(&_impl_.flags_)) + sizeof(_impl_.len_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IonAllocBufferStartFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string client_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_client_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string heap_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_heap_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mask = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_mask(&has_bits);
          _impl_.mask_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IonAllocBufferStartFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IonAllocBufferStartFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string client_name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_client_name(), target);
  }

  // optional uint32 flags = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_flags(), target);
  }

  // optional string heap_name = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_heap_name(), target);
  }

  // optional uint64 len = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_len(), target);
  }

  // optional uint32 mask = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_mask(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IonAllocBufferStartFtraceEvent)
  return target;
}

size_t IonAllocBufferStartFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonAllocBufferStartFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string client_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_client_name());
    }

    // optional string heap_name = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_heap_name());
    }

    // optional uint32 flags = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

    // optional uint32 mask = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mask());
    }

    // optional uint64 len = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_len());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IonAllocBufferStartFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IonAllocBufferStartFtraceEvent*>(
      &from));
}

void IonAllocBufferStartFtraceEvent::MergeFrom(const IonAllocBufferStartFtraceEvent& from) {
  IonAllocBufferStartFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonAllocBufferStartFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_client_name(from._internal_client_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_heap_name(from._internal_heap_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.mask_ = from._impl_.mask_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IonAllocBufferStartFtraceEvent::CopyFrom(const IonAllocBufferStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonAllocBufferStartFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonAllocBufferStartFtraceEvent::IsInitialized() const {
  return true;
}

void IonAllocBufferStartFtraceEvent::InternalSwap(IonAllocBufferStartFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.client_name_, lhs_arena,
      &other->_impl_.client_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.heap_name_, lhs_arena,
      &other->_impl_.heap_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IonAllocBufferStartFtraceEvent, _impl_.len_)
      + sizeof(IonAllocBufferStartFtraceEvent::_impl_.len_)
      - PROTOBUF_FIELD_OFFSET(IonAllocBufferStartFtraceEvent, _impl_.flags_)>(
          reinterpret_cast<char*>(&_impl_.flags_),
          reinterpret_cast<char*>(&other->_impl_.flags_));
}

std::string IonAllocBufferStartFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IonAllocBufferStartFtraceEvent";
}


// ===================================================================

class IonCpAllocRetryFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonCpAllocRetryFtraceEvent>()._impl_._has_bits_);
  static void set_has_tries(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

IonCpAllocRetryFtraceEvent::IonCpAllocRetryFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IonCpAllocRetryFtraceEvent)
}
IonCpAllocRetryFtraceEvent::IonCpAllocRetryFtraceEvent(const IonCpAllocRetryFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IonCpAllocRetryFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tries_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.tries_ = from._impl_.tries_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonCpAllocRetryFtraceEvent)
}

inline void IonCpAllocRetryFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tries_){0}
  };
}

IonCpAllocRetryFtraceEvent::~IonCpAllocRetryFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonCpAllocRetryFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IonCpAllocRetryFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void IonCpAllocRetryFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IonCpAllocRetryFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonCpAllocRetryFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tries_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IonCpAllocRetryFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 tries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_tries(&has_bits);
          _impl_.tries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IonCpAllocRetryFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IonCpAllocRetryFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 tries = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_tries(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IonCpAllocRetryFtraceEvent)
  return target;
}

size_t IonCpAllocRetryFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonCpAllocRetryFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 tries = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_tries());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IonCpAllocRetryFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IonCpAllocRetryFtraceEvent*>(
      &from));
}

void IonCpAllocRetryFtraceEvent::MergeFrom(const IonCpAllocRetryFtraceEvent& from) {
  IonCpAllocRetryFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonCpAllocRetryFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_tries()) {
    _this->_internal_set_tries(from._internal_tries());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IonCpAllocRetryFtraceEvent::CopyFrom(const IonCpAllocRetryFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonCpAllocRetryFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonCpAllocRetryFtraceEvent::IsInitialized() const {
  return true;
}

void IonCpAllocRetryFtraceEvent::InternalSwap(IonCpAllocRetryFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.tries_, other->_impl_.tries_);
}

std::string IonCpAllocRetryFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IonCpAllocRetryFtraceEvent";
}


// ===================================================================

class IonCpSecureBufferEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonCpSecureBufferEndFtraceEvent>()._impl_._has_bits_);
  static void set_has_align(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_heap_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

IonCpSecureBufferEndFtraceEvent::IonCpSecureBufferEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IonCpSecureBufferEndFtraceEvent)
}
IonCpSecureBufferEndFtraceEvent::IonCpSecureBufferEndFtraceEvent(const IonCpSecureBufferEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IonCpSecureBufferEndFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.heap_name_){}
    , decltype(_impl_.align_){}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.len_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_heap_name()) {
    _this->_impl_.heap_name_.Set(from._internal_heap_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.align_, &from._impl_.align_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.len_) -
    reinterpret_cast<char*>(&_impl_.align_)) + sizeof(_impl_.len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonCpSecureBufferEndFtraceEvent)
}

inline void IonCpSecureBufferEndFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.heap_name_){}
    , decltype(_impl_.align_){uint64_t{0u}}
    , decltype(_impl_.flags_){uint64_t{0u}}
    , decltype(_impl_.len_){uint64_t{0u}}
  };
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IonCpSecureBufferEndFtraceEvent::~IonCpSecureBufferEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonCpSecureBufferEndFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IonCpSecureBufferEndFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.heap_name_.Destroy();
}

void IonCpSecureBufferEndFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IonCpSecureBufferEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonCpSecureBufferEndFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.heap_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.align_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.len_) -
        reinterpret_cast<char*>(&_impl_.align_)) + sizeof(_impl_.len_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IonCpSecureBufferEndFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 align = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_align(&has_bits);
          _impl_.align_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 flags = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string heap_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_heap_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IonCpSecureBufferEndFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IonCpSecureBufferEndFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 align = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_align(), target);
  }

  // optional uint64 flags = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_flags(), target);
  }

  // optional string heap_name = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_heap_name(), target);
  }

  // optional uint64 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IonCpSecureBufferEndFtraceEvent)
  return target;
}

size_t IonCpSecureBufferEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonCpSecureBufferEndFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string heap_name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_heap_name());
    }

    // optional uint64 align = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_align());
    }

    // optional uint64 flags = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_flags());
    }

    // optional uint64 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_len());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IonCpSecureBufferEndFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IonCpSecureBufferEndFtraceEvent*>(
      &from));
}

void IonCpSecureBufferEndFtraceEvent::MergeFrom(const IonCpSecureBufferEndFtraceEvent& from) {
  IonCpSecureBufferEndFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonCpSecureBufferEndFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_heap_name(from._internal_heap_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.align_ = from._impl_.align_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IonCpSecureBufferEndFtraceEvent::CopyFrom(const IonCpSecureBufferEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonCpSecureBufferEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonCpSecureBufferEndFtraceEvent::IsInitialized() const {
  return true;
}

void IonCpSecureBufferEndFtraceEvent::InternalSwap(IonCpSecureBufferEndFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.heap_name_, lhs_arena,
      &other->_impl_.heap_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IonCpSecureBufferEndFtraceEvent, _impl_.len_)
      + sizeof(IonCpSecureBufferEndFtraceEvent::_impl_.len_)
      - PROTOBUF_FIELD_OFFSET(IonCpSecureBufferEndFtraceEvent, _impl_.align_)>(
          reinterpret_cast<char*>(&_impl_.align_),
          reinterpret_cast<char*>(&other->_impl_.align_));
}

std::string IonCpSecureBufferEndFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IonCpSecureBufferEndFtraceEvent";
}


// ===================================================================

class IonCpSecureBufferStartFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonCpSecureBufferStartFtraceEvent>()._impl_._has_bits_);
  static void set_has_align(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_heap_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

IonCpSecureBufferStartFtraceEvent::IonCpSecureBufferStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IonCpSecureBufferStartFtraceEvent)
}
IonCpSecureBufferStartFtraceEvent::IonCpSecureBufferStartFtraceEvent(const IonCpSecureBufferStartFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IonCpSecureBufferStartFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.heap_name_){}
    , decltype(_impl_.align_){}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.len_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_heap_name()) {
    _this->_impl_.heap_name_.Set(from._internal_heap_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.align_, &from._impl_.align_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.len_) -
    reinterpret_cast<char*>(&_impl_.align_)) + sizeof(_impl_.len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonCpSecureBufferStartFtraceEvent)
}

inline void IonCpSecureBufferStartFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.heap_name_){}
    , decltype(_impl_.align_){uint64_t{0u}}
    , decltype(_impl_.flags_){uint64_t{0u}}
    , decltype(_impl_.len_){uint64_t{0u}}
  };
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IonCpSecureBufferStartFtraceEvent::~IonCpSecureBufferStartFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonCpSecureBufferStartFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IonCpSecureBufferStartFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.heap_name_.Destroy();
}

void IonCpSecureBufferStartFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IonCpSecureBufferStartFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonCpSecureBufferStartFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.heap_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.align_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.len_) -
        reinterpret_cast<char*>(&_impl_.align_)) + sizeof(_impl_.len_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IonCpSecureBufferStartFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 align = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_align(&has_bits);
          _impl_.align_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 flags = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string heap_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_heap_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IonCpSecureBufferStartFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IonCpSecureBufferStartFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 align = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_align(), target);
  }

  // optional uint64 flags = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_flags(), target);
  }

  // optional string heap_name = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_heap_name(), target);
  }

  // optional uint64 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IonCpSecureBufferStartFtraceEvent)
  return target;
}

size_t IonCpSecureBufferStartFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonCpSecureBufferStartFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string heap_name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_heap_name());
    }

    // optional uint64 align = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_align());
    }

    // optional uint64 flags = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_flags());
    }

    // optional uint64 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_len());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IonCpSecureBufferStartFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IonCpSecureBufferStartFtraceEvent*>(
      &from));
}

void IonCpSecureBufferStartFtraceEvent::MergeFrom(const IonCpSecureBufferStartFtraceEvent& from) {
  IonCpSecureBufferStartFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonCpSecureBufferStartFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_heap_name(from._internal_heap_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.align_ = from._impl_.align_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IonCpSecureBufferStartFtraceEvent::CopyFrom(const IonCpSecureBufferStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonCpSecureBufferStartFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonCpSecureBufferStartFtraceEvent::IsInitialized() const {
  return true;
}

void IonCpSecureBufferStartFtraceEvent::InternalSwap(IonCpSecureBufferStartFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.heap_name_, lhs_arena,
      &other->_impl_.heap_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IonCpSecureBufferStartFtraceEvent, _impl_.len_)
      + sizeof(IonCpSecureBufferStartFtraceEvent::_impl_.len_)
      - PROTOBUF_FIELD_OFFSET(IonCpSecureBufferStartFtraceEvent, _impl_.align_)>(
          reinterpret_cast<char*>(&_impl_.align_),
          reinterpret_cast<char*>(&other->_impl_.align_));
}

std::string IonCpSecureBufferStartFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IonCpSecureBufferStartFtraceEvent";
}


// ===================================================================

class IonPrefetchingFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonPrefetchingFtraceEvent>()._impl_._has_bits_);
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

IonPrefetchingFtraceEvent::IonPrefetchingFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IonPrefetchingFtraceEvent)
}
IonPrefetchingFtraceEvent::IonPrefetchingFtraceEvent(const IonPrefetchingFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IonPrefetchingFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.len_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.len_ = from._impl_.len_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonPrefetchingFtraceEvent)
}

inline void IonPrefetchingFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.len_){uint64_t{0u}}
  };
}

IonPrefetchingFtraceEvent::~IonPrefetchingFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonPrefetchingFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IonPrefetchingFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void IonPrefetchingFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IonPrefetchingFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonPrefetchingFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.len_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IonPrefetchingFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 len = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IonPrefetchingFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IonPrefetchingFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 len = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IonPrefetchingFtraceEvent)
  return target;
}

size_t IonPrefetchingFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonPrefetchingFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 len = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_len());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IonPrefetchingFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IonPrefetchingFtraceEvent*>(
      &from));
}

void IonPrefetchingFtraceEvent::MergeFrom(const IonPrefetchingFtraceEvent& from) {
  IonPrefetchingFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonPrefetchingFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_len()) {
    _this->_internal_set_len(from._internal_len());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IonPrefetchingFtraceEvent::CopyFrom(const IonPrefetchingFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonPrefetchingFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonPrefetchingFtraceEvent::IsInitialized() const {
  return true;
}

void IonPrefetchingFtraceEvent::InternalSwap(IonPrefetchingFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.len_, other->_impl_.len_);
}

std::string IonPrefetchingFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IonPrefetchingFtraceEvent";
}


// ===================================================================

class IonSecureCmaAddToPoolEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonSecureCmaAddToPoolEndFtraceEvent>()._impl_._has_bits_);
  static void set_has_is_prefetch(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pool_total(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

IonSecureCmaAddToPoolEndFtraceEvent::IonSecureCmaAddToPoolEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent)
}
IonSecureCmaAddToPoolEndFtraceEvent::IonSecureCmaAddToPoolEndFtraceEvent(const IonSecureCmaAddToPoolEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IonSecureCmaAddToPoolEndFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.len_){}
    , decltype(_impl_.is_prefetch_){}
    , decltype(_impl_.pool_total_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.len_, &from._impl_.len_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.pool_total_) -
    reinterpret_cast<char*>(&_impl_.len_)) + sizeof(_impl_.pool_total_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent)
}

inline void IonSecureCmaAddToPoolEndFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.len_){uint64_t{0u}}
    , decltype(_impl_.is_prefetch_){0u}
    , decltype(_impl_.pool_total_){0}
  };
}

IonSecureCmaAddToPoolEndFtraceEvent::~IonSecureCmaAddToPoolEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IonSecureCmaAddToPoolEndFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void IonSecureCmaAddToPoolEndFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IonSecureCmaAddToPoolEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.len_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.pool_total_) -
        reinterpret_cast<char*>(&_impl_.len_)) + sizeof(_impl_.pool_total_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IonSecureCmaAddToPoolEndFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 is_prefetch = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_is_prefetch(&has_bits);
          _impl_.is_prefetch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 len = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 pool_total = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_pool_total(&has_bits);
          _impl_.pool_total_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IonSecureCmaAddToPoolEndFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 is_prefetch = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_is_prefetch(), target);
  }

  // optional uint64 len = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_len(), target);
  }

  // optional int32 pool_total = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_pool_total(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent)
  return target;
}

size_t IonSecureCmaAddToPoolEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 len = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_len());
    }

    // optional uint32 is_prefetch = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_is_prefetch());
    }

    // optional int32 pool_total = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pool_total());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IonSecureCmaAddToPoolEndFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IonSecureCmaAddToPoolEndFtraceEvent*>(
      &from));
}

void IonSecureCmaAddToPoolEndFtraceEvent::MergeFrom(const IonSecureCmaAddToPoolEndFtraceEvent& from) {
  IonSecureCmaAddToPoolEndFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.is_prefetch_ = from._impl_.is_prefetch_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pool_total_ = from._impl_.pool_total_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IonSecureCmaAddToPoolEndFtraceEvent::CopyFrom(const IonSecureCmaAddToPoolEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonSecureCmaAddToPoolEndFtraceEvent::IsInitialized() const {
  return true;
}

void IonSecureCmaAddToPoolEndFtraceEvent::InternalSwap(IonSecureCmaAddToPoolEndFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IonSecureCmaAddToPoolEndFtraceEvent, _impl_.pool_total_)
      + sizeof(IonSecureCmaAddToPoolEndFtraceEvent::_impl_.pool_total_)
      - PROTOBUF_FIELD_OFFSET(IonSecureCmaAddToPoolEndFtraceEvent, _impl_.len_)>(
          reinterpret_cast<char*>(&_impl_.len_),
          reinterpret_cast<char*>(&other->_impl_.len_));
}

std::string IonSecureCmaAddToPoolEndFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IonSecureCmaAddToPoolEndFtraceEvent";
}


// ===================================================================

class IonSecureCmaAddToPoolStartFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonSecureCmaAddToPoolStartFtraceEvent>()._impl_._has_bits_);
  static void set_has_is_prefetch(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pool_total(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

IonSecureCmaAddToPoolStartFtraceEvent::IonSecureCmaAddToPoolStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent)
}
IonSecureCmaAddToPoolStartFtraceEvent::IonSecureCmaAddToPoolStartFtraceEvent(const IonSecureCmaAddToPoolStartFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IonSecureCmaAddToPoolStartFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.len_){}
    , decltype(_impl_.is_prefetch_){}
    , decltype(_impl_.pool_total_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.len_, &from._impl_.len_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.pool_total_) -
    reinterpret_cast<char*>(&_impl_.len_)) + sizeof(_impl_.pool_total_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent)
}

inline void IonSecureCmaAddToPoolStartFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.len_){uint64_t{0u}}
    , decltype(_impl_.is_prefetch_){0u}
    , decltype(_impl_.pool_total_){0}
  };
}

IonSecureCmaAddToPoolStartFtraceEvent::~IonSecureCmaAddToPoolStartFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IonSecureCmaAddToPoolStartFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void IonSecureCmaAddToPoolStartFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IonSecureCmaAddToPoolStartFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.len_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.pool_total_) -
        reinterpret_cast<char*>(&_impl_.len_)) + sizeof(_impl_.pool_total_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IonSecureCmaAddToPoolStartFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 is_prefetch = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_is_prefetch(&has_bits);
          _impl_.is_prefetch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 len = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 pool_total = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_pool_total(&has_bits);
          _impl_.pool_total_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IonSecureCmaAddToPoolStartFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 is_prefetch = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_is_prefetch(), target);
  }

  // optional uint64 len = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_len(), target);
  }

  // optional int32 pool_total = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_pool_total(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent)
  return target;
}

size_t IonSecureCmaAddToPoolStartFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 len = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_len());
    }

    // optional uint32 is_prefetch = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_is_prefetch());
    }

    // optional int32 pool_total = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pool_total());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IonSecureCmaAddToPoolStartFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IonSecureCmaAddToPoolStartFtraceEvent*>(
      &from));
}

void IonSecureCmaAddToPoolStartFtraceEvent::MergeFrom(const IonSecureCmaAddToPoolStartFtraceEvent& from) {
  IonSecureCmaAddToPoolStartFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.is_prefetch_ = from._impl_.is_prefetch_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pool_total_ = from._impl_.pool_total_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IonSecureCmaAddToPoolStartFtraceEvent::CopyFrom(const IonSecureCmaAddToPoolStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonSecureCmaAddToPoolStartFtraceEvent::IsInitialized() const {
  return true;
}

void IonSecureCmaAddToPoolStartFtraceEvent::InternalSwap(IonSecureCmaAddToPoolStartFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IonSecureCmaAddToPoolStartFtraceEvent, _impl_.pool_total_)
      + sizeof(IonSecureCmaAddToPoolStartFtraceEvent::_impl_.pool_total_)
      - PROTOBUF_FIELD_OFFSET(IonSecureCmaAddToPoolStartFtraceEvent, _impl_.len_)>(
          reinterpret_cast<char*>(&_impl_.len_),
          reinterpret_cast<char*>(&other->_impl_.len_));
}

std::string IonSecureCmaAddToPoolStartFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IonSecureCmaAddToPoolStartFtraceEvent";
}


// ===================================================================

class IonSecureCmaAllocateEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonSecureCmaAllocateEndFtraceEvent>()._impl_._has_bits_);
  static void set_has_align(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_heap_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

IonSecureCmaAllocateEndFtraceEvent::IonSecureCmaAllocateEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent)
}
IonSecureCmaAllocateEndFtraceEvent::IonSecureCmaAllocateEndFtraceEvent(const IonSecureCmaAllocateEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IonSecureCmaAllocateEndFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.heap_name_){}
    , decltype(_impl_.align_){}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.len_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_heap_name()) {
    _this->_impl_.heap_name_.Set(from._internal_heap_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.align_, &from._impl_.align_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.len_) -
    reinterpret_cast<char*>(&_impl_.align_)) + sizeof(_impl_.len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent)
}

inline void IonSecureCmaAllocateEndFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.heap_name_){}
    , decltype(_impl_.align_){uint64_t{0u}}
    , decltype(_impl_.flags_){uint64_t{0u}}
    , decltype(_impl_.len_){uint64_t{0u}}
  };
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IonSecureCmaAllocateEndFtraceEvent::~IonSecureCmaAllocateEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IonSecureCmaAllocateEndFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.heap_name_.Destroy();
}

void IonSecureCmaAllocateEndFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IonSecureCmaAllocateEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.heap_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.align_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.len_) -
        reinterpret_cast<char*>(&_impl_.align_)) + sizeof(_impl_.len_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IonSecureCmaAllocateEndFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 align = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_align(&has_bits);
          _impl_.align_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 flags = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string heap_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_heap_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IonSecureCmaAllocateEndFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 align = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_align(), target);
  }

  // optional uint64 flags = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_flags(), target);
  }

  // optional string heap_name = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_heap_name(), target);
  }

  // optional uint64 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent)
  return target;
}

size_t IonSecureCmaAllocateEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string heap_name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_heap_name());
    }

    // optional uint64 align = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_align());
    }

    // optional uint64 flags = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_flags());
    }

    // optional uint64 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_len());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IonSecureCmaAllocateEndFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IonSecureCmaAllocateEndFtraceEvent*>(
      &from));
}

void IonSecureCmaAllocateEndFtraceEvent::MergeFrom(const IonSecureCmaAllocateEndFtraceEvent& from) {
  IonSecureCmaAllocateEndFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_heap_name(from._internal_heap_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.align_ = from._impl_.align_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IonSecureCmaAllocateEndFtraceEvent::CopyFrom(const IonSecureCmaAllocateEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonSecureCmaAllocateEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonSecureCmaAllocateEndFtraceEvent::IsInitialized() const {
  return true;
}

void IonSecureCmaAllocateEndFtraceEvent::InternalSwap(IonSecureCmaAllocateEndFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.heap_name_, lhs_arena,
      &other->_impl_.heap_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IonSecureCmaAllocateEndFtraceEvent, _impl_.len_)
      + sizeof(IonSecureCmaAllocateEndFtraceEvent::_impl_.len_)
      - PROTOBUF_FIELD_OFFSET(IonSecureCmaAllocateEndFtraceEvent, _impl_.align_)>(
          reinterpret_cast<char*>(&_impl_.align_),
          reinterpret_cast<char*>(&other->_impl_.align_));
}

std::string IonSecureCmaAllocateEndFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IonSecureCmaAllocateEndFtraceEvent";
}


// ===================================================================

class IonSecureCmaAllocateStartFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonSecureCmaAllocateStartFtraceEvent>()._impl_._has_bits_);
  static void set_has_align(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_heap_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

IonSecureCmaAllocateStartFtraceEvent::IonSecureCmaAllocateStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent)
}
IonSecureCmaAllocateStartFtraceEvent::IonSecureCmaAllocateStartFtraceEvent(const IonSecureCmaAllocateStartFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IonSecureCmaAllocateStartFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.heap_name_){}
    , decltype(_impl_.align_){}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.len_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_heap_name()) {
    _this->_impl_.heap_name_.Set(from._internal_heap_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.align_, &from._impl_.align_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.len_) -
    reinterpret_cast<char*>(&_impl_.align_)) + sizeof(_impl_.len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent)
}

inline void IonSecureCmaAllocateStartFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.heap_name_){}
    , decltype(_impl_.align_){uint64_t{0u}}
    , decltype(_impl_.flags_){uint64_t{0u}}
    , decltype(_impl_.len_){uint64_t{0u}}
  };
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IonSecureCmaAllocateStartFtraceEvent::~IonSecureCmaAllocateStartFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IonSecureCmaAllocateStartFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.heap_name_.Destroy();
}

void IonSecureCmaAllocateStartFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IonSecureCmaAllocateStartFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.heap_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.align_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.len_) -
        reinterpret_cast<char*>(&_impl_.align_)) + sizeof(_impl_.len_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IonSecureCmaAllocateStartFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 align = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_align(&has_bits);
          _impl_.align_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 flags = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string heap_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_heap_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IonSecureCmaAllocateStartFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 align = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_align(), target);
  }

  // optional uint64 flags = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_flags(), target);
  }

  // optional string heap_name = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_heap_name(), target);
  }

  // optional uint64 len = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent)
  return target;
}

size_t IonSecureCmaAllocateStartFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string heap_name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_heap_name());
    }

    // optional uint64 align = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_align());
    }

    // optional uint64 flags = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_flags());
    }

    // optional uint64 len = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_len());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IonSecureCmaAllocateStartFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IonSecureCmaAllocateStartFtraceEvent*>(
      &from));
}

void IonSecureCmaAllocateStartFtraceEvent::MergeFrom(const IonSecureCmaAllocateStartFtraceEvent& from) {
  IonSecureCmaAllocateStartFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_heap_name(from._internal_heap_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.align_ = from._impl_.align_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IonSecureCmaAllocateStartFtraceEvent::CopyFrom(const IonSecureCmaAllocateStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonSecureCmaAllocateStartFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonSecureCmaAllocateStartFtraceEvent::IsInitialized() const {
  return true;
}

void IonSecureCmaAllocateStartFtraceEvent::InternalSwap(IonSecureCmaAllocateStartFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.heap_name_, lhs_arena,
      &other->_impl_.heap_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IonSecureCmaAllocateStartFtraceEvent, _impl_.len_)
      + sizeof(IonSecureCmaAllocateStartFtraceEvent::_impl_.len_)
      - PROTOBUF_FIELD_OFFSET(IonSecureCmaAllocateStartFtraceEvent, _impl_.align_)>(
          reinterpret_cast<char*>(&_impl_.align_),
          reinterpret_cast<char*>(&other->_impl_.align_));
}

std::string IonSecureCmaAllocateStartFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IonSecureCmaAllocateStartFtraceEvent";
}


// ===================================================================

class IonSecureCmaShrinkPoolEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonSecureCmaShrinkPoolEndFtraceEvent>()._impl_._has_bits_);
  static void set_has_drained_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_skipped_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

IonSecureCmaShrinkPoolEndFtraceEvent::IonSecureCmaShrinkPoolEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent)
}
IonSecureCmaShrinkPoolEndFtraceEvent::IonSecureCmaShrinkPoolEndFtraceEvent(const IonSecureCmaShrinkPoolEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IonSecureCmaShrinkPoolEndFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.drained_size_){}
    , decltype(_impl_.skipped_size_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.drained_size_, &from._impl_.drained_size_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.skipped_size_) -
    reinterpret_cast<char*>(&_impl_.drained_size_)) + sizeof(_impl_.skipped_size_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent)
}

inline void IonSecureCmaShrinkPoolEndFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.drained_size_){uint64_t{0u}}
    , decltype(_impl_.skipped_size_){uint64_t{0u}}
  };
}

IonSecureCmaShrinkPoolEndFtraceEvent::~IonSecureCmaShrinkPoolEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IonSecureCmaShrinkPoolEndFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void IonSecureCmaShrinkPoolEndFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IonSecureCmaShrinkPoolEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.drained_size_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.skipped_size_) -
        reinterpret_cast<char*>(&_impl_.drained_size_)) + sizeof(_impl_.skipped_size_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IonSecureCmaShrinkPoolEndFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 drained_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_drained_size(&has_bits);
          _impl_.drained_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 skipped_size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_skipped_size(&has_bits);
          _impl_.skipped_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IonSecureCmaShrinkPoolEndFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 drained_size = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_drained_size(), target);
  }

  // optional uint64 skipped_size = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_skipped_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent)
  return target;
}

size_t IonSecureCmaShrinkPoolEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 drained_size = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_drained_size());
    }

    // optional uint64 skipped_size = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_skipped_size());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IonSecureCmaShrinkPoolEndFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IonSecureCmaShrinkPoolEndFtraceEvent*>(
      &from));
}

void IonSecureCmaShrinkPoolEndFtraceEvent::MergeFrom(const IonSecureCmaShrinkPoolEndFtraceEvent& from) {
  IonSecureCmaShrinkPoolEndFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.drained_size_ = from._impl_.drained_size_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.skipped_size_ = from._impl_.skipped_size_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IonSecureCmaShrinkPoolEndFtraceEvent::CopyFrom(const IonSecureCmaShrinkPoolEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonSecureCmaShrinkPoolEndFtraceEvent::IsInitialized() const {
  return true;
}

void IonSecureCmaShrinkPoolEndFtraceEvent::InternalSwap(IonSecureCmaShrinkPoolEndFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IonSecureCmaShrinkPoolEndFtraceEvent, _impl_.skipped_size_)
      + sizeof(IonSecureCmaShrinkPoolEndFtraceEvent::_impl_.skipped_size_)
      - PROTOBUF_FIELD_OFFSET(IonSecureCmaShrinkPoolEndFtraceEvent, _impl_.drained_size_)>(
          reinterpret_cast<char*>(&_impl_.drained_size_),
          reinterpret_cast<char*>(&other->_impl_.drained_size_));
}

std::string IonSecureCmaShrinkPoolEndFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IonSecureCmaShrinkPoolEndFtraceEvent";
}


// ===================================================================

class IonSecureCmaShrinkPoolStartFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonSecureCmaShrinkPoolStartFtraceEvent>()._impl_._has_bits_);
  static void set_has_drained_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_skipped_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

IonSecureCmaShrinkPoolStartFtraceEvent::IonSecureCmaShrinkPoolStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent)
}
IonSecureCmaShrinkPoolStartFtraceEvent::IonSecureCmaShrinkPoolStartFtraceEvent(const IonSecureCmaShrinkPoolStartFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IonSecureCmaShrinkPoolStartFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.drained_size_){}
    , decltype(_impl_.skipped_size_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.drained_size_, &from._impl_.drained_size_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.skipped_size_) -
    reinterpret_cast<char*>(&_impl_.drained_size_)) + sizeof(_impl_.skipped_size_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent)
}

inline void IonSecureCmaShrinkPoolStartFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.drained_size_){uint64_t{0u}}
    , decltype(_impl_.skipped_size_){uint64_t{0u}}
  };
}

IonSecureCmaShrinkPoolStartFtraceEvent::~IonSecureCmaShrinkPoolStartFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IonSecureCmaShrinkPoolStartFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void IonSecureCmaShrinkPoolStartFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IonSecureCmaShrinkPoolStartFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.drained_size_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.skipped_size_) -
        reinterpret_cast<char*>(&_impl_.drained_size_)) + sizeof(_impl_.skipped_size_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IonSecureCmaShrinkPoolStartFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 drained_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_drained_size(&has_bits);
          _impl_.drained_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 skipped_size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_skipped_size(&has_bits);
          _impl_.skipped_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IonSecureCmaShrinkPoolStartFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 drained_size = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_drained_size(), target);
  }

  // optional uint64 skipped_size = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_skipped_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent)
  return target;
}

size_t IonSecureCmaShrinkPoolStartFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 drained_size = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_drained_size());
    }

    // optional uint64 skipped_size = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_skipped_size());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IonSecureCmaShrinkPoolStartFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IonSecureCmaShrinkPoolStartFtraceEvent*>(
      &from));
}

void IonSecureCmaShrinkPoolStartFtraceEvent::MergeFrom(const IonSecureCmaShrinkPoolStartFtraceEvent& from) {
  IonSecureCmaShrinkPoolStartFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.drained_size_ = from._impl_.drained_size_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.skipped_size_ = from._impl_.skipped_size_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IonSecureCmaShrinkPoolStartFtraceEvent::CopyFrom(const IonSecureCmaShrinkPoolStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonSecureCmaShrinkPoolStartFtraceEvent::IsInitialized() const {
  return true;
}

void IonSecureCmaShrinkPoolStartFtraceEvent::InternalSwap(IonSecureCmaShrinkPoolStartFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IonSecureCmaShrinkPoolStartFtraceEvent, _impl_.skipped_size_)
      + sizeof(IonSecureCmaShrinkPoolStartFtraceEvent::_impl_.skipped_size_)
      - PROTOBUF_FIELD_OFFSET(IonSecureCmaShrinkPoolStartFtraceEvent, _impl_.drained_size_)>(
          reinterpret_cast<char*>(&_impl_.drained_size_),
          reinterpret_cast<char*>(&other->_impl_.drained_size_));
}

std::string IonSecureCmaShrinkPoolStartFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IonSecureCmaShrinkPoolStartFtraceEvent";
}


// ===================================================================

class KfreeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KfreeFtraceEvent>()._impl_._has_bits_);
  static void set_has_call_site(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ptr(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

KfreeFtraceEvent::KfreeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KfreeFtraceEvent)
}
KfreeFtraceEvent::KfreeFtraceEvent(const KfreeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KfreeFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.call_site_){}
    , decltype(_impl_.ptr_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.call_site_, &from._impl_.call_site_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ptr_) -
    reinterpret_cast<char*>(&_impl_.call_site_)) + sizeof(_impl_.ptr_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KfreeFtraceEvent)
}

inline void KfreeFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.call_site_){uint64_t{0u}}
    , decltype(_impl_.ptr_){uint64_t{0u}}
  };
}

KfreeFtraceEvent::~KfreeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KfreeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KfreeFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KfreeFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KfreeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KfreeFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.call_site_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ptr_) -
        reinterpret_cast<char*>(&_impl_.call_site_)) + sizeof(_impl_.ptr_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KfreeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 call_site = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_call_site(&has_bits);
          _impl_.call_site_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ptr = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ptr(&has_bits);
          _impl_.ptr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KfreeFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KfreeFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 call_site = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_call_site(), target);
  }

  // optional uint64 ptr = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ptr(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KfreeFtraceEvent)
  return target;
}

size_t KfreeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KfreeFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 call_site = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_call_site());
    }

    // optional uint64 ptr = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ptr());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KfreeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KfreeFtraceEvent*>(
      &from));
}

void KfreeFtraceEvent::MergeFrom(const KfreeFtraceEvent& from) {
  KfreeFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KfreeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.call_site_ = from._impl_.call_site_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ptr_ = from._impl_.ptr_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KfreeFtraceEvent::CopyFrom(const KfreeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KfreeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KfreeFtraceEvent::IsInitialized() const {
  return true;
}

void KfreeFtraceEvent::InternalSwap(KfreeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KfreeFtraceEvent, _impl_.ptr_)
      + sizeof(KfreeFtraceEvent::_impl_.ptr_)
      - PROTOBUF_FIELD_OFFSET(KfreeFtraceEvent, _impl_.call_site_)>(
          reinterpret_cast<char*>(&_impl_.call_site_),
          reinterpret_cast<char*>(&other->_impl_.call_site_));
}

std::string KfreeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KfreeFtraceEvent";
}


// ===================================================================

class KmallocFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KmallocFtraceEvent>()._impl_._has_bits_);
  static void set_has_bytes_alloc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bytes_req(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_call_site(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gfp_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ptr(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

KmallocFtraceEvent::KmallocFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KmallocFtraceEvent)
}
KmallocFtraceEvent::KmallocFtraceEvent(const KmallocFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KmallocFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bytes_alloc_){}
    , decltype(_impl_.bytes_req_){}
    , decltype(_impl_.call_site_){}
    , decltype(_impl_.ptr_){}
    , decltype(_impl_.gfp_flags_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.bytes_alloc_, &from._impl_.bytes_alloc_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.gfp_flags_) -
    reinterpret_cast<char*>(&_impl_.bytes_alloc_)) + sizeof(_impl_.gfp_flags_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KmallocFtraceEvent)
}

inline void KmallocFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bytes_alloc_){uint64_t{0u}}
    , decltype(_impl_.bytes_req_){uint64_t{0u}}
    , decltype(_impl_.call_site_){uint64_t{0u}}
    , decltype(_impl_.ptr_){uint64_t{0u}}
    , decltype(_impl_.gfp_flags_){0u}
  };
}

KmallocFtraceEvent::~KmallocFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KmallocFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KmallocFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KmallocFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KmallocFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KmallocFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.bytes_alloc_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.gfp_flags_) -
        reinterpret_cast<char*>(&_impl_.bytes_alloc_)) + sizeof(_impl_.gfp_flags_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KmallocFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 bytes_alloc = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_bytes_alloc(&has_bits);
          _impl_.bytes_alloc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 bytes_req = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_bytes_req(&has_bits);
          _impl_.bytes_req_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 call_site = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_call_site(&has_bits);
          _impl_.call_site_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gfp_flags = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_gfp_flags(&has_bits);
          _impl_.gfp_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ptr = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_ptr(&has_bits);
          _impl_.ptr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KmallocFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KmallocFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 bytes_alloc = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_bytes_alloc(), target);
  }

  // optional uint64 bytes_req = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_bytes_req(), target);
  }

  // optional uint64 call_site = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_call_site(), target);
  }

  // optional uint32 gfp_flags = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_gfp_flags(), target);
  }

  // optional uint64 ptr = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_ptr(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KmallocFtraceEvent)
  return target;
}

size_t KmallocFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KmallocFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 bytes_alloc = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_bytes_alloc());
    }

    // optional uint64 bytes_req = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_bytes_req());
    }

    // optional uint64 call_site = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_call_site());
    }

    // optional uint64 ptr = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ptr());
    }

    // optional uint32 gfp_flags = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gfp_flags());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KmallocFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KmallocFtraceEvent*>(
      &from));
}

void KmallocFtraceEvent::MergeFrom(const KmallocFtraceEvent& from) {
  KmallocFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KmallocFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.bytes_alloc_ = from._impl_.bytes_alloc_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.bytes_req_ = from._impl_.bytes_req_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.call_site_ = from._impl_.call_site_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.ptr_ = from._impl_.ptr_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.gfp_flags_ = from._impl_.gfp_flags_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KmallocFtraceEvent::CopyFrom(const KmallocFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KmallocFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KmallocFtraceEvent::IsInitialized() const {
  return true;
}

void KmallocFtraceEvent::InternalSwap(KmallocFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KmallocFtraceEvent, _impl_.gfp_flags_)
      + sizeof(KmallocFtraceEvent::_impl_.gfp_flags_)
      - PROTOBUF_FIELD_OFFSET(KmallocFtraceEvent, _impl_.bytes_alloc_)>(
          reinterpret_cast<char*>(&_impl_.bytes_alloc_),
          reinterpret_cast<char*>(&other->_impl_.bytes_alloc_));
}

std::string KmallocFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KmallocFtraceEvent";
}


// ===================================================================

class KmallocNodeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KmallocNodeFtraceEvent>()._impl_._has_bits_);
  static void set_has_bytes_alloc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bytes_req(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_call_site(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gfp_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_node(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ptr(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

KmallocNodeFtraceEvent::KmallocNodeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KmallocNodeFtraceEvent)
}
KmallocNodeFtraceEvent::KmallocNodeFtraceEvent(const KmallocNodeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KmallocNodeFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bytes_alloc_){}
    , decltype(_impl_.bytes_req_){}
    , decltype(_impl_.call_site_){}
    , decltype(_impl_.gfp_flags_){}
    , decltype(_impl_.node_){}
    , decltype(_impl_.ptr_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.bytes_alloc_, &from._impl_.bytes_alloc_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ptr_) -
    reinterpret_cast<char*>(&_impl_.bytes_alloc_)) + sizeof(_impl_.ptr_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KmallocNodeFtraceEvent)
}

inline void KmallocNodeFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bytes_alloc_){uint64_t{0u}}
    , decltype(_impl_.bytes_req_){uint64_t{0u}}
    , decltype(_impl_.call_site_){uint64_t{0u}}
    , decltype(_impl_.gfp_flags_){0u}
    , decltype(_impl_.node_){0}
    , decltype(_impl_.ptr_){uint64_t{0u}}
  };
}

KmallocNodeFtraceEvent::~KmallocNodeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KmallocNodeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KmallocNodeFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KmallocNodeFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KmallocNodeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KmallocNodeFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.bytes_alloc_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ptr_) -
        reinterpret_cast<char*>(&_impl_.bytes_alloc_)) + sizeof(_impl_.ptr_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KmallocNodeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 bytes_alloc = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_bytes_alloc(&has_bits);
          _impl_.bytes_alloc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 bytes_req = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_bytes_req(&has_bits);
          _impl_.bytes_req_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 call_site = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_call_site(&has_bits);
          _impl_.call_site_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gfp_flags = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_gfp_flags(&has_bits);
          _impl_.gfp_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 node = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_node(&has_bits);
          _impl_.node_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ptr = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_ptr(&has_bits);
          _impl_.ptr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KmallocNodeFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KmallocNodeFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 bytes_alloc = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_bytes_alloc(), target);
  }

  // optional uint64 bytes_req = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_bytes_req(), target);
  }

  // optional uint64 call_site = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_call_site(), target);
  }

  // optional uint32 gfp_flags = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_gfp_flags(), target);
  }

  // optional int32 node = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_node(), target);
  }

  // optional uint64 ptr = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_ptr(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KmallocNodeFtraceEvent)
  return target;
}

size_t KmallocNodeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KmallocNodeFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 bytes_alloc = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_bytes_alloc());
    }

    // optional uint64 bytes_req = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_bytes_req());
    }

    // optional uint64 call_site = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_call_site());
    }

    // optional uint32 gfp_flags = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gfp_flags());
    }

    // optional int32 node = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_node());
    }

    // optional uint64 ptr = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ptr());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KmallocNodeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KmallocNodeFtraceEvent*>(
      &from));
}

void KmallocNodeFtraceEvent::MergeFrom(const KmallocNodeFtraceEvent& from) {
  KmallocNodeFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KmallocNodeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.bytes_alloc_ = from._impl_.bytes_alloc_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.bytes_req_ = from._impl_.bytes_req_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.call_site_ = from._impl_.call_site_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.gfp_flags_ = from._impl_.gfp_flags_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.node_ = from._impl_.node_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.ptr_ = from._impl_.ptr_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KmallocNodeFtraceEvent::CopyFrom(const KmallocNodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KmallocNodeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KmallocNodeFtraceEvent::IsInitialized() const {
  return true;
}

void KmallocNodeFtraceEvent::InternalSwap(KmallocNodeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KmallocNodeFtraceEvent, _impl_.ptr_)
      + sizeof(KmallocNodeFtraceEvent::_impl_.ptr_)
      - PROTOBUF_FIELD_OFFSET(KmallocNodeFtraceEvent, _impl_.bytes_alloc_)>(
          reinterpret_cast<char*>(&_impl_.bytes_alloc_),
          reinterpret_cast<char*>(&other->_impl_.bytes_alloc_));
}

std::string KmallocNodeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KmallocNodeFtraceEvent";
}


// ===================================================================

class KmemCacheAllocFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KmemCacheAllocFtraceEvent>()._impl_._has_bits_);
  static void set_has_bytes_alloc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bytes_req(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_call_site(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gfp_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ptr(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

KmemCacheAllocFtraceEvent::KmemCacheAllocFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KmemCacheAllocFtraceEvent)
}
KmemCacheAllocFtraceEvent::KmemCacheAllocFtraceEvent(const KmemCacheAllocFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KmemCacheAllocFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bytes_alloc_){}
    , decltype(_impl_.bytes_req_){}
    , decltype(_impl_.call_site_){}
    , decltype(_impl_.ptr_){}
    , decltype(_impl_.gfp_flags_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.bytes_alloc_, &from._impl_.bytes_alloc_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.gfp_flags_) -
    reinterpret_cast<char*>(&_impl_.bytes_alloc_)) + sizeof(_impl_.gfp_flags_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KmemCacheAllocFtraceEvent)
}

inline void KmemCacheAllocFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bytes_alloc_){uint64_t{0u}}
    , decltype(_impl_.bytes_req_){uint64_t{0u}}
    , decltype(_impl_.call_site_){uint64_t{0u}}
    , decltype(_impl_.ptr_){uint64_t{0u}}
    , decltype(_impl_.gfp_flags_){0u}
  };
}

KmemCacheAllocFtraceEvent::~KmemCacheAllocFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KmemCacheAllocFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KmemCacheAllocFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KmemCacheAllocFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KmemCacheAllocFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KmemCacheAllocFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.bytes_alloc_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.gfp_flags_) -
        reinterpret_cast<char*>(&_impl_.bytes_alloc_)) + sizeof(_impl_.gfp_flags_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KmemCacheAllocFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 bytes_alloc = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_bytes_alloc(&has_bits);
          _impl_.bytes_alloc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 bytes_req = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_bytes_req(&has_bits);
          _impl_.bytes_req_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 call_site = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_call_site(&has_bits);
          _impl_.call_site_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gfp_flags = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_gfp_flags(&has_bits);
          _impl_.gfp_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ptr = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_ptr(&has_bits);
          _impl_.ptr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KmemCacheAllocFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KmemCacheAllocFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 bytes_alloc = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_bytes_alloc(), target);
  }

  // optional uint64 bytes_req = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_bytes_req(), target);
  }

  // optional uint64 call_site = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_call_site(), target);
  }

  // optional uint32 gfp_flags = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_gfp_flags(), target);
  }

  // optional uint64 ptr = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_ptr(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KmemCacheAllocFtraceEvent)
  return target;
}

size_t KmemCacheAllocFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KmemCacheAllocFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 bytes_alloc = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_bytes_alloc());
    }

    // optional uint64 bytes_req = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_bytes_req());
    }

    // optional uint64 call_site = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_call_site());
    }

    // optional uint64 ptr = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ptr());
    }

    // optional uint32 gfp_flags = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gfp_flags());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KmemCacheAllocFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KmemCacheAllocFtraceEvent*>(
      &from));
}

void KmemCacheAllocFtraceEvent::MergeFrom(const KmemCacheAllocFtraceEvent& from) {
  KmemCacheAllocFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KmemCacheAllocFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.bytes_alloc_ = from._impl_.bytes_alloc_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.bytes_req_ = from._impl_.bytes_req_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.call_site_ = from._impl_.call_site_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.ptr_ = from._impl_.ptr_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.gfp_flags_ = from._impl_.gfp_flags_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KmemCacheAllocFtraceEvent::CopyFrom(const KmemCacheAllocFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KmemCacheAllocFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KmemCacheAllocFtraceEvent::IsInitialized() const {
  return true;
}

void KmemCacheAllocFtraceEvent::InternalSwap(KmemCacheAllocFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KmemCacheAllocFtraceEvent, _impl_.gfp_flags_)
      + sizeof(KmemCacheAllocFtraceEvent::_impl_.gfp_flags_)
      - PROTOBUF_FIELD_OFFSET(KmemCacheAllocFtraceEvent, _impl_.bytes_alloc_)>(
          reinterpret_cast<char*>(&_impl_.bytes_alloc_),
          reinterpret_cast<char*>(&other->_impl_.bytes_alloc_));
}

std::string KmemCacheAllocFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KmemCacheAllocFtraceEvent";
}


// ===================================================================

class KmemCacheAllocNodeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KmemCacheAllocNodeFtraceEvent>()._impl_._has_bits_);
  static void set_has_bytes_alloc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bytes_req(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_call_site(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gfp_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_node(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ptr(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

KmemCacheAllocNodeFtraceEvent::KmemCacheAllocNodeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KmemCacheAllocNodeFtraceEvent)
}
KmemCacheAllocNodeFtraceEvent::KmemCacheAllocNodeFtraceEvent(const KmemCacheAllocNodeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KmemCacheAllocNodeFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bytes_alloc_){}
    , decltype(_impl_.bytes_req_){}
    , decltype(_impl_.call_site_){}
    , decltype(_impl_.gfp_flags_){}
    , decltype(_impl_.node_){}
    , decltype(_impl_.ptr_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.bytes_alloc_, &from._impl_.bytes_alloc_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ptr_) -
    reinterpret_cast<char*>(&_impl_.bytes_alloc_)) + sizeof(_impl_.ptr_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KmemCacheAllocNodeFtraceEvent)
}

inline void KmemCacheAllocNodeFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bytes_alloc_){uint64_t{0u}}
    , decltype(_impl_.bytes_req_){uint64_t{0u}}
    , decltype(_impl_.call_site_){uint64_t{0u}}
    , decltype(_impl_.gfp_flags_){0u}
    , decltype(_impl_.node_){0}
    , decltype(_impl_.ptr_){uint64_t{0u}}
  };
}

KmemCacheAllocNodeFtraceEvent::~KmemCacheAllocNodeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KmemCacheAllocNodeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KmemCacheAllocNodeFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KmemCacheAllocNodeFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KmemCacheAllocNodeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KmemCacheAllocNodeFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.bytes_alloc_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ptr_) -
        reinterpret_cast<char*>(&_impl_.bytes_alloc_)) + sizeof(_impl_.ptr_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KmemCacheAllocNodeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 bytes_alloc = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_bytes_alloc(&has_bits);
          _impl_.bytes_alloc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 bytes_req = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_bytes_req(&has_bits);
          _impl_.bytes_req_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 call_site = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_call_site(&has_bits);
          _impl_.call_site_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gfp_flags = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_gfp_flags(&has_bits);
          _impl_.gfp_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 node = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_node(&has_bits);
          _impl_.node_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ptr = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_ptr(&has_bits);
          _impl_.ptr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KmemCacheAllocNodeFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KmemCacheAllocNodeFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 bytes_alloc = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_bytes_alloc(), target);
  }

  // optional uint64 bytes_req = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_bytes_req(), target);
  }

  // optional uint64 call_site = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_call_site(), target);
  }

  // optional uint32 gfp_flags = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_gfp_flags(), target);
  }

  // optional int32 node = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_node(), target);
  }

  // optional uint64 ptr = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_ptr(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KmemCacheAllocNodeFtraceEvent)
  return target;
}

size_t KmemCacheAllocNodeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KmemCacheAllocNodeFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 bytes_alloc = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_bytes_alloc());
    }

    // optional uint64 bytes_req = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_bytes_req());
    }

    // optional uint64 call_site = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_call_site());
    }

    // optional uint32 gfp_flags = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gfp_flags());
    }

    // optional int32 node = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_node());
    }

    // optional uint64 ptr = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ptr());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KmemCacheAllocNodeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KmemCacheAllocNodeFtraceEvent*>(
      &from));
}

void KmemCacheAllocNodeFtraceEvent::MergeFrom(const KmemCacheAllocNodeFtraceEvent& from) {
  KmemCacheAllocNodeFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KmemCacheAllocNodeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.bytes_alloc_ = from._impl_.bytes_alloc_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.bytes_req_ = from._impl_.bytes_req_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.call_site_ = from._impl_.call_site_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.gfp_flags_ = from._impl_.gfp_flags_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.node_ = from._impl_.node_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.ptr_ = from._impl_.ptr_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KmemCacheAllocNodeFtraceEvent::CopyFrom(const KmemCacheAllocNodeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KmemCacheAllocNodeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KmemCacheAllocNodeFtraceEvent::IsInitialized() const {
  return true;
}

void KmemCacheAllocNodeFtraceEvent::InternalSwap(KmemCacheAllocNodeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KmemCacheAllocNodeFtraceEvent, _impl_.ptr_)
      + sizeof(KmemCacheAllocNodeFtraceEvent::_impl_.ptr_)
      - PROTOBUF_FIELD_OFFSET(KmemCacheAllocNodeFtraceEvent, _impl_.bytes_alloc_)>(
          reinterpret_cast<char*>(&_impl_.bytes_alloc_),
          reinterpret_cast<char*>(&other->_impl_.bytes_alloc_));
}

std::string KmemCacheAllocNodeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KmemCacheAllocNodeFtraceEvent";
}


// ===================================================================

class KmemCacheFreeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KmemCacheFreeFtraceEvent>()._impl_._has_bits_);
  static void set_has_call_site(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ptr(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

KmemCacheFreeFtraceEvent::KmemCacheFreeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.KmemCacheFreeFtraceEvent)
}
KmemCacheFreeFtraceEvent::KmemCacheFreeFtraceEvent(const KmemCacheFreeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KmemCacheFreeFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.call_site_){}
    , decltype(_impl_.ptr_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.call_site_, &from._impl_.call_site_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ptr_) -
    reinterpret_cast<char*>(&_impl_.call_site_)) + sizeof(_impl_.ptr_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.KmemCacheFreeFtraceEvent)
}

inline void KmemCacheFreeFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.call_site_){uint64_t{0u}}
    , decltype(_impl_.ptr_){uint64_t{0u}}
  };
}

KmemCacheFreeFtraceEvent::~KmemCacheFreeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.KmemCacheFreeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KmemCacheFreeFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KmemCacheFreeFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KmemCacheFreeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.KmemCacheFreeFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.call_site_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ptr_) -
        reinterpret_cast<char*>(&_impl_.call_site_)) + sizeof(_impl_.ptr_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KmemCacheFreeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 call_site = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_call_site(&has_bits);
          _impl_.call_site_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ptr = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ptr(&has_bits);
          _impl_.ptr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KmemCacheFreeFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.KmemCacheFreeFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 call_site = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_call_site(), target);
  }

  // optional uint64 ptr = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ptr(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.KmemCacheFreeFtraceEvent)
  return target;
}

size_t KmemCacheFreeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.KmemCacheFreeFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 call_site = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_call_site());
    }

    // optional uint64 ptr = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ptr());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KmemCacheFreeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KmemCacheFreeFtraceEvent*>(
      &from));
}

void KmemCacheFreeFtraceEvent::MergeFrom(const KmemCacheFreeFtraceEvent& from) {
  KmemCacheFreeFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.KmemCacheFreeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.call_site_ = from._impl_.call_site_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ptr_ = from._impl_.ptr_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KmemCacheFreeFtraceEvent::CopyFrom(const KmemCacheFreeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.KmemCacheFreeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KmemCacheFreeFtraceEvent::IsInitialized() const {
  return true;
}

void KmemCacheFreeFtraceEvent::InternalSwap(KmemCacheFreeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KmemCacheFreeFtraceEvent, _impl_.ptr_)
      + sizeof(KmemCacheFreeFtraceEvent::_impl_.ptr_)
      - PROTOBUF_FIELD_OFFSET(KmemCacheFreeFtraceEvent, _impl_.call_site_)>(
          reinterpret_cast<char*>(&_impl_.call_site_),
          reinterpret_cast<char*>(&other->_impl_.call_site_));
}

std::string KmemCacheFreeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.KmemCacheFreeFtraceEvent";
}


// ===================================================================

class MigratePagesEndFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MigratePagesEndFtraceEvent>()._impl_._has_bits_);
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

MigratePagesEndFtraceEvent::MigratePagesEndFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MigratePagesEndFtraceEvent)
}
MigratePagesEndFtraceEvent::MigratePagesEndFtraceEvent(const MigratePagesEndFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MigratePagesEndFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mode_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.mode_ = from._impl_.mode_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MigratePagesEndFtraceEvent)
}

inline void MigratePagesEndFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mode_){0}
  };
}

MigratePagesEndFtraceEvent::~MigratePagesEndFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MigratePagesEndFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MigratePagesEndFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MigratePagesEndFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MigratePagesEndFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MigratePagesEndFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.mode_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MigratePagesEndFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 mode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_mode(&has_bits);
          _impl_.mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MigratePagesEndFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MigratePagesEndFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 mode = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MigratePagesEndFtraceEvent)
  return target;
}

size_t MigratePagesEndFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MigratePagesEndFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 mode = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mode());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MigratePagesEndFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MigratePagesEndFtraceEvent*>(
      &from));
}

void MigratePagesEndFtraceEvent::MergeFrom(const MigratePagesEndFtraceEvent& from) {
  MigratePagesEndFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MigratePagesEndFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_mode()) {
    _this->_internal_set_mode(from._internal_mode());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MigratePagesEndFtraceEvent::CopyFrom(const MigratePagesEndFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MigratePagesEndFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MigratePagesEndFtraceEvent::IsInitialized() const {
  return true;
}

void MigratePagesEndFtraceEvent::InternalSwap(MigratePagesEndFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.mode_, other->_impl_.mode_);
}

std::string MigratePagesEndFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MigratePagesEndFtraceEvent";
}


// ===================================================================

class MigratePagesStartFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MigratePagesStartFtraceEvent>()._impl_._has_bits_);
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

MigratePagesStartFtraceEvent::MigratePagesStartFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MigratePagesStartFtraceEvent)
}
MigratePagesStartFtraceEvent::MigratePagesStartFtraceEvent(const MigratePagesStartFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MigratePagesStartFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mode_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.mode_ = from._impl_.mode_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MigratePagesStartFtraceEvent)
}

inline void MigratePagesStartFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mode_){0}
  };
}

MigratePagesStartFtraceEvent::~MigratePagesStartFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MigratePagesStartFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MigratePagesStartFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MigratePagesStartFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MigratePagesStartFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MigratePagesStartFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.mode_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MigratePagesStartFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 mode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_mode(&has_bits);
          _impl_.mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MigratePagesStartFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MigratePagesStartFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 mode = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MigratePagesStartFtraceEvent)
  return target;
}

size_t MigratePagesStartFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MigratePagesStartFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 mode = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mode());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MigratePagesStartFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MigratePagesStartFtraceEvent*>(
      &from));
}

void MigratePagesStartFtraceEvent::MergeFrom(const MigratePagesStartFtraceEvent& from) {
  MigratePagesStartFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MigratePagesStartFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_mode()) {
    _this->_internal_set_mode(from._internal_mode());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MigratePagesStartFtraceEvent::CopyFrom(const MigratePagesStartFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MigratePagesStartFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MigratePagesStartFtraceEvent::IsInitialized() const {
  return true;
}

void MigratePagesStartFtraceEvent::InternalSwap(MigratePagesStartFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.mode_, other->_impl_.mode_);
}

std::string MigratePagesStartFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MigratePagesStartFtraceEvent";
}


// ===================================================================

class MigrateRetryFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MigrateRetryFtraceEvent>()._impl_._has_bits_);
  static void set_has_tries(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

MigrateRetryFtraceEvent::MigrateRetryFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MigrateRetryFtraceEvent)
}
MigrateRetryFtraceEvent::MigrateRetryFtraceEvent(const MigrateRetryFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MigrateRetryFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tries_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.tries_ = from._impl_.tries_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MigrateRetryFtraceEvent)
}

inline void MigrateRetryFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tries_){0}
  };
}

MigrateRetryFtraceEvent::~MigrateRetryFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MigrateRetryFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MigrateRetryFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MigrateRetryFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MigrateRetryFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MigrateRetryFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tries_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MigrateRetryFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 tries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_tries(&has_bits);
          _impl_.tries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MigrateRetryFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MigrateRetryFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 tries = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_tries(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MigrateRetryFtraceEvent)
  return target;
}

size_t MigrateRetryFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MigrateRetryFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 tries = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_tries());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MigrateRetryFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MigrateRetryFtraceEvent*>(
      &from));
}

void MigrateRetryFtraceEvent::MergeFrom(const MigrateRetryFtraceEvent& from) {
  MigrateRetryFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MigrateRetryFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_tries()) {
    _this->_internal_set_tries(from._internal_tries());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MigrateRetryFtraceEvent::CopyFrom(const MigrateRetryFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MigrateRetryFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MigrateRetryFtraceEvent::IsInitialized() const {
  return true;
}

void MigrateRetryFtraceEvent::InternalSwap(MigrateRetryFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.tries_, other->_impl_.tries_);
}

std::string MigrateRetryFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MigrateRetryFtraceEvent";
}


// ===================================================================

class MmPageAllocFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MmPageAllocFtraceEvent>()._impl_._has_bits_);
  static void set_has_gfp_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_migratetype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_page(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_pfn(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

MmPageAllocFtraceEvent::MmPageAllocFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MmPageAllocFtraceEvent)
}
MmPageAllocFtraceEvent::MmPageAllocFtraceEvent(const MmPageAllocFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MmPageAllocFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gfp_flags_){}
    , decltype(_impl_.migratetype_){}
    , decltype(_impl_.page_){}
    , decltype(_impl_.pfn_){}
    , decltype(_impl_.order_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.gfp_flags_, &from._impl_.gfp_flags_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.order_) -
    reinterpret_cast<char*>(&_impl_.gfp_flags_)) + sizeof(_impl_.order_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MmPageAllocFtraceEvent)
}

inline void MmPageAllocFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gfp_flags_){0u}
    , decltype(_impl_.migratetype_){0}
    , decltype(_impl_.page_){uint64_t{0u}}
    , decltype(_impl_.pfn_){uint64_t{0u}}
    , decltype(_impl_.order_){0u}
  };
}

MmPageAllocFtraceEvent::~MmPageAllocFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MmPageAllocFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MmPageAllocFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MmPageAllocFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MmPageAllocFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MmPageAllocFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.gfp_flags_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.order_) -
        reinterpret_cast<char*>(&_impl_.gfp_flags_)) + sizeof(_impl_.order_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MmPageAllocFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 gfp_flags = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gfp_flags(&has_bits);
          _impl_.gfp_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 migratetype = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_migratetype(&has_bits);
          _impl_.migratetype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 order = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_order(&has_bits);
          _impl_.order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 page = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_page(&has_bits);
          _impl_.page_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pfn = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_pfn(&has_bits);
          _impl_.pfn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MmPageAllocFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MmPageAllocFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 gfp_flags = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_gfp_flags(), target);
  }

  // optional int32 migratetype = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_migratetype(), target);
  }

  // optional uint32 order = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_order(), target);
  }

  // optional uint64 page = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_page(), target);
  }

  // optional uint64 pfn = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_pfn(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MmPageAllocFtraceEvent)
  return target;
}

size_t MmPageAllocFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MmPageAllocFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint32 gfp_flags = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_gfp_flags());
    }

    // optional int32 migratetype = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_migratetype());
    }

    // optional uint64 page = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_page());
    }

    // optional uint64 pfn = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pfn());
    }

    // optional uint32 order = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_order());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MmPageAllocFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MmPageAllocFtraceEvent*>(
      &from));
}

void MmPageAllocFtraceEvent::MergeFrom(const MmPageAllocFtraceEvent& from) {
  MmPageAllocFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MmPageAllocFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.gfp_flags_ = from._impl_.gfp_flags_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.migratetype_ = from._impl_.migratetype_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.page_ = from._impl_.page_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.pfn_ = from._impl_.pfn_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.order_ = from._impl_.order_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MmPageAllocFtraceEvent::CopyFrom(const MmPageAllocFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MmPageAllocFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MmPageAllocFtraceEvent::IsInitialized() const {
  return true;
}

void MmPageAllocFtraceEvent::InternalSwap(MmPageAllocFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MmPageAllocFtraceEvent, _impl_.order_)
      + sizeof(MmPageAllocFtraceEvent::_impl_.order_)
      - PROTOBUF_FIELD_OFFSET(MmPageAllocFtraceEvent, _impl_.gfp_flags_)>(
          reinterpret_cast<char*>(&_impl_.gfp_flags_),
          reinterpret_cast<char*>(&other->_impl_.gfp_flags_));
}

std::string MmPageAllocFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MmPageAllocFtraceEvent";
}


// ===================================================================

class MmPageAllocExtfragFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MmPageAllocExtfragFtraceEvent>()._impl_._has_bits_);
  static void set_has_alloc_migratetype(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_alloc_order(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_fallback_migratetype(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_fallback_order(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_page(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_change_ownership(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_pfn(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

MmPageAllocExtfragFtraceEvent::MmPageAllocExtfragFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MmPageAllocExtfragFtraceEvent)
}
MmPageAllocExtfragFtraceEvent::MmPageAllocExtfragFtraceEvent(const MmPageAllocExtfragFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MmPageAllocExtfragFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.alloc_migratetype_){}
    , decltype(_impl_.alloc_order_){}
    , decltype(_impl_.fallback_migratetype_){}
    , decltype(_impl_.fallback_order_){}
    , decltype(_impl_.page_){}
    , decltype(_impl_.pfn_){}
    , decltype(_impl_.change_ownership_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.alloc_migratetype_, &from._impl_.alloc_migratetype_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.change_ownership_) -
    reinterpret_cast<char*>(&_impl_.alloc_migratetype_)) + sizeof(_impl_.change_ownership_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MmPageAllocExtfragFtraceEvent)
}

inline void MmPageAllocExtfragFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.alloc_migratetype_){0}
    , decltype(_impl_.alloc_order_){0}
    , decltype(_impl_.fallback_migratetype_){0}
    , decltype(_impl_.fallback_order_){0}
    , decltype(_impl_.page_){uint64_t{0u}}
    , decltype(_impl_.pfn_){uint64_t{0u}}
    , decltype(_impl_.change_ownership_){0}
  };
}

MmPageAllocExtfragFtraceEvent::~MmPageAllocExtfragFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MmPageAllocExtfragFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MmPageAllocExtfragFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MmPageAllocExtfragFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MmPageAllocExtfragFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MmPageAllocExtfragFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&_impl_.alloc_migratetype_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.change_ownership_) -
        reinterpret_cast<char*>(&_impl_.alloc_migratetype_)) + sizeof(_impl_.change_ownership_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MmPageAllocExtfragFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 alloc_migratetype = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_alloc_migratetype(&has_bits);
          _impl_.alloc_migratetype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 alloc_order = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_alloc_order(&has_bits);
          _impl_.alloc_order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 fallback_migratetype = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_fallback_migratetype(&has_bits);
          _impl_.fallback_migratetype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 fallback_order = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_fallback_order(&has_bits);
          _impl_.fallback_order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 page = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_page(&has_bits);
          _impl_.page_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 change_ownership = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_change_ownership(&has_bits);
          _impl_.change_ownership_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pfn = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_pfn(&has_bits);
          _impl_.pfn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MmPageAllocExtfragFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MmPageAllocExtfragFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 alloc_migratetype = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_alloc_migratetype(), target);
  }

  // optional int32 alloc_order = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_alloc_order(), target);
  }

  // optional int32 fallback_migratetype = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_fallback_migratetype(), target);
  }

  // optional int32 fallback_order = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_fallback_order(), target);
  }

  // optional uint64 page = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_page(), target);
  }

  // optional int32 change_ownership = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_change_ownership(), target);
  }

  // optional uint64 pfn = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(7, this->_internal_pfn(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MmPageAllocExtfragFtraceEvent)
  return target;
}

size_t MmPageAllocExtfragFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MmPageAllocExtfragFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional int32 alloc_migratetype = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_alloc_migratetype());
    }

    // optional int32 alloc_order = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_alloc_order());
    }

    // optional int32 fallback_migratetype = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_fallback_migratetype());
    }

    // optional int32 fallback_order = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_fallback_order());
    }

    // optional uint64 page = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_page());
    }

    // optional uint64 pfn = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pfn());
    }

    // optional int32 change_ownership = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_change_ownership());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MmPageAllocExtfragFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MmPageAllocExtfragFtraceEvent*>(
      &from));
}

void MmPageAllocExtfragFtraceEvent::MergeFrom(const MmPageAllocExtfragFtraceEvent& from) {
  MmPageAllocExtfragFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MmPageAllocExtfragFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.alloc_migratetype_ = from._impl_.alloc_migratetype_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.alloc_order_ = from._impl_.alloc_order_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.fallback_migratetype_ = from._impl_.fallback_migratetype_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.fallback_order_ = from._impl_.fallback_order_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.page_ = from._impl_.page_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.pfn_ = from._impl_.pfn_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.change_ownership_ = from._impl_.change_ownership_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MmPageAllocExtfragFtraceEvent::CopyFrom(const MmPageAllocExtfragFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MmPageAllocExtfragFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MmPageAllocExtfragFtraceEvent::IsInitialized() const {
  return true;
}

void MmPageAllocExtfragFtraceEvent::InternalSwap(MmPageAllocExtfragFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MmPageAllocExtfragFtraceEvent, _impl_.change_ownership_)
      + sizeof(MmPageAllocExtfragFtraceEvent::_impl_.change_ownership_)
      - PROTOBUF_FIELD_OFFSET(MmPageAllocExtfragFtraceEvent, _impl_.alloc_migratetype_)>(
          reinterpret_cast<char*>(&_impl_.alloc_migratetype_),
          reinterpret_cast<char*>(&other->_impl_.alloc_migratetype_));
}

std::string MmPageAllocExtfragFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MmPageAllocExtfragFtraceEvent";
}


// ===================================================================

class MmPageAllocZoneLockedFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MmPageAllocZoneLockedFtraceEvent>()._impl_._has_bits_);
  static void set_has_migratetype(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_page(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_pfn(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

MmPageAllocZoneLockedFtraceEvent::MmPageAllocZoneLockedFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MmPageAllocZoneLockedFtraceEvent)
}
MmPageAllocZoneLockedFtraceEvent::MmPageAllocZoneLockedFtraceEvent(const MmPageAllocZoneLockedFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MmPageAllocZoneLockedFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.migratetype_){}
    , decltype(_impl_.order_){}
    , decltype(_impl_.page_){}
    , decltype(_impl_.pfn_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.migratetype_, &from._impl_.migratetype_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.pfn_) -
    reinterpret_cast<char*>(&_impl_.migratetype_)) + sizeof(_impl_.pfn_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MmPageAllocZoneLockedFtraceEvent)
}

inline void MmPageAllocZoneLockedFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.migratetype_){0}
    , decltype(_impl_.order_){0u}
    , decltype(_impl_.page_){uint64_t{0u}}
    , decltype(_impl_.pfn_){uint64_t{0u}}
  };
}

MmPageAllocZoneLockedFtraceEvent::~MmPageAllocZoneLockedFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MmPageAllocZoneLockedFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MmPageAllocZoneLockedFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MmPageAllocZoneLockedFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MmPageAllocZoneLockedFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MmPageAllocZoneLockedFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.migratetype_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.pfn_) -
        reinterpret_cast<char*>(&_impl_.migratetype_)) + sizeof(_impl_.pfn_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MmPageAllocZoneLockedFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 migratetype = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_migratetype(&has_bits);
          _impl_.migratetype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 order = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_order(&has_bits);
          _impl_.order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 page = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_page(&has_bits);
          _impl_.page_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pfn = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_pfn(&has_bits);
          _impl_.pfn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MmPageAllocZoneLockedFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MmPageAllocZoneLockedFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 migratetype = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_migratetype(), target);
  }

  // optional uint32 order = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_order(), target);
  }

  // optional uint64 page = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_page(), target);
  }

  // optional uint64 pfn = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_pfn(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MmPageAllocZoneLockedFtraceEvent)
  return target;
}

size_t MmPageAllocZoneLockedFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MmPageAllocZoneLockedFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int32 migratetype = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_migratetype());
    }

    // optional uint32 order = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_order());
    }

    // optional uint64 page = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_page());
    }

    // optional uint64 pfn = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pfn());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MmPageAllocZoneLockedFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MmPageAllocZoneLockedFtraceEvent*>(
      &from));
}

void MmPageAllocZoneLockedFtraceEvent::MergeFrom(const MmPageAllocZoneLockedFtraceEvent& from) {
  MmPageAllocZoneLockedFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MmPageAllocZoneLockedFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.migratetype_ = from._impl_.migratetype_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.order_ = from._impl_.order_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.page_ = from._impl_.page_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.pfn_ = from._impl_.pfn_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MmPageAllocZoneLockedFtraceEvent::CopyFrom(const MmPageAllocZoneLockedFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MmPageAllocZoneLockedFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MmPageAllocZoneLockedFtraceEvent::IsInitialized() const {
  return true;
}

void MmPageAllocZoneLockedFtraceEvent::InternalSwap(MmPageAllocZoneLockedFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MmPageAllocZoneLockedFtraceEvent, _impl_.pfn_)
      + sizeof(MmPageAllocZoneLockedFtraceEvent::_impl_.pfn_)
      - PROTOBUF_FIELD_OFFSET(MmPageAllocZoneLockedFtraceEvent, _impl_.migratetype_)>(
          reinterpret_cast<char*>(&_impl_.migratetype_),
          reinterpret_cast<char*>(&other->_impl_.migratetype_));
}

std::string MmPageAllocZoneLockedFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MmPageAllocZoneLockedFtraceEvent";
}


// ===================================================================

class MmPageFreeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MmPageFreeFtraceEvent>()._impl_._has_bits_);
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_page(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pfn(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

MmPageFreeFtraceEvent::MmPageFreeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MmPageFreeFtraceEvent)
}
MmPageFreeFtraceEvent::MmPageFreeFtraceEvent(const MmPageFreeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MmPageFreeFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.page_){}
    , decltype(_impl_.pfn_){}
    , decltype(_impl_.order_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.page_, &from._impl_.page_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.order_) -
    reinterpret_cast<char*>(&_impl_.page_)) + sizeof(_impl_.order_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MmPageFreeFtraceEvent)
}

inline void MmPageFreeFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.page_){uint64_t{0u}}
    , decltype(_impl_.pfn_){uint64_t{0u}}
    , decltype(_impl_.order_){0u}
  };
}

MmPageFreeFtraceEvent::~MmPageFreeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MmPageFreeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MmPageFreeFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MmPageFreeFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MmPageFreeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MmPageFreeFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.page_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.order_) -
        reinterpret_cast<char*>(&_impl_.page_)) + sizeof(_impl_.order_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MmPageFreeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 order = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_order(&has_bits);
          _impl_.order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 page = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_page(&has_bits);
          _impl_.page_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pfn = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_pfn(&has_bits);
          _impl_.pfn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MmPageFreeFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MmPageFreeFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 order = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_order(), target);
  }

  // optional uint64 page = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_page(), target);
  }

  // optional uint64 pfn = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_pfn(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MmPageFreeFtraceEvent)
  return target;
}

size_t MmPageFreeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MmPageFreeFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 page = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_page());
    }

    // optional uint64 pfn = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pfn());
    }

    // optional uint32 order = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_order());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MmPageFreeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MmPageFreeFtraceEvent*>(
      &from));
}

void MmPageFreeFtraceEvent::MergeFrom(const MmPageFreeFtraceEvent& from) {
  MmPageFreeFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MmPageFreeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.page_ = from._impl_.page_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pfn_ = from._impl_.pfn_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.order_ = from._impl_.order_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MmPageFreeFtraceEvent::CopyFrom(const MmPageFreeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MmPageFreeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MmPageFreeFtraceEvent::IsInitialized() const {
  return true;
}

void MmPageFreeFtraceEvent::InternalSwap(MmPageFreeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MmPageFreeFtraceEvent, _impl_.order_)
      + sizeof(MmPageFreeFtraceEvent::_impl_.order_)
      - PROTOBUF_FIELD_OFFSET(MmPageFreeFtraceEvent, _impl_.page_)>(
          reinterpret_cast<char*>(&_impl_.page_),
          reinterpret_cast<char*>(&other->_impl_.page_));
}

std::string MmPageFreeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MmPageFreeFtraceEvent";
}


// ===================================================================

class MmPageFreeBatchedFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MmPageFreeBatchedFtraceEvent>()._impl_._has_bits_);
  static void set_has_cold(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_page(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pfn(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

MmPageFreeBatchedFtraceEvent::MmPageFreeBatchedFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MmPageFreeBatchedFtraceEvent)
}
MmPageFreeBatchedFtraceEvent::MmPageFreeBatchedFtraceEvent(const MmPageFreeBatchedFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MmPageFreeBatchedFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.page_){}
    , decltype(_impl_.pfn_){}
    , decltype(_impl_.cold_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.page_, &from._impl_.page_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.cold_) -
    reinterpret_cast<char*>(&_impl_.page_)) + sizeof(_impl_.cold_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MmPageFreeBatchedFtraceEvent)
}

inline void MmPageFreeBatchedFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.page_){uint64_t{0u}}
    , decltype(_impl_.pfn_){uint64_t{0u}}
    , decltype(_impl_.cold_){0}
  };
}

MmPageFreeBatchedFtraceEvent::~MmPageFreeBatchedFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MmPageFreeBatchedFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MmPageFreeBatchedFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MmPageFreeBatchedFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MmPageFreeBatchedFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MmPageFreeBatchedFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.page_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.cold_) -
        reinterpret_cast<char*>(&_impl_.page_)) + sizeof(_impl_.cold_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MmPageFreeBatchedFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 cold = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_cold(&has_bits);
          _impl_.cold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 page = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_page(&has_bits);
          _impl_.page_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pfn = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_pfn(&has_bits);
          _impl_.pfn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MmPageFreeBatchedFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MmPageFreeBatchedFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 cold = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_cold(), target);
  }

  // optional uint64 page = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_page(), target);
  }

  // optional uint64 pfn = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_pfn(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MmPageFreeBatchedFtraceEvent)
  return target;
}

size_t MmPageFreeBatchedFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MmPageFreeBatchedFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 page = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_page());
    }

    // optional uint64 pfn = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pfn());
    }

    // optional int32 cold = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_cold());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MmPageFreeBatchedFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MmPageFreeBatchedFtraceEvent*>(
      &from));
}

void MmPageFreeBatchedFtraceEvent::MergeFrom(const MmPageFreeBatchedFtraceEvent& from) {
  MmPageFreeBatchedFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MmPageFreeBatchedFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.page_ = from._impl_.page_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pfn_ = from._impl_.pfn_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.cold_ = from._impl_.cold_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MmPageFreeBatchedFtraceEvent::CopyFrom(const MmPageFreeBatchedFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MmPageFreeBatchedFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MmPageFreeBatchedFtraceEvent::IsInitialized() const {
  return true;
}

void MmPageFreeBatchedFtraceEvent::InternalSwap(MmPageFreeBatchedFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MmPageFreeBatchedFtraceEvent, _impl_.cold_)
      + sizeof(MmPageFreeBatchedFtraceEvent::_impl_.cold_)
      - PROTOBUF_FIELD_OFFSET(MmPageFreeBatchedFtraceEvent, _impl_.page_)>(
          reinterpret_cast<char*>(&_impl_.page_),
          reinterpret_cast<char*>(&other->_impl_.page_));
}

std::string MmPageFreeBatchedFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MmPageFreeBatchedFtraceEvent";
}


// ===================================================================

class MmPagePcpuDrainFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MmPagePcpuDrainFtraceEvent>()._impl_._has_bits_);
  static void set_has_migratetype(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_order(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_page(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_pfn(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

MmPagePcpuDrainFtraceEvent::MmPagePcpuDrainFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MmPagePcpuDrainFtraceEvent)
}
MmPagePcpuDrainFtraceEvent::MmPagePcpuDrainFtraceEvent(const MmPagePcpuDrainFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MmPagePcpuDrainFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.migratetype_){}
    , decltype(_impl_.order_){}
    , decltype(_impl_.page_){}
    , decltype(_impl_.pfn_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.migratetype_, &from._impl_.migratetype_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.pfn_) -
    reinterpret_cast<char*>(&_impl_.migratetype_)) + sizeof(_impl_.pfn_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MmPagePcpuDrainFtraceEvent)
}

inline void MmPagePcpuDrainFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.migratetype_){0}
    , decltype(_impl_.order_){0u}
    , decltype(_impl_.page_){uint64_t{0u}}
    , decltype(_impl_.pfn_){uint64_t{0u}}
  };
}

MmPagePcpuDrainFtraceEvent::~MmPagePcpuDrainFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MmPagePcpuDrainFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MmPagePcpuDrainFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MmPagePcpuDrainFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MmPagePcpuDrainFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MmPagePcpuDrainFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.migratetype_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.pfn_) -
        reinterpret_cast<char*>(&_impl_.migratetype_)) + sizeof(_impl_.pfn_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MmPagePcpuDrainFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 migratetype = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_migratetype(&has_bits);
          _impl_.migratetype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 order = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_order(&has_bits);
          _impl_.order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 page = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_page(&has_bits);
          _impl_.page_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 pfn = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_pfn(&has_bits);
          _impl_.pfn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MmPagePcpuDrainFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MmPagePcpuDrainFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 migratetype = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_migratetype(), target);
  }

  // optional uint32 order = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_order(), target);
  }

  // optional uint64 page = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_page(), target);
  }

  // optional uint64 pfn = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_pfn(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MmPagePcpuDrainFtraceEvent)
  return target;
}

size_t MmPagePcpuDrainFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MmPagePcpuDrainFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int32 migratetype = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_migratetype());
    }

    // optional uint32 order = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_order());
    }

    // optional uint64 page = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_page());
    }

    // optional uint64 pfn = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_pfn());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MmPagePcpuDrainFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MmPagePcpuDrainFtraceEvent*>(
      &from));
}

void MmPagePcpuDrainFtraceEvent::MergeFrom(const MmPagePcpuDrainFtraceEvent& from) {
  MmPagePcpuDrainFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MmPagePcpuDrainFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.migratetype_ = from._impl_.migratetype_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.order_ = from._impl_.order_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.page_ = from._impl_.page_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.pfn_ = from._impl_.pfn_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MmPagePcpuDrainFtraceEvent::CopyFrom(const MmPagePcpuDrainFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MmPagePcpuDrainFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MmPagePcpuDrainFtraceEvent::IsInitialized() const {
  return true;
}

void MmPagePcpuDrainFtraceEvent::InternalSwap(MmPagePcpuDrainFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MmPagePcpuDrainFtraceEvent, _impl_.pfn_)
      + sizeof(MmPagePcpuDrainFtraceEvent::_impl_.pfn_)
      - PROTOBUF_FIELD_OFFSET(MmPagePcpuDrainFtraceEvent, _impl_.migratetype_)>(
          reinterpret_cast<char*>(&_impl_.migratetype_),
          reinterpret_cast<char*>(&other->_impl_.migratetype_));
}

std::string MmPagePcpuDrainFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MmPagePcpuDrainFtraceEvent";
}


// ===================================================================

class RssStatFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<RssStatFtraceEvent>()._impl_._has_bits_);
  static void set_has_member(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_curr(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_mm_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

RssStatFtraceEvent::RssStatFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.RssStatFtraceEvent)
}
RssStatFtraceEvent::RssStatFtraceEvent(const RssStatFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  RssStatFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.size_){}
    , decltype(_impl_.member_){}
    , decltype(_impl_.curr_){}
    , decltype(_impl_.mm_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.size_, &from._impl_.size_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.mm_id_) -
    reinterpret_cast<char*>(&_impl_.size_)) + sizeof(_impl_.mm_id_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.RssStatFtraceEvent)
}

inline void RssStatFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.size_){int64_t{0}}
    , decltype(_impl_.member_){0}
    , decltype(_impl_.curr_){0u}
    , decltype(_impl_.mm_id_){0u}
  };
}

RssStatFtraceEvent::~RssStatFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.RssStatFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RssStatFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RssStatFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RssStatFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.RssStatFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.size_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.mm_id_) -
        reinterpret_cast<char*>(&_impl_.size_)) + sizeof(_impl_.mm_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RssStatFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 member = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_member(&has_bits);
          _impl_.member_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 curr = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_curr(&has_bits);
          _impl_.curr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mm_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_mm_id(&has_bits);
          _impl_.mm_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RssStatFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.RssStatFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 member = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_member(), target);
  }

  // optional int64 size = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_size(), target);
  }

  // optional uint32 curr = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_curr(), target);
  }

  // optional uint32 mm_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_mm_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.RssStatFtraceEvent)
  return target;
}

size_t RssStatFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.RssStatFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int64 size = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_size());
    }

    // optional int32 member = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_member());
    }

    // optional uint32 curr = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_curr());
    }

    // optional uint32 mm_id = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mm_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RssStatFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RssStatFtraceEvent*>(
      &from));
}

void RssStatFtraceEvent::MergeFrom(const RssStatFtraceEvent& from) {
  RssStatFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.RssStatFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.member_ = from._impl_.member_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.curr_ = from._impl_.curr_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.mm_id_ = from._impl_.mm_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RssStatFtraceEvent::CopyFrom(const RssStatFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.RssStatFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RssStatFtraceEvent::IsInitialized() const {
  return true;
}

void RssStatFtraceEvent::InternalSwap(RssStatFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RssStatFtraceEvent, _impl_.mm_id_)
      + sizeof(RssStatFtraceEvent::_impl_.mm_id_)
      - PROTOBUF_FIELD_OFFSET(RssStatFtraceEvent, _impl_.size_)>(
          reinterpret_cast<char*>(&_impl_.size_),
          reinterpret_cast<char*>(&other->_impl_.size_));
}

std::string RssStatFtraceEvent::GetTypeName() const {
  return "perfetto.protos.RssStatFtraceEvent";
}


// ===================================================================

class IonHeapShrinkFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonHeapShrinkFtraceEvent>()._impl_._has_bits_);
  static void set_has_heap_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_total_allocated(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

IonHeapShrinkFtraceEvent::IonHeapShrinkFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IonHeapShrinkFtraceEvent)
}
IonHeapShrinkFtraceEvent::IonHeapShrinkFtraceEvent(const IonHeapShrinkFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IonHeapShrinkFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.heap_name_){}
    , decltype(_impl_.len_){}
    , decltype(_impl_.total_allocated_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_heap_name()) {
    _this->_impl_.heap_name_.Set(from._internal_heap_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.len_, &from._impl_.len_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.total_allocated_) -
    reinterpret_cast<char*>(&_impl_.len_)) + sizeof(_impl_.total_allocated_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonHeapShrinkFtraceEvent)
}

inline void IonHeapShrinkFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.heap_name_){}
    , decltype(_impl_.len_){uint64_t{0u}}
    , decltype(_impl_.total_allocated_){int64_t{0}}
  };
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IonHeapShrinkFtraceEvent::~IonHeapShrinkFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonHeapShrinkFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IonHeapShrinkFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.heap_name_.Destroy();
}

void IonHeapShrinkFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IonHeapShrinkFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonHeapShrinkFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.heap_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.len_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.total_allocated_) -
        reinterpret_cast<char*>(&_impl_.len_)) + sizeof(_impl_.total_allocated_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IonHeapShrinkFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string heap_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_heap_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 len = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 total_allocated = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_total_allocated(&has_bits);
          _impl_.total_allocated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IonHeapShrinkFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IonHeapShrinkFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string heap_name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_heap_name(), target);
  }

  // optional uint64 len = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_len(), target);
  }

  // optional int64 total_allocated = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_total_allocated(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IonHeapShrinkFtraceEvent)
  return target;
}

size_t IonHeapShrinkFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonHeapShrinkFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string heap_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_heap_name());
    }

    // optional uint64 len = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_len());
    }

    // optional int64 total_allocated = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_total_allocated());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IonHeapShrinkFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IonHeapShrinkFtraceEvent*>(
      &from));
}

void IonHeapShrinkFtraceEvent::MergeFrom(const IonHeapShrinkFtraceEvent& from) {
  IonHeapShrinkFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonHeapShrinkFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_heap_name(from._internal_heap_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.total_allocated_ = from._impl_.total_allocated_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IonHeapShrinkFtraceEvent::CopyFrom(const IonHeapShrinkFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonHeapShrinkFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonHeapShrinkFtraceEvent::IsInitialized() const {
  return true;
}

void IonHeapShrinkFtraceEvent::InternalSwap(IonHeapShrinkFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.heap_name_, lhs_arena,
      &other->_impl_.heap_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IonHeapShrinkFtraceEvent, _impl_.total_allocated_)
      + sizeof(IonHeapShrinkFtraceEvent::_impl_.total_allocated_)
      - PROTOBUF_FIELD_OFFSET(IonHeapShrinkFtraceEvent, _impl_.len_)>(
          reinterpret_cast<char*>(&_impl_.len_),
          reinterpret_cast<char*>(&other->_impl_.len_));
}

std::string IonHeapShrinkFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IonHeapShrinkFtraceEvent";
}


// ===================================================================

class IonHeapGrowFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonHeapGrowFtraceEvent>()._impl_._has_bits_);
  static void set_has_heap_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_total_allocated(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

IonHeapGrowFtraceEvent::IonHeapGrowFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IonHeapGrowFtraceEvent)
}
IonHeapGrowFtraceEvent::IonHeapGrowFtraceEvent(const IonHeapGrowFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IonHeapGrowFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.heap_name_){}
    , decltype(_impl_.len_){}
    , decltype(_impl_.total_allocated_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_heap_name()) {
    _this->_impl_.heap_name_.Set(from._internal_heap_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.len_, &from._impl_.len_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.total_allocated_) -
    reinterpret_cast<char*>(&_impl_.len_)) + sizeof(_impl_.total_allocated_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonHeapGrowFtraceEvent)
}

inline void IonHeapGrowFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.heap_name_){}
    , decltype(_impl_.len_){uint64_t{0u}}
    , decltype(_impl_.total_allocated_){int64_t{0}}
  };
  _impl_.heap_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.heap_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IonHeapGrowFtraceEvent::~IonHeapGrowFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonHeapGrowFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IonHeapGrowFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.heap_name_.Destroy();
}

void IonHeapGrowFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IonHeapGrowFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonHeapGrowFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.heap_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.len_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.total_allocated_) -
        reinterpret_cast<char*>(&_impl_.len_)) + sizeof(_impl_.total_allocated_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IonHeapGrowFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string heap_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_heap_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 len = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 total_allocated = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_total_allocated(&has_bits);
          _impl_.total_allocated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IonHeapGrowFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IonHeapGrowFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string heap_name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_heap_name(), target);
  }

  // optional uint64 len = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_len(), target);
  }

  // optional int64 total_allocated = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_total_allocated(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IonHeapGrowFtraceEvent)
  return target;
}

size_t IonHeapGrowFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonHeapGrowFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string heap_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_heap_name());
    }

    // optional uint64 len = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_len());
    }

    // optional int64 total_allocated = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_total_allocated());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IonHeapGrowFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IonHeapGrowFtraceEvent*>(
      &from));
}

void IonHeapGrowFtraceEvent::MergeFrom(const IonHeapGrowFtraceEvent& from) {
  IonHeapGrowFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonHeapGrowFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_heap_name(from._internal_heap_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.total_allocated_ = from._impl_.total_allocated_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IonHeapGrowFtraceEvent::CopyFrom(const IonHeapGrowFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonHeapGrowFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonHeapGrowFtraceEvent::IsInitialized() const {
  return true;
}

void IonHeapGrowFtraceEvent::InternalSwap(IonHeapGrowFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.heap_name_, lhs_arena,
      &other->_impl_.heap_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IonHeapGrowFtraceEvent, _impl_.total_allocated_)
      + sizeof(IonHeapGrowFtraceEvent::_impl_.total_allocated_)
      - PROTOBUF_FIELD_OFFSET(IonHeapGrowFtraceEvent, _impl_.len_)>(
          reinterpret_cast<char*>(&_impl_.len_),
          reinterpret_cast<char*>(&other->_impl_.len_));
}

std::string IonHeapGrowFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IonHeapGrowFtraceEvent";
}


// ===================================================================

class IonBufferCreateFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonBufferCreateFtraceEvent>()._impl_._has_bits_);
  static void set_has_addr(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

IonBufferCreateFtraceEvent::IonBufferCreateFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IonBufferCreateFtraceEvent)
}
IonBufferCreateFtraceEvent::IonBufferCreateFtraceEvent(const IonBufferCreateFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IonBufferCreateFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.addr_){}
    , decltype(_impl_.len_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.addr_, &from._impl_.addr_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.len_) -
    reinterpret_cast<char*>(&_impl_.addr_)) + sizeof(_impl_.len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonBufferCreateFtraceEvent)
}

inline void IonBufferCreateFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.addr_){uint64_t{0u}}
    , decltype(_impl_.len_){uint64_t{0u}}
  };
}

IonBufferCreateFtraceEvent::~IonBufferCreateFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonBufferCreateFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IonBufferCreateFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void IonBufferCreateFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IonBufferCreateFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonBufferCreateFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.addr_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.len_) -
        reinterpret_cast<char*>(&_impl_.addr_)) + sizeof(_impl_.len_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IonBufferCreateFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 addr = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_addr(&has_bits);
          _impl_.addr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 len = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IonBufferCreateFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IonBufferCreateFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 addr = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_addr(), target);
  }

  // optional uint64 len = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IonBufferCreateFtraceEvent)
  return target;
}

size_t IonBufferCreateFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonBufferCreateFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 addr = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_addr());
    }

    // optional uint64 len = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_len());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IonBufferCreateFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IonBufferCreateFtraceEvent*>(
      &from));
}

void IonBufferCreateFtraceEvent::MergeFrom(const IonBufferCreateFtraceEvent& from) {
  IonBufferCreateFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonBufferCreateFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.addr_ = from._impl_.addr_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IonBufferCreateFtraceEvent::CopyFrom(const IonBufferCreateFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonBufferCreateFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonBufferCreateFtraceEvent::IsInitialized() const {
  return true;
}

void IonBufferCreateFtraceEvent::InternalSwap(IonBufferCreateFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IonBufferCreateFtraceEvent, _impl_.len_)
      + sizeof(IonBufferCreateFtraceEvent::_impl_.len_)
      - PROTOBUF_FIELD_OFFSET(IonBufferCreateFtraceEvent, _impl_.addr_)>(
          reinterpret_cast<char*>(&_impl_.addr_),
          reinterpret_cast<char*>(&other->_impl_.addr_));
}

std::string IonBufferCreateFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IonBufferCreateFtraceEvent";
}


// ===================================================================

class IonBufferDestroyFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IonBufferDestroyFtraceEvent>()._impl_._has_bits_);
  static void set_has_addr(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

IonBufferDestroyFtraceEvent::IonBufferDestroyFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.IonBufferDestroyFtraceEvent)
}
IonBufferDestroyFtraceEvent::IonBufferDestroyFtraceEvent(const IonBufferDestroyFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IonBufferDestroyFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.addr_){}
    , decltype(_impl_.len_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.addr_, &from._impl_.addr_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.len_) -
    reinterpret_cast<char*>(&_impl_.addr_)) + sizeof(_impl_.len_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.IonBufferDestroyFtraceEvent)
}

inline void IonBufferDestroyFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.addr_){uint64_t{0u}}
    , decltype(_impl_.len_){uint64_t{0u}}
  };
}

IonBufferDestroyFtraceEvent::~IonBufferDestroyFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.IonBufferDestroyFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IonBufferDestroyFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void IonBufferDestroyFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IonBufferDestroyFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.IonBufferDestroyFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.addr_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.len_) -
        reinterpret_cast<char*>(&_impl_.addr_)) + sizeof(_impl_.len_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IonBufferDestroyFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 addr = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_addr(&has_bits);
          _impl_.addr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 len = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_len(&has_bits);
          _impl_.len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IonBufferDestroyFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.IonBufferDestroyFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 addr = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_addr(), target);
  }

  // optional uint64 len = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.IonBufferDestroyFtraceEvent)
  return target;
}

size_t IonBufferDestroyFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.IonBufferDestroyFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 addr = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_addr());
    }

    // optional uint64 len = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_len());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IonBufferDestroyFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IonBufferDestroyFtraceEvent*>(
      &from));
}

void IonBufferDestroyFtraceEvent::MergeFrom(const IonBufferDestroyFtraceEvent& from) {
  IonBufferDestroyFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.IonBufferDestroyFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.addr_ = from._impl_.addr_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IonBufferDestroyFtraceEvent::CopyFrom(const IonBufferDestroyFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.IonBufferDestroyFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IonBufferDestroyFtraceEvent::IsInitialized() const {
  return true;
}

void IonBufferDestroyFtraceEvent::InternalSwap(IonBufferDestroyFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IonBufferDestroyFtraceEvent, _impl_.len_)
      + sizeof(IonBufferDestroyFtraceEvent::_impl_.len_)
      - PROTOBUF_FIELD_OFFSET(IonBufferDestroyFtraceEvent, _impl_.addr_)>(
          reinterpret_cast<char*>(&_impl_.addr_),
          reinterpret_cast<char*>(&other->_impl_.addr_));
}

std::string IonBufferDestroyFtraceEvent::GetTypeName() const {
  return "perfetto.protos.IonBufferDestroyFtraceEvent";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace protos
}  // namespace perfetto
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::perfetto::protos::AllocPagesIommuEndFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::AllocPagesIommuEndFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::AllocPagesIommuEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::AllocPagesIommuFailFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::AllocPagesIommuFailFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::AllocPagesIommuFailFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::AllocPagesIommuStartFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::AllocPagesIommuStartFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::AllocPagesIommuStartFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::AllocPagesSysEndFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::AllocPagesSysEndFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::AllocPagesSysEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::AllocPagesSysFailFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::AllocPagesSysFailFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::AllocPagesSysFailFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::AllocPagesSysStartFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::AllocPagesSysStartFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::AllocPagesSysStartFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::DmaAllocContiguousRetryFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::DmaAllocContiguousRetryFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::DmaAllocContiguousRetryFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IommuMapRangeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IommuMapRangeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IommuMapRangeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IommuSecPtblMapRangeEndFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IommuSecPtblMapRangeEndFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IommuSecPtblMapRangeEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IommuSecPtblMapRangeStartFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IommuSecPtblMapRangeStartFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IommuSecPtblMapRangeStartFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonAllocBufferEndFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IonAllocBufferEndFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IonAllocBufferEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonAllocBufferFailFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IonAllocBufferFailFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IonAllocBufferFailFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonAllocBufferFallbackFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IonAllocBufferFallbackFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IonAllocBufferFallbackFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonAllocBufferStartFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IonAllocBufferStartFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IonAllocBufferStartFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonCpAllocRetryFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IonCpAllocRetryFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IonCpAllocRetryFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonCpSecureBufferEndFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IonCpSecureBufferEndFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IonCpSecureBufferEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonCpSecureBufferStartFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IonCpSecureBufferStartFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IonCpSecureBufferStartFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonPrefetchingFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IonPrefetchingFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IonPrefetchingFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonSecureCmaAddToPoolEndFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IonSecureCmaAddToPoolEndFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IonSecureCmaAddToPoolEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonSecureCmaAddToPoolStartFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IonSecureCmaAddToPoolStartFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IonSecureCmaAddToPoolStartFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonSecureCmaAllocateEndFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IonSecureCmaAllocateEndFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IonSecureCmaAllocateEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonSecureCmaAllocateStartFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IonSecureCmaAllocateStartFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IonSecureCmaAllocateStartFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonSecureCmaShrinkPoolEndFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IonSecureCmaShrinkPoolEndFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IonSecureCmaShrinkPoolEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonSecureCmaShrinkPoolStartFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IonSecureCmaShrinkPoolStartFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IonSecureCmaShrinkPoolStartFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KfreeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KfreeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KfreeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KmallocFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KmallocFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KmallocFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KmallocNodeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KmallocNodeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KmallocNodeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KmemCacheAllocFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KmemCacheAllocFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KmemCacheAllocFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KmemCacheAllocNodeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KmemCacheAllocNodeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KmemCacheAllocNodeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::KmemCacheFreeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::KmemCacheFreeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::KmemCacheFreeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MigratePagesEndFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MigratePagesEndFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MigratePagesEndFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MigratePagesStartFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MigratePagesStartFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MigratePagesStartFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MigrateRetryFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MigrateRetryFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MigrateRetryFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MmPageAllocFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MmPageAllocFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MmPageAllocFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MmPageAllocExtfragFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MmPageAllocExtfragFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MmPageAllocExtfragFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MmPageAllocZoneLockedFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MmPageAllocZoneLockedFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MmPageAllocZoneLockedFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MmPageFreeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MmPageFreeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MmPageFreeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MmPageFreeBatchedFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MmPageFreeBatchedFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MmPageFreeBatchedFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MmPagePcpuDrainFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MmPagePcpuDrainFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MmPagePcpuDrainFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::RssStatFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::RssStatFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::RssStatFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonHeapShrinkFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IonHeapShrinkFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IonHeapShrinkFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonHeapGrowFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IonHeapGrowFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IonHeapGrowFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonBufferCreateFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IonBufferCreateFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IonBufferCreateFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::IonBufferDestroyFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::IonBufferDestroyFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::IonBufferDestroyFtraceEvent >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
