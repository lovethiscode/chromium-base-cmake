// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_F2FS_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_F2FS_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class F2fsGcEndFtraceEvent;
class F2fsGcBeginFtraceEvent;
class F2fsBackgroundGcFtraceEvent;
class F2fsIostatLatencyFtraceEvent;
class F2fsIostatFtraceEvent;
class F2fsWriteEndFtraceEvent;
class F2fsWriteCheckpointFtraceEvent;
class F2fsWriteBeginFtraceEvent;
class F2fsVmPageMkwriteFtraceEvent;
class F2fsUnlinkExitFtraceEvent;
class F2fsUnlinkEnterFtraceEvent;
class F2fsTruncatePartialNodesFtraceEvent;
class F2fsTruncateNodesExitFtraceEvent;
class F2fsTruncateNodesEnterFtraceEvent;
class F2fsTruncateNodeFtraceEvent;
class F2fsTruncateInodeBlocksExitFtraceEvent;
class F2fsTruncateInodeBlocksEnterFtraceEvent;
class F2fsTruncateDataBlocksRangeFtraceEvent;
class F2fsTruncateBlocksExitFtraceEvent;
class F2fsTruncateBlocksEnterFtraceEvent;
class F2fsTruncateFtraceEvent;
class F2fsSyncFsFtraceEvent;
class F2fsSyncFileExitFtraceEvent;
class F2fsSyncFileEnterFtraceEvent;
class F2fsSubmitWritePageFtraceEvent;
class F2fsSetPageDirtyFtraceEvent;
class F2fsReserveNewBlockFtraceEvent;
class F2fsReadpageFtraceEvent;
class F2fsNewInodeFtraceEvent;
class F2fsIgetExitFtraceEvent;
class F2fsIgetFtraceEvent;
class F2fsGetVictimFtraceEvent;
class F2fsGetDataBlockFtraceEvent;
class F2fsFallocateFtraceEvent;
class F2fsEvictInodeFtraceEvent;
class F2fsDoSubmitBioFtraceEvent;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {

class PERFETTO_EXPORT_COMPONENT F2fsGcEndFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kRetFieldNumber = 2,
    kSegFreedFieldNumber = 3,
    kSecFreedFieldNumber = 4,
    kDirtyNodesFieldNumber = 5,
    kDirtyDentsFieldNumber = 6,
    kDirtyImetaFieldNumber = 7,
    kFreeSecFieldNumber = 8,
    kFreeSegFieldNumber = 9,
    kReservedSegFieldNumber = 10,
    kPrefreeSegFieldNumber = 11,
  };

  F2fsGcEndFtraceEvent();
  ~F2fsGcEndFtraceEvent() override;
  F2fsGcEndFtraceEvent(F2fsGcEndFtraceEvent&&) noexcept;
  F2fsGcEndFtraceEvent& operator=(F2fsGcEndFtraceEvent&&);
  F2fsGcEndFtraceEvent(const F2fsGcEndFtraceEvent&);
  F2fsGcEndFtraceEvent& operator=(const F2fsGcEndFtraceEvent&);
  bool operator==(const F2fsGcEndFtraceEvent&) const;
  bool operator!=(const F2fsGcEndFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ret() const { return _has_field_[2]; }
  int32_t ret() const { return ret_; }
  void set_ret(int32_t value) { ret_ = value; _has_field_.set(2); }

  bool has_seg_freed() const { return _has_field_[3]; }
  int32_t seg_freed() const { return seg_freed_; }
  void set_seg_freed(int32_t value) { seg_freed_ = value; _has_field_.set(3); }

  bool has_sec_freed() const { return _has_field_[4]; }
  int32_t sec_freed() const { return sec_freed_; }
  void set_sec_freed(int32_t value) { sec_freed_ = value; _has_field_.set(4); }

  bool has_dirty_nodes() const { return _has_field_[5]; }
  int64_t dirty_nodes() const { return dirty_nodes_; }
  void set_dirty_nodes(int64_t value) { dirty_nodes_ = value; _has_field_.set(5); }

  bool has_dirty_dents() const { return _has_field_[6]; }
  int64_t dirty_dents() const { return dirty_dents_; }
  void set_dirty_dents(int64_t value) { dirty_dents_ = value; _has_field_.set(6); }

  bool has_dirty_imeta() const { return _has_field_[7]; }
  int64_t dirty_imeta() const { return dirty_imeta_; }
  void set_dirty_imeta(int64_t value) { dirty_imeta_ = value; _has_field_.set(7); }

  bool has_free_sec() const { return _has_field_[8]; }
  uint32_t free_sec() const { return free_sec_; }
  void set_free_sec(uint32_t value) { free_sec_ = value; _has_field_.set(8); }

  bool has_free_seg() const { return _has_field_[9]; }
  uint32_t free_seg() const { return free_seg_; }
  void set_free_seg(uint32_t value) { free_seg_ = value; _has_field_.set(9); }

  bool has_reserved_seg() const { return _has_field_[10]; }
  int32_t reserved_seg() const { return reserved_seg_; }
  void set_reserved_seg(int32_t value) { reserved_seg_ = value; _has_field_.set(10); }

  bool has_prefree_seg() const { return _has_field_[11]; }
  uint32_t prefree_seg() const { return prefree_seg_; }
  void set_prefree_seg(uint32_t value) { prefree_seg_ = value; _has_field_.set(11); }

 private:
  uint64_t dev_{};
  int32_t ret_{};
  int32_t seg_freed_{};
  int32_t sec_freed_{};
  int64_t dirty_nodes_{};
  int64_t dirty_dents_{};
  int64_t dirty_imeta_{};
  uint32_t free_sec_{};
  uint32_t free_seg_{};
  int32_t reserved_seg_{};
  uint32_t prefree_seg_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<12> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT F2fsGcBeginFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kSyncFieldNumber = 2,
    kBackgroundFieldNumber = 3,
    kDirtyNodesFieldNumber = 4,
    kDirtyDentsFieldNumber = 5,
    kDirtyImetaFieldNumber = 6,
    kFreeSecFieldNumber = 7,
    kFreeSegFieldNumber = 8,
    kReservedSegFieldNumber = 9,
    kPrefreeSegFieldNumber = 10,
    kGcTypeFieldNumber = 11,
    kNoBgGcFieldNumber = 12,
    kNrFreeSecsFieldNumber = 13,
  };

  F2fsGcBeginFtraceEvent();
  ~F2fsGcBeginFtraceEvent() override;
  F2fsGcBeginFtraceEvent(F2fsGcBeginFtraceEvent&&) noexcept;
  F2fsGcBeginFtraceEvent& operator=(F2fsGcBeginFtraceEvent&&);
  F2fsGcBeginFtraceEvent(const F2fsGcBeginFtraceEvent&);
  F2fsGcBeginFtraceEvent& operator=(const F2fsGcBeginFtraceEvent&);
  bool operator==(const F2fsGcBeginFtraceEvent&) const;
  bool operator!=(const F2fsGcBeginFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_sync() const { return _has_field_[2]; }
  uint32_t sync() const { return sync_; }
  void set_sync(uint32_t value) { sync_ = value; _has_field_.set(2); }

  bool has_background() const { return _has_field_[3]; }
  uint32_t background() const { return background_; }
  void set_background(uint32_t value) { background_ = value; _has_field_.set(3); }

  bool has_dirty_nodes() const { return _has_field_[4]; }
  int64_t dirty_nodes() const { return dirty_nodes_; }
  void set_dirty_nodes(int64_t value) { dirty_nodes_ = value; _has_field_.set(4); }

  bool has_dirty_dents() const { return _has_field_[5]; }
  int64_t dirty_dents() const { return dirty_dents_; }
  void set_dirty_dents(int64_t value) { dirty_dents_ = value; _has_field_.set(5); }

  bool has_dirty_imeta() const { return _has_field_[6]; }
  int64_t dirty_imeta() const { return dirty_imeta_; }
  void set_dirty_imeta(int64_t value) { dirty_imeta_ = value; _has_field_.set(6); }

  bool has_free_sec() const { return _has_field_[7]; }
  uint32_t free_sec() const { return free_sec_; }
  void set_free_sec(uint32_t value) { free_sec_ = value; _has_field_.set(7); }

  bool has_free_seg() const { return _has_field_[8]; }
  uint32_t free_seg() const { return free_seg_; }
  void set_free_seg(uint32_t value) { free_seg_ = value; _has_field_.set(8); }

  bool has_reserved_seg() const { return _has_field_[9]; }
  int32_t reserved_seg() const { return reserved_seg_; }
  void set_reserved_seg(int32_t value) { reserved_seg_ = value; _has_field_.set(9); }

  bool has_prefree_seg() const { return _has_field_[10]; }
  uint32_t prefree_seg() const { return prefree_seg_; }
  void set_prefree_seg(uint32_t value) { prefree_seg_ = value; _has_field_.set(10); }

  bool has_gc_type() const { return _has_field_[11]; }
  int32_t gc_type() const { return gc_type_; }
  void set_gc_type(int32_t value) { gc_type_ = value; _has_field_.set(11); }

  bool has_no_bg_gc() const { return _has_field_[12]; }
  uint32_t no_bg_gc() const { return no_bg_gc_; }
  void set_no_bg_gc(uint32_t value) { no_bg_gc_ = value; _has_field_.set(12); }

  bool has_nr_free_secs() const { return _has_field_[13]; }
  uint32_t nr_free_secs() const { return nr_free_secs_; }
  void set_nr_free_secs(uint32_t value) { nr_free_secs_ = value; _has_field_.set(13); }

 private:
  uint64_t dev_{};
  uint32_t sync_{};
  uint32_t background_{};
  int64_t dirty_nodes_{};
  int64_t dirty_dents_{};
  int64_t dirty_imeta_{};
  uint32_t free_sec_{};
  uint32_t free_seg_{};
  int32_t reserved_seg_{};
  uint32_t prefree_seg_{};
  int32_t gc_type_{};
  uint32_t no_bg_gc_{};
  uint32_t nr_free_secs_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<14> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT F2fsBackgroundGcFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kWaitMsFieldNumber = 2,
    kPrefreeFieldNumber = 3,
    kFreeFieldNumber = 4,
  };

  F2fsBackgroundGcFtraceEvent();
  ~F2fsBackgroundGcFtraceEvent() override;
  F2fsBackgroundGcFtraceEvent(F2fsBackgroundGcFtraceEvent&&) noexcept;
  F2fsBackgroundGcFtraceEvent& operator=(F2fsBackgroundGcFtraceEvent&&);
  F2fsBackgroundGcFtraceEvent(const F2fsBackgroundGcFtraceEvent&);
  F2fsBackgroundGcFtraceEvent& operator=(const F2fsBackgroundGcFtraceEvent&);
  bool operator==(const F2fsBackgroundGcFtraceEvent&) const;
  bool operator!=(const F2fsBackgroundGcFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_wait_ms() const { return _has_field_[2]; }
  uint32_t wait_ms() const { return wait_ms_; }
  void set_wait_ms(uint32_t value) { wait_ms_ = value; _has_field_.set(2); }

  bool has_prefree() const { return _has_field_[3]; }
  uint32_t prefree() const { return prefree_; }
  void set_prefree(uint32_t value) { prefree_ = value; _has_field_.set(3); }

  bool has_free() const { return _has_field_[4]; }
  uint32_t free() const { return free_; }
  void set_free(uint32_t value) { free_ = value; _has_field_.set(4); }

 private:
  uint64_t dev_{};
  uint32_t wait_ms_{};
  uint32_t prefree_{};
  uint32_t free_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT F2fsIostatLatencyFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDRdAvgFieldNumber = 1,
    kDRdCntFieldNumber = 2,
    kDRdPeakFieldNumber = 3,
    kDWrAsAvgFieldNumber = 4,
    kDWrAsCntFieldNumber = 5,
    kDWrAsPeakFieldNumber = 6,
    kDWrSAvgFieldNumber = 7,
    kDWrSCntFieldNumber = 8,
    kDWrSPeakFieldNumber = 9,
    kDevFieldNumber = 10,
    kMRdAvgFieldNumber = 11,
    kMRdCntFieldNumber = 12,
    kMRdPeakFieldNumber = 13,
    kMWrAsAvgFieldNumber = 14,
    kMWrAsCntFieldNumber = 15,
    kMWrAsPeakFieldNumber = 16,
    kMWrSAvgFieldNumber = 17,
    kMWrSCntFieldNumber = 18,
    kMWrSPeakFieldNumber = 19,
    kNRdAvgFieldNumber = 20,
    kNRdCntFieldNumber = 21,
    kNRdPeakFieldNumber = 22,
    kNWrAsAvgFieldNumber = 23,
    kNWrAsCntFieldNumber = 24,
    kNWrAsPeakFieldNumber = 25,
    kNWrSAvgFieldNumber = 26,
    kNWrSCntFieldNumber = 27,
    kNWrSPeakFieldNumber = 28,
  };

  F2fsIostatLatencyFtraceEvent();
  ~F2fsIostatLatencyFtraceEvent() override;
  F2fsIostatLatencyFtraceEvent(F2fsIostatLatencyFtraceEvent&&) noexcept;
  F2fsIostatLatencyFtraceEvent& operator=(F2fsIostatLatencyFtraceEvent&&);
  F2fsIostatLatencyFtraceEvent(const F2fsIostatLatencyFtraceEvent&);
  F2fsIostatLatencyFtraceEvent& operator=(const F2fsIostatLatencyFtraceEvent&);
  bool operator==(const F2fsIostatLatencyFtraceEvent&) const;
  bool operator!=(const F2fsIostatLatencyFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_d_rd_avg() const { return _has_field_[1]; }
  uint32_t d_rd_avg() const { return d_rd_avg_; }
  void set_d_rd_avg(uint32_t value) { d_rd_avg_ = value; _has_field_.set(1); }

  bool has_d_rd_cnt() const { return _has_field_[2]; }
  uint32_t d_rd_cnt() const { return d_rd_cnt_; }
  void set_d_rd_cnt(uint32_t value) { d_rd_cnt_ = value; _has_field_.set(2); }

  bool has_d_rd_peak() const { return _has_field_[3]; }
  uint32_t d_rd_peak() const { return d_rd_peak_; }
  void set_d_rd_peak(uint32_t value) { d_rd_peak_ = value; _has_field_.set(3); }

  bool has_d_wr_as_avg() const { return _has_field_[4]; }
  uint32_t d_wr_as_avg() const { return d_wr_as_avg_; }
  void set_d_wr_as_avg(uint32_t value) { d_wr_as_avg_ = value; _has_field_.set(4); }

  bool has_d_wr_as_cnt() const { return _has_field_[5]; }
  uint32_t d_wr_as_cnt() const { return d_wr_as_cnt_; }
  void set_d_wr_as_cnt(uint32_t value) { d_wr_as_cnt_ = value; _has_field_.set(5); }

  bool has_d_wr_as_peak() const { return _has_field_[6]; }
  uint32_t d_wr_as_peak() const { return d_wr_as_peak_; }
  void set_d_wr_as_peak(uint32_t value) { d_wr_as_peak_ = value; _has_field_.set(6); }

  bool has_d_wr_s_avg() const { return _has_field_[7]; }
  uint32_t d_wr_s_avg() const { return d_wr_s_avg_; }
  void set_d_wr_s_avg(uint32_t value) { d_wr_s_avg_ = value; _has_field_.set(7); }

  bool has_d_wr_s_cnt() const { return _has_field_[8]; }
  uint32_t d_wr_s_cnt() const { return d_wr_s_cnt_; }
  void set_d_wr_s_cnt(uint32_t value) { d_wr_s_cnt_ = value; _has_field_.set(8); }

  bool has_d_wr_s_peak() const { return _has_field_[9]; }
  uint32_t d_wr_s_peak() const { return d_wr_s_peak_; }
  void set_d_wr_s_peak(uint32_t value) { d_wr_s_peak_ = value; _has_field_.set(9); }

  bool has_dev() const { return _has_field_[10]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(10); }

  bool has_m_rd_avg() const { return _has_field_[11]; }
  uint32_t m_rd_avg() const { return m_rd_avg_; }
  void set_m_rd_avg(uint32_t value) { m_rd_avg_ = value; _has_field_.set(11); }

  bool has_m_rd_cnt() const { return _has_field_[12]; }
  uint32_t m_rd_cnt() const { return m_rd_cnt_; }
  void set_m_rd_cnt(uint32_t value) { m_rd_cnt_ = value; _has_field_.set(12); }

  bool has_m_rd_peak() const { return _has_field_[13]; }
  uint32_t m_rd_peak() const { return m_rd_peak_; }
  void set_m_rd_peak(uint32_t value) { m_rd_peak_ = value; _has_field_.set(13); }

  bool has_m_wr_as_avg() const { return _has_field_[14]; }
  uint32_t m_wr_as_avg() const { return m_wr_as_avg_; }
  void set_m_wr_as_avg(uint32_t value) { m_wr_as_avg_ = value; _has_field_.set(14); }

  bool has_m_wr_as_cnt() const { return _has_field_[15]; }
  uint32_t m_wr_as_cnt() const { return m_wr_as_cnt_; }
  void set_m_wr_as_cnt(uint32_t value) { m_wr_as_cnt_ = value; _has_field_.set(15); }

  bool has_m_wr_as_peak() const { return _has_field_[16]; }
  uint32_t m_wr_as_peak() const { return m_wr_as_peak_; }
  void set_m_wr_as_peak(uint32_t value) { m_wr_as_peak_ = value; _has_field_.set(16); }

  bool has_m_wr_s_avg() const { return _has_field_[17]; }
  uint32_t m_wr_s_avg() const { return m_wr_s_avg_; }
  void set_m_wr_s_avg(uint32_t value) { m_wr_s_avg_ = value; _has_field_.set(17); }

  bool has_m_wr_s_cnt() const { return _has_field_[18]; }
  uint32_t m_wr_s_cnt() const { return m_wr_s_cnt_; }
  void set_m_wr_s_cnt(uint32_t value) { m_wr_s_cnt_ = value; _has_field_.set(18); }

  bool has_m_wr_s_peak() const { return _has_field_[19]; }
  uint32_t m_wr_s_peak() const { return m_wr_s_peak_; }
  void set_m_wr_s_peak(uint32_t value) { m_wr_s_peak_ = value; _has_field_.set(19); }

  bool has_n_rd_avg() const { return _has_field_[20]; }
  uint32_t n_rd_avg() const { return n_rd_avg_; }
  void set_n_rd_avg(uint32_t value) { n_rd_avg_ = value; _has_field_.set(20); }

  bool has_n_rd_cnt() const { return _has_field_[21]; }
  uint32_t n_rd_cnt() const { return n_rd_cnt_; }
  void set_n_rd_cnt(uint32_t value) { n_rd_cnt_ = value; _has_field_.set(21); }

  bool has_n_rd_peak() const { return _has_field_[22]; }
  uint32_t n_rd_peak() const { return n_rd_peak_; }
  void set_n_rd_peak(uint32_t value) { n_rd_peak_ = value; _has_field_.set(22); }

  bool has_n_wr_as_avg() const { return _has_field_[23]; }
  uint32_t n_wr_as_avg() const { return n_wr_as_avg_; }
  void set_n_wr_as_avg(uint32_t value) { n_wr_as_avg_ = value; _has_field_.set(23); }

  bool has_n_wr_as_cnt() const { return _has_field_[24]; }
  uint32_t n_wr_as_cnt() const { return n_wr_as_cnt_; }
  void set_n_wr_as_cnt(uint32_t value) { n_wr_as_cnt_ = value; _has_field_.set(24); }

  bool has_n_wr_as_peak() const { return _has_field_[25]; }
  uint32_t n_wr_as_peak() const { return n_wr_as_peak_; }
  void set_n_wr_as_peak(uint32_t value) { n_wr_as_peak_ = value; _has_field_.set(25); }

  bool has_n_wr_s_avg() const { return _has_field_[26]; }
  uint32_t n_wr_s_avg() const { return n_wr_s_avg_; }
  void set_n_wr_s_avg(uint32_t value) { n_wr_s_avg_ = value; _has_field_.set(26); }

  bool has_n_wr_s_cnt() const { return _has_field_[27]; }
  uint32_t n_wr_s_cnt() const { return n_wr_s_cnt_; }
  void set_n_wr_s_cnt(uint32_t value) { n_wr_s_cnt_ = value; _has_field_.set(27); }

  bool has_n_wr_s_peak() const { return _has_field_[28]; }
  uint32_t n_wr_s_peak() const { return n_wr_s_peak_; }
  void set_n_wr_s_peak(uint32_t value) { n_wr_s_peak_ = value; _has_field_.set(28); }

 private:
  uint32_t d_rd_avg_{};
  uint32_t d_rd_cnt_{};
  uint32_t d_rd_peak_{};
  uint32_t d_wr_as_avg_{};
  uint32_t d_wr_as_cnt_{};
  uint32_t d_wr_as_peak_{};
  uint32_t d_wr_s_avg_{};
  uint32_t d_wr_s_cnt_{};
  uint32_t d_wr_s_peak_{};
  uint64_t dev_{};
  uint32_t m_rd_avg_{};
  uint32_t m_rd_cnt_{};
  uint32_t m_rd_peak_{};
  uint32_t m_wr_as_avg_{};
  uint32_t m_wr_as_cnt_{};
  uint32_t m_wr_as_peak_{};
  uint32_t m_wr_s_avg_{};
  uint32_t m_wr_s_cnt_{};
  uint32_t m_wr_s_peak_{};
  uint32_t n_rd_avg_{};
  uint32_t n_rd_cnt_{};
  uint32_t n_rd_peak_{};
  uint32_t n_wr_as_avg_{};
  uint32_t n_wr_as_cnt_{};
  uint32_t n_wr_as_peak_{};
  uint32_t n_wr_s_avg_{};
  uint32_t n_wr_s_cnt_{};
  uint32_t n_wr_s_peak_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<29> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT F2fsIostatFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kAppBioFieldNumber = 1,
    kAppBrioFieldNumber = 2,
    kAppDioFieldNumber = 3,
    kAppDrioFieldNumber = 4,
    kAppMioFieldNumber = 5,
    kAppMrioFieldNumber = 6,
    kAppRioFieldNumber = 7,
    kAppWioFieldNumber = 8,
    kDevFieldNumber = 9,
    kFsCdrioFieldNumber = 10,
    kFsCpDioFieldNumber = 11,
    kFsCpMioFieldNumber = 12,
    kFsCpNioFieldNumber = 13,
    kFsDioFieldNumber = 14,
    kFsDiscardFieldNumber = 15,
    kFsDrioFieldNumber = 16,
    kFsGcDioFieldNumber = 17,
    kFsGcNioFieldNumber = 18,
    kFsGdrioFieldNumber = 19,
    kFsMioFieldNumber = 20,
    kFsMrioFieldNumber = 21,
    kFsNioFieldNumber = 22,
    kFsNrioFieldNumber = 23,
  };

  F2fsIostatFtraceEvent();
  ~F2fsIostatFtraceEvent() override;
  F2fsIostatFtraceEvent(F2fsIostatFtraceEvent&&) noexcept;
  F2fsIostatFtraceEvent& operator=(F2fsIostatFtraceEvent&&);
  F2fsIostatFtraceEvent(const F2fsIostatFtraceEvent&);
  F2fsIostatFtraceEvent& operator=(const F2fsIostatFtraceEvent&);
  bool operator==(const F2fsIostatFtraceEvent&) const;
  bool operator!=(const F2fsIostatFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_app_bio() const { return _has_field_[1]; }
  uint64_t app_bio() const { return app_bio_; }
  void set_app_bio(uint64_t value) { app_bio_ = value; _has_field_.set(1); }

  bool has_app_brio() const { return _has_field_[2]; }
  uint64_t app_brio() const { return app_brio_; }
  void set_app_brio(uint64_t value) { app_brio_ = value; _has_field_.set(2); }

  bool has_app_dio() const { return _has_field_[3]; }
  uint64_t app_dio() const { return app_dio_; }
  void set_app_dio(uint64_t value) { app_dio_ = value; _has_field_.set(3); }

  bool has_app_drio() const { return _has_field_[4]; }
  uint64_t app_drio() const { return app_drio_; }
  void set_app_drio(uint64_t value) { app_drio_ = value; _has_field_.set(4); }

  bool has_app_mio() const { return _has_field_[5]; }
  uint64_t app_mio() const { return app_mio_; }
  void set_app_mio(uint64_t value) { app_mio_ = value; _has_field_.set(5); }

  bool has_app_mrio() const { return _has_field_[6]; }
  uint64_t app_mrio() const { return app_mrio_; }
  void set_app_mrio(uint64_t value) { app_mrio_ = value; _has_field_.set(6); }

  bool has_app_rio() const { return _has_field_[7]; }
  uint64_t app_rio() const { return app_rio_; }
  void set_app_rio(uint64_t value) { app_rio_ = value; _has_field_.set(7); }

  bool has_app_wio() const { return _has_field_[8]; }
  uint64_t app_wio() const { return app_wio_; }
  void set_app_wio(uint64_t value) { app_wio_ = value; _has_field_.set(8); }

  bool has_dev() const { return _has_field_[9]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(9); }

  bool has_fs_cdrio() const { return _has_field_[10]; }
  uint64_t fs_cdrio() const { return fs_cdrio_; }
  void set_fs_cdrio(uint64_t value) { fs_cdrio_ = value; _has_field_.set(10); }

  bool has_fs_cp_dio() const { return _has_field_[11]; }
  uint64_t fs_cp_dio() const { return fs_cp_dio_; }
  void set_fs_cp_dio(uint64_t value) { fs_cp_dio_ = value; _has_field_.set(11); }

  bool has_fs_cp_mio() const { return _has_field_[12]; }
  uint64_t fs_cp_mio() const { return fs_cp_mio_; }
  void set_fs_cp_mio(uint64_t value) { fs_cp_mio_ = value; _has_field_.set(12); }

  bool has_fs_cp_nio() const { return _has_field_[13]; }
  uint64_t fs_cp_nio() const { return fs_cp_nio_; }
  void set_fs_cp_nio(uint64_t value) { fs_cp_nio_ = value; _has_field_.set(13); }

  bool has_fs_dio() const { return _has_field_[14]; }
  uint64_t fs_dio() const { return fs_dio_; }
  void set_fs_dio(uint64_t value) { fs_dio_ = value; _has_field_.set(14); }

  bool has_fs_discard() const { return _has_field_[15]; }
  uint64_t fs_discard() const { return fs_discard_; }
  void set_fs_discard(uint64_t value) { fs_discard_ = value; _has_field_.set(15); }

  bool has_fs_drio() const { return _has_field_[16]; }
  uint64_t fs_drio() const { return fs_drio_; }
  void set_fs_drio(uint64_t value) { fs_drio_ = value; _has_field_.set(16); }

  bool has_fs_gc_dio() const { return _has_field_[17]; }
  uint64_t fs_gc_dio() const { return fs_gc_dio_; }
  void set_fs_gc_dio(uint64_t value) { fs_gc_dio_ = value; _has_field_.set(17); }

  bool has_fs_gc_nio() const { return _has_field_[18]; }
  uint64_t fs_gc_nio() const { return fs_gc_nio_; }
  void set_fs_gc_nio(uint64_t value) { fs_gc_nio_ = value; _has_field_.set(18); }

  bool has_fs_gdrio() const { return _has_field_[19]; }
  uint64_t fs_gdrio() const { return fs_gdrio_; }
  void set_fs_gdrio(uint64_t value) { fs_gdrio_ = value; _has_field_.set(19); }

  bool has_fs_mio() const { return _has_field_[20]; }
  uint64_t fs_mio() const { return fs_mio_; }
  void set_fs_mio(uint64_t value) { fs_mio_ = value; _has_field_.set(20); }

  bool has_fs_mrio() const { return _has_field_[21]; }
  uint64_t fs_mrio() const { return fs_mrio_; }
  void set_fs_mrio(uint64_t value) { fs_mrio_ = value; _has_field_.set(21); }

  bool has_fs_nio() const { return _has_field_[22]; }
  uint64_t fs_nio() const { return fs_nio_; }
  void set_fs_nio(uint64_t value) { fs_nio_ = value; _has_field_.set(22); }

  bool has_fs_nrio() const { return _has_field_[23]; }
  uint64_t fs_nrio() const { return fs_nrio_; }
  void set_fs_nrio(uint64_t value) { fs_nrio_ = value; _has_field_.set(23); }

 private:
  uint64_t app_bio_{};
  uint64_t app_brio_{};
  uint64_t app_dio_{};
  uint64_t app_drio_{};
  uint64_t app_mio_{};
  uint64_t app_mrio_{};
  uint64_t app_rio_{};
  uint64_t app_wio_{};
  uint64_t dev_{};
  uint64_t fs_cdrio_{};
  uint64_t fs_cp_dio_{};
  uint64_t fs_cp_mio_{};
  uint64_t fs_cp_nio_{};
  uint64_t fs_dio_{};
  uint64_t fs_discard_{};
  uint64_t fs_drio_{};
  uint64_t fs_gc_dio_{};
  uint64_t fs_gc_nio_{};
  uint64_t fs_gdrio_{};
  uint64_t fs_mio_{};
  uint64_t fs_mrio_{};
  uint64_t fs_nio_{};
  uint64_t fs_nrio_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<24> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT F2fsWriteEndFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kCopiedFieldNumber = 5,
  };

  F2fsWriteEndFtraceEvent();
  ~F2fsWriteEndFtraceEvent() override;
  F2fsWriteEndFtraceEvent(F2fsWriteEndFtraceEvent&&) noexcept;
  F2fsWriteEndFtraceEvent& operator=(F2fsWriteEndFtraceEvent&&);
  F2fsWriteEndFtraceEvent(const F2fsWriteEndFtraceEvent&);
  F2fsWriteEndFtraceEvent& operator=(const F2fsWriteEndFtraceEvent&);
  bool operator==(const F2fsWriteEndFtraceEvent&) const;
  bool operator!=(const F2fsWriteEndFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_pos() const { return _has_field_[3]; }
  int64_t pos() const { return pos_; }
  void set_pos(int64_t value) { pos_ = value; _has_field_.set(3); }

  bool has_len() const { return _has_field_[4]; }
  uint32_t len() const { return len_; }
  void set_len(uint32_t value) { len_ = value; _has_field_.set(4); }

  bool has_copied() const { return _has_field_[5]; }
  uint32_t copied() const { return copied_; }
  void set_copied(uint32_t value) { copied_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int64_t pos_{};
  uint32_t len_{};
  uint32_t copied_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT F2fsWriteCheckpointFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kIsUmountFieldNumber = 2,
    kMsgFieldNumber = 3,
    kReasonFieldNumber = 4,
  };

  F2fsWriteCheckpointFtraceEvent();
  ~F2fsWriteCheckpointFtraceEvent() override;
  F2fsWriteCheckpointFtraceEvent(F2fsWriteCheckpointFtraceEvent&&) noexcept;
  F2fsWriteCheckpointFtraceEvent& operator=(F2fsWriteCheckpointFtraceEvent&&);
  F2fsWriteCheckpointFtraceEvent(const F2fsWriteCheckpointFtraceEvent&);
  F2fsWriteCheckpointFtraceEvent& operator=(const F2fsWriteCheckpointFtraceEvent&);
  bool operator==(const F2fsWriteCheckpointFtraceEvent&) const;
  bool operator!=(const F2fsWriteCheckpointFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_is_umount() const { return _has_field_[2]; }
  uint32_t is_umount() const { return is_umount_; }
  void set_is_umount(uint32_t value) { is_umount_ = value; _has_field_.set(2); }

  bool has_msg() const { return _has_field_[3]; }
  const std::string& msg() const { return msg_; }
  void set_msg(const std::string& value) { msg_ = value; _has_field_.set(3); }

  bool has_reason() const { return _has_field_[4]; }
  int32_t reason() const { return reason_; }
  void set_reason(int32_t value) { reason_ = value; _has_field_.set(4); }

 private:
  uint64_t dev_{};
  uint32_t is_umount_{};
  std::string msg_{};
  int32_t reason_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT F2fsWriteBeginFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kFlagsFieldNumber = 5,
  };

  F2fsWriteBeginFtraceEvent();
  ~F2fsWriteBeginFtraceEvent() override;
  F2fsWriteBeginFtraceEvent(F2fsWriteBeginFtraceEvent&&) noexcept;
  F2fsWriteBeginFtraceEvent& operator=(F2fsWriteBeginFtraceEvent&&);
  F2fsWriteBeginFtraceEvent(const F2fsWriteBeginFtraceEvent&);
  F2fsWriteBeginFtraceEvent& operator=(const F2fsWriteBeginFtraceEvent&);
  bool operator==(const F2fsWriteBeginFtraceEvent&) const;
  bool operator!=(const F2fsWriteBeginFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_pos() const { return _has_field_[3]; }
  int64_t pos() const { return pos_; }
  void set_pos(int64_t value) { pos_ = value; _has_field_.set(3); }

  bool has_len() const { return _has_field_[4]; }
  uint32_t len() const { return len_; }
  void set_len(uint32_t value) { len_ = value; _has_field_.set(4); }

  bool has_flags() const { return _has_field_[5]; }
  uint32_t flags() const { return flags_; }
  void set_flags(uint32_t value) { flags_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int64_t pos_{};
  uint32_t len_{};
  uint32_t flags_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT F2fsVmPageMkwriteFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kTypeFieldNumber = 3,
    kDirFieldNumber = 4,
    kIndexFieldNumber = 5,
    kDirtyFieldNumber = 6,
    kUptodateFieldNumber = 7,
  };

  F2fsVmPageMkwriteFtraceEvent();
  ~F2fsVmPageMkwriteFtraceEvent() override;
  F2fsVmPageMkwriteFtraceEvent(F2fsVmPageMkwriteFtraceEvent&&) noexcept;
  F2fsVmPageMkwriteFtraceEvent& operator=(F2fsVmPageMkwriteFtraceEvent&&);
  F2fsVmPageMkwriteFtraceEvent(const F2fsVmPageMkwriteFtraceEvent&);
  F2fsVmPageMkwriteFtraceEvent& operator=(const F2fsVmPageMkwriteFtraceEvent&);
  bool operator==(const F2fsVmPageMkwriteFtraceEvent&) const;
  bool operator!=(const F2fsVmPageMkwriteFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_type() const { return _has_field_[3]; }
  int32_t type() const { return type_; }
  void set_type(int32_t value) { type_ = value; _has_field_.set(3); }

  bool has_dir() const { return _has_field_[4]; }
  int32_t dir() const { return dir_; }
  void set_dir(int32_t value) { dir_ = value; _has_field_.set(4); }

  bool has_index() const { return _has_field_[5]; }
  uint64_t index() const { return index_; }
  void set_index(uint64_t value) { index_ = value; _has_field_.set(5); }

  bool has_dirty() const { return _has_field_[6]; }
  int32_t dirty() const { return dirty_; }
  void set_dirty(int32_t value) { dirty_ = value; _has_field_.set(6); }

  bool has_uptodate() const { return _has_field_[7]; }
  int32_t uptodate() const { return uptodate_; }
  void set_uptodate(int32_t value) { uptodate_ = value; _has_field_.set(7); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int32_t type_{};
  int32_t dir_{};
  uint64_t index_{};
  int32_t dirty_{};
  int32_t uptodate_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<8> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT F2fsUnlinkExitFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };

  F2fsUnlinkExitFtraceEvent();
  ~F2fsUnlinkExitFtraceEvent() override;
  F2fsUnlinkExitFtraceEvent(F2fsUnlinkExitFtraceEvent&&) noexcept;
  F2fsUnlinkExitFtraceEvent& operator=(F2fsUnlinkExitFtraceEvent&&);
  F2fsUnlinkExitFtraceEvent(const F2fsUnlinkExitFtraceEvent&);
  F2fsUnlinkExitFtraceEvent& operator=(const F2fsUnlinkExitFtraceEvent&);
  bool operator==(const F2fsUnlinkExitFtraceEvent&) const;
  bool operator!=(const F2fsUnlinkExitFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_ret() const { return _has_field_[3]; }
  int32_t ret() const { return ret_; }
  void set_ret(int32_t value) { ret_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int32_t ret_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT F2fsUnlinkEnterFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kSizeFieldNumber = 3,
    kBlocksFieldNumber = 4,
    kNameFieldNumber = 5,
  };

  F2fsUnlinkEnterFtraceEvent();
  ~F2fsUnlinkEnterFtraceEvent() override;
  F2fsUnlinkEnterFtraceEvent(F2fsUnlinkEnterFtraceEvent&&) noexcept;
  F2fsUnlinkEnterFtraceEvent& operator=(F2fsUnlinkEnterFtraceEvent&&);
  F2fsUnlinkEnterFtraceEvent(const F2fsUnlinkEnterFtraceEvent&);
  F2fsUnlinkEnterFtraceEvent& operator=(const F2fsUnlinkEnterFtraceEvent&);
  bool operator==(const F2fsUnlinkEnterFtraceEvent&) const;
  bool operator!=(const F2fsUnlinkEnterFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_size() const { return _has_field_[3]; }
  int64_t size() const { return size_; }
  void set_size(int64_t value) { size_ = value; _has_field_.set(3); }

  bool has_blocks() const { return _has_field_[4]; }
  uint64_t blocks() const { return blocks_; }
  void set_blocks(uint64_t value) { blocks_ = value; _has_field_.set(4); }

  bool has_name() const { return _has_field_[5]; }
  const std::string& name() const { return name_; }
  void set_name(const std::string& value) { name_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int64_t size_{};
  uint64_t blocks_{};
  std::string name_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT F2fsTruncatePartialNodesFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNidFieldNumber = 3,
    kDepthFieldNumber = 4,
    kErrFieldNumber = 5,
  };

  F2fsTruncatePartialNodesFtraceEvent();
  ~F2fsTruncatePartialNodesFtraceEvent() override;
  F2fsTruncatePartialNodesFtraceEvent(F2fsTruncatePartialNodesFtraceEvent&&) noexcept;
  F2fsTruncatePartialNodesFtraceEvent& operator=(F2fsTruncatePartialNodesFtraceEvent&&);
  F2fsTruncatePartialNodesFtraceEvent(const F2fsTruncatePartialNodesFtraceEvent&);
  F2fsTruncatePartialNodesFtraceEvent& operator=(const F2fsTruncatePartialNodesFtraceEvent&);
  bool operator==(const F2fsTruncatePartialNodesFtraceEvent&) const;
  bool operator!=(const F2fsTruncatePartialNodesFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_nid() const { return _has_field_[3]; }
  uint32_t nid() const { return nid_; }
  void set_nid(uint32_t value) { nid_ = value; _has_field_.set(3); }

  bool has_depth() const { return _has_field_[4]; }
  int32_t depth() const { return depth_; }
  void set_depth(int32_t value) { depth_ = value; _has_field_.set(4); }

  bool has_err() const { return _has_field_[5]; }
  int32_t err() const { return err_; }
  void set_err(int32_t value) { err_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint32_t nid_{};
  int32_t depth_{};
  int32_t err_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT F2fsTruncateNodesExitFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };

  F2fsTruncateNodesExitFtraceEvent();
  ~F2fsTruncateNodesExitFtraceEvent() override;
  F2fsTruncateNodesExitFtraceEvent(F2fsTruncateNodesExitFtraceEvent&&) noexcept;
  F2fsTruncateNodesExitFtraceEvent& operator=(F2fsTruncateNodesExitFtraceEvent&&);
  F2fsTruncateNodesExitFtraceEvent(const F2fsTruncateNodesExitFtraceEvent&);
  F2fsTruncateNodesExitFtraceEvent& operator=(const F2fsTruncateNodesExitFtraceEvent&);
  bool operator==(const F2fsTruncateNodesExitFtraceEvent&) const;
  bool operator!=(const F2fsTruncateNodesExitFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_ret() const { return _has_field_[3]; }
  int32_t ret() const { return ret_; }
  void set_ret(int32_t value) { ret_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int32_t ret_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT F2fsTruncateNodesEnterFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNidFieldNumber = 3,
    kBlkAddrFieldNumber = 4,
  };

  F2fsTruncateNodesEnterFtraceEvent();
  ~F2fsTruncateNodesEnterFtraceEvent() override;
  F2fsTruncateNodesEnterFtraceEvent(F2fsTruncateNodesEnterFtraceEvent&&) noexcept;
  F2fsTruncateNodesEnterFtraceEvent& operator=(F2fsTruncateNodesEnterFtraceEvent&&);
  F2fsTruncateNodesEnterFtraceEvent(const F2fsTruncateNodesEnterFtraceEvent&);
  F2fsTruncateNodesEnterFtraceEvent& operator=(const F2fsTruncateNodesEnterFtraceEvent&);
  bool operator==(const F2fsTruncateNodesEnterFtraceEvent&) const;
  bool operator!=(const F2fsTruncateNodesEnterFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_nid() const { return _has_field_[3]; }
  uint32_t nid() const { return nid_; }
  void set_nid(uint32_t value) { nid_ = value; _has_field_.set(3); }

  bool has_blk_addr() const { return _has_field_[4]; }
  uint32_t blk_addr() const { return blk_addr_; }
  void set_blk_addr(uint32_t value) { blk_addr_ = value; _has_field_.set(4); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint32_t nid_{};
  uint32_t blk_addr_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT F2fsTruncateNodeFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNidFieldNumber = 3,
    kBlkAddrFieldNumber = 4,
  };

  F2fsTruncateNodeFtraceEvent();
  ~F2fsTruncateNodeFtraceEvent() override;
  F2fsTruncateNodeFtraceEvent(F2fsTruncateNodeFtraceEvent&&) noexcept;
  F2fsTruncateNodeFtraceEvent& operator=(F2fsTruncateNodeFtraceEvent&&);
  F2fsTruncateNodeFtraceEvent(const F2fsTruncateNodeFtraceEvent&);
  F2fsTruncateNodeFtraceEvent& operator=(const F2fsTruncateNodeFtraceEvent&);
  bool operator==(const F2fsTruncateNodeFtraceEvent&) const;
  bool operator!=(const F2fsTruncateNodeFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_nid() const { return _has_field_[3]; }
  uint32_t nid() const { return nid_; }
  void set_nid(uint32_t value) { nid_ = value; _has_field_.set(3); }

  bool has_blk_addr() const { return _has_field_[4]; }
  uint32_t blk_addr() const { return blk_addr_; }
  void set_blk_addr(uint32_t value) { blk_addr_ = value; _has_field_.set(4); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint32_t nid_{};
  uint32_t blk_addr_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT F2fsTruncateInodeBlocksExitFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };

  F2fsTruncateInodeBlocksExitFtraceEvent();
  ~F2fsTruncateInodeBlocksExitFtraceEvent() override;
  F2fsTruncateInodeBlocksExitFtraceEvent(F2fsTruncateInodeBlocksExitFtraceEvent&&) noexcept;
  F2fsTruncateInodeBlocksExitFtraceEvent& operator=(F2fsTruncateInodeBlocksExitFtraceEvent&&);
  F2fsTruncateInodeBlocksExitFtraceEvent(const F2fsTruncateInodeBlocksExitFtraceEvent&);
  F2fsTruncateInodeBlocksExitFtraceEvent& operator=(const F2fsTruncateInodeBlocksExitFtraceEvent&);
  bool operator==(const F2fsTruncateInodeBlocksExitFtraceEvent&) const;
  bool operator!=(const F2fsTruncateInodeBlocksExitFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_ret() const { return _has_field_[3]; }
  int32_t ret() const { return ret_; }
  void set_ret(int32_t value) { ret_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int32_t ret_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT F2fsTruncateInodeBlocksEnterFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kSizeFieldNumber = 3,
    kBlocksFieldNumber = 4,
    kFromFieldNumber = 5,
  };

  F2fsTruncateInodeBlocksEnterFtraceEvent();
  ~F2fsTruncateInodeBlocksEnterFtraceEvent() override;
  F2fsTruncateInodeBlocksEnterFtraceEvent(F2fsTruncateInodeBlocksEnterFtraceEvent&&) noexcept;
  F2fsTruncateInodeBlocksEnterFtraceEvent& operator=(F2fsTruncateInodeBlocksEnterFtraceEvent&&);
  F2fsTruncateInodeBlocksEnterFtraceEvent(const F2fsTruncateInodeBlocksEnterFtraceEvent&);
  F2fsTruncateInodeBlocksEnterFtraceEvent& operator=(const F2fsTruncateInodeBlocksEnterFtraceEvent&);
  bool operator==(const F2fsTruncateInodeBlocksEnterFtraceEvent&) const;
  bool operator!=(const F2fsTruncateInodeBlocksEnterFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_size() const { return _has_field_[3]; }
  int64_t size() const { return size_; }
  void set_size(int64_t value) { size_ = value; _has_field_.set(3); }

  bool has_blocks() const { return _has_field_[4]; }
  uint64_t blocks() const { return blocks_; }
  void set_blocks(uint64_t value) { blocks_ = value; _has_field_.set(4); }

  bool has_from() const { return _has_field_[5]; }
  uint64_t from() const { return from_; }
  void set_from(uint64_t value) { from_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int64_t size_{};
  uint64_t blocks_{};
  uint64_t from_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT F2fsTruncateDataBlocksRangeFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNidFieldNumber = 3,
    kOfsFieldNumber = 4,
    kFreeFieldNumber = 5,
  };

  F2fsTruncateDataBlocksRangeFtraceEvent();
  ~F2fsTruncateDataBlocksRangeFtraceEvent() override;
  F2fsTruncateDataBlocksRangeFtraceEvent(F2fsTruncateDataBlocksRangeFtraceEvent&&) noexcept;
  F2fsTruncateDataBlocksRangeFtraceEvent& operator=(F2fsTruncateDataBlocksRangeFtraceEvent&&);
  F2fsTruncateDataBlocksRangeFtraceEvent(const F2fsTruncateDataBlocksRangeFtraceEvent&);
  F2fsTruncateDataBlocksRangeFtraceEvent& operator=(const F2fsTruncateDataBlocksRangeFtraceEvent&);
  bool operator==(const F2fsTruncateDataBlocksRangeFtraceEvent&) const;
  bool operator!=(const F2fsTruncateDataBlocksRangeFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_nid() const { return _has_field_[3]; }
  uint32_t nid() const { return nid_; }
  void set_nid(uint32_t value) { nid_ = value; _has_field_.set(3); }

  bool has_ofs() const { return _has_field_[4]; }
  uint32_t ofs() const { return ofs_; }
  void set_ofs(uint32_t value) { ofs_ = value; _has_field_.set(4); }

  bool has_free() const { return _has_field_[5]; }
  int32_t free() const { return free_; }
  void set_free(int32_t value) { free_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint32_t nid_{};
  uint32_t ofs_{};
  int32_t free_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT F2fsTruncateBlocksExitFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };

  F2fsTruncateBlocksExitFtraceEvent();
  ~F2fsTruncateBlocksExitFtraceEvent() override;
  F2fsTruncateBlocksExitFtraceEvent(F2fsTruncateBlocksExitFtraceEvent&&) noexcept;
  F2fsTruncateBlocksExitFtraceEvent& operator=(F2fsTruncateBlocksExitFtraceEvent&&);
  F2fsTruncateBlocksExitFtraceEvent(const F2fsTruncateBlocksExitFtraceEvent&);
  F2fsTruncateBlocksExitFtraceEvent& operator=(const F2fsTruncateBlocksExitFtraceEvent&);
  bool operator==(const F2fsTruncateBlocksExitFtraceEvent&) const;
  bool operator!=(const F2fsTruncateBlocksExitFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_ret() const { return _has_field_[3]; }
  int32_t ret() const { return ret_; }
  void set_ret(int32_t value) { ret_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int32_t ret_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT F2fsTruncateBlocksEnterFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kSizeFieldNumber = 3,
    kBlocksFieldNumber = 4,
    kFromFieldNumber = 5,
  };

  F2fsTruncateBlocksEnterFtraceEvent();
  ~F2fsTruncateBlocksEnterFtraceEvent() override;
  F2fsTruncateBlocksEnterFtraceEvent(F2fsTruncateBlocksEnterFtraceEvent&&) noexcept;
  F2fsTruncateBlocksEnterFtraceEvent& operator=(F2fsTruncateBlocksEnterFtraceEvent&&);
  F2fsTruncateBlocksEnterFtraceEvent(const F2fsTruncateBlocksEnterFtraceEvent&);
  F2fsTruncateBlocksEnterFtraceEvent& operator=(const F2fsTruncateBlocksEnterFtraceEvent&);
  bool operator==(const F2fsTruncateBlocksEnterFtraceEvent&) const;
  bool operator!=(const F2fsTruncateBlocksEnterFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_size() const { return _has_field_[3]; }
  int64_t size() const { return size_; }
  void set_size(int64_t value) { size_ = value; _has_field_.set(3); }

  bool has_blocks() const { return _has_field_[4]; }
  uint64_t blocks() const { return blocks_; }
  void set_blocks(uint64_t value) { blocks_ = value; _has_field_.set(4); }

  bool has_from() const { return _has_field_[5]; }
  uint64_t from() const { return from_; }
  void set_from(uint64_t value) { from_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int64_t size_{};
  uint64_t blocks_{};
  uint64_t from_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT F2fsTruncateFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPinoFieldNumber = 3,
    kModeFieldNumber = 4,
    kSizeFieldNumber = 5,
    kNlinkFieldNumber = 6,
    kBlocksFieldNumber = 7,
    kAdviseFieldNumber = 8,
  };

  F2fsTruncateFtraceEvent();
  ~F2fsTruncateFtraceEvent() override;
  F2fsTruncateFtraceEvent(F2fsTruncateFtraceEvent&&) noexcept;
  F2fsTruncateFtraceEvent& operator=(F2fsTruncateFtraceEvent&&);
  F2fsTruncateFtraceEvent(const F2fsTruncateFtraceEvent&);
  F2fsTruncateFtraceEvent& operator=(const F2fsTruncateFtraceEvent&);
  bool operator==(const F2fsTruncateFtraceEvent&) const;
  bool operator!=(const F2fsTruncateFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_pino() const { return _has_field_[3]; }
  uint64_t pino() const { return pino_; }
  void set_pino(uint64_t value) { pino_ = value; _has_field_.set(3); }

  bool has_mode() const { return _has_field_[4]; }
  uint32_t mode() const { return mode_; }
  void set_mode(uint32_t value) { mode_ = value; _has_field_.set(4); }

  bool has_size() const { return _has_field_[5]; }
  int64_t size() const { return size_; }
  void set_size(int64_t value) { size_ = value; _has_field_.set(5); }

  bool has_nlink() const { return _has_field_[6]; }
  uint32_t nlink() const { return nlink_; }
  void set_nlink(uint32_t value) { nlink_ = value; _has_field_.set(6); }

  bool has_blocks() const { return _has_field_[7]; }
  uint64_t blocks() const { return blocks_; }
  void set_blocks(uint64_t value) { blocks_ = value; _has_field_.set(7); }

  bool has_advise() const { return _has_field_[8]; }
  uint32_t advise() const { return advise_; }
  void set_advise(uint32_t value) { advise_ = value; _has_field_.set(8); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t pino_{};
  uint32_t mode_{};
  int64_t size_{};
  uint32_t nlink_{};
  uint64_t blocks_{};
  uint32_t advise_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<9> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT F2fsSyncFsFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kDirtyFieldNumber = 2,
    kWaitFieldNumber = 3,
  };

  F2fsSyncFsFtraceEvent();
  ~F2fsSyncFsFtraceEvent() override;
  F2fsSyncFsFtraceEvent(F2fsSyncFsFtraceEvent&&) noexcept;
  F2fsSyncFsFtraceEvent& operator=(F2fsSyncFsFtraceEvent&&);
  F2fsSyncFsFtraceEvent(const F2fsSyncFsFtraceEvent&);
  F2fsSyncFsFtraceEvent& operator=(const F2fsSyncFsFtraceEvent&);
  bool operator==(const F2fsSyncFsFtraceEvent&) const;
  bool operator!=(const F2fsSyncFsFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_dirty() const { return _has_field_[2]; }
  int32_t dirty() const { return dirty_; }
  void set_dirty(int32_t value) { dirty_ = value; _has_field_.set(2); }

  bool has_wait() const { return _has_field_[3]; }
  int32_t wait() const { return wait_; }
  void set_wait(int32_t value) { wait_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  int32_t dirty_{};
  int32_t wait_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT F2fsSyncFileExitFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNeedCpFieldNumber = 3,
    kDatasyncFieldNumber = 4,
    kRetFieldNumber = 5,
    kCpReasonFieldNumber = 6,
  };

  F2fsSyncFileExitFtraceEvent();
  ~F2fsSyncFileExitFtraceEvent() override;
  F2fsSyncFileExitFtraceEvent(F2fsSyncFileExitFtraceEvent&&) noexcept;
  F2fsSyncFileExitFtraceEvent& operator=(F2fsSyncFileExitFtraceEvent&&);
  F2fsSyncFileExitFtraceEvent(const F2fsSyncFileExitFtraceEvent&);
  F2fsSyncFileExitFtraceEvent& operator=(const F2fsSyncFileExitFtraceEvent&);
  bool operator==(const F2fsSyncFileExitFtraceEvent&) const;
  bool operator!=(const F2fsSyncFileExitFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_need_cp() const { return _has_field_[3]; }
  uint32_t need_cp() const { return need_cp_; }
  void set_need_cp(uint32_t value) { need_cp_ = value; _has_field_.set(3); }

  bool has_datasync() const { return _has_field_[4]; }
  int32_t datasync() const { return datasync_; }
  void set_datasync(int32_t value) { datasync_ = value; _has_field_.set(4); }

  bool has_ret() const { return _has_field_[5]; }
  int32_t ret() const { return ret_; }
  void set_ret(int32_t value) { ret_ = value; _has_field_.set(5); }

  bool has_cp_reason() const { return _has_field_[6]; }
  int32_t cp_reason() const { return cp_reason_; }
  void set_cp_reason(int32_t value) { cp_reason_ = value; _has_field_.set(6); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint32_t need_cp_{};
  int32_t datasync_{};
  int32_t ret_{};
  int32_t cp_reason_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<7> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT F2fsSyncFileEnterFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPinoFieldNumber = 3,
    kModeFieldNumber = 4,
    kSizeFieldNumber = 5,
    kNlinkFieldNumber = 6,
    kBlocksFieldNumber = 7,
    kAdviseFieldNumber = 8,
  };

  F2fsSyncFileEnterFtraceEvent();
  ~F2fsSyncFileEnterFtraceEvent() override;
  F2fsSyncFileEnterFtraceEvent(F2fsSyncFileEnterFtraceEvent&&) noexcept;
  F2fsSyncFileEnterFtraceEvent& operator=(F2fsSyncFileEnterFtraceEvent&&);
  F2fsSyncFileEnterFtraceEvent(const F2fsSyncFileEnterFtraceEvent&);
  F2fsSyncFileEnterFtraceEvent& operator=(const F2fsSyncFileEnterFtraceEvent&);
  bool operator==(const F2fsSyncFileEnterFtraceEvent&) const;
  bool operator!=(const F2fsSyncFileEnterFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_pino() const { return _has_field_[3]; }
  uint64_t pino() const { return pino_; }
  void set_pino(uint64_t value) { pino_ = value; _has_field_.set(3); }

  bool has_mode() const { return _has_field_[4]; }
  uint32_t mode() const { return mode_; }
  void set_mode(uint32_t value) { mode_ = value; _has_field_.set(4); }

  bool has_size() const { return _has_field_[5]; }
  int64_t size() const { return size_; }
  void set_size(int64_t value) { size_ = value; _has_field_.set(5); }

  bool has_nlink() const { return _has_field_[6]; }
  uint32_t nlink() const { return nlink_; }
  void set_nlink(uint32_t value) { nlink_ = value; _has_field_.set(6); }

  bool has_blocks() const { return _has_field_[7]; }
  uint64_t blocks() const { return blocks_; }
  void set_blocks(uint64_t value) { blocks_ = value; _has_field_.set(7); }

  bool has_advise() const { return _has_field_[8]; }
  uint32_t advise() const { return advise_; }
  void set_advise(uint32_t value) { advise_ = value; _has_field_.set(8); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t pino_{};
  uint32_t mode_{};
  int64_t size_{};
  uint32_t nlink_{};
  uint64_t blocks_{};
  uint32_t advise_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<9> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT F2fsSubmitWritePageFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kTypeFieldNumber = 3,
    kIndexFieldNumber = 4,
    kBlockFieldNumber = 5,
  };

  F2fsSubmitWritePageFtraceEvent();
  ~F2fsSubmitWritePageFtraceEvent() override;
  F2fsSubmitWritePageFtraceEvent(F2fsSubmitWritePageFtraceEvent&&) noexcept;
  F2fsSubmitWritePageFtraceEvent& operator=(F2fsSubmitWritePageFtraceEvent&&);
  F2fsSubmitWritePageFtraceEvent(const F2fsSubmitWritePageFtraceEvent&);
  F2fsSubmitWritePageFtraceEvent& operator=(const F2fsSubmitWritePageFtraceEvent&);
  bool operator==(const F2fsSubmitWritePageFtraceEvent&) const;
  bool operator!=(const F2fsSubmitWritePageFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_type() const { return _has_field_[3]; }
  int32_t type() const { return type_; }
  void set_type(int32_t value) { type_ = value; _has_field_.set(3); }

  bool has_index() const { return _has_field_[4]; }
  uint64_t index() const { return index_; }
  void set_index(uint64_t value) { index_ = value; _has_field_.set(4); }

  bool has_block() const { return _has_field_[5]; }
  uint32_t block() const { return block_; }
  void set_block(uint32_t value) { block_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int32_t type_{};
  uint64_t index_{};
  uint32_t block_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT F2fsSetPageDirtyFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kTypeFieldNumber = 3,
    kDirFieldNumber = 4,
    kIndexFieldNumber = 5,
    kDirtyFieldNumber = 6,
    kUptodateFieldNumber = 7,
  };

  F2fsSetPageDirtyFtraceEvent();
  ~F2fsSetPageDirtyFtraceEvent() override;
  F2fsSetPageDirtyFtraceEvent(F2fsSetPageDirtyFtraceEvent&&) noexcept;
  F2fsSetPageDirtyFtraceEvent& operator=(F2fsSetPageDirtyFtraceEvent&&);
  F2fsSetPageDirtyFtraceEvent(const F2fsSetPageDirtyFtraceEvent&);
  F2fsSetPageDirtyFtraceEvent& operator=(const F2fsSetPageDirtyFtraceEvent&);
  bool operator==(const F2fsSetPageDirtyFtraceEvent&) const;
  bool operator!=(const F2fsSetPageDirtyFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_type() const { return _has_field_[3]; }
  int32_t type() const { return type_; }
  void set_type(int32_t value) { type_ = value; _has_field_.set(3); }

  bool has_dir() const { return _has_field_[4]; }
  int32_t dir() const { return dir_; }
  void set_dir(int32_t value) { dir_ = value; _has_field_.set(4); }

  bool has_index() const { return _has_field_[5]; }
  uint64_t index() const { return index_; }
  void set_index(uint64_t value) { index_ = value; _has_field_.set(5); }

  bool has_dirty() const { return _has_field_[6]; }
  int32_t dirty() const { return dirty_; }
  void set_dirty(int32_t value) { dirty_ = value; _has_field_.set(6); }

  bool has_uptodate() const { return _has_field_[7]; }
  int32_t uptodate() const { return uptodate_; }
  void set_uptodate(int32_t value) { uptodate_ = value; _has_field_.set(7); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int32_t type_{};
  int32_t dir_{};
  uint64_t index_{};
  int32_t dirty_{};
  int32_t uptodate_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<8> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT F2fsReserveNewBlockFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kNidFieldNumber = 2,
    kOfsInNodeFieldNumber = 3,
  };

  F2fsReserveNewBlockFtraceEvent();
  ~F2fsReserveNewBlockFtraceEvent() override;
  F2fsReserveNewBlockFtraceEvent(F2fsReserveNewBlockFtraceEvent&&) noexcept;
  F2fsReserveNewBlockFtraceEvent& operator=(F2fsReserveNewBlockFtraceEvent&&);
  F2fsReserveNewBlockFtraceEvent(const F2fsReserveNewBlockFtraceEvent&);
  F2fsReserveNewBlockFtraceEvent& operator=(const F2fsReserveNewBlockFtraceEvent&);
  bool operator==(const F2fsReserveNewBlockFtraceEvent&) const;
  bool operator!=(const F2fsReserveNewBlockFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_nid() const { return _has_field_[2]; }
  uint32_t nid() const { return nid_; }
  void set_nid(uint32_t value) { nid_ = value; _has_field_.set(2); }

  bool has_ofs_in_node() const { return _has_field_[3]; }
  uint32_t ofs_in_node() const { return ofs_in_node_; }
  void set_ofs_in_node(uint32_t value) { ofs_in_node_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  uint32_t nid_{};
  uint32_t ofs_in_node_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT F2fsReadpageFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIndexFieldNumber = 3,
    kBlkaddrFieldNumber = 4,
    kTypeFieldNumber = 5,
    kDirFieldNumber = 6,
    kDirtyFieldNumber = 7,
    kUptodateFieldNumber = 8,
  };

  F2fsReadpageFtraceEvent();
  ~F2fsReadpageFtraceEvent() override;
  F2fsReadpageFtraceEvent(F2fsReadpageFtraceEvent&&) noexcept;
  F2fsReadpageFtraceEvent& operator=(F2fsReadpageFtraceEvent&&);
  F2fsReadpageFtraceEvent(const F2fsReadpageFtraceEvent&);
  F2fsReadpageFtraceEvent& operator=(const F2fsReadpageFtraceEvent&);
  bool operator==(const F2fsReadpageFtraceEvent&) const;
  bool operator!=(const F2fsReadpageFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_index() const { return _has_field_[3]; }
  uint64_t index() const { return index_; }
  void set_index(uint64_t value) { index_ = value; _has_field_.set(3); }

  bool has_blkaddr() const { return _has_field_[4]; }
  uint64_t blkaddr() const { return blkaddr_; }
  void set_blkaddr(uint64_t value) { blkaddr_ = value; _has_field_.set(4); }

  bool has_type() const { return _has_field_[5]; }
  int32_t type() const { return type_; }
  void set_type(int32_t value) { type_ = value; _has_field_.set(5); }

  bool has_dir() const { return _has_field_[6]; }
  int32_t dir() const { return dir_; }
  void set_dir(int32_t value) { dir_ = value; _has_field_.set(6); }

  bool has_dirty() const { return _has_field_[7]; }
  int32_t dirty() const { return dirty_; }
  void set_dirty(int32_t value) { dirty_ = value; _has_field_.set(7); }

  bool has_uptodate() const { return _has_field_[8]; }
  int32_t uptodate() const { return uptodate_; }
  void set_uptodate(int32_t value) { uptodate_ = value; _has_field_.set(8); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t index_{};
  uint64_t blkaddr_{};
  int32_t type_{};
  int32_t dir_{};
  int32_t dirty_{};
  int32_t uptodate_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<9> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT F2fsNewInodeFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };

  F2fsNewInodeFtraceEvent();
  ~F2fsNewInodeFtraceEvent() override;
  F2fsNewInodeFtraceEvent(F2fsNewInodeFtraceEvent&&) noexcept;
  F2fsNewInodeFtraceEvent& operator=(F2fsNewInodeFtraceEvent&&);
  F2fsNewInodeFtraceEvent(const F2fsNewInodeFtraceEvent&);
  F2fsNewInodeFtraceEvent& operator=(const F2fsNewInodeFtraceEvent&);
  bool operator==(const F2fsNewInodeFtraceEvent&) const;
  bool operator!=(const F2fsNewInodeFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_ret() const { return _has_field_[3]; }
  int32_t ret() const { return ret_; }
  void set_ret(int32_t value) { ret_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int32_t ret_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT F2fsIgetExitFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };

  F2fsIgetExitFtraceEvent();
  ~F2fsIgetExitFtraceEvent() override;
  F2fsIgetExitFtraceEvent(F2fsIgetExitFtraceEvent&&) noexcept;
  F2fsIgetExitFtraceEvent& operator=(F2fsIgetExitFtraceEvent&&);
  F2fsIgetExitFtraceEvent(const F2fsIgetExitFtraceEvent&);
  F2fsIgetExitFtraceEvent& operator=(const F2fsIgetExitFtraceEvent&);
  bool operator==(const F2fsIgetExitFtraceEvent&) const;
  bool operator!=(const F2fsIgetExitFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_ret() const { return _has_field_[3]; }
  int32_t ret() const { return ret_; }
  void set_ret(int32_t value) { ret_ = value; _has_field_.set(3); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int32_t ret_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT F2fsIgetFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPinoFieldNumber = 3,
    kModeFieldNumber = 4,
    kSizeFieldNumber = 5,
    kNlinkFieldNumber = 6,
    kBlocksFieldNumber = 7,
    kAdviseFieldNumber = 8,
  };

  F2fsIgetFtraceEvent();
  ~F2fsIgetFtraceEvent() override;
  F2fsIgetFtraceEvent(F2fsIgetFtraceEvent&&) noexcept;
  F2fsIgetFtraceEvent& operator=(F2fsIgetFtraceEvent&&);
  F2fsIgetFtraceEvent(const F2fsIgetFtraceEvent&);
  F2fsIgetFtraceEvent& operator=(const F2fsIgetFtraceEvent&);
  bool operator==(const F2fsIgetFtraceEvent&) const;
  bool operator!=(const F2fsIgetFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_pino() const { return _has_field_[3]; }
  uint64_t pino() const { return pino_; }
  void set_pino(uint64_t value) { pino_ = value; _has_field_.set(3); }

  bool has_mode() const { return _has_field_[4]; }
  uint32_t mode() const { return mode_; }
  void set_mode(uint32_t value) { mode_ = value; _has_field_.set(4); }

  bool has_size() const { return _has_field_[5]; }
  int64_t size() const { return size_; }
  void set_size(int64_t value) { size_ = value; _has_field_.set(5); }

  bool has_nlink() const { return _has_field_[6]; }
  uint32_t nlink() const { return nlink_; }
  void set_nlink(uint32_t value) { nlink_ = value; _has_field_.set(6); }

  bool has_blocks() const { return _has_field_[7]; }
  uint64_t blocks() const { return blocks_; }
  void set_blocks(uint64_t value) { blocks_ = value; _has_field_.set(7); }

  bool has_advise() const { return _has_field_[8]; }
  uint32_t advise() const { return advise_; }
  void set_advise(uint32_t value) { advise_ = value; _has_field_.set(8); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t pino_{};
  uint32_t mode_{};
  int64_t size_{};
  uint32_t nlink_{};
  uint64_t blocks_{};
  uint32_t advise_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<9> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT F2fsGetVictimFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kTypeFieldNumber = 2,
    kGcTypeFieldNumber = 3,
    kAllocModeFieldNumber = 4,
    kGcModeFieldNumber = 5,
    kVictimFieldNumber = 6,
    kOfsUnitFieldNumber = 7,
    kPreVictimFieldNumber = 8,
    kPrefreeFieldNumber = 9,
    kFreeFieldNumber = 10,
    kCostFieldNumber = 11,
  };

  F2fsGetVictimFtraceEvent();
  ~F2fsGetVictimFtraceEvent() override;
  F2fsGetVictimFtraceEvent(F2fsGetVictimFtraceEvent&&) noexcept;
  F2fsGetVictimFtraceEvent& operator=(F2fsGetVictimFtraceEvent&&);
  F2fsGetVictimFtraceEvent(const F2fsGetVictimFtraceEvent&);
  F2fsGetVictimFtraceEvent& operator=(const F2fsGetVictimFtraceEvent&);
  bool operator==(const F2fsGetVictimFtraceEvent&) const;
  bool operator!=(const F2fsGetVictimFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_type() const { return _has_field_[2]; }
  int32_t type() const { return type_; }
  void set_type(int32_t value) { type_ = value; _has_field_.set(2); }

  bool has_gc_type() const { return _has_field_[3]; }
  int32_t gc_type() const { return gc_type_; }
  void set_gc_type(int32_t value) { gc_type_ = value; _has_field_.set(3); }

  bool has_alloc_mode() const { return _has_field_[4]; }
  int32_t alloc_mode() const { return alloc_mode_; }
  void set_alloc_mode(int32_t value) { alloc_mode_ = value; _has_field_.set(4); }

  bool has_gc_mode() const { return _has_field_[5]; }
  int32_t gc_mode() const { return gc_mode_; }
  void set_gc_mode(int32_t value) { gc_mode_ = value; _has_field_.set(5); }

  bool has_victim() const { return _has_field_[6]; }
  uint32_t victim() const { return victim_; }
  void set_victim(uint32_t value) { victim_ = value; _has_field_.set(6); }

  bool has_ofs_unit() const { return _has_field_[7]; }
  uint32_t ofs_unit() const { return ofs_unit_; }
  void set_ofs_unit(uint32_t value) { ofs_unit_ = value; _has_field_.set(7); }

  bool has_pre_victim() const { return _has_field_[8]; }
  uint32_t pre_victim() const { return pre_victim_; }
  void set_pre_victim(uint32_t value) { pre_victim_ = value; _has_field_.set(8); }

  bool has_prefree() const { return _has_field_[9]; }
  uint32_t prefree() const { return prefree_; }
  void set_prefree(uint32_t value) { prefree_ = value; _has_field_.set(9); }

  bool has_free() const { return _has_field_[10]; }
  uint32_t free() const { return free_; }
  void set_free(uint32_t value) { free_ = value; _has_field_.set(10); }

  bool has_cost() const { return _has_field_[11]; }
  uint32_t cost() const { return cost_; }
  void set_cost(uint32_t value) { cost_ = value; _has_field_.set(11); }

 private:
  uint64_t dev_{};
  int32_t type_{};
  int32_t gc_type_{};
  int32_t alloc_mode_{};
  int32_t gc_mode_{};
  uint32_t victim_{};
  uint32_t ofs_unit_{};
  uint32_t pre_victim_{};
  uint32_t prefree_{};
  uint32_t free_{};
  uint32_t cost_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<12> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT F2fsGetDataBlockFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIblockFieldNumber = 3,
    kBhStartFieldNumber = 4,
    kBhSizeFieldNumber = 5,
    kRetFieldNumber = 6,
  };

  F2fsGetDataBlockFtraceEvent();
  ~F2fsGetDataBlockFtraceEvent() override;
  F2fsGetDataBlockFtraceEvent(F2fsGetDataBlockFtraceEvent&&) noexcept;
  F2fsGetDataBlockFtraceEvent& operator=(F2fsGetDataBlockFtraceEvent&&);
  F2fsGetDataBlockFtraceEvent(const F2fsGetDataBlockFtraceEvent&);
  F2fsGetDataBlockFtraceEvent& operator=(const F2fsGetDataBlockFtraceEvent&);
  bool operator==(const F2fsGetDataBlockFtraceEvent&) const;
  bool operator!=(const F2fsGetDataBlockFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_iblock() const { return _has_field_[3]; }
  uint64_t iblock() const { return iblock_; }
  void set_iblock(uint64_t value) { iblock_ = value; _has_field_.set(3); }

  bool has_bh_start() const { return _has_field_[4]; }
  uint64_t bh_start() const { return bh_start_; }
  void set_bh_start(uint64_t value) { bh_start_ = value; _has_field_.set(4); }

  bool has_bh_size() const { return _has_field_[5]; }
  uint64_t bh_size() const { return bh_size_; }
  void set_bh_size(uint64_t value) { bh_size_ = value; _has_field_.set(5); }

  bool has_ret() const { return _has_field_[6]; }
  int32_t ret() const { return ret_; }
  void set_ret(int32_t value) { ret_ = value; _has_field_.set(6); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t iblock_{};
  uint64_t bh_start_{};
  uint64_t bh_size_{};
  int32_t ret_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<7> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT F2fsFallocateFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kModeFieldNumber = 3,
    kOffsetFieldNumber = 4,
    kLenFieldNumber = 5,
    kSizeFieldNumber = 6,
    kBlocksFieldNumber = 7,
    kRetFieldNumber = 8,
  };

  F2fsFallocateFtraceEvent();
  ~F2fsFallocateFtraceEvent() override;
  F2fsFallocateFtraceEvent(F2fsFallocateFtraceEvent&&) noexcept;
  F2fsFallocateFtraceEvent& operator=(F2fsFallocateFtraceEvent&&);
  F2fsFallocateFtraceEvent(const F2fsFallocateFtraceEvent&);
  F2fsFallocateFtraceEvent& operator=(const F2fsFallocateFtraceEvent&);
  bool operator==(const F2fsFallocateFtraceEvent&) const;
  bool operator!=(const F2fsFallocateFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_mode() const { return _has_field_[3]; }
  int32_t mode() const { return mode_; }
  void set_mode(int32_t value) { mode_ = value; _has_field_.set(3); }

  bool has_offset() const { return _has_field_[4]; }
  int64_t offset() const { return offset_; }
  void set_offset(int64_t value) { offset_ = value; _has_field_.set(4); }

  bool has_len() const { return _has_field_[5]; }
  int64_t len() const { return len_; }
  void set_len(int64_t value) { len_ = value; _has_field_.set(5); }

  bool has_size() const { return _has_field_[6]; }
  int64_t size() const { return size_; }
  void set_size(int64_t value) { size_ = value; _has_field_.set(6); }

  bool has_blocks() const { return _has_field_[7]; }
  uint64_t blocks() const { return blocks_; }
  void set_blocks(uint64_t value) { blocks_ = value; _has_field_.set(7); }

  bool has_ret() const { return _has_field_[8]; }
  int32_t ret() const { return ret_; }
  void set_ret(int32_t value) { ret_ = value; _has_field_.set(8); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  int32_t mode_{};
  int64_t offset_{};
  int64_t len_{};
  int64_t size_{};
  uint64_t blocks_{};
  int32_t ret_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<9> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT F2fsEvictInodeFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPinoFieldNumber = 3,
    kModeFieldNumber = 4,
    kSizeFieldNumber = 5,
    kNlinkFieldNumber = 6,
    kBlocksFieldNumber = 7,
    kAdviseFieldNumber = 8,
  };

  F2fsEvictInodeFtraceEvent();
  ~F2fsEvictInodeFtraceEvent() override;
  F2fsEvictInodeFtraceEvent(F2fsEvictInodeFtraceEvent&&) noexcept;
  F2fsEvictInodeFtraceEvent& operator=(F2fsEvictInodeFtraceEvent&&);
  F2fsEvictInodeFtraceEvent(const F2fsEvictInodeFtraceEvent&);
  F2fsEvictInodeFtraceEvent& operator=(const F2fsEvictInodeFtraceEvent&);
  bool operator==(const F2fsEvictInodeFtraceEvent&) const;
  bool operator!=(const F2fsEvictInodeFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_ino() const { return _has_field_[2]; }
  uint64_t ino() const { return ino_; }
  void set_ino(uint64_t value) { ino_ = value; _has_field_.set(2); }

  bool has_pino() const { return _has_field_[3]; }
  uint64_t pino() const { return pino_; }
  void set_pino(uint64_t value) { pino_ = value; _has_field_.set(3); }

  bool has_mode() const { return _has_field_[4]; }
  uint32_t mode() const { return mode_; }
  void set_mode(uint32_t value) { mode_ = value; _has_field_.set(4); }

  bool has_size() const { return _has_field_[5]; }
  int64_t size() const { return size_; }
  void set_size(int64_t value) { size_ = value; _has_field_.set(5); }

  bool has_nlink() const { return _has_field_[6]; }
  uint32_t nlink() const { return nlink_; }
  void set_nlink(uint32_t value) { nlink_ = value; _has_field_.set(6); }

  bool has_blocks() const { return _has_field_[7]; }
  uint64_t blocks() const { return blocks_; }
  void set_blocks(uint64_t value) { blocks_ = value; _has_field_.set(7); }

  bool has_advise() const { return _has_field_[8]; }
  uint32_t advise() const { return advise_; }
  void set_advise(uint32_t value) { advise_ = value; _has_field_.set(8); }

 private:
  uint64_t dev_{};
  uint64_t ino_{};
  uint64_t pino_{};
  uint32_t mode_{};
  int64_t size_{};
  uint32_t nlink_{};
  uint64_t blocks_{};
  uint32_t advise_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<9> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT F2fsDoSubmitBioFtraceEvent : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDevFieldNumber = 1,
    kBtypeFieldNumber = 2,
    kSyncFieldNumber = 3,
    kSectorFieldNumber = 4,
    kSizeFieldNumber = 5,
  };

  F2fsDoSubmitBioFtraceEvent();
  ~F2fsDoSubmitBioFtraceEvent() override;
  F2fsDoSubmitBioFtraceEvent(F2fsDoSubmitBioFtraceEvent&&) noexcept;
  F2fsDoSubmitBioFtraceEvent& operator=(F2fsDoSubmitBioFtraceEvent&&);
  F2fsDoSubmitBioFtraceEvent(const F2fsDoSubmitBioFtraceEvent&);
  F2fsDoSubmitBioFtraceEvent& operator=(const F2fsDoSubmitBioFtraceEvent&);
  bool operator==(const F2fsDoSubmitBioFtraceEvent&) const;
  bool operator!=(const F2fsDoSubmitBioFtraceEvent& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_dev() const { return _has_field_[1]; }
  uint64_t dev() const { return dev_; }
  void set_dev(uint64_t value) { dev_ = value; _has_field_.set(1); }

  bool has_btype() const { return _has_field_[2]; }
  int32_t btype() const { return btype_; }
  void set_btype(int32_t value) { btype_ = value; _has_field_.set(2); }

  bool has_sync() const { return _has_field_[3]; }
  uint32_t sync() const { return sync_; }
  void set_sync(uint32_t value) { sync_ = value; _has_field_.set(3); }

  bool has_sector() const { return _has_field_[4]; }
  uint64_t sector() const { return sector_; }
  void set_sector(uint64_t value) { sector_ = value; _has_field_.set(4); }

  bool has_size() const { return _has_field_[5]; }
  uint32_t size() const { return size_; }
  void set_size(uint32_t value) { size_ = value; _has_field_.set(5); }

 private:
  uint64_t dev_{};
  int32_t btype_{};
  uint32_t sync_{};
  uint64_t sector_{};
  uint32_t size_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_F2FS_PROTO_CPP_H_
