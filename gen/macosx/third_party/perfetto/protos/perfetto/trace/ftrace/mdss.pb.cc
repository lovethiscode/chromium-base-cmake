// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/trace/ftrace/mdss.proto

#include "protos/perfetto/trace/ftrace/mdss.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace perfetto {
namespace protos {
PROTOBUF_CONSTEXPR MdpCmdKickoffFtraceEvent::MdpCmdKickoffFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ctl_num_)*/0u
  , /*decltype(_impl_.kickoff_cnt_)*/0} {}
struct MdpCmdKickoffFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MdpCmdKickoffFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MdpCmdKickoffFtraceEventDefaultTypeInternal() {}
  union {
    MdpCmdKickoffFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MdpCmdKickoffFtraceEventDefaultTypeInternal _MdpCmdKickoffFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR MdpCommitFtraceEvent::MdpCommitFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.num_)*/0u
  , /*decltype(_impl_.play_cnt_)*/0u
  , /*decltype(_impl_.bandwidth_)*/uint64_t{0u}
  , /*decltype(_impl_.clk_rate_)*/0u} {}
struct MdpCommitFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MdpCommitFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MdpCommitFtraceEventDefaultTypeInternal() {}
  union {
    MdpCommitFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MdpCommitFtraceEventDefaultTypeInternal _MdpCommitFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR MdpPerfSetOtFtraceEvent::MdpPerfSetOtFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pnum_)*/0u
  , /*decltype(_impl_.xin_id_)*/0u
  , /*decltype(_impl_.rd_lim_)*/0u
  , /*decltype(_impl_.is_vbif_rt_)*/0u} {}
struct MdpPerfSetOtFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MdpPerfSetOtFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MdpPerfSetOtFtraceEventDefaultTypeInternal() {}
  union {
    MdpPerfSetOtFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MdpPerfSetOtFtraceEventDefaultTypeInternal _MdpPerfSetOtFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR MdpSsppChangeFtraceEvent::MdpSsppChangeFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.num_)*/0u
  , /*decltype(_impl_.play_cnt_)*/0u
  , /*decltype(_impl_.mixer_)*/0u
  , /*decltype(_impl_.stage_)*/0u
  , /*decltype(_impl_.flags_)*/0u
  , /*decltype(_impl_.format_)*/0u
  , /*decltype(_impl_.img_w_)*/0u
  , /*decltype(_impl_.img_h_)*/0u
  , /*decltype(_impl_.src_x_)*/0u
  , /*decltype(_impl_.src_y_)*/0u
  , /*decltype(_impl_.src_w_)*/0u
  , /*decltype(_impl_.src_h_)*/0u
  , /*decltype(_impl_.dst_x_)*/0u
  , /*decltype(_impl_.dst_y_)*/0u
  , /*decltype(_impl_.dst_w_)*/0u
  , /*decltype(_impl_.dst_h_)*/0u} {}
struct MdpSsppChangeFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MdpSsppChangeFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MdpSsppChangeFtraceEventDefaultTypeInternal() {}
  union {
    MdpSsppChangeFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MdpSsppChangeFtraceEventDefaultTypeInternal _MdpSsppChangeFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR TracingMarkWriteFtraceEvent::TracingMarkWriteFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.trace_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pid_)*/0
  , /*decltype(_impl_.trace_begin_)*/0u} {}
struct TracingMarkWriteFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TracingMarkWriteFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TracingMarkWriteFtraceEventDefaultTypeInternal() {}
  union {
    TracingMarkWriteFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TracingMarkWriteFtraceEventDefaultTypeInternal _TracingMarkWriteFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR MdpCmdPingpongDoneFtraceEvent::MdpCmdPingpongDoneFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ctl_num_)*/0u
  , /*decltype(_impl_.intf_num_)*/0u
  , /*decltype(_impl_.pp_num_)*/0u
  , /*decltype(_impl_.koff_cnt_)*/0} {}
struct MdpCmdPingpongDoneFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MdpCmdPingpongDoneFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MdpCmdPingpongDoneFtraceEventDefaultTypeInternal() {}
  union {
    MdpCmdPingpongDoneFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MdpCmdPingpongDoneFtraceEventDefaultTypeInternal _MdpCmdPingpongDoneFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR MdpCompareBwFtraceEvent::MdpCompareBwFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.new_ab_)*/uint64_t{0u}
  , /*decltype(_impl_.new_ib_)*/uint64_t{0u}
  , /*decltype(_impl_.new_wb_)*/uint64_t{0u}
  , /*decltype(_impl_.old_ab_)*/uint64_t{0u}
  , /*decltype(_impl_.old_ib_)*/uint64_t{0u}
  , /*decltype(_impl_.old_wb_)*/uint64_t{0u}
  , /*decltype(_impl_.params_changed_)*/0u
  , /*decltype(_impl_.update_bw_)*/0u} {}
struct MdpCompareBwFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MdpCompareBwFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MdpCompareBwFtraceEventDefaultTypeInternal() {}
  union {
    MdpCompareBwFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MdpCompareBwFtraceEventDefaultTypeInternal _MdpCompareBwFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR MdpPerfSetPanicLutsFtraceEvent::MdpPerfSetPanicLutsFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pnum_)*/0u
  , /*decltype(_impl_.fmt_)*/0u
  , /*decltype(_impl_.mode_)*/0u
  , /*decltype(_impl_.panic_lut_)*/0u
  , /*decltype(_impl_.robust_lut_)*/0u} {}
struct MdpPerfSetPanicLutsFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MdpPerfSetPanicLutsFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MdpPerfSetPanicLutsFtraceEventDefaultTypeInternal() {}
  union {
    MdpPerfSetPanicLutsFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MdpPerfSetPanicLutsFtraceEventDefaultTypeInternal _MdpPerfSetPanicLutsFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR MdpSsppSetFtraceEvent::MdpSsppSetFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.num_)*/0u
  , /*decltype(_impl_.play_cnt_)*/0u
  , /*decltype(_impl_.mixer_)*/0u
  , /*decltype(_impl_.stage_)*/0u
  , /*decltype(_impl_.flags_)*/0u
  , /*decltype(_impl_.format_)*/0u
  , /*decltype(_impl_.img_w_)*/0u
  , /*decltype(_impl_.img_h_)*/0u
  , /*decltype(_impl_.src_x_)*/0u
  , /*decltype(_impl_.src_y_)*/0u
  , /*decltype(_impl_.src_w_)*/0u
  , /*decltype(_impl_.src_h_)*/0u
  , /*decltype(_impl_.dst_x_)*/0u
  , /*decltype(_impl_.dst_y_)*/0u
  , /*decltype(_impl_.dst_w_)*/0u
  , /*decltype(_impl_.dst_h_)*/0u} {}
struct MdpSsppSetFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MdpSsppSetFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MdpSsppSetFtraceEventDefaultTypeInternal() {}
  union {
    MdpSsppSetFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MdpSsppSetFtraceEventDefaultTypeInternal _MdpSsppSetFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR MdpCmdReadptrDoneFtraceEvent::MdpCmdReadptrDoneFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ctl_num_)*/0u
  , /*decltype(_impl_.koff_cnt_)*/0} {}
struct MdpCmdReadptrDoneFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MdpCmdReadptrDoneFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MdpCmdReadptrDoneFtraceEventDefaultTypeInternal() {}
  union {
    MdpCmdReadptrDoneFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MdpCmdReadptrDoneFtraceEventDefaultTypeInternal _MdpCmdReadptrDoneFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR MdpMisrCrcFtraceEvent::MdpMisrCrcFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.block_id_)*/0u
  , /*decltype(_impl_.vsync_cnt_)*/0u
  , /*decltype(_impl_.crc_)*/0u} {}
struct MdpMisrCrcFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MdpMisrCrcFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MdpMisrCrcFtraceEventDefaultTypeInternal() {}
  union {
    MdpMisrCrcFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MdpMisrCrcFtraceEventDefaultTypeInternal _MdpMisrCrcFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR MdpPerfSetQosLutsFtraceEvent::MdpPerfSetQosLutsFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pnum_)*/0u
  , /*decltype(_impl_.fmt_)*/0u
  , /*decltype(_impl_.intf_)*/0u
  , /*decltype(_impl_.rot_)*/0u
  , /*decltype(_impl_.fl_)*/0u
  , /*decltype(_impl_.lut_)*/0u
  , /*decltype(_impl_.linear_)*/0u} {}
struct MdpPerfSetQosLutsFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MdpPerfSetQosLutsFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MdpPerfSetQosLutsFtraceEventDefaultTypeInternal() {}
  union {
    MdpPerfSetQosLutsFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MdpPerfSetQosLutsFtraceEventDefaultTypeInternal _MdpPerfSetQosLutsFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR MdpTraceCounterFtraceEvent::MdpTraceCounterFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.counter_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pid_)*/0
  , /*decltype(_impl_.value_)*/0} {}
struct MdpTraceCounterFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MdpTraceCounterFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MdpTraceCounterFtraceEventDefaultTypeInternal() {}
  union {
    MdpTraceCounterFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MdpTraceCounterFtraceEventDefaultTypeInternal _MdpTraceCounterFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR MdpCmdReleaseBwFtraceEvent::MdpCmdReleaseBwFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ctl_num_)*/0u} {}
struct MdpCmdReleaseBwFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MdpCmdReleaseBwFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MdpCmdReleaseBwFtraceEventDefaultTypeInternal() {}
  union {
    MdpCmdReleaseBwFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MdpCmdReleaseBwFtraceEventDefaultTypeInternal _MdpCmdReleaseBwFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR MdpMixerUpdateFtraceEvent::MdpMixerUpdateFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.mixer_num_)*/0u} {}
struct MdpMixerUpdateFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MdpMixerUpdateFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MdpMixerUpdateFtraceEventDefaultTypeInternal() {}
  union {
    MdpMixerUpdateFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MdpMixerUpdateFtraceEventDefaultTypeInternal _MdpMixerUpdateFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR MdpPerfSetWmLevelsFtraceEvent::MdpPerfSetWmLevelsFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pnum_)*/0u
  , /*decltype(_impl_.use_space_)*/0u
  , /*decltype(_impl_.priority_bytes_)*/0u
  , /*decltype(_impl_.wm0_)*/0u
  , /*decltype(_impl_.wm1_)*/0u
  , /*decltype(_impl_.wm2_)*/0u
  , /*decltype(_impl_.mb_cnt_)*/0u
  , /*decltype(_impl_.mb_size_)*/0u} {}
struct MdpPerfSetWmLevelsFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MdpPerfSetWmLevelsFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MdpPerfSetWmLevelsFtraceEventDefaultTypeInternal() {}
  union {
    MdpPerfSetWmLevelsFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MdpPerfSetWmLevelsFtraceEventDefaultTypeInternal _MdpPerfSetWmLevelsFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR MdpVideoUnderrunDoneFtraceEvent::MdpVideoUnderrunDoneFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ctl_num_)*/0u
  , /*decltype(_impl_.underrun_cnt_)*/0u} {}
struct MdpVideoUnderrunDoneFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MdpVideoUnderrunDoneFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MdpVideoUnderrunDoneFtraceEventDefaultTypeInternal() {}
  union {
    MdpVideoUnderrunDoneFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MdpVideoUnderrunDoneFtraceEventDefaultTypeInternal _MdpVideoUnderrunDoneFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR MdpCmdWaitPingpongFtraceEvent::MdpCmdWaitPingpongFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ctl_num_)*/0u
  , /*decltype(_impl_.kickoff_cnt_)*/0} {}
struct MdpCmdWaitPingpongFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MdpCmdWaitPingpongFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MdpCmdWaitPingpongFtraceEventDefaultTypeInternal() {}
  union {
    MdpCmdWaitPingpongFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MdpCmdWaitPingpongFtraceEventDefaultTypeInternal _MdpCmdWaitPingpongFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR MdpPerfPrefillCalcFtraceEvent::MdpPerfPrefillCalcFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pnum_)*/0u
  , /*decltype(_impl_.latency_buf_)*/0u
  , /*decltype(_impl_.ot_)*/0u
  , /*decltype(_impl_.y_buf_)*/0u
  , /*decltype(_impl_.y_scaler_)*/0u
  , /*decltype(_impl_.pp_lines_)*/0u
  , /*decltype(_impl_.pp_bytes_)*/0u
  , /*decltype(_impl_.post_sc_)*/0u
  , /*decltype(_impl_.fbc_bytes_)*/0u
  , /*decltype(_impl_.prefill_bytes_)*/0u} {}
struct MdpPerfPrefillCalcFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MdpPerfPrefillCalcFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MdpPerfPrefillCalcFtraceEventDefaultTypeInternal() {}
  union {
    MdpPerfPrefillCalcFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MdpPerfPrefillCalcFtraceEventDefaultTypeInternal _MdpPerfPrefillCalcFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR MdpPerfUpdateBusFtraceEvent::MdpPerfUpdateBusFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ab_quota_)*/uint64_t{0u}
  , /*decltype(_impl_.ib_quota_)*/uint64_t{0u}
  , /*decltype(_impl_.client_)*/0} {}
struct MdpPerfUpdateBusFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MdpPerfUpdateBusFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MdpPerfUpdateBusFtraceEventDefaultTypeInternal() {}
  union {
    MdpPerfUpdateBusFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MdpPerfUpdateBusFtraceEventDefaultTypeInternal _MdpPerfUpdateBusFtraceEvent_default_instance_;
PROTOBUF_CONSTEXPR RotatorBwAoAsContextFtraceEvent::RotatorBwAoAsContextFtraceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.state_)*/0u} {}
struct RotatorBwAoAsContextFtraceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RotatorBwAoAsContextFtraceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RotatorBwAoAsContextFtraceEventDefaultTypeInternal() {}
  union {
    RotatorBwAoAsContextFtraceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RotatorBwAoAsContextFtraceEventDefaultTypeInternal _RotatorBwAoAsContextFtraceEvent_default_instance_;
}  // namespace protos
}  // namespace perfetto
namespace perfetto {
namespace protos {

// ===================================================================

class MdpCmdKickoffFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MdpCmdKickoffFtraceEvent>()._impl_._has_bits_);
  static void set_has_ctl_num(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_kickoff_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

MdpCmdKickoffFtraceEvent::MdpCmdKickoffFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MdpCmdKickoffFtraceEvent)
}
MdpCmdKickoffFtraceEvent::MdpCmdKickoffFtraceEvent(const MdpCmdKickoffFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MdpCmdKickoffFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ctl_num_){}
    , decltype(_impl_.kickoff_cnt_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.ctl_num_, &from._impl_.ctl_num_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.kickoff_cnt_) -
    reinterpret_cast<char*>(&_impl_.ctl_num_)) + sizeof(_impl_.kickoff_cnt_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MdpCmdKickoffFtraceEvent)
}

inline void MdpCmdKickoffFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ctl_num_){0u}
    , decltype(_impl_.kickoff_cnt_){0}
  };
}

MdpCmdKickoffFtraceEvent::~MdpCmdKickoffFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MdpCmdKickoffFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MdpCmdKickoffFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MdpCmdKickoffFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MdpCmdKickoffFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MdpCmdKickoffFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.ctl_num_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.kickoff_cnt_) -
        reinterpret_cast<char*>(&_impl_.ctl_num_)) + sizeof(_impl_.kickoff_cnt_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MdpCmdKickoffFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 ctl_num = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ctl_num(&has_bits);
          _impl_.ctl_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 kickoff_cnt = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_kickoff_cnt(&has_bits);
          _impl_.kickoff_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MdpCmdKickoffFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MdpCmdKickoffFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 ctl_num = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_ctl_num(), target);
  }

  // optional int32 kickoff_cnt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_kickoff_cnt(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MdpCmdKickoffFtraceEvent)
  return target;
}

size_t MdpCmdKickoffFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MdpCmdKickoffFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 ctl_num = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ctl_num());
    }

    // optional int32 kickoff_cnt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_kickoff_cnt());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MdpCmdKickoffFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MdpCmdKickoffFtraceEvent*>(
      &from));
}

void MdpCmdKickoffFtraceEvent::MergeFrom(const MdpCmdKickoffFtraceEvent& from) {
  MdpCmdKickoffFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MdpCmdKickoffFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.ctl_num_ = from._impl_.ctl_num_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.kickoff_cnt_ = from._impl_.kickoff_cnt_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MdpCmdKickoffFtraceEvent::CopyFrom(const MdpCmdKickoffFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MdpCmdKickoffFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MdpCmdKickoffFtraceEvent::IsInitialized() const {
  return true;
}

void MdpCmdKickoffFtraceEvent::InternalSwap(MdpCmdKickoffFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MdpCmdKickoffFtraceEvent, _impl_.kickoff_cnt_)
      + sizeof(MdpCmdKickoffFtraceEvent::_impl_.kickoff_cnt_)
      - PROTOBUF_FIELD_OFFSET(MdpCmdKickoffFtraceEvent, _impl_.ctl_num_)>(
          reinterpret_cast<char*>(&_impl_.ctl_num_),
          reinterpret_cast<char*>(&other->_impl_.ctl_num_));
}

std::string MdpCmdKickoffFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MdpCmdKickoffFtraceEvent";
}


// ===================================================================

class MdpCommitFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MdpCommitFtraceEvent>()._impl_._has_bits_);
  static void set_has_num(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_play_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_clk_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_bandwidth(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

MdpCommitFtraceEvent::MdpCommitFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MdpCommitFtraceEvent)
}
MdpCommitFtraceEvent::MdpCommitFtraceEvent(const MdpCommitFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MdpCommitFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.num_){}
    , decltype(_impl_.play_cnt_){}
    , decltype(_impl_.bandwidth_){}
    , decltype(_impl_.clk_rate_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.num_, &from._impl_.num_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.clk_rate_) -
    reinterpret_cast<char*>(&_impl_.num_)) + sizeof(_impl_.clk_rate_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MdpCommitFtraceEvent)
}

inline void MdpCommitFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.num_){0u}
    , decltype(_impl_.play_cnt_){0u}
    , decltype(_impl_.bandwidth_){uint64_t{0u}}
    , decltype(_impl_.clk_rate_){0u}
  };
}

MdpCommitFtraceEvent::~MdpCommitFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MdpCommitFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MdpCommitFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MdpCommitFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MdpCommitFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MdpCommitFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.num_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.clk_rate_) -
        reinterpret_cast<char*>(&_impl_.num_)) + sizeof(_impl_.clk_rate_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MdpCommitFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 num = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_num(&has_bits);
          _impl_.num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 play_cnt = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_play_cnt(&has_bits);
          _impl_.play_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 clk_rate = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_clk_rate(&has_bits);
          _impl_.clk_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 bandwidth = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_bandwidth(&has_bits);
          _impl_.bandwidth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MdpCommitFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MdpCommitFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 num = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_num(), target);
  }

  // optional uint32 play_cnt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_play_cnt(), target);
  }

  // optional uint32 clk_rate = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_clk_rate(), target);
  }

  // optional uint64 bandwidth = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_bandwidth(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MdpCommitFtraceEvent)
  return target;
}

size_t MdpCommitFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MdpCommitFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint32 num = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num());
    }

    // optional uint32 play_cnt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_play_cnt());
    }

    // optional uint64 bandwidth = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_bandwidth());
    }

    // optional uint32 clk_rate = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_clk_rate());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MdpCommitFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MdpCommitFtraceEvent*>(
      &from));
}

void MdpCommitFtraceEvent::MergeFrom(const MdpCommitFtraceEvent& from) {
  MdpCommitFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MdpCommitFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.num_ = from._impl_.num_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.play_cnt_ = from._impl_.play_cnt_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.bandwidth_ = from._impl_.bandwidth_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.clk_rate_ = from._impl_.clk_rate_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MdpCommitFtraceEvent::CopyFrom(const MdpCommitFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MdpCommitFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MdpCommitFtraceEvent::IsInitialized() const {
  return true;
}

void MdpCommitFtraceEvent::InternalSwap(MdpCommitFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MdpCommitFtraceEvent, _impl_.clk_rate_)
      + sizeof(MdpCommitFtraceEvent::_impl_.clk_rate_)
      - PROTOBUF_FIELD_OFFSET(MdpCommitFtraceEvent, _impl_.num_)>(
          reinterpret_cast<char*>(&_impl_.num_),
          reinterpret_cast<char*>(&other->_impl_.num_));
}

std::string MdpCommitFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MdpCommitFtraceEvent";
}


// ===================================================================

class MdpPerfSetOtFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MdpPerfSetOtFtraceEvent>()._impl_._has_bits_);
  static void set_has_pnum(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_xin_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_rd_lim(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_vbif_rt(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

MdpPerfSetOtFtraceEvent::MdpPerfSetOtFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MdpPerfSetOtFtraceEvent)
}
MdpPerfSetOtFtraceEvent::MdpPerfSetOtFtraceEvent(const MdpPerfSetOtFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MdpPerfSetOtFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pnum_){}
    , decltype(_impl_.xin_id_){}
    , decltype(_impl_.rd_lim_){}
    , decltype(_impl_.is_vbif_rt_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.pnum_, &from._impl_.pnum_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_vbif_rt_) -
    reinterpret_cast<char*>(&_impl_.pnum_)) + sizeof(_impl_.is_vbif_rt_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MdpPerfSetOtFtraceEvent)
}

inline void MdpPerfSetOtFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pnum_){0u}
    , decltype(_impl_.xin_id_){0u}
    , decltype(_impl_.rd_lim_){0u}
    , decltype(_impl_.is_vbif_rt_){0u}
  };
}

MdpPerfSetOtFtraceEvent::~MdpPerfSetOtFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MdpPerfSetOtFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MdpPerfSetOtFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MdpPerfSetOtFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MdpPerfSetOtFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MdpPerfSetOtFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.pnum_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_vbif_rt_) -
        reinterpret_cast<char*>(&_impl_.pnum_)) + sizeof(_impl_.is_vbif_rt_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MdpPerfSetOtFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 pnum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_pnum(&has_bits);
          _impl_.pnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 xin_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_xin_id(&has_bits);
          _impl_.xin_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rd_lim = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_rd_lim(&has_bits);
          _impl_.rd_lim_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 is_vbif_rt = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_vbif_rt(&has_bits);
          _impl_.is_vbif_rt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MdpPerfSetOtFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MdpPerfSetOtFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 pnum = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_pnum(), target);
  }

  // optional uint32 xin_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_xin_id(), target);
  }

  // optional uint32 rd_lim = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_rd_lim(), target);
  }

  // optional uint32 is_vbif_rt = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_is_vbif_rt(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MdpPerfSetOtFtraceEvent)
  return target;
}

size_t MdpPerfSetOtFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MdpPerfSetOtFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint32 pnum = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_pnum());
    }

    // optional uint32 xin_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_xin_id());
    }

    // optional uint32 rd_lim = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rd_lim());
    }

    // optional uint32 is_vbif_rt = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_is_vbif_rt());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MdpPerfSetOtFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MdpPerfSetOtFtraceEvent*>(
      &from));
}

void MdpPerfSetOtFtraceEvent::MergeFrom(const MdpPerfSetOtFtraceEvent& from) {
  MdpPerfSetOtFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MdpPerfSetOtFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.pnum_ = from._impl_.pnum_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.xin_id_ = from._impl_.xin_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.rd_lim_ = from._impl_.rd_lim_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.is_vbif_rt_ = from._impl_.is_vbif_rt_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MdpPerfSetOtFtraceEvent::CopyFrom(const MdpPerfSetOtFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MdpPerfSetOtFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MdpPerfSetOtFtraceEvent::IsInitialized() const {
  return true;
}

void MdpPerfSetOtFtraceEvent::InternalSwap(MdpPerfSetOtFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MdpPerfSetOtFtraceEvent, _impl_.is_vbif_rt_)
      + sizeof(MdpPerfSetOtFtraceEvent::_impl_.is_vbif_rt_)
      - PROTOBUF_FIELD_OFFSET(MdpPerfSetOtFtraceEvent, _impl_.pnum_)>(
          reinterpret_cast<char*>(&_impl_.pnum_),
          reinterpret_cast<char*>(&other->_impl_.pnum_));
}

std::string MdpPerfSetOtFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MdpPerfSetOtFtraceEvent";
}


// ===================================================================

class MdpSsppChangeFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MdpSsppChangeFtraceEvent>()._impl_._has_bits_);
  static void set_has_num(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_play_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_mixer(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_stage(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_format(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_img_w(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_img_h(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_src_x(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_src_y(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_src_w(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_src_h(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_dst_x(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_dst_y(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_dst_w(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_dst_h(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
};

MdpSsppChangeFtraceEvent::MdpSsppChangeFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MdpSsppChangeFtraceEvent)
}
MdpSsppChangeFtraceEvent::MdpSsppChangeFtraceEvent(const MdpSsppChangeFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MdpSsppChangeFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.num_){}
    , decltype(_impl_.play_cnt_){}
    , decltype(_impl_.mixer_){}
    , decltype(_impl_.stage_){}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.format_){}
    , decltype(_impl_.img_w_){}
    , decltype(_impl_.img_h_){}
    , decltype(_impl_.src_x_){}
    , decltype(_impl_.src_y_){}
    , decltype(_impl_.src_w_){}
    , decltype(_impl_.src_h_){}
    , decltype(_impl_.dst_x_){}
    , decltype(_impl_.dst_y_){}
    , decltype(_impl_.dst_w_){}
    , decltype(_impl_.dst_h_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.num_, &from._impl_.num_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.dst_h_) -
    reinterpret_cast<char*>(&_impl_.num_)) + sizeof(_impl_.dst_h_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MdpSsppChangeFtraceEvent)
}

inline void MdpSsppChangeFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.num_){0u}
    , decltype(_impl_.play_cnt_){0u}
    , decltype(_impl_.mixer_){0u}
    , decltype(_impl_.stage_){0u}
    , decltype(_impl_.flags_){0u}
    , decltype(_impl_.format_){0u}
    , decltype(_impl_.img_w_){0u}
    , decltype(_impl_.img_h_){0u}
    , decltype(_impl_.src_x_){0u}
    , decltype(_impl_.src_y_){0u}
    , decltype(_impl_.src_w_){0u}
    , decltype(_impl_.src_h_){0u}
    , decltype(_impl_.dst_x_){0u}
    , decltype(_impl_.dst_y_){0u}
    , decltype(_impl_.dst_w_){0u}
    , decltype(_impl_.dst_h_){0u}
  };
}

MdpSsppChangeFtraceEvent::~MdpSsppChangeFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MdpSsppChangeFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MdpSsppChangeFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MdpSsppChangeFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MdpSsppChangeFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MdpSsppChangeFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.num_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.img_h_) -
        reinterpret_cast<char*>(&_impl_.num_)) + sizeof(_impl_.img_h_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.src_x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.dst_h_) -
        reinterpret_cast<char*>(&_impl_.src_x_)) + sizeof(_impl_.dst_h_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MdpSsppChangeFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 num = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_num(&has_bits);
          _impl_.num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 play_cnt = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_play_cnt(&has_bits);
          _impl_.play_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mixer = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_mixer(&has_bits);
          _impl_.mixer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 stage = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_stage(&has_bits);
          _impl_.stage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 format = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_format(&has_bits);
          _impl_.format_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 img_w = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_img_w(&has_bits);
          _impl_.img_w_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 img_h = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_img_h(&has_bits);
          _impl_.img_h_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 src_x = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_src_x(&has_bits);
          _impl_.src_x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 src_y = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_src_y(&has_bits);
          _impl_.src_y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 src_w = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_src_w(&has_bits);
          _impl_.src_w_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 src_h = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_src_h(&has_bits);
          _impl_.src_h_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 dst_x = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_dst_x(&has_bits);
          _impl_.dst_x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 dst_y = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_dst_y(&has_bits);
          _impl_.dst_y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 dst_w = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_dst_w(&has_bits);
          _impl_.dst_w_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 dst_h = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_dst_h(&has_bits);
          _impl_.dst_h_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MdpSsppChangeFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MdpSsppChangeFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 num = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_num(), target);
  }

  // optional uint32 play_cnt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_play_cnt(), target);
  }

  // optional uint32 mixer = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_mixer(), target);
  }

  // optional uint32 stage = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_stage(), target);
  }

  // optional uint32 flags = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_flags(), target);
  }

  // optional uint32 format = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_format(), target);
  }

  // optional uint32 img_w = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_img_w(), target);
  }

  // optional uint32 img_h = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_img_h(), target);
  }

  // optional uint32 src_x = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_src_x(), target);
  }

  // optional uint32 src_y = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_src_y(), target);
  }

  // optional uint32 src_w = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_src_w(), target);
  }

  // optional uint32 src_h = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_src_h(), target);
  }

  // optional uint32 dst_x = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_dst_x(), target);
  }

  // optional uint32 dst_y = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_dst_y(), target);
  }

  // optional uint32 dst_w = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_dst_w(), target);
  }

  // optional uint32 dst_h = 16;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(16, this->_internal_dst_h(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MdpSsppChangeFtraceEvent)
  return target;
}

size_t MdpSsppChangeFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MdpSsppChangeFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 num = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num());
    }

    // optional uint32 play_cnt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_play_cnt());
    }

    // optional uint32 mixer = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mixer());
    }

    // optional uint32 stage = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_stage());
    }

    // optional uint32 flags = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

    // optional uint32 format = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_format());
    }

    // optional uint32 img_w = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_img_w());
    }

    // optional uint32 img_h = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_img_h());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 src_x = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_src_x());
    }

    // optional uint32 src_y = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_src_y());
    }

    // optional uint32 src_w = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_src_w());
    }

    // optional uint32 src_h = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_src_h());
    }

    // optional uint32 dst_x = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_dst_x());
    }

    // optional uint32 dst_y = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_dst_y());
    }

    // optional uint32 dst_w = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_dst_w());
    }

    // optional uint32 dst_h = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_dst_h());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MdpSsppChangeFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MdpSsppChangeFtraceEvent*>(
      &from));
}

void MdpSsppChangeFtraceEvent::MergeFrom(const MdpSsppChangeFtraceEvent& from) {
  MdpSsppChangeFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MdpSsppChangeFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.num_ = from._impl_.num_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.play_cnt_ = from._impl_.play_cnt_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.mixer_ = from._impl_.mixer_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.stage_ = from._impl_.stage_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.format_ = from._impl_.format_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.img_w_ = from._impl_.img_w_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.img_h_ = from._impl_.img_h_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.src_x_ = from._impl_.src_x_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.src_y_ = from._impl_.src_y_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.src_w_ = from._impl_.src_w_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.src_h_ = from._impl_.src_h_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.dst_x_ = from._impl_.dst_x_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.dst_y_ = from._impl_.dst_y_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.dst_w_ = from._impl_.dst_w_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.dst_h_ = from._impl_.dst_h_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MdpSsppChangeFtraceEvent::CopyFrom(const MdpSsppChangeFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MdpSsppChangeFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MdpSsppChangeFtraceEvent::IsInitialized() const {
  return true;
}

void MdpSsppChangeFtraceEvent::InternalSwap(MdpSsppChangeFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MdpSsppChangeFtraceEvent, _impl_.dst_h_)
      + sizeof(MdpSsppChangeFtraceEvent::_impl_.dst_h_)
      - PROTOBUF_FIELD_OFFSET(MdpSsppChangeFtraceEvent, _impl_.num_)>(
          reinterpret_cast<char*>(&_impl_.num_),
          reinterpret_cast<char*>(&other->_impl_.num_));
}

std::string MdpSsppChangeFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MdpSsppChangeFtraceEvent";
}


// ===================================================================

class TracingMarkWriteFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<TracingMarkWriteFtraceEvent>()._impl_._has_bits_);
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_trace_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_trace_begin(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

TracingMarkWriteFtraceEvent::TracingMarkWriteFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.TracingMarkWriteFtraceEvent)
}
TracingMarkWriteFtraceEvent::TracingMarkWriteFtraceEvent(const TracingMarkWriteFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TracingMarkWriteFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.trace_name_){}
    , decltype(_impl_.pid_){}
    , decltype(_impl_.trace_begin_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.trace_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.trace_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_trace_name()) {
    _this->_impl_.trace_name_.Set(from._internal_trace_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.pid_, &from._impl_.pid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.trace_begin_) -
    reinterpret_cast<char*>(&_impl_.pid_)) + sizeof(_impl_.trace_begin_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.TracingMarkWriteFtraceEvent)
}

inline void TracingMarkWriteFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.trace_name_){}
    , decltype(_impl_.pid_){0}
    , decltype(_impl_.trace_begin_){0u}
  };
  _impl_.trace_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.trace_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TracingMarkWriteFtraceEvent::~TracingMarkWriteFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.TracingMarkWriteFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TracingMarkWriteFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.trace_name_.Destroy();
}

void TracingMarkWriteFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TracingMarkWriteFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.TracingMarkWriteFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.trace_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.pid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.trace_begin_) -
        reinterpret_cast<char*>(&_impl_.pid_)) + sizeof(_impl_.trace_begin_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TracingMarkWriteFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 pid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_pid(&has_bits);
          _impl_.pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string trace_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_trace_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 trace_begin = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_trace_begin(&has_bits);
          _impl_.trace_begin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TracingMarkWriteFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.TracingMarkWriteFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 pid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_pid(), target);
  }

  // optional string trace_name = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_trace_name(), target);
  }

  // optional uint32 trace_begin = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_trace_begin(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.TracingMarkWriteFtraceEvent)
  return target;
}

size_t TracingMarkWriteFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.TracingMarkWriteFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string trace_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_trace_name());
    }

    // optional int32 pid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pid());
    }

    // optional uint32 trace_begin = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_trace_begin());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TracingMarkWriteFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TracingMarkWriteFtraceEvent*>(
      &from));
}

void TracingMarkWriteFtraceEvent::MergeFrom(const TracingMarkWriteFtraceEvent& from) {
  TracingMarkWriteFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.TracingMarkWriteFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_trace_name(from._internal_trace_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pid_ = from._impl_.pid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.trace_begin_ = from._impl_.trace_begin_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TracingMarkWriteFtraceEvent::CopyFrom(const TracingMarkWriteFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.TracingMarkWriteFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TracingMarkWriteFtraceEvent::IsInitialized() const {
  return true;
}

void TracingMarkWriteFtraceEvent::InternalSwap(TracingMarkWriteFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.trace_name_, lhs_arena,
      &other->_impl_.trace_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TracingMarkWriteFtraceEvent, _impl_.trace_begin_)
      + sizeof(TracingMarkWriteFtraceEvent::_impl_.trace_begin_)
      - PROTOBUF_FIELD_OFFSET(TracingMarkWriteFtraceEvent, _impl_.pid_)>(
          reinterpret_cast<char*>(&_impl_.pid_),
          reinterpret_cast<char*>(&other->_impl_.pid_));
}

std::string TracingMarkWriteFtraceEvent::GetTypeName() const {
  return "perfetto.protos.TracingMarkWriteFtraceEvent";
}


// ===================================================================

class MdpCmdPingpongDoneFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MdpCmdPingpongDoneFtraceEvent>()._impl_._has_bits_);
  static void set_has_ctl_num(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_intf_num(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pp_num(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_koff_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

MdpCmdPingpongDoneFtraceEvent::MdpCmdPingpongDoneFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MdpCmdPingpongDoneFtraceEvent)
}
MdpCmdPingpongDoneFtraceEvent::MdpCmdPingpongDoneFtraceEvent(const MdpCmdPingpongDoneFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MdpCmdPingpongDoneFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ctl_num_){}
    , decltype(_impl_.intf_num_){}
    , decltype(_impl_.pp_num_){}
    , decltype(_impl_.koff_cnt_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.ctl_num_, &from._impl_.ctl_num_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.koff_cnt_) -
    reinterpret_cast<char*>(&_impl_.ctl_num_)) + sizeof(_impl_.koff_cnt_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MdpCmdPingpongDoneFtraceEvent)
}

inline void MdpCmdPingpongDoneFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ctl_num_){0u}
    , decltype(_impl_.intf_num_){0u}
    , decltype(_impl_.pp_num_){0u}
    , decltype(_impl_.koff_cnt_){0}
  };
}

MdpCmdPingpongDoneFtraceEvent::~MdpCmdPingpongDoneFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MdpCmdPingpongDoneFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MdpCmdPingpongDoneFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MdpCmdPingpongDoneFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MdpCmdPingpongDoneFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MdpCmdPingpongDoneFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.ctl_num_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.koff_cnt_) -
        reinterpret_cast<char*>(&_impl_.ctl_num_)) + sizeof(_impl_.koff_cnt_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MdpCmdPingpongDoneFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 ctl_num = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ctl_num(&has_bits);
          _impl_.ctl_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 intf_num = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_intf_num(&has_bits);
          _impl_.intf_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 pp_num = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_pp_num(&has_bits);
          _impl_.pp_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 koff_cnt = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_koff_cnt(&has_bits);
          _impl_.koff_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MdpCmdPingpongDoneFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MdpCmdPingpongDoneFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 ctl_num = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_ctl_num(), target);
  }

  // optional uint32 intf_num = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_intf_num(), target);
  }

  // optional uint32 pp_num = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_pp_num(), target);
  }

  // optional int32 koff_cnt = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_koff_cnt(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MdpCmdPingpongDoneFtraceEvent)
  return target;
}

size_t MdpCmdPingpongDoneFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MdpCmdPingpongDoneFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint32 ctl_num = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ctl_num());
    }

    // optional uint32 intf_num = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_intf_num());
    }

    // optional uint32 pp_num = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_pp_num());
    }

    // optional int32 koff_cnt = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_koff_cnt());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MdpCmdPingpongDoneFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MdpCmdPingpongDoneFtraceEvent*>(
      &from));
}

void MdpCmdPingpongDoneFtraceEvent::MergeFrom(const MdpCmdPingpongDoneFtraceEvent& from) {
  MdpCmdPingpongDoneFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MdpCmdPingpongDoneFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.ctl_num_ = from._impl_.ctl_num_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.intf_num_ = from._impl_.intf_num_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.pp_num_ = from._impl_.pp_num_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.koff_cnt_ = from._impl_.koff_cnt_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MdpCmdPingpongDoneFtraceEvent::CopyFrom(const MdpCmdPingpongDoneFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MdpCmdPingpongDoneFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MdpCmdPingpongDoneFtraceEvent::IsInitialized() const {
  return true;
}

void MdpCmdPingpongDoneFtraceEvent::InternalSwap(MdpCmdPingpongDoneFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MdpCmdPingpongDoneFtraceEvent, _impl_.koff_cnt_)
      + sizeof(MdpCmdPingpongDoneFtraceEvent::_impl_.koff_cnt_)
      - PROTOBUF_FIELD_OFFSET(MdpCmdPingpongDoneFtraceEvent, _impl_.ctl_num_)>(
          reinterpret_cast<char*>(&_impl_.ctl_num_),
          reinterpret_cast<char*>(&other->_impl_.ctl_num_));
}

std::string MdpCmdPingpongDoneFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MdpCmdPingpongDoneFtraceEvent";
}


// ===================================================================

class MdpCompareBwFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MdpCompareBwFtraceEvent>()._impl_._has_bits_);
  static void set_has_new_ab(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_new_ib(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_new_wb(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_old_ab(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_old_ib(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_old_wb(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_params_changed(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_update_bw(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

MdpCompareBwFtraceEvent::MdpCompareBwFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MdpCompareBwFtraceEvent)
}
MdpCompareBwFtraceEvent::MdpCompareBwFtraceEvent(const MdpCompareBwFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MdpCompareBwFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.new_ab_){}
    , decltype(_impl_.new_ib_){}
    , decltype(_impl_.new_wb_){}
    , decltype(_impl_.old_ab_){}
    , decltype(_impl_.old_ib_){}
    , decltype(_impl_.old_wb_){}
    , decltype(_impl_.params_changed_){}
    , decltype(_impl_.update_bw_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.new_ab_, &from._impl_.new_ab_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.update_bw_) -
    reinterpret_cast<char*>(&_impl_.new_ab_)) + sizeof(_impl_.update_bw_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MdpCompareBwFtraceEvent)
}

inline void MdpCompareBwFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.new_ab_){uint64_t{0u}}
    , decltype(_impl_.new_ib_){uint64_t{0u}}
    , decltype(_impl_.new_wb_){uint64_t{0u}}
    , decltype(_impl_.old_ab_){uint64_t{0u}}
    , decltype(_impl_.old_ib_){uint64_t{0u}}
    , decltype(_impl_.old_wb_){uint64_t{0u}}
    , decltype(_impl_.params_changed_){0u}
    , decltype(_impl_.update_bw_){0u}
  };
}

MdpCompareBwFtraceEvent::~MdpCompareBwFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MdpCompareBwFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MdpCompareBwFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MdpCompareBwFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MdpCompareBwFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MdpCompareBwFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.new_ab_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.update_bw_) -
        reinterpret_cast<char*>(&_impl_.new_ab_)) + sizeof(_impl_.update_bw_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MdpCompareBwFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 new_ab = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_new_ab(&has_bits);
          _impl_.new_ab_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 new_ib = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_new_ib(&has_bits);
          _impl_.new_ib_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 new_wb = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_new_wb(&has_bits);
          _impl_.new_wb_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 old_ab = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_old_ab(&has_bits);
          _impl_.old_ab_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 old_ib = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_old_ib(&has_bits);
          _impl_.old_ib_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 old_wb = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_old_wb(&has_bits);
          _impl_.old_wb_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 params_changed = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_params_changed(&has_bits);
          _impl_.params_changed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 update_bw = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_update_bw(&has_bits);
          _impl_.update_bw_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MdpCompareBwFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MdpCompareBwFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 new_ab = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_new_ab(), target);
  }

  // optional uint64 new_ib = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_new_ib(), target);
  }

  // optional uint64 new_wb = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_new_wb(), target);
  }

  // optional uint64 old_ab = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_old_ab(), target);
  }

  // optional uint64 old_ib = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_old_ib(), target);
  }

  // optional uint64 old_wb = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_old_wb(), target);
  }

  // optional uint32 params_changed = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_params_changed(), target);
  }

  // optional uint32 update_bw = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_update_bw(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MdpCompareBwFtraceEvent)
  return target;
}

size_t MdpCompareBwFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MdpCompareBwFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint64 new_ab = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_new_ab());
    }

    // optional uint64 new_ib = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_new_ib());
    }

    // optional uint64 new_wb = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_new_wb());
    }

    // optional uint64 old_ab = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_old_ab());
    }

    // optional uint64 old_ib = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_old_ib());
    }

    // optional uint64 old_wb = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_old_wb());
    }

    // optional uint32 params_changed = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_params_changed());
    }

    // optional uint32 update_bw = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_update_bw());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MdpCompareBwFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MdpCompareBwFtraceEvent*>(
      &from));
}

void MdpCompareBwFtraceEvent::MergeFrom(const MdpCompareBwFtraceEvent& from) {
  MdpCompareBwFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MdpCompareBwFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.new_ab_ = from._impl_.new_ab_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.new_ib_ = from._impl_.new_ib_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.new_wb_ = from._impl_.new_wb_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.old_ab_ = from._impl_.old_ab_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.old_ib_ = from._impl_.old_ib_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.old_wb_ = from._impl_.old_wb_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.params_changed_ = from._impl_.params_changed_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.update_bw_ = from._impl_.update_bw_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MdpCompareBwFtraceEvent::CopyFrom(const MdpCompareBwFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MdpCompareBwFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MdpCompareBwFtraceEvent::IsInitialized() const {
  return true;
}

void MdpCompareBwFtraceEvent::InternalSwap(MdpCompareBwFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MdpCompareBwFtraceEvent, _impl_.update_bw_)
      + sizeof(MdpCompareBwFtraceEvent::_impl_.update_bw_)
      - PROTOBUF_FIELD_OFFSET(MdpCompareBwFtraceEvent, _impl_.new_ab_)>(
          reinterpret_cast<char*>(&_impl_.new_ab_),
          reinterpret_cast<char*>(&other->_impl_.new_ab_));
}

std::string MdpCompareBwFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MdpCompareBwFtraceEvent";
}


// ===================================================================

class MdpPerfSetPanicLutsFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MdpPerfSetPanicLutsFtraceEvent>()._impl_._has_bits_);
  static void set_has_pnum(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_fmt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_panic_lut(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_robust_lut(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

MdpPerfSetPanicLutsFtraceEvent::MdpPerfSetPanicLutsFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MdpPerfSetPanicLutsFtraceEvent)
}
MdpPerfSetPanicLutsFtraceEvent::MdpPerfSetPanicLutsFtraceEvent(const MdpPerfSetPanicLutsFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MdpPerfSetPanicLutsFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pnum_){}
    , decltype(_impl_.fmt_){}
    , decltype(_impl_.mode_){}
    , decltype(_impl_.panic_lut_){}
    , decltype(_impl_.robust_lut_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.pnum_, &from._impl_.pnum_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.robust_lut_) -
    reinterpret_cast<char*>(&_impl_.pnum_)) + sizeof(_impl_.robust_lut_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MdpPerfSetPanicLutsFtraceEvent)
}

inline void MdpPerfSetPanicLutsFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pnum_){0u}
    , decltype(_impl_.fmt_){0u}
    , decltype(_impl_.mode_){0u}
    , decltype(_impl_.panic_lut_){0u}
    , decltype(_impl_.robust_lut_){0u}
  };
}

MdpPerfSetPanicLutsFtraceEvent::~MdpPerfSetPanicLutsFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MdpPerfSetPanicLutsFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MdpPerfSetPanicLutsFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MdpPerfSetPanicLutsFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MdpPerfSetPanicLutsFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MdpPerfSetPanicLutsFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.pnum_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.robust_lut_) -
        reinterpret_cast<char*>(&_impl_.pnum_)) + sizeof(_impl_.robust_lut_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MdpPerfSetPanicLutsFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 pnum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_pnum(&has_bits);
          _impl_.pnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 fmt = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_fmt(&has_bits);
          _impl_.fmt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_mode(&has_bits);
          _impl_.mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 panic_lut = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_panic_lut(&has_bits);
          _impl_.panic_lut_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 robust_lut = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_robust_lut(&has_bits);
          _impl_.robust_lut_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MdpPerfSetPanicLutsFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MdpPerfSetPanicLutsFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 pnum = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_pnum(), target);
  }

  // optional uint32 fmt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_fmt(), target);
  }

  // optional uint32 mode = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_mode(), target);
  }

  // optional uint32 panic_lut = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_panic_lut(), target);
  }

  // optional uint32 robust_lut = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_robust_lut(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MdpPerfSetPanicLutsFtraceEvent)
  return target;
}

size_t MdpPerfSetPanicLutsFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MdpPerfSetPanicLutsFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint32 pnum = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_pnum());
    }

    // optional uint32 fmt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_fmt());
    }

    // optional uint32 mode = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mode());
    }

    // optional uint32 panic_lut = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_panic_lut());
    }

    // optional uint32 robust_lut = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_robust_lut());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MdpPerfSetPanicLutsFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MdpPerfSetPanicLutsFtraceEvent*>(
      &from));
}

void MdpPerfSetPanicLutsFtraceEvent::MergeFrom(const MdpPerfSetPanicLutsFtraceEvent& from) {
  MdpPerfSetPanicLutsFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MdpPerfSetPanicLutsFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.pnum_ = from._impl_.pnum_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.fmt_ = from._impl_.fmt_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.mode_ = from._impl_.mode_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.panic_lut_ = from._impl_.panic_lut_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.robust_lut_ = from._impl_.robust_lut_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MdpPerfSetPanicLutsFtraceEvent::CopyFrom(const MdpPerfSetPanicLutsFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MdpPerfSetPanicLutsFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MdpPerfSetPanicLutsFtraceEvent::IsInitialized() const {
  return true;
}

void MdpPerfSetPanicLutsFtraceEvent::InternalSwap(MdpPerfSetPanicLutsFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MdpPerfSetPanicLutsFtraceEvent, _impl_.robust_lut_)
      + sizeof(MdpPerfSetPanicLutsFtraceEvent::_impl_.robust_lut_)
      - PROTOBUF_FIELD_OFFSET(MdpPerfSetPanicLutsFtraceEvent, _impl_.pnum_)>(
          reinterpret_cast<char*>(&_impl_.pnum_),
          reinterpret_cast<char*>(&other->_impl_.pnum_));
}

std::string MdpPerfSetPanicLutsFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MdpPerfSetPanicLutsFtraceEvent";
}


// ===================================================================

class MdpSsppSetFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MdpSsppSetFtraceEvent>()._impl_._has_bits_);
  static void set_has_num(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_play_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_mixer(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_stage(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_format(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_img_w(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_img_h(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_src_x(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_src_y(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_src_w(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_src_h(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_dst_x(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_dst_y(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_dst_w(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_dst_h(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
};

MdpSsppSetFtraceEvent::MdpSsppSetFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MdpSsppSetFtraceEvent)
}
MdpSsppSetFtraceEvent::MdpSsppSetFtraceEvent(const MdpSsppSetFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MdpSsppSetFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.num_){}
    , decltype(_impl_.play_cnt_){}
    , decltype(_impl_.mixer_){}
    , decltype(_impl_.stage_){}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.format_){}
    , decltype(_impl_.img_w_){}
    , decltype(_impl_.img_h_){}
    , decltype(_impl_.src_x_){}
    , decltype(_impl_.src_y_){}
    , decltype(_impl_.src_w_){}
    , decltype(_impl_.src_h_){}
    , decltype(_impl_.dst_x_){}
    , decltype(_impl_.dst_y_){}
    , decltype(_impl_.dst_w_){}
    , decltype(_impl_.dst_h_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.num_, &from._impl_.num_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.dst_h_) -
    reinterpret_cast<char*>(&_impl_.num_)) + sizeof(_impl_.dst_h_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MdpSsppSetFtraceEvent)
}

inline void MdpSsppSetFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.num_){0u}
    , decltype(_impl_.play_cnt_){0u}
    , decltype(_impl_.mixer_){0u}
    , decltype(_impl_.stage_){0u}
    , decltype(_impl_.flags_){0u}
    , decltype(_impl_.format_){0u}
    , decltype(_impl_.img_w_){0u}
    , decltype(_impl_.img_h_){0u}
    , decltype(_impl_.src_x_){0u}
    , decltype(_impl_.src_y_){0u}
    , decltype(_impl_.src_w_){0u}
    , decltype(_impl_.src_h_){0u}
    , decltype(_impl_.dst_x_){0u}
    , decltype(_impl_.dst_y_){0u}
    , decltype(_impl_.dst_w_){0u}
    , decltype(_impl_.dst_h_){0u}
  };
}

MdpSsppSetFtraceEvent::~MdpSsppSetFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MdpSsppSetFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MdpSsppSetFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MdpSsppSetFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MdpSsppSetFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MdpSsppSetFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.num_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.img_h_) -
        reinterpret_cast<char*>(&_impl_.num_)) + sizeof(_impl_.img_h_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.src_x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.dst_h_) -
        reinterpret_cast<char*>(&_impl_.src_x_)) + sizeof(_impl_.dst_h_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MdpSsppSetFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 num = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_num(&has_bits);
          _impl_.num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 play_cnt = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_play_cnt(&has_bits);
          _impl_.play_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mixer = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_mixer(&has_bits);
          _impl_.mixer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 stage = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_stage(&has_bits);
          _impl_.stage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 format = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_format(&has_bits);
          _impl_.format_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 img_w = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_img_w(&has_bits);
          _impl_.img_w_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 img_h = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_img_h(&has_bits);
          _impl_.img_h_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 src_x = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_src_x(&has_bits);
          _impl_.src_x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 src_y = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_src_y(&has_bits);
          _impl_.src_y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 src_w = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_src_w(&has_bits);
          _impl_.src_w_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 src_h = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_src_h(&has_bits);
          _impl_.src_h_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 dst_x = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_dst_x(&has_bits);
          _impl_.dst_x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 dst_y = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_dst_y(&has_bits);
          _impl_.dst_y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 dst_w = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_dst_w(&has_bits);
          _impl_.dst_w_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 dst_h = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_dst_h(&has_bits);
          _impl_.dst_h_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MdpSsppSetFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MdpSsppSetFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 num = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_num(), target);
  }

  // optional uint32 play_cnt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_play_cnt(), target);
  }

  // optional uint32 mixer = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_mixer(), target);
  }

  // optional uint32 stage = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_stage(), target);
  }

  // optional uint32 flags = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_flags(), target);
  }

  // optional uint32 format = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_format(), target);
  }

  // optional uint32 img_w = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_img_w(), target);
  }

  // optional uint32 img_h = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_img_h(), target);
  }

  // optional uint32 src_x = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_src_x(), target);
  }

  // optional uint32 src_y = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_src_y(), target);
  }

  // optional uint32 src_w = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_src_w(), target);
  }

  // optional uint32 src_h = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_src_h(), target);
  }

  // optional uint32 dst_x = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_dst_x(), target);
  }

  // optional uint32 dst_y = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_dst_y(), target);
  }

  // optional uint32 dst_w = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_dst_w(), target);
  }

  // optional uint32 dst_h = 16;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(16, this->_internal_dst_h(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MdpSsppSetFtraceEvent)
  return target;
}

size_t MdpSsppSetFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MdpSsppSetFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 num = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num());
    }

    // optional uint32 play_cnt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_play_cnt());
    }

    // optional uint32 mixer = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mixer());
    }

    // optional uint32 stage = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_stage());
    }

    // optional uint32 flags = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

    // optional uint32 format = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_format());
    }

    // optional uint32 img_w = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_img_w());
    }

    // optional uint32 img_h = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_img_h());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 src_x = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_src_x());
    }

    // optional uint32 src_y = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_src_y());
    }

    // optional uint32 src_w = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_src_w());
    }

    // optional uint32 src_h = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_src_h());
    }

    // optional uint32 dst_x = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_dst_x());
    }

    // optional uint32 dst_y = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_dst_y());
    }

    // optional uint32 dst_w = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_dst_w());
    }

    // optional uint32 dst_h = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_dst_h());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MdpSsppSetFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MdpSsppSetFtraceEvent*>(
      &from));
}

void MdpSsppSetFtraceEvent::MergeFrom(const MdpSsppSetFtraceEvent& from) {
  MdpSsppSetFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MdpSsppSetFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.num_ = from._impl_.num_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.play_cnt_ = from._impl_.play_cnt_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.mixer_ = from._impl_.mixer_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.stage_ = from._impl_.stage_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.format_ = from._impl_.format_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.img_w_ = from._impl_.img_w_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.img_h_ = from._impl_.img_h_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.src_x_ = from._impl_.src_x_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.src_y_ = from._impl_.src_y_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.src_w_ = from._impl_.src_w_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.src_h_ = from._impl_.src_h_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.dst_x_ = from._impl_.dst_x_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.dst_y_ = from._impl_.dst_y_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.dst_w_ = from._impl_.dst_w_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.dst_h_ = from._impl_.dst_h_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MdpSsppSetFtraceEvent::CopyFrom(const MdpSsppSetFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MdpSsppSetFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MdpSsppSetFtraceEvent::IsInitialized() const {
  return true;
}

void MdpSsppSetFtraceEvent::InternalSwap(MdpSsppSetFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MdpSsppSetFtraceEvent, _impl_.dst_h_)
      + sizeof(MdpSsppSetFtraceEvent::_impl_.dst_h_)
      - PROTOBUF_FIELD_OFFSET(MdpSsppSetFtraceEvent, _impl_.num_)>(
          reinterpret_cast<char*>(&_impl_.num_),
          reinterpret_cast<char*>(&other->_impl_.num_));
}

std::string MdpSsppSetFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MdpSsppSetFtraceEvent";
}


// ===================================================================

class MdpCmdReadptrDoneFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MdpCmdReadptrDoneFtraceEvent>()._impl_._has_bits_);
  static void set_has_ctl_num(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_koff_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

MdpCmdReadptrDoneFtraceEvent::MdpCmdReadptrDoneFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MdpCmdReadptrDoneFtraceEvent)
}
MdpCmdReadptrDoneFtraceEvent::MdpCmdReadptrDoneFtraceEvent(const MdpCmdReadptrDoneFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MdpCmdReadptrDoneFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ctl_num_){}
    , decltype(_impl_.koff_cnt_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.ctl_num_, &from._impl_.ctl_num_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.koff_cnt_) -
    reinterpret_cast<char*>(&_impl_.ctl_num_)) + sizeof(_impl_.koff_cnt_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MdpCmdReadptrDoneFtraceEvent)
}

inline void MdpCmdReadptrDoneFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ctl_num_){0u}
    , decltype(_impl_.koff_cnt_){0}
  };
}

MdpCmdReadptrDoneFtraceEvent::~MdpCmdReadptrDoneFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MdpCmdReadptrDoneFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MdpCmdReadptrDoneFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MdpCmdReadptrDoneFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MdpCmdReadptrDoneFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MdpCmdReadptrDoneFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.ctl_num_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.koff_cnt_) -
        reinterpret_cast<char*>(&_impl_.ctl_num_)) + sizeof(_impl_.koff_cnt_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MdpCmdReadptrDoneFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 ctl_num = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ctl_num(&has_bits);
          _impl_.ctl_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 koff_cnt = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_koff_cnt(&has_bits);
          _impl_.koff_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MdpCmdReadptrDoneFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MdpCmdReadptrDoneFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 ctl_num = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_ctl_num(), target);
  }

  // optional int32 koff_cnt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_koff_cnt(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MdpCmdReadptrDoneFtraceEvent)
  return target;
}

size_t MdpCmdReadptrDoneFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MdpCmdReadptrDoneFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 ctl_num = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ctl_num());
    }

    // optional int32 koff_cnt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_koff_cnt());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MdpCmdReadptrDoneFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MdpCmdReadptrDoneFtraceEvent*>(
      &from));
}

void MdpCmdReadptrDoneFtraceEvent::MergeFrom(const MdpCmdReadptrDoneFtraceEvent& from) {
  MdpCmdReadptrDoneFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MdpCmdReadptrDoneFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.ctl_num_ = from._impl_.ctl_num_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.koff_cnt_ = from._impl_.koff_cnt_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MdpCmdReadptrDoneFtraceEvent::CopyFrom(const MdpCmdReadptrDoneFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MdpCmdReadptrDoneFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MdpCmdReadptrDoneFtraceEvent::IsInitialized() const {
  return true;
}

void MdpCmdReadptrDoneFtraceEvent::InternalSwap(MdpCmdReadptrDoneFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MdpCmdReadptrDoneFtraceEvent, _impl_.koff_cnt_)
      + sizeof(MdpCmdReadptrDoneFtraceEvent::_impl_.koff_cnt_)
      - PROTOBUF_FIELD_OFFSET(MdpCmdReadptrDoneFtraceEvent, _impl_.ctl_num_)>(
          reinterpret_cast<char*>(&_impl_.ctl_num_),
          reinterpret_cast<char*>(&other->_impl_.ctl_num_));
}

std::string MdpCmdReadptrDoneFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MdpCmdReadptrDoneFtraceEvent";
}


// ===================================================================

class MdpMisrCrcFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MdpMisrCrcFtraceEvent>()._impl_._has_bits_);
  static void set_has_block_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_vsync_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_crc(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

MdpMisrCrcFtraceEvent::MdpMisrCrcFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MdpMisrCrcFtraceEvent)
}
MdpMisrCrcFtraceEvent::MdpMisrCrcFtraceEvent(const MdpMisrCrcFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MdpMisrCrcFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.block_id_){}
    , decltype(_impl_.vsync_cnt_){}
    , decltype(_impl_.crc_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.block_id_, &from._impl_.block_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.crc_) -
    reinterpret_cast<char*>(&_impl_.block_id_)) + sizeof(_impl_.crc_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MdpMisrCrcFtraceEvent)
}

inline void MdpMisrCrcFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.block_id_){0u}
    , decltype(_impl_.vsync_cnt_){0u}
    , decltype(_impl_.crc_){0u}
  };
}

MdpMisrCrcFtraceEvent::~MdpMisrCrcFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MdpMisrCrcFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MdpMisrCrcFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MdpMisrCrcFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MdpMisrCrcFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MdpMisrCrcFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.block_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.crc_) -
        reinterpret_cast<char*>(&_impl_.block_id_)) + sizeof(_impl_.crc_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MdpMisrCrcFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 block_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_block_id(&has_bits);
          _impl_.block_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 vsync_cnt = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_vsync_cnt(&has_bits);
          _impl_.vsync_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 crc = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_crc(&has_bits);
          _impl_.crc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MdpMisrCrcFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MdpMisrCrcFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 block_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_block_id(), target);
  }

  // optional uint32 vsync_cnt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_vsync_cnt(), target);
  }

  // optional uint32 crc = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_crc(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MdpMisrCrcFtraceEvent)
  return target;
}

size_t MdpMisrCrcFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MdpMisrCrcFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 block_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_block_id());
    }

    // optional uint32 vsync_cnt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_vsync_cnt());
    }

    // optional uint32 crc = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_crc());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MdpMisrCrcFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MdpMisrCrcFtraceEvent*>(
      &from));
}

void MdpMisrCrcFtraceEvent::MergeFrom(const MdpMisrCrcFtraceEvent& from) {
  MdpMisrCrcFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MdpMisrCrcFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.block_id_ = from._impl_.block_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.vsync_cnt_ = from._impl_.vsync_cnt_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.crc_ = from._impl_.crc_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MdpMisrCrcFtraceEvent::CopyFrom(const MdpMisrCrcFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MdpMisrCrcFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MdpMisrCrcFtraceEvent::IsInitialized() const {
  return true;
}

void MdpMisrCrcFtraceEvent::InternalSwap(MdpMisrCrcFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MdpMisrCrcFtraceEvent, _impl_.crc_)
      + sizeof(MdpMisrCrcFtraceEvent::_impl_.crc_)
      - PROTOBUF_FIELD_OFFSET(MdpMisrCrcFtraceEvent, _impl_.block_id_)>(
          reinterpret_cast<char*>(&_impl_.block_id_),
          reinterpret_cast<char*>(&other->_impl_.block_id_));
}

std::string MdpMisrCrcFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MdpMisrCrcFtraceEvent";
}


// ===================================================================

class MdpPerfSetQosLutsFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MdpPerfSetQosLutsFtraceEvent>()._impl_._has_bits_);
  static void set_has_pnum(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_fmt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_intf(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_rot(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_fl(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_lut(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_linear(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

MdpPerfSetQosLutsFtraceEvent::MdpPerfSetQosLutsFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MdpPerfSetQosLutsFtraceEvent)
}
MdpPerfSetQosLutsFtraceEvent::MdpPerfSetQosLutsFtraceEvent(const MdpPerfSetQosLutsFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MdpPerfSetQosLutsFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pnum_){}
    , decltype(_impl_.fmt_){}
    , decltype(_impl_.intf_){}
    , decltype(_impl_.rot_){}
    , decltype(_impl_.fl_){}
    , decltype(_impl_.lut_){}
    , decltype(_impl_.linear_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.pnum_, &from._impl_.pnum_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.linear_) -
    reinterpret_cast<char*>(&_impl_.pnum_)) + sizeof(_impl_.linear_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MdpPerfSetQosLutsFtraceEvent)
}

inline void MdpPerfSetQosLutsFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pnum_){0u}
    , decltype(_impl_.fmt_){0u}
    , decltype(_impl_.intf_){0u}
    , decltype(_impl_.rot_){0u}
    , decltype(_impl_.fl_){0u}
    , decltype(_impl_.lut_){0u}
    , decltype(_impl_.linear_){0u}
  };
}

MdpPerfSetQosLutsFtraceEvent::~MdpPerfSetQosLutsFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MdpPerfSetQosLutsFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MdpPerfSetQosLutsFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MdpPerfSetQosLutsFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MdpPerfSetQosLutsFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MdpPerfSetQosLutsFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&_impl_.pnum_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.linear_) -
        reinterpret_cast<char*>(&_impl_.pnum_)) + sizeof(_impl_.linear_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MdpPerfSetQosLutsFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 pnum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_pnum(&has_bits);
          _impl_.pnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 fmt = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_fmt(&has_bits);
          _impl_.fmt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 intf = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_intf(&has_bits);
          _impl_.intf_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rot = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_rot(&has_bits);
          _impl_.rot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 fl = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_fl(&has_bits);
          _impl_.fl_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lut = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_lut(&has_bits);
          _impl_.lut_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 linear = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_linear(&has_bits);
          _impl_.linear_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MdpPerfSetQosLutsFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MdpPerfSetQosLutsFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 pnum = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_pnum(), target);
  }

  // optional uint32 fmt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_fmt(), target);
  }

  // optional uint32 intf = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_intf(), target);
  }

  // optional uint32 rot = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_rot(), target);
  }

  // optional uint32 fl = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_fl(), target);
  }

  // optional uint32 lut = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_lut(), target);
  }

  // optional uint32 linear = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_linear(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MdpPerfSetQosLutsFtraceEvent)
  return target;
}

size_t MdpPerfSetQosLutsFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MdpPerfSetQosLutsFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional uint32 pnum = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_pnum());
    }

    // optional uint32 fmt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_fmt());
    }

    // optional uint32 intf = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_intf());
    }

    // optional uint32 rot = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rot());
    }

    // optional uint32 fl = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_fl());
    }

    // optional uint32 lut = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lut());
    }

    // optional uint32 linear = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_linear());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MdpPerfSetQosLutsFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MdpPerfSetQosLutsFtraceEvent*>(
      &from));
}

void MdpPerfSetQosLutsFtraceEvent::MergeFrom(const MdpPerfSetQosLutsFtraceEvent& from) {
  MdpPerfSetQosLutsFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MdpPerfSetQosLutsFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.pnum_ = from._impl_.pnum_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.fmt_ = from._impl_.fmt_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.intf_ = from._impl_.intf_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.rot_ = from._impl_.rot_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.fl_ = from._impl_.fl_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.lut_ = from._impl_.lut_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.linear_ = from._impl_.linear_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MdpPerfSetQosLutsFtraceEvent::CopyFrom(const MdpPerfSetQosLutsFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MdpPerfSetQosLutsFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MdpPerfSetQosLutsFtraceEvent::IsInitialized() const {
  return true;
}

void MdpPerfSetQosLutsFtraceEvent::InternalSwap(MdpPerfSetQosLutsFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MdpPerfSetQosLutsFtraceEvent, _impl_.linear_)
      + sizeof(MdpPerfSetQosLutsFtraceEvent::_impl_.linear_)
      - PROTOBUF_FIELD_OFFSET(MdpPerfSetQosLutsFtraceEvent, _impl_.pnum_)>(
          reinterpret_cast<char*>(&_impl_.pnum_),
          reinterpret_cast<char*>(&other->_impl_.pnum_));
}

std::string MdpPerfSetQosLutsFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MdpPerfSetQosLutsFtraceEvent";
}


// ===================================================================

class MdpTraceCounterFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MdpTraceCounterFtraceEvent>()._impl_._has_bits_);
  static void set_has_pid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_counter_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

MdpTraceCounterFtraceEvent::MdpTraceCounterFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MdpTraceCounterFtraceEvent)
}
MdpTraceCounterFtraceEvent::MdpTraceCounterFtraceEvent(const MdpTraceCounterFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MdpTraceCounterFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.counter_name_){}
    , decltype(_impl_.pid_){}
    , decltype(_impl_.value_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.counter_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.counter_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_counter_name()) {
    _this->_impl_.counter_name_.Set(from._internal_counter_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.pid_, &from._impl_.pid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.value_) -
    reinterpret_cast<char*>(&_impl_.pid_)) + sizeof(_impl_.value_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MdpTraceCounterFtraceEvent)
}

inline void MdpTraceCounterFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.counter_name_){}
    , decltype(_impl_.pid_){0}
    , decltype(_impl_.value_){0}
  };
  _impl_.counter_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.counter_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MdpTraceCounterFtraceEvent::~MdpTraceCounterFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MdpTraceCounterFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MdpTraceCounterFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.counter_name_.Destroy();
}

void MdpTraceCounterFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MdpTraceCounterFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MdpTraceCounterFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.counter_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.pid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.value_) -
        reinterpret_cast<char*>(&_impl_.pid_)) + sizeof(_impl_.value_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MdpTraceCounterFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 pid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_pid(&has_bits);
          _impl_.pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string counter_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_counter_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_value(&has_bits);
          _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MdpTraceCounterFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MdpTraceCounterFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 pid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_pid(), target);
  }

  // optional string counter_name = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_counter_name(), target);
  }

  // optional int32 value = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MdpTraceCounterFtraceEvent)
  return target;
}

size_t MdpTraceCounterFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MdpTraceCounterFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string counter_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_counter_name());
    }

    // optional int32 pid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pid());
    }

    // optional int32 value = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_value());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MdpTraceCounterFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MdpTraceCounterFtraceEvent*>(
      &from));
}

void MdpTraceCounterFtraceEvent::MergeFrom(const MdpTraceCounterFtraceEvent& from) {
  MdpTraceCounterFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MdpTraceCounterFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_counter_name(from._internal_counter_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pid_ = from._impl_.pid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.value_ = from._impl_.value_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MdpTraceCounterFtraceEvent::CopyFrom(const MdpTraceCounterFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MdpTraceCounterFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MdpTraceCounterFtraceEvent::IsInitialized() const {
  return true;
}

void MdpTraceCounterFtraceEvent::InternalSwap(MdpTraceCounterFtraceEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.counter_name_, lhs_arena,
      &other->_impl_.counter_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MdpTraceCounterFtraceEvent, _impl_.value_)
      + sizeof(MdpTraceCounterFtraceEvent::_impl_.value_)
      - PROTOBUF_FIELD_OFFSET(MdpTraceCounterFtraceEvent, _impl_.pid_)>(
          reinterpret_cast<char*>(&_impl_.pid_),
          reinterpret_cast<char*>(&other->_impl_.pid_));
}

std::string MdpTraceCounterFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MdpTraceCounterFtraceEvent";
}


// ===================================================================

class MdpCmdReleaseBwFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MdpCmdReleaseBwFtraceEvent>()._impl_._has_bits_);
  static void set_has_ctl_num(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

MdpCmdReleaseBwFtraceEvent::MdpCmdReleaseBwFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MdpCmdReleaseBwFtraceEvent)
}
MdpCmdReleaseBwFtraceEvent::MdpCmdReleaseBwFtraceEvent(const MdpCmdReleaseBwFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MdpCmdReleaseBwFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ctl_num_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.ctl_num_ = from._impl_.ctl_num_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MdpCmdReleaseBwFtraceEvent)
}

inline void MdpCmdReleaseBwFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ctl_num_){0u}
  };
}

MdpCmdReleaseBwFtraceEvent::~MdpCmdReleaseBwFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MdpCmdReleaseBwFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MdpCmdReleaseBwFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MdpCmdReleaseBwFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MdpCmdReleaseBwFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MdpCmdReleaseBwFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ctl_num_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MdpCmdReleaseBwFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 ctl_num = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ctl_num(&has_bits);
          _impl_.ctl_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MdpCmdReleaseBwFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MdpCmdReleaseBwFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 ctl_num = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_ctl_num(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MdpCmdReleaseBwFtraceEvent)
  return target;
}

size_t MdpCmdReleaseBwFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MdpCmdReleaseBwFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 ctl_num = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ctl_num());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MdpCmdReleaseBwFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MdpCmdReleaseBwFtraceEvent*>(
      &from));
}

void MdpCmdReleaseBwFtraceEvent::MergeFrom(const MdpCmdReleaseBwFtraceEvent& from) {
  MdpCmdReleaseBwFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MdpCmdReleaseBwFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_ctl_num()) {
    _this->_internal_set_ctl_num(from._internal_ctl_num());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MdpCmdReleaseBwFtraceEvent::CopyFrom(const MdpCmdReleaseBwFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MdpCmdReleaseBwFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MdpCmdReleaseBwFtraceEvent::IsInitialized() const {
  return true;
}

void MdpCmdReleaseBwFtraceEvent::InternalSwap(MdpCmdReleaseBwFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.ctl_num_, other->_impl_.ctl_num_);
}

std::string MdpCmdReleaseBwFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MdpCmdReleaseBwFtraceEvent";
}


// ===================================================================

class MdpMixerUpdateFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MdpMixerUpdateFtraceEvent>()._impl_._has_bits_);
  static void set_has_mixer_num(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

MdpMixerUpdateFtraceEvent::MdpMixerUpdateFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MdpMixerUpdateFtraceEvent)
}
MdpMixerUpdateFtraceEvent::MdpMixerUpdateFtraceEvent(const MdpMixerUpdateFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MdpMixerUpdateFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mixer_num_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.mixer_num_ = from._impl_.mixer_num_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MdpMixerUpdateFtraceEvent)
}

inline void MdpMixerUpdateFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mixer_num_){0u}
  };
}

MdpMixerUpdateFtraceEvent::~MdpMixerUpdateFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MdpMixerUpdateFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MdpMixerUpdateFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MdpMixerUpdateFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MdpMixerUpdateFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MdpMixerUpdateFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.mixer_num_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MdpMixerUpdateFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 mixer_num = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_mixer_num(&has_bits);
          _impl_.mixer_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MdpMixerUpdateFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MdpMixerUpdateFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 mixer_num = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_mixer_num(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MdpMixerUpdateFtraceEvent)
  return target;
}

size_t MdpMixerUpdateFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MdpMixerUpdateFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 mixer_num = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mixer_num());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MdpMixerUpdateFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MdpMixerUpdateFtraceEvent*>(
      &from));
}

void MdpMixerUpdateFtraceEvent::MergeFrom(const MdpMixerUpdateFtraceEvent& from) {
  MdpMixerUpdateFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MdpMixerUpdateFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_mixer_num()) {
    _this->_internal_set_mixer_num(from._internal_mixer_num());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MdpMixerUpdateFtraceEvent::CopyFrom(const MdpMixerUpdateFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MdpMixerUpdateFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MdpMixerUpdateFtraceEvent::IsInitialized() const {
  return true;
}

void MdpMixerUpdateFtraceEvent::InternalSwap(MdpMixerUpdateFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.mixer_num_, other->_impl_.mixer_num_);
}

std::string MdpMixerUpdateFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MdpMixerUpdateFtraceEvent";
}


// ===================================================================

class MdpPerfSetWmLevelsFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MdpPerfSetWmLevelsFtraceEvent>()._impl_._has_bits_);
  static void set_has_pnum(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_use_space(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_priority_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_wm0(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_wm1(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_wm2(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_mb_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_mb_size(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

MdpPerfSetWmLevelsFtraceEvent::MdpPerfSetWmLevelsFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MdpPerfSetWmLevelsFtraceEvent)
}
MdpPerfSetWmLevelsFtraceEvent::MdpPerfSetWmLevelsFtraceEvent(const MdpPerfSetWmLevelsFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MdpPerfSetWmLevelsFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pnum_){}
    , decltype(_impl_.use_space_){}
    , decltype(_impl_.priority_bytes_){}
    , decltype(_impl_.wm0_){}
    , decltype(_impl_.wm1_){}
    , decltype(_impl_.wm2_){}
    , decltype(_impl_.mb_cnt_){}
    , decltype(_impl_.mb_size_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.pnum_, &from._impl_.pnum_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.mb_size_) -
    reinterpret_cast<char*>(&_impl_.pnum_)) + sizeof(_impl_.mb_size_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MdpPerfSetWmLevelsFtraceEvent)
}

inline void MdpPerfSetWmLevelsFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pnum_){0u}
    , decltype(_impl_.use_space_){0u}
    , decltype(_impl_.priority_bytes_){0u}
    , decltype(_impl_.wm0_){0u}
    , decltype(_impl_.wm1_){0u}
    , decltype(_impl_.wm2_){0u}
    , decltype(_impl_.mb_cnt_){0u}
    , decltype(_impl_.mb_size_){0u}
  };
}

MdpPerfSetWmLevelsFtraceEvent::~MdpPerfSetWmLevelsFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MdpPerfSetWmLevelsFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MdpPerfSetWmLevelsFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MdpPerfSetWmLevelsFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MdpPerfSetWmLevelsFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MdpPerfSetWmLevelsFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.pnum_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.mb_size_) -
        reinterpret_cast<char*>(&_impl_.pnum_)) + sizeof(_impl_.mb_size_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MdpPerfSetWmLevelsFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 pnum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_pnum(&has_bits);
          _impl_.pnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 use_space = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_use_space(&has_bits);
          _impl_.use_space_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 priority_bytes = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_priority_bytes(&has_bits);
          _impl_.priority_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 wm0 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_wm0(&has_bits);
          _impl_.wm0_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 wm1 = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_wm1(&has_bits);
          _impl_.wm1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 wm2 = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_wm2(&has_bits);
          _impl_.wm2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mb_cnt = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_mb_cnt(&has_bits);
          _impl_.mb_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mb_size = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_mb_size(&has_bits);
          _impl_.mb_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MdpPerfSetWmLevelsFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MdpPerfSetWmLevelsFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 pnum = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_pnum(), target);
  }

  // optional uint32 use_space = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_use_space(), target);
  }

  // optional uint32 priority_bytes = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_priority_bytes(), target);
  }

  // optional uint32 wm0 = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_wm0(), target);
  }

  // optional uint32 wm1 = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_wm1(), target);
  }

  // optional uint32 wm2 = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_wm2(), target);
  }

  // optional uint32 mb_cnt = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_mb_cnt(), target);
  }

  // optional uint32 mb_size = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_mb_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MdpPerfSetWmLevelsFtraceEvent)
  return target;
}

size_t MdpPerfSetWmLevelsFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MdpPerfSetWmLevelsFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 pnum = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_pnum());
    }

    // optional uint32 use_space = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_use_space());
    }

    // optional uint32 priority_bytes = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_priority_bytes());
    }

    // optional uint32 wm0 = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_wm0());
    }

    // optional uint32 wm1 = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_wm1());
    }

    // optional uint32 wm2 = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_wm2());
    }

    // optional uint32 mb_cnt = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mb_cnt());
    }

    // optional uint32 mb_size = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mb_size());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MdpPerfSetWmLevelsFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MdpPerfSetWmLevelsFtraceEvent*>(
      &from));
}

void MdpPerfSetWmLevelsFtraceEvent::MergeFrom(const MdpPerfSetWmLevelsFtraceEvent& from) {
  MdpPerfSetWmLevelsFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MdpPerfSetWmLevelsFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.pnum_ = from._impl_.pnum_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.use_space_ = from._impl_.use_space_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.priority_bytes_ = from._impl_.priority_bytes_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.wm0_ = from._impl_.wm0_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.wm1_ = from._impl_.wm1_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.wm2_ = from._impl_.wm2_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.mb_cnt_ = from._impl_.mb_cnt_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.mb_size_ = from._impl_.mb_size_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MdpPerfSetWmLevelsFtraceEvent::CopyFrom(const MdpPerfSetWmLevelsFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MdpPerfSetWmLevelsFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MdpPerfSetWmLevelsFtraceEvent::IsInitialized() const {
  return true;
}

void MdpPerfSetWmLevelsFtraceEvent::InternalSwap(MdpPerfSetWmLevelsFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MdpPerfSetWmLevelsFtraceEvent, _impl_.mb_size_)
      + sizeof(MdpPerfSetWmLevelsFtraceEvent::_impl_.mb_size_)
      - PROTOBUF_FIELD_OFFSET(MdpPerfSetWmLevelsFtraceEvent, _impl_.pnum_)>(
          reinterpret_cast<char*>(&_impl_.pnum_),
          reinterpret_cast<char*>(&other->_impl_.pnum_));
}

std::string MdpPerfSetWmLevelsFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MdpPerfSetWmLevelsFtraceEvent";
}


// ===================================================================

class MdpVideoUnderrunDoneFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MdpVideoUnderrunDoneFtraceEvent>()._impl_._has_bits_);
  static void set_has_ctl_num(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_underrun_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

MdpVideoUnderrunDoneFtraceEvent::MdpVideoUnderrunDoneFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MdpVideoUnderrunDoneFtraceEvent)
}
MdpVideoUnderrunDoneFtraceEvent::MdpVideoUnderrunDoneFtraceEvent(const MdpVideoUnderrunDoneFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MdpVideoUnderrunDoneFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ctl_num_){}
    , decltype(_impl_.underrun_cnt_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.ctl_num_, &from._impl_.ctl_num_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.underrun_cnt_) -
    reinterpret_cast<char*>(&_impl_.ctl_num_)) + sizeof(_impl_.underrun_cnt_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MdpVideoUnderrunDoneFtraceEvent)
}

inline void MdpVideoUnderrunDoneFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ctl_num_){0u}
    , decltype(_impl_.underrun_cnt_){0u}
  };
}

MdpVideoUnderrunDoneFtraceEvent::~MdpVideoUnderrunDoneFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MdpVideoUnderrunDoneFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MdpVideoUnderrunDoneFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MdpVideoUnderrunDoneFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MdpVideoUnderrunDoneFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MdpVideoUnderrunDoneFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.ctl_num_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.underrun_cnt_) -
        reinterpret_cast<char*>(&_impl_.ctl_num_)) + sizeof(_impl_.underrun_cnt_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MdpVideoUnderrunDoneFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 ctl_num = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ctl_num(&has_bits);
          _impl_.ctl_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 underrun_cnt = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_underrun_cnt(&has_bits);
          _impl_.underrun_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MdpVideoUnderrunDoneFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MdpVideoUnderrunDoneFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 ctl_num = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_ctl_num(), target);
  }

  // optional uint32 underrun_cnt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_underrun_cnt(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MdpVideoUnderrunDoneFtraceEvent)
  return target;
}

size_t MdpVideoUnderrunDoneFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MdpVideoUnderrunDoneFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 ctl_num = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ctl_num());
    }

    // optional uint32 underrun_cnt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_underrun_cnt());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MdpVideoUnderrunDoneFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MdpVideoUnderrunDoneFtraceEvent*>(
      &from));
}

void MdpVideoUnderrunDoneFtraceEvent::MergeFrom(const MdpVideoUnderrunDoneFtraceEvent& from) {
  MdpVideoUnderrunDoneFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MdpVideoUnderrunDoneFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.ctl_num_ = from._impl_.ctl_num_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.underrun_cnt_ = from._impl_.underrun_cnt_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MdpVideoUnderrunDoneFtraceEvent::CopyFrom(const MdpVideoUnderrunDoneFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MdpVideoUnderrunDoneFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MdpVideoUnderrunDoneFtraceEvent::IsInitialized() const {
  return true;
}

void MdpVideoUnderrunDoneFtraceEvent::InternalSwap(MdpVideoUnderrunDoneFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MdpVideoUnderrunDoneFtraceEvent, _impl_.underrun_cnt_)
      + sizeof(MdpVideoUnderrunDoneFtraceEvent::_impl_.underrun_cnt_)
      - PROTOBUF_FIELD_OFFSET(MdpVideoUnderrunDoneFtraceEvent, _impl_.ctl_num_)>(
          reinterpret_cast<char*>(&_impl_.ctl_num_),
          reinterpret_cast<char*>(&other->_impl_.ctl_num_));
}

std::string MdpVideoUnderrunDoneFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MdpVideoUnderrunDoneFtraceEvent";
}


// ===================================================================

class MdpCmdWaitPingpongFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MdpCmdWaitPingpongFtraceEvent>()._impl_._has_bits_);
  static void set_has_ctl_num(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_kickoff_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

MdpCmdWaitPingpongFtraceEvent::MdpCmdWaitPingpongFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MdpCmdWaitPingpongFtraceEvent)
}
MdpCmdWaitPingpongFtraceEvent::MdpCmdWaitPingpongFtraceEvent(const MdpCmdWaitPingpongFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MdpCmdWaitPingpongFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ctl_num_){}
    , decltype(_impl_.kickoff_cnt_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.ctl_num_, &from._impl_.ctl_num_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.kickoff_cnt_) -
    reinterpret_cast<char*>(&_impl_.ctl_num_)) + sizeof(_impl_.kickoff_cnt_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MdpCmdWaitPingpongFtraceEvent)
}

inline void MdpCmdWaitPingpongFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ctl_num_){0u}
    , decltype(_impl_.kickoff_cnt_){0}
  };
}

MdpCmdWaitPingpongFtraceEvent::~MdpCmdWaitPingpongFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MdpCmdWaitPingpongFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MdpCmdWaitPingpongFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MdpCmdWaitPingpongFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MdpCmdWaitPingpongFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MdpCmdWaitPingpongFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.ctl_num_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.kickoff_cnt_) -
        reinterpret_cast<char*>(&_impl_.ctl_num_)) + sizeof(_impl_.kickoff_cnt_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MdpCmdWaitPingpongFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 ctl_num = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ctl_num(&has_bits);
          _impl_.ctl_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 kickoff_cnt = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_kickoff_cnt(&has_bits);
          _impl_.kickoff_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MdpCmdWaitPingpongFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MdpCmdWaitPingpongFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 ctl_num = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_ctl_num(), target);
  }

  // optional int32 kickoff_cnt = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_kickoff_cnt(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MdpCmdWaitPingpongFtraceEvent)
  return target;
}

size_t MdpCmdWaitPingpongFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MdpCmdWaitPingpongFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 ctl_num = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ctl_num());
    }

    // optional int32 kickoff_cnt = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_kickoff_cnt());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MdpCmdWaitPingpongFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MdpCmdWaitPingpongFtraceEvent*>(
      &from));
}

void MdpCmdWaitPingpongFtraceEvent::MergeFrom(const MdpCmdWaitPingpongFtraceEvent& from) {
  MdpCmdWaitPingpongFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MdpCmdWaitPingpongFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.ctl_num_ = from._impl_.ctl_num_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.kickoff_cnt_ = from._impl_.kickoff_cnt_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MdpCmdWaitPingpongFtraceEvent::CopyFrom(const MdpCmdWaitPingpongFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MdpCmdWaitPingpongFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MdpCmdWaitPingpongFtraceEvent::IsInitialized() const {
  return true;
}

void MdpCmdWaitPingpongFtraceEvent::InternalSwap(MdpCmdWaitPingpongFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MdpCmdWaitPingpongFtraceEvent, _impl_.kickoff_cnt_)
      + sizeof(MdpCmdWaitPingpongFtraceEvent::_impl_.kickoff_cnt_)
      - PROTOBUF_FIELD_OFFSET(MdpCmdWaitPingpongFtraceEvent, _impl_.ctl_num_)>(
          reinterpret_cast<char*>(&_impl_.ctl_num_),
          reinterpret_cast<char*>(&other->_impl_.ctl_num_));
}

std::string MdpCmdWaitPingpongFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MdpCmdWaitPingpongFtraceEvent";
}


// ===================================================================

class MdpPerfPrefillCalcFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MdpPerfPrefillCalcFtraceEvent>()._impl_._has_bits_);
  static void set_has_pnum(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_latency_buf(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ot(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_y_buf(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_y_scaler(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_pp_lines(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_pp_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_post_sc(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_fbc_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_prefill_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

MdpPerfPrefillCalcFtraceEvent::MdpPerfPrefillCalcFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MdpPerfPrefillCalcFtraceEvent)
}
MdpPerfPrefillCalcFtraceEvent::MdpPerfPrefillCalcFtraceEvent(const MdpPerfPrefillCalcFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MdpPerfPrefillCalcFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pnum_){}
    , decltype(_impl_.latency_buf_){}
    , decltype(_impl_.ot_){}
    , decltype(_impl_.y_buf_){}
    , decltype(_impl_.y_scaler_){}
    , decltype(_impl_.pp_lines_){}
    , decltype(_impl_.pp_bytes_){}
    , decltype(_impl_.post_sc_){}
    , decltype(_impl_.fbc_bytes_){}
    , decltype(_impl_.prefill_bytes_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.pnum_, &from._impl_.pnum_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.prefill_bytes_) -
    reinterpret_cast<char*>(&_impl_.pnum_)) + sizeof(_impl_.prefill_bytes_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MdpPerfPrefillCalcFtraceEvent)
}

inline void MdpPerfPrefillCalcFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pnum_){0u}
    , decltype(_impl_.latency_buf_){0u}
    , decltype(_impl_.ot_){0u}
    , decltype(_impl_.y_buf_){0u}
    , decltype(_impl_.y_scaler_){0u}
    , decltype(_impl_.pp_lines_){0u}
    , decltype(_impl_.pp_bytes_){0u}
    , decltype(_impl_.post_sc_){0u}
    , decltype(_impl_.fbc_bytes_){0u}
    , decltype(_impl_.prefill_bytes_){0u}
  };
}

MdpPerfPrefillCalcFtraceEvent::~MdpPerfPrefillCalcFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MdpPerfPrefillCalcFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MdpPerfPrefillCalcFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MdpPerfPrefillCalcFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MdpPerfPrefillCalcFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MdpPerfPrefillCalcFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.pnum_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.post_sc_) -
        reinterpret_cast<char*>(&_impl_.pnum_)) + sizeof(_impl_.post_sc_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.fbc_bytes_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.prefill_bytes_) -
        reinterpret_cast<char*>(&_impl_.fbc_bytes_)) + sizeof(_impl_.prefill_bytes_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MdpPerfPrefillCalcFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 pnum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_pnum(&has_bits);
          _impl_.pnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 latency_buf = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_latency_buf(&has_bits);
          _impl_.latency_buf_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ot = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_ot(&has_bits);
          _impl_.ot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 y_buf = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_y_buf(&has_bits);
          _impl_.y_buf_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 y_scaler = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_y_scaler(&has_bits);
          _impl_.y_scaler_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 pp_lines = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_pp_lines(&has_bits);
          _impl_.pp_lines_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 pp_bytes = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_pp_bytes(&has_bits);
          _impl_.pp_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 post_sc = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_post_sc(&has_bits);
          _impl_.post_sc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 fbc_bytes = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_fbc_bytes(&has_bits);
          _impl_.fbc_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 prefill_bytes = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_prefill_bytes(&has_bits);
          _impl_.prefill_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MdpPerfPrefillCalcFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MdpPerfPrefillCalcFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 pnum = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_pnum(), target);
  }

  // optional uint32 latency_buf = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_latency_buf(), target);
  }

  // optional uint32 ot = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_ot(), target);
  }

  // optional uint32 y_buf = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_y_buf(), target);
  }

  // optional uint32 y_scaler = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_y_scaler(), target);
  }

  // optional uint32 pp_lines = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_pp_lines(), target);
  }

  // optional uint32 pp_bytes = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_pp_bytes(), target);
  }

  // optional uint32 post_sc = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_post_sc(), target);
  }

  // optional uint32 fbc_bytes = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_fbc_bytes(), target);
  }

  // optional uint32 prefill_bytes = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_prefill_bytes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MdpPerfPrefillCalcFtraceEvent)
  return target;
}

size_t MdpPerfPrefillCalcFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MdpPerfPrefillCalcFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 pnum = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_pnum());
    }

    // optional uint32 latency_buf = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_latency_buf());
    }

    // optional uint32 ot = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ot());
    }

    // optional uint32 y_buf = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_y_buf());
    }

    // optional uint32 y_scaler = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_y_scaler());
    }

    // optional uint32 pp_lines = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_pp_lines());
    }

    // optional uint32 pp_bytes = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_pp_bytes());
    }

    // optional uint32 post_sc = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_post_sc());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint32 fbc_bytes = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_fbc_bytes());
    }

    // optional uint32 prefill_bytes = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_prefill_bytes());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MdpPerfPrefillCalcFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MdpPerfPrefillCalcFtraceEvent*>(
      &from));
}

void MdpPerfPrefillCalcFtraceEvent::MergeFrom(const MdpPerfPrefillCalcFtraceEvent& from) {
  MdpPerfPrefillCalcFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MdpPerfPrefillCalcFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.pnum_ = from._impl_.pnum_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.latency_buf_ = from._impl_.latency_buf_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ot_ = from._impl_.ot_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.y_buf_ = from._impl_.y_buf_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.y_scaler_ = from._impl_.y_scaler_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.pp_lines_ = from._impl_.pp_lines_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.pp_bytes_ = from._impl_.pp_bytes_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.post_sc_ = from._impl_.post_sc_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.fbc_bytes_ = from._impl_.fbc_bytes_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.prefill_bytes_ = from._impl_.prefill_bytes_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MdpPerfPrefillCalcFtraceEvent::CopyFrom(const MdpPerfPrefillCalcFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MdpPerfPrefillCalcFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MdpPerfPrefillCalcFtraceEvent::IsInitialized() const {
  return true;
}

void MdpPerfPrefillCalcFtraceEvent::InternalSwap(MdpPerfPrefillCalcFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MdpPerfPrefillCalcFtraceEvent, _impl_.prefill_bytes_)
      + sizeof(MdpPerfPrefillCalcFtraceEvent::_impl_.prefill_bytes_)
      - PROTOBUF_FIELD_OFFSET(MdpPerfPrefillCalcFtraceEvent, _impl_.pnum_)>(
          reinterpret_cast<char*>(&_impl_.pnum_),
          reinterpret_cast<char*>(&other->_impl_.pnum_));
}

std::string MdpPerfPrefillCalcFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MdpPerfPrefillCalcFtraceEvent";
}


// ===================================================================

class MdpPerfUpdateBusFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MdpPerfUpdateBusFtraceEvent>()._impl_._has_bits_);
  static void set_has_client(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ab_quota(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ib_quota(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

MdpPerfUpdateBusFtraceEvent::MdpPerfUpdateBusFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.MdpPerfUpdateBusFtraceEvent)
}
MdpPerfUpdateBusFtraceEvent::MdpPerfUpdateBusFtraceEvent(const MdpPerfUpdateBusFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MdpPerfUpdateBusFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ab_quota_){}
    , decltype(_impl_.ib_quota_){}
    , decltype(_impl_.client_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.ab_quota_, &from._impl_.ab_quota_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.client_) -
    reinterpret_cast<char*>(&_impl_.ab_quota_)) + sizeof(_impl_.client_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.MdpPerfUpdateBusFtraceEvent)
}

inline void MdpPerfUpdateBusFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ab_quota_){uint64_t{0u}}
    , decltype(_impl_.ib_quota_){uint64_t{0u}}
    , decltype(_impl_.client_){0}
  };
}

MdpPerfUpdateBusFtraceEvent::~MdpPerfUpdateBusFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.MdpPerfUpdateBusFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MdpPerfUpdateBusFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MdpPerfUpdateBusFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MdpPerfUpdateBusFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.MdpPerfUpdateBusFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.ab_quota_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.client_) -
        reinterpret_cast<char*>(&_impl_.ab_quota_)) + sizeof(_impl_.client_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MdpPerfUpdateBusFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 client = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_client(&has_bits);
          _impl_.client_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ab_quota = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ab_quota(&has_bits);
          _impl_.ab_quota_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 ib_quota = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_ib_quota(&has_bits);
          _impl_.ib_quota_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MdpPerfUpdateBusFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.MdpPerfUpdateBusFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 client = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_client(), target);
  }

  // optional uint64 ab_quota = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ab_quota(), target);
  }

  // optional uint64 ib_quota = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_ib_quota(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.MdpPerfUpdateBusFtraceEvent)
  return target;
}

size_t MdpPerfUpdateBusFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.MdpPerfUpdateBusFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 ab_quota = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ab_quota());
    }

    // optional uint64 ib_quota = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ib_quota());
    }

    // optional int32 client = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_client());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MdpPerfUpdateBusFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MdpPerfUpdateBusFtraceEvent*>(
      &from));
}

void MdpPerfUpdateBusFtraceEvent::MergeFrom(const MdpPerfUpdateBusFtraceEvent& from) {
  MdpPerfUpdateBusFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.MdpPerfUpdateBusFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.ab_quota_ = from._impl_.ab_quota_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ib_quota_ = from._impl_.ib_quota_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.client_ = from._impl_.client_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MdpPerfUpdateBusFtraceEvent::CopyFrom(const MdpPerfUpdateBusFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.MdpPerfUpdateBusFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MdpPerfUpdateBusFtraceEvent::IsInitialized() const {
  return true;
}

void MdpPerfUpdateBusFtraceEvent::InternalSwap(MdpPerfUpdateBusFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MdpPerfUpdateBusFtraceEvent, _impl_.client_)
      + sizeof(MdpPerfUpdateBusFtraceEvent::_impl_.client_)
      - PROTOBUF_FIELD_OFFSET(MdpPerfUpdateBusFtraceEvent, _impl_.ab_quota_)>(
          reinterpret_cast<char*>(&_impl_.ab_quota_),
          reinterpret_cast<char*>(&other->_impl_.ab_quota_));
}

std::string MdpPerfUpdateBusFtraceEvent::GetTypeName() const {
  return "perfetto.protos.MdpPerfUpdateBusFtraceEvent";
}


// ===================================================================

class RotatorBwAoAsContextFtraceEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<RotatorBwAoAsContextFtraceEvent>()._impl_._has_bits_);
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

RotatorBwAoAsContextFtraceEvent::RotatorBwAoAsContextFtraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.RotatorBwAoAsContextFtraceEvent)
}
RotatorBwAoAsContextFtraceEvent::RotatorBwAoAsContextFtraceEvent(const RotatorBwAoAsContextFtraceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  RotatorBwAoAsContextFtraceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.state_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.state_ = from._impl_.state_;
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.RotatorBwAoAsContextFtraceEvent)
}

inline void RotatorBwAoAsContextFtraceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.state_){0u}
  };
}

RotatorBwAoAsContextFtraceEvent::~RotatorBwAoAsContextFtraceEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.RotatorBwAoAsContextFtraceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RotatorBwAoAsContextFtraceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RotatorBwAoAsContextFtraceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RotatorBwAoAsContextFtraceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.RotatorBwAoAsContextFtraceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.state_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RotatorBwAoAsContextFtraceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 state = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_state(&has_bits);
          _impl_.state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RotatorBwAoAsContextFtraceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.RotatorBwAoAsContextFtraceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 state = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.RotatorBwAoAsContextFtraceEvent)
  return target;
}

size_t RotatorBwAoAsContextFtraceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.RotatorBwAoAsContextFtraceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 state = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_state());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RotatorBwAoAsContextFtraceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RotatorBwAoAsContextFtraceEvent*>(
      &from));
}

void RotatorBwAoAsContextFtraceEvent::MergeFrom(const RotatorBwAoAsContextFtraceEvent& from) {
  RotatorBwAoAsContextFtraceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.RotatorBwAoAsContextFtraceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_state()) {
    _this->_internal_set_state(from._internal_state());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RotatorBwAoAsContextFtraceEvent::CopyFrom(const RotatorBwAoAsContextFtraceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.RotatorBwAoAsContextFtraceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RotatorBwAoAsContextFtraceEvent::IsInitialized() const {
  return true;
}

void RotatorBwAoAsContextFtraceEvent::InternalSwap(RotatorBwAoAsContextFtraceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.state_, other->_impl_.state_);
}

std::string RotatorBwAoAsContextFtraceEvent::GetTypeName() const {
  return "perfetto.protos.RotatorBwAoAsContextFtraceEvent";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace protos
}  // namespace perfetto
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::perfetto::protos::MdpCmdKickoffFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MdpCmdKickoffFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MdpCmdKickoffFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MdpCommitFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MdpCommitFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MdpCommitFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MdpPerfSetOtFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MdpPerfSetOtFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MdpPerfSetOtFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MdpSsppChangeFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MdpSsppChangeFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MdpSsppChangeFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::TracingMarkWriteFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::TracingMarkWriteFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::TracingMarkWriteFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MdpCmdPingpongDoneFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MdpCmdPingpongDoneFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MdpCmdPingpongDoneFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MdpCompareBwFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MdpCompareBwFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MdpCompareBwFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MdpPerfSetPanicLutsFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MdpPerfSetPanicLutsFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MdpPerfSetPanicLutsFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MdpSsppSetFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MdpSsppSetFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MdpSsppSetFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MdpCmdReadptrDoneFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MdpCmdReadptrDoneFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MdpCmdReadptrDoneFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MdpMisrCrcFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MdpMisrCrcFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MdpMisrCrcFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MdpPerfSetQosLutsFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MdpPerfSetQosLutsFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MdpPerfSetQosLutsFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MdpTraceCounterFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MdpTraceCounterFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MdpTraceCounterFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MdpCmdReleaseBwFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MdpCmdReleaseBwFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MdpCmdReleaseBwFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MdpMixerUpdateFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MdpMixerUpdateFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MdpMixerUpdateFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MdpPerfSetWmLevelsFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MdpPerfSetWmLevelsFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MdpPerfSetWmLevelsFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MdpVideoUnderrunDoneFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MdpVideoUnderrunDoneFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MdpVideoUnderrunDoneFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MdpCmdWaitPingpongFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MdpCmdWaitPingpongFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MdpCmdWaitPingpongFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MdpPerfPrefillCalcFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MdpPerfPrefillCalcFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MdpPerfPrefillCalcFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::MdpPerfUpdateBusFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::MdpPerfUpdateBusFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::MdpPerfUpdateBusFtraceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::RotatorBwAoAsContextFtraceEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::RotatorBwAoAsContextFtraceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::RotatorBwAoAsContextFtraceEvent >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
