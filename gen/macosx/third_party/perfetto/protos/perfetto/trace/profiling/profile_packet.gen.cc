#include "perfetto/protozero/gen_field_helpers.h"
#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/scattered_heap_buffer.h"
// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
#endif
#include "protos/perfetto/trace/profiling/profile_packet.gen.h"
#include "protos/perfetto/trace/profiling/profile_common.gen.h"
#include "protos/perfetto/common/perf_events.gen.h"

namespace perfetto {
namespace protos {
namespace gen {

PerfSampleDefaults::PerfSampleDefaults() = default;
PerfSampleDefaults::~PerfSampleDefaults() = default;
PerfSampleDefaults::PerfSampleDefaults(const PerfSampleDefaults&) = default;
PerfSampleDefaults& PerfSampleDefaults::operator=(const PerfSampleDefaults&) = default;
PerfSampleDefaults::PerfSampleDefaults(PerfSampleDefaults&&) noexcept = default;
PerfSampleDefaults& PerfSampleDefaults::operator=(PerfSampleDefaults&&) = default;

bool PerfSampleDefaults::operator==(const PerfSampleDefaults& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(timebase_, other.timebase_)
   && ::protozero::internal::gen_helpers::EqualsField(process_shard_count_, other.process_shard_count_)
   && ::protozero::internal::gen_helpers::EqualsField(chosen_process_shard_, other.chosen_process_shard_);
}

bool PerfSampleDefaults::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* timebase */:
        (*timebase_).ParseFromArray(field.data(), field.size());
        break;
      case 2 /* process_shard_count */:
        field.get(&process_shard_count_);
        break;
      case 3 /* chosen_process_shard */:
        field.get(&chosen_process_shard_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string PerfSampleDefaults::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> PerfSampleDefaults::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void PerfSampleDefaults::Serialize(::protozero::Message* msg) const {
  // Field 1: timebase
  if (_has_field_[1]) {
    (*timebase_).Serialize(msg->BeginNestedMessage<::protozero::Message>(1));
  }

  // Field 2: process_shard_count
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, process_shard_count_, msg);
  }

  // Field 3: chosen_process_shard
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, chosen_process_shard_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


PerfSample::PerfSample() = default;
PerfSample::~PerfSample() = default;
PerfSample::PerfSample(const PerfSample&) = default;
PerfSample& PerfSample::operator=(const PerfSample&) = default;
PerfSample::PerfSample(PerfSample&&) noexcept = default;
PerfSample& PerfSample::operator=(PerfSample&&) = default;

bool PerfSample::operator==(const PerfSample& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(cpu_, other.cpu_)
   && ::protozero::internal::gen_helpers::EqualsField(pid_, other.pid_)
   && ::protozero::internal::gen_helpers::EqualsField(tid_, other.tid_)
   && ::protozero::internal::gen_helpers::EqualsField(cpu_mode_, other.cpu_mode_)
   && ::protozero::internal::gen_helpers::EqualsField(timebase_count_, other.timebase_count_)
   && ::protozero::internal::gen_helpers::EqualsField(callstack_iid_, other.callstack_iid_)
   && ::protozero::internal::gen_helpers::EqualsField(unwind_error_, other.unwind_error_)
   && ::protozero::internal::gen_helpers::EqualsField(kernel_records_lost_, other.kernel_records_lost_)
   && ::protozero::internal::gen_helpers::EqualsField(sample_skipped_reason_, other.sample_skipped_reason_)
   && ::protozero::internal::gen_helpers::EqualsField(producer_event_, other.producer_event_);
}

bool PerfSample::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* cpu */:
        field.get(&cpu_);
        break;
      case 2 /* pid */:
        field.get(&pid_);
        break;
      case 3 /* tid */:
        field.get(&tid_);
        break;
      case 5 /* cpu_mode */:
        field.get(&cpu_mode_);
        break;
      case 6 /* timebase_count */:
        field.get(&timebase_count_);
        break;
      case 4 /* callstack_iid */:
        field.get(&callstack_iid_);
        break;
      case 16 /* unwind_error */:
        field.get(&unwind_error_);
        break;
      case 17 /* kernel_records_lost */:
        field.get(&kernel_records_lost_);
        break;
      case 18 /* sample_skipped_reason */:
        field.get(&sample_skipped_reason_);
        break;
      case 19 /* producer_event */:
        (*producer_event_).ParseFromArray(field.data(), field.size());
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string PerfSample::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> PerfSample::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void PerfSample::Serialize(::protozero::Message* msg) const {
  // Field 1: cpu
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, cpu_, msg);
  }

  // Field 2: pid
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, pid_, msg);
  }

  // Field 3: tid
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, tid_, msg);
  }

  // Field 5: cpu_mode
  if (_has_field_[5]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(5, cpu_mode_, msg);
  }

  // Field 6: timebase_count
  if (_has_field_[6]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(6, timebase_count_, msg);
  }

  // Field 4: callstack_iid
  if (_has_field_[4]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(4, callstack_iid_, msg);
  }

  // Field 16: unwind_error
  if (_has_field_[16]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(16, unwind_error_, msg);
  }

  // Field 17: kernel_records_lost
  if (_has_field_[17]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(17, kernel_records_lost_, msg);
  }

  // Field 18: sample_skipped_reason
  if (_has_field_[18]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(18, sample_skipped_reason_, msg);
  }

  // Field 19: producer_event
  if (_has_field_[19]) {
    (*producer_event_).Serialize(msg->BeginNestedMessage<::protozero::Message>(19));
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


PerfSample_ProducerEvent::PerfSample_ProducerEvent() = default;
PerfSample_ProducerEvent::~PerfSample_ProducerEvent() = default;
PerfSample_ProducerEvent::PerfSample_ProducerEvent(const PerfSample_ProducerEvent&) = default;
PerfSample_ProducerEvent& PerfSample_ProducerEvent::operator=(const PerfSample_ProducerEvent&) = default;
PerfSample_ProducerEvent::PerfSample_ProducerEvent(PerfSample_ProducerEvent&&) noexcept = default;
PerfSample_ProducerEvent& PerfSample_ProducerEvent::operator=(PerfSample_ProducerEvent&&) = default;

bool PerfSample_ProducerEvent::operator==(const PerfSample_ProducerEvent& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(source_stop_reason_, other.source_stop_reason_);
}

bool PerfSample_ProducerEvent::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* source_stop_reason */:
        field.get(&source_stop_reason_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string PerfSample_ProducerEvent::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> PerfSample_ProducerEvent::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void PerfSample_ProducerEvent::Serialize(::protozero::Message* msg) const {
  // Field 1: source_stop_reason
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, source_stop_reason_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


Profiling::Profiling() = default;
Profiling::~Profiling() = default;
Profiling::Profiling(const Profiling&) = default;
Profiling& Profiling::operator=(const Profiling&) = default;
Profiling::Profiling(Profiling&&) noexcept = default;
Profiling& Profiling::operator=(Profiling&&) = default;

bool Profiling::operator==(const Profiling& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_);
}

bool Profiling::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string Profiling::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> Profiling::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void Profiling::Serialize(::protozero::Message* msg) const {
  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


StreamingProfilePacket::StreamingProfilePacket() = default;
StreamingProfilePacket::~StreamingProfilePacket() = default;
StreamingProfilePacket::StreamingProfilePacket(const StreamingProfilePacket&) = default;
StreamingProfilePacket& StreamingProfilePacket::operator=(const StreamingProfilePacket&) = default;
StreamingProfilePacket::StreamingProfilePacket(StreamingProfilePacket&&) noexcept = default;
StreamingProfilePacket& StreamingProfilePacket::operator=(StreamingProfilePacket&&) = default;

bool StreamingProfilePacket::operator==(const StreamingProfilePacket& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(callstack_iid_, other.callstack_iid_)
   && ::protozero::internal::gen_helpers::EqualsField(timestamp_delta_us_, other.timestamp_delta_us_)
   && ::protozero::internal::gen_helpers::EqualsField(process_priority_, other.process_priority_);
}

bool StreamingProfilePacket::ParseFromArray(const void* raw, size_t size) {
  callstack_iid_.clear();
  timestamp_delta_us_.clear();
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* callstack_iid */:
        callstack_iid_.emplace_back();
        field.get(&callstack_iid_.back());
        break;
      case 2 /* timestamp_delta_us */:
        timestamp_delta_us_.emplace_back();
        field.get(&timestamp_delta_us_.back());
        break;
      case 3 /* process_priority */:
        field.get(&process_priority_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string StreamingProfilePacket::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> StreamingProfilePacket::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void StreamingProfilePacket::Serialize(::protozero::Message* msg) const {
  // Field 1: callstack_iid
  for (auto& it : callstack_iid_) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, it, msg);
  }

  // Field 2: timestamp_delta_us
  for (auto& it : timestamp_delta_us_) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, it, msg);
  }

  // Field 3: process_priority
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, process_priority_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


StreamingFree::StreamingFree() = default;
StreamingFree::~StreamingFree() = default;
StreamingFree::StreamingFree(const StreamingFree&) = default;
StreamingFree& StreamingFree::operator=(const StreamingFree&) = default;
StreamingFree::StreamingFree(StreamingFree&&) noexcept = default;
StreamingFree& StreamingFree::operator=(StreamingFree&&) = default;

bool StreamingFree::operator==(const StreamingFree& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(address_, other.address_)
   && ::protozero::internal::gen_helpers::EqualsField(heap_id_, other.heap_id_)
   && ::protozero::internal::gen_helpers::EqualsField(sequence_number_, other.sequence_number_);
}

bool StreamingFree::ParseFromArray(const void* raw, size_t size) {
  address_.clear();
  heap_id_.clear();
  sequence_number_.clear();
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* address */:
        address_.emplace_back();
        field.get(&address_.back());
        break;
      case 2 /* heap_id */:
        heap_id_.emplace_back();
        field.get(&heap_id_.back());
        break;
      case 3 /* sequence_number */:
        sequence_number_.emplace_back();
        field.get(&sequence_number_.back());
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string StreamingFree::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> StreamingFree::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void StreamingFree::Serialize(::protozero::Message* msg) const {
  // Field 1: address
  for (auto& it : address_) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, it, msg);
  }

  // Field 2: heap_id
  for (auto& it : heap_id_) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, it, msg);
  }

  // Field 3: sequence_number
  for (auto& it : sequence_number_) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, it, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


StreamingAllocation::StreamingAllocation() = default;
StreamingAllocation::~StreamingAllocation() = default;
StreamingAllocation::StreamingAllocation(const StreamingAllocation&) = default;
StreamingAllocation& StreamingAllocation::operator=(const StreamingAllocation&) = default;
StreamingAllocation::StreamingAllocation(StreamingAllocation&&) noexcept = default;
StreamingAllocation& StreamingAllocation::operator=(StreamingAllocation&&) = default;

bool StreamingAllocation::operator==(const StreamingAllocation& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(address_, other.address_)
   && ::protozero::internal::gen_helpers::EqualsField(size_, other.size_)
   && ::protozero::internal::gen_helpers::EqualsField(sample_size_, other.sample_size_)
   && ::protozero::internal::gen_helpers::EqualsField(clock_monotonic_coarse_timestamp_, other.clock_monotonic_coarse_timestamp_)
   && ::protozero::internal::gen_helpers::EqualsField(heap_id_, other.heap_id_)
   && ::protozero::internal::gen_helpers::EqualsField(sequence_number_, other.sequence_number_);
}

bool StreamingAllocation::ParseFromArray(const void* raw, size_t size) {
  address_.clear();
  size_.clear();
  sample_size_.clear();
  clock_monotonic_coarse_timestamp_.clear();
  heap_id_.clear();
  sequence_number_.clear();
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* address */:
        address_.emplace_back();
        field.get(&address_.back());
        break;
      case 2 /* size */:
        size_.emplace_back();
        field.get(&size_.back());
        break;
      case 3 /* sample_size */:
        sample_size_.emplace_back();
        field.get(&sample_size_.back());
        break;
      case 4 /* clock_monotonic_coarse_timestamp */:
        clock_monotonic_coarse_timestamp_.emplace_back();
        field.get(&clock_monotonic_coarse_timestamp_.back());
        break;
      case 5 /* heap_id */:
        heap_id_.emplace_back();
        field.get(&heap_id_.back());
        break;
      case 6 /* sequence_number */:
        sequence_number_.emplace_back();
        field.get(&sequence_number_.back());
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string StreamingAllocation::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> StreamingAllocation::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void StreamingAllocation::Serialize(::protozero::Message* msg) const {
  // Field 1: address
  for (auto& it : address_) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, it, msg);
  }

  // Field 2: size
  for (auto& it : size_) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, it, msg);
  }

  // Field 3: sample_size
  for (auto& it : sample_size_) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, it, msg);
  }

  // Field 4: clock_monotonic_coarse_timestamp
  for (auto& it : clock_monotonic_coarse_timestamp_) {
    ::protozero::internal::gen_helpers::SerializeVarInt(4, it, msg);
  }

  // Field 5: heap_id
  for (auto& it : heap_id_) {
    ::protozero::internal::gen_helpers::SerializeVarInt(5, it, msg);
  }

  // Field 6: sequence_number
  for (auto& it : sequence_number_) {
    ::protozero::internal::gen_helpers::SerializeVarInt(6, it, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


ProfilePacket::ProfilePacket() = default;
ProfilePacket::~ProfilePacket() = default;
ProfilePacket::ProfilePacket(const ProfilePacket&) = default;
ProfilePacket& ProfilePacket::operator=(const ProfilePacket&) = default;
ProfilePacket::ProfilePacket(ProfilePacket&&) noexcept = default;
ProfilePacket& ProfilePacket::operator=(ProfilePacket&&) = default;

bool ProfilePacket::operator==(const ProfilePacket& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(strings_, other.strings_)
   && ::protozero::internal::gen_helpers::EqualsField(mappings_, other.mappings_)
   && ::protozero::internal::gen_helpers::EqualsField(frames_, other.frames_)
   && ::protozero::internal::gen_helpers::EqualsField(callstacks_, other.callstacks_)
   && ::protozero::internal::gen_helpers::EqualsField(process_dumps_, other.process_dumps_)
   && ::protozero::internal::gen_helpers::EqualsField(continued_, other.continued_)
   && ::protozero::internal::gen_helpers::EqualsField(index_, other.index_);
}

int ProfilePacket::strings_size() const { return static_cast<int>(strings_.size()); }
void ProfilePacket::clear_strings() { strings_.clear(); }
InternedString* ProfilePacket::add_strings() { strings_.emplace_back(); return &strings_.back(); }
int ProfilePacket::mappings_size() const { return static_cast<int>(mappings_.size()); }
void ProfilePacket::clear_mappings() { mappings_.clear(); }
Mapping* ProfilePacket::add_mappings() { mappings_.emplace_back(); return &mappings_.back(); }
int ProfilePacket::frames_size() const { return static_cast<int>(frames_.size()); }
void ProfilePacket::clear_frames() { frames_.clear(); }
Frame* ProfilePacket::add_frames() { frames_.emplace_back(); return &frames_.back(); }
int ProfilePacket::callstacks_size() const { return static_cast<int>(callstacks_.size()); }
void ProfilePacket::clear_callstacks() { callstacks_.clear(); }
Callstack* ProfilePacket::add_callstacks() { callstacks_.emplace_back(); return &callstacks_.back(); }
int ProfilePacket::process_dumps_size() const { return static_cast<int>(process_dumps_.size()); }
void ProfilePacket::clear_process_dumps() { process_dumps_.clear(); }
ProfilePacket_ProcessHeapSamples* ProfilePacket::add_process_dumps() { process_dumps_.emplace_back(); return &process_dumps_.back(); }
bool ProfilePacket::ParseFromArray(const void* raw, size_t size) {
  strings_.clear();
  mappings_.clear();
  frames_.clear();
  callstacks_.clear();
  process_dumps_.clear();
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* strings */:
        strings_.emplace_back();
        strings_.back().ParseFromArray(field.data(), field.size());
        break;
      case 4 /* mappings */:
        mappings_.emplace_back();
        mappings_.back().ParseFromArray(field.data(), field.size());
        break;
      case 2 /* frames */:
        frames_.emplace_back();
        frames_.back().ParseFromArray(field.data(), field.size());
        break;
      case 3 /* callstacks */:
        callstacks_.emplace_back();
        callstacks_.back().ParseFromArray(field.data(), field.size());
        break;
      case 5 /* process_dumps */:
        process_dumps_.emplace_back();
        process_dumps_.back().ParseFromArray(field.data(), field.size());
        break;
      case 6 /* continued */:
        field.get(&continued_);
        break;
      case 7 /* index */:
        field.get(&index_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string ProfilePacket::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> ProfilePacket::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void ProfilePacket::Serialize(::protozero::Message* msg) const {
  // Field 1: strings
  for (auto& it : strings_) {
    it.Serialize(msg->BeginNestedMessage<::protozero::Message>(1));
  }

  // Field 4: mappings
  for (auto& it : mappings_) {
    it.Serialize(msg->BeginNestedMessage<::protozero::Message>(4));
  }

  // Field 2: frames
  for (auto& it : frames_) {
    it.Serialize(msg->BeginNestedMessage<::protozero::Message>(2));
  }

  // Field 3: callstacks
  for (auto& it : callstacks_) {
    it.Serialize(msg->BeginNestedMessage<::protozero::Message>(3));
  }

  // Field 5: process_dumps
  for (auto& it : process_dumps_) {
    it.Serialize(msg->BeginNestedMessage<::protozero::Message>(5));
  }

  // Field 6: continued
  if (_has_field_[6]) {
    ::protozero::internal::gen_helpers::SerializeTinyVarInt(6, continued_, msg);
  }

  // Field 7: index
  if (_has_field_[7]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(7, index_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


ProfilePacket_ProcessHeapSamples::ProfilePacket_ProcessHeapSamples() = default;
ProfilePacket_ProcessHeapSamples::~ProfilePacket_ProcessHeapSamples() = default;
ProfilePacket_ProcessHeapSamples::ProfilePacket_ProcessHeapSamples(const ProfilePacket_ProcessHeapSamples&) = default;
ProfilePacket_ProcessHeapSamples& ProfilePacket_ProcessHeapSamples::operator=(const ProfilePacket_ProcessHeapSamples&) = default;
ProfilePacket_ProcessHeapSamples::ProfilePacket_ProcessHeapSamples(ProfilePacket_ProcessHeapSamples&&) noexcept = default;
ProfilePacket_ProcessHeapSamples& ProfilePacket_ProcessHeapSamples::operator=(ProfilePacket_ProcessHeapSamples&&) = default;

bool ProfilePacket_ProcessHeapSamples::operator==(const ProfilePacket_ProcessHeapSamples& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(pid_, other.pid_)
   && ::protozero::internal::gen_helpers::EqualsField(from_startup_, other.from_startup_)
   && ::protozero::internal::gen_helpers::EqualsField(rejected_concurrent_, other.rejected_concurrent_)
   && ::protozero::internal::gen_helpers::EqualsField(disconnected_, other.disconnected_)
   && ::protozero::internal::gen_helpers::EqualsField(buffer_overran_, other.buffer_overran_)
   && ::protozero::internal::gen_helpers::EqualsField(client_error_, other.client_error_)
   && ::protozero::internal::gen_helpers::EqualsField(buffer_corrupted_, other.buffer_corrupted_)
   && ::protozero::internal::gen_helpers::EqualsField(hit_guardrail_, other.hit_guardrail_)
   && ::protozero::internal::gen_helpers::EqualsField(heap_name_, other.heap_name_)
   && ::protozero::internal::gen_helpers::EqualsField(sampling_interval_bytes_, other.sampling_interval_bytes_)
   && ::protozero::internal::gen_helpers::EqualsField(orig_sampling_interval_bytes_, other.orig_sampling_interval_bytes_)
   && ::protozero::internal::gen_helpers::EqualsField(timestamp_, other.timestamp_)
   && ::protozero::internal::gen_helpers::EqualsField(stats_, other.stats_)
   && ::protozero::internal::gen_helpers::EqualsField(samples_, other.samples_);
}

int ProfilePacket_ProcessHeapSamples::samples_size() const { return static_cast<int>(samples_.size()); }
void ProfilePacket_ProcessHeapSamples::clear_samples() { samples_.clear(); }
ProfilePacket_HeapSample* ProfilePacket_ProcessHeapSamples::add_samples() { samples_.emplace_back(); return &samples_.back(); }
bool ProfilePacket_ProcessHeapSamples::ParseFromArray(const void* raw, size_t size) {
  samples_.clear();
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* pid */:
        field.get(&pid_);
        break;
      case 3 /* from_startup */:
        field.get(&from_startup_);
        break;
      case 4 /* rejected_concurrent */:
        field.get(&rejected_concurrent_);
        break;
      case 6 /* disconnected */:
        field.get(&disconnected_);
        break;
      case 7 /* buffer_overran */:
        field.get(&buffer_overran_);
        break;
      case 14 /* client_error */:
        field.get(&client_error_);
        break;
      case 8 /* buffer_corrupted */:
        field.get(&buffer_corrupted_);
        break;
      case 10 /* hit_guardrail */:
        field.get(&hit_guardrail_);
        break;
      case 11 /* heap_name */:
        ::protozero::internal::gen_helpers::DeserializeString(field, &heap_name_);
        break;
      case 12 /* sampling_interval_bytes */:
        field.get(&sampling_interval_bytes_);
        break;
      case 13 /* orig_sampling_interval_bytes */:
        field.get(&orig_sampling_interval_bytes_);
        break;
      case 9 /* timestamp */:
        field.get(&timestamp_);
        break;
      case 5 /* stats */:
        (*stats_).ParseFromArray(field.data(), field.size());
        break;
      case 2 /* samples */:
        samples_.emplace_back();
        samples_.back().ParseFromArray(field.data(), field.size());
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string ProfilePacket_ProcessHeapSamples::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> ProfilePacket_ProcessHeapSamples::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void ProfilePacket_ProcessHeapSamples::Serialize(::protozero::Message* msg) const {
  // Field 1: pid
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, pid_, msg);
  }

  // Field 3: from_startup
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeTinyVarInt(3, from_startup_, msg);
  }

  // Field 4: rejected_concurrent
  if (_has_field_[4]) {
    ::protozero::internal::gen_helpers::SerializeTinyVarInt(4, rejected_concurrent_, msg);
  }

  // Field 6: disconnected
  if (_has_field_[6]) {
    ::protozero::internal::gen_helpers::SerializeTinyVarInt(6, disconnected_, msg);
  }

  // Field 7: buffer_overran
  if (_has_field_[7]) {
    ::protozero::internal::gen_helpers::SerializeTinyVarInt(7, buffer_overran_, msg);
  }

  // Field 14: client_error
  if (_has_field_[14]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(14, client_error_, msg);
  }

  // Field 8: buffer_corrupted
  if (_has_field_[8]) {
    ::protozero::internal::gen_helpers::SerializeTinyVarInt(8, buffer_corrupted_, msg);
  }

  // Field 10: hit_guardrail
  if (_has_field_[10]) {
    ::protozero::internal::gen_helpers::SerializeTinyVarInt(10, hit_guardrail_, msg);
  }

  // Field 11: heap_name
  if (_has_field_[11]) {
    ::protozero::internal::gen_helpers::SerializeString(11, heap_name_, msg);
  }

  // Field 12: sampling_interval_bytes
  if (_has_field_[12]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(12, sampling_interval_bytes_, msg);
  }

  // Field 13: orig_sampling_interval_bytes
  if (_has_field_[13]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(13, orig_sampling_interval_bytes_, msg);
  }

  // Field 9: timestamp
  if (_has_field_[9]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(9, timestamp_, msg);
  }

  // Field 5: stats
  if (_has_field_[5]) {
    (*stats_).Serialize(msg->BeginNestedMessage<::protozero::Message>(5));
  }

  // Field 2: samples
  for (auto& it : samples_) {
    it.Serialize(msg->BeginNestedMessage<::protozero::Message>(2));
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


ProfilePacket_HeapSample::ProfilePacket_HeapSample() = default;
ProfilePacket_HeapSample::~ProfilePacket_HeapSample() = default;
ProfilePacket_HeapSample::ProfilePacket_HeapSample(const ProfilePacket_HeapSample&) = default;
ProfilePacket_HeapSample& ProfilePacket_HeapSample::operator=(const ProfilePacket_HeapSample&) = default;
ProfilePacket_HeapSample::ProfilePacket_HeapSample(ProfilePacket_HeapSample&&) noexcept = default;
ProfilePacket_HeapSample& ProfilePacket_HeapSample::operator=(ProfilePacket_HeapSample&&) = default;

bool ProfilePacket_HeapSample::operator==(const ProfilePacket_HeapSample& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(callstack_id_, other.callstack_id_)
   && ::protozero::internal::gen_helpers::EqualsField(self_allocated_, other.self_allocated_)
   && ::protozero::internal::gen_helpers::EqualsField(self_freed_, other.self_freed_)
   && ::protozero::internal::gen_helpers::EqualsField(self_max_, other.self_max_)
   && ::protozero::internal::gen_helpers::EqualsField(self_max_count_, other.self_max_count_)
   && ::protozero::internal::gen_helpers::EqualsField(timestamp_, other.timestamp_)
   && ::protozero::internal::gen_helpers::EqualsField(alloc_count_, other.alloc_count_)
   && ::protozero::internal::gen_helpers::EqualsField(free_count_, other.free_count_);
}

bool ProfilePacket_HeapSample::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* callstack_id */:
        field.get(&callstack_id_);
        break;
      case 2 /* self_allocated */:
        field.get(&self_allocated_);
        break;
      case 3 /* self_freed */:
        field.get(&self_freed_);
        break;
      case 8 /* self_max */:
        field.get(&self_max_);
        break;
      case 9 /* self_max_count */:
        field.get(&self_max_count_);
        break;
      case 4 /* timestamp */:
        field.get(&timestamp_);
        break;
      case 5 /* alloc_count */:
        field.get(&alloc_count_);
        break;
      case 6 /* free_count */:
        field.get(&free_count_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string ProfilePacket_HeapSample::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> ProfilePacket_HeapSample::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void ProfilePacket_HeapSample::Serialize(::protozero::Message* msg) const {
  // Field 1: callstack_id
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, callstack_id_, msg);
  }

  // Field 2: self_allocated
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, self_allocated_, msg);
  }

  // Field 3: self_freed
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, self_freed_, msg);
  }

  // Field 8: self_max
  if (_has_field_[8]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(8, self_max_, msg);
  }

  // Field 9: self_max_count
  if (_has_field_[9]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(9, self_max_count_, msg);
  }

  // Field 4: timestamp
  if (_has_field_[4]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(4, timestamp_, msg);
  }

  // Field 5: alloc_count
  if (_has_field_[5]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(5, alloc_count_, msg);
  }

  // Field 6: free_count
  if (_has_field_[6]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(6, free_count_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


ProfilePacket_ProcessStats::ProfilePacket_ProcessStats() = default;
ProfilePacket_ProcessStats::~ProfilePacket_ProcessStats() = default;
ProfilePacket_ProcessStats::ProfilePacket_ProcessStats(const ProfilePacket_ProcessStats&) = default;
ProfilePacket_ProcessStats& ProfilePacket_ProcessStats::operator=(const ProfilePacket_ProcessStats&) = default;
ProfilePacket_ProcessStats::ProfilePacket_ProcessStats(ProfilePacket_ProcessStats&&) noexcept = default;
ProfilePacket_ProcessStats& ProfilePacket_ProcessStats::operator=(ProfilePacket_ProcessStats&&) = default;

bool ProfilePacket_ProcessStats::operator==(const ProfilePacket_ProcessStats& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(unwinding_errors_, other.unwinding_errors_)
   && ::protozero::internal::gen_helpers::EqualsField(heap_samples_, other.heap_samples_)
   && ::protozero::internal::gen_helpers::EqualsField(map_reparses_, other.map_reparses_)
   && ::protozero::internal::gen_helpers::EqualsField(unwinding_time_us_, other.unwinding_time_us_)
   && ::protozero::internal::gen_helpers::EqualsField(total_unwinding_time_us_, other.total_unwinding_time_us_)
   && ::protozero::internal::gen_helpers::EqualsField(client_spinlock_blocked_us_, other.client_spinlock_blocked_us_);
}

bool ProfilePacket_ProcessStats::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* unwinding_errors */:
        field.get(&unwinding_errors_);
        break;
      case 2 /* heap_samples */:
        field.get(&heap_samples_);
        break;
      case 3 /* map_reparses */:
        field.get(&map_reparses_);
        break;
      case 4 /* unwinding_time_us */:
        (*unwinding_time_us_).ParseFromArray(field.data(), field.size());
        break;
      case 5 /* total_unwinding_time_us */:
        field.get(&total_unwinding_time_us_);
        break;
      case 6 /* client_spinlock_blocked_us */:
        field.get(&client_spinlock_blocked_us_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string ProfilePacket_ProcessStats::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> ProfilePacket_ProcessStats::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void ProfilePacket_ProcessStats::Serialize(::protozero::Message* msg) const {
  // Field 1: unwinding_errors
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, unwinding_errors_, msg);
  }

  // Field 2: heap_samples
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, heap_samples_, msg);
  }

  // Field 3: map_reparses
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, map_reparses_, msg);
  }

  // Field 4: unwinding_time_us
  if (_has_field_[4]) {
    (*unwinding_time_us_).Serialize(msg->BeginNestedMessage<::protozero::Message>(4));
  }

  // Field 5: total_unwinding_time_us
  if (_has_field_[5]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(5, total_unwinding_time_us_, msg);
  }

  // Field 6: client_spinlock_blocked_us
  if (_has_field_[6]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(6, client_spinlock_blocked_us_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


ProfilePacket_Histogram::ProfilePacket_Histogram() = default;
ProfilePacket_Histogram::~ProfilePacket_Histogram() = default;
ProfilePacket_Histogram::ProfilePacket_Histogram(const ProfilePacket_Histogram&) = default;
ProfilePacket_Histogram& ProfilePacket_Histogram::operator=(const ProfilePacket_Histogram&) = default;
ProfilePacket_Histogram::ProfilePacket_Histogram(ProfilePacket_Histogram&&) noexcept = default;
ProfilePacket_Histogram& ProfilePacket_Histogram::operator=(ProfilePacket_Histogram&&) = default;

bool ProfilePacket_Histogram::operator==(const ProfilePacket_Histogram& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(buckets_, other.buckets_);
}

int ProfilePacket_Histogram::buckets_size() const { return static_cast<int>(buckets_.size()); }
void ProfilePacket_Histogram::clear_buckets() { buckets_.clear(); }
ProfilePacket_Histogram_Bucket* ProfilePacket_Histogram::add_buckets() { buckets_.emplace_back(); return &buckets_.back(); }
bool ProfilePacket_Histogram::ParseFromArray(const void* raw, size_t size) {
  buckets_.clear();
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* buckets */:
        buckets_.emplace_back();
        buckets_.back().ParseFromArray(field.data(), field.size());
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string ProfilePacket_Histogram::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> ProfilePacket_Histogram::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void ProfilePacket_Histogram::Serialize(::protozero::Message* msg) const {
  // Field 1: buckets
  for (auto& it : buckets_) {
    it.Serialize(msg->BeginNestedMessage<::protozero::Message>(1));
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


ProfilePacket_Histogram_Bucket::ProfilePacket_Histogram_Bucket() = default;
ProfilePacket_Histogram_Bucket::~ProfilePacket_Histogram_Bucket() = default;
ProfilePacket_Histogram_Bucket::ProfilePacket_Histogram_Bucket(const ProfilePacket_Histogram_Bucket&) = default;
ProfilePacket_Histogram_Bucket& ProfilePacket_Histogram_Bucket::operator=(const ProfilePacket_Histogram_Bucket&) = default;
ProfilePacket_Histogram_Bucket::ProfilePacket_Histogram_Bucket(ProfilePacket_Histogram_Bucket&&) noexcept = default;
ProfilePacket_Histogram_Bucket& ProfilePacket_Histogram_Bucket::operator=(ProfilePacket_Histogram_Bucket&&) = default;

bool ProfilePacket_Histogram_Bucket::operator==(const ProfilePacket_Histogram_Bucket& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(upper_limit_, other.upper_limit_)
   && ::protozero::internal::gen_helpers::EqualsField(max_bucket_, other.max_bucket_)
   && ::protozero::internal::gen_helpers::EqualsField(count_, other.count_);
}

bool ProfilePacket_Histogram_Bucket::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* upper_limit */:
        field.get(&upper_limit_);
        break;
      case 2 /* max_bucket */:
        field.get(&max_bucket_);
        break;
      case 3 /* count */:
        field.get(&count_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string ProfilePacket_Histogram_Bucket::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> ProfilePacket_Histogram_Bucket::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void ProfilePacket_Histogram_Bucket::Serialize(::protozero::Message* msg) const {
  // Field 1: upper_limit
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, upper_limit_, msg);
  }

  // Field 2: max_bucket
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeTinyVarInt(2, max_bucket_, msg);
  }

  // Field 3: count
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, count_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}

}  // namespace perfetto
}  // namespace protos
}  // namespace gen
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif
