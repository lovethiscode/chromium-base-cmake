// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_GPU_VULKAN_MEMORY_EVENT_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_GPU_VULKAN_MEMORY_EVENT_PROTO_H_

#include <stddef.h>
#include <stdint.h>

#include "perfetto/protozero/field_writer.h"
#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {
class VulkanMemoryEventAnnotation;
namespace perfetto_pbzero_enum_VulkanMemoryEvent {
enum AllocationScope : int32_t;
}  // namespace perfetto_pbzero_enum_VulkanMemoryEvent
using VulkanMemoryEvent_AllocationScope = perfetto_pbzero_enum_VulkanMemoryEvent::AllocationScope;
namespace perfetto_pbzero_enum_VulkanMemoryEvent {
enum Operation : int32_t;
}  // namespace perfetto_pbzero_enum_VulkanMemoryEvent
using VulkanMemoryEvent_Operation = perfetto_pbzero_enum_VulkanMemoryEvent::Operation;
namespace perfetto_pbzero_enum_VulkanMemoryEvent {
enum Source : int32_t;
}  // namespace perfetto_pbzero_enum_VulkanMemoryEvent
using VulkanMemoryEvent_Source = perfetto_pbzero_enum_VulkanMemoryEvent::Source;
} // Namespace pbzero.
} // Namespace protos.
} // Namespace perfetto.

namespace perfetto {
namespace protos {
namespace pbzero {

namespace perfetto_pbzero_enum_VulkanMemoryEvent {
enum Source : int32_t {
  SOURCE_UNSPECIFIED = 0,
  SOURCE_DRIVER = 1,
  SOURCE_DEVICE = 2,
  SOURCE_DEVICE_MEMORY = 3,
  SOURCE_BUFFER = 4,
  SOURCE_IMAGE = 5,
};
} // namespace perfetto_pbzero_enum_VulkanMemoryEvent
using VulkanMemoryEvent_Source = perfetto_pbzero_enum_VulkanMemoryEvent::Source;


constexpr VulkanMemoryEvent_Source VulkanMemoryEvent_Source_MIN = VulkanMemoryEvent_Source::SOURCE_UNSPECIFIED;
constexpr VulkanMemoryEvent_Source VulkanMemoryEvent_Source_MAX = VulkanMemoryEvent_Source::SOURCE_IMAGE;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* VulkanMemoryEvent_Source_Name(::perfetto::protos::pbzero::VulkanMemoryEvent_Source value) {
  switch (value) {
  case ::perfetto::protos::pbzero::VulkanMemoryEvent_Source::SOURCE_UNSPECIFIED:
    return "SOURCE_UNSPECIFIED";

  case ::perfetto::protos::pbzero::VulkanMemoryEvent_Source::SOURCE_DRIVER:
    return "SOURCE_DRIVER";

  case ::perfetto::protos::pbzero::VulkanMemoryEvent_Source::SOURCE_DEVICE:
    return "SOURCE_DEVICE";

  case ::perfetto::protos::pbzero::VulkanMemoryEvent_Source::SOURCE_DEVICE_MEMORY:
    return "SOURCE_DEVICE_MEMORY";

  case ::perfetto::protos::pbzero::VulkanMemoryEvent_Source::SOURCE_BUFFER:
    return "SOURCE_BUFFER";

  case ::perfetto::protos::pbzero::VulkanMemoryEvent_Source::SOURCE_IMAGE:
    return "SOURCE_IMAGE";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_VulkanMemoryEvent {
enum Operation : int32_t {
  OP_UNSPECIFIED = 0,
  OP_CREATE = 1,
  OP_DESTROY = 2,
  OP_BIND = 3,
  OP_DESTROY_BOUND = 4,
  OP_ANNOTATIONS = 5,
};
} // namespace perfetto_pbzero_enum_VulkanMemoryEvent
using VulkanMemoryEvent_Operation = perfetto_pbzero_enum_VulkanMemoryEvent::Operation;


constexpr VulkanMemoryEvent_Operation VulkanMemoryEvent_Operation_MIN = VulkanMemoryEvent_Operation::OP_UNSPECIFIED;
constexpr VulkanMemoryEvent_Operation VulkanMemoryEvent_Operation_MAX = VulkanMemoryEvent_Operation::OP_ANNOTATIONS;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* VulkanMemoryEvent_Operation_Name(::perfetto::protos::pbzero::VulkanMemoryEvent_Operation value) {
  switch (value) {
  case ::perfetto::protos::pbzero::VulkanMemoryEvent_Operation::OP_UNSPECIFIED:
    return "OP_UNSPECIFIED";

  case ::perfetto::protos::pbzero::VulkanMemoryEvent_Operation::OP_CREATE:
    return "OP_CREATE";

  case ::perfetto::protos::pbzero::VulkanMemoryEvent_Operation::OP_DESTROY:
    return "OP_DESTROY";

  case ::perfetto::protos::pbzero::VulkanMemoryEvent_Operation::OP_BIND:
    return "OP_BIND";

  case ::perfetto::protos::pbzero::VulkanMemoryEvent_Operation::OP_DESTROY_BOUND:
    return "OP_DESTROY_BOUND";

  case ::perfetto::protos::pbzero::VulkanMemoryEvent_Operation::OP_ANNOTATIONS:
    return "OP_ANNOTATIONS";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_VulkanMemoryEvent {
enum AllocationScope : int32_t {
  SCOPE_UNSPECIFIED = 0,
  SCOPE_COMMAND = 1,
  SCOPE_OBJECT = 2,
  SCOPE_CACHE = 3,
  SCOPE_DEVICE = 4,
  SCOPE_INSTANCE = 5,
};
} // namespace perfetto_pbzero_enum_VulkanMemoryEvent
using VulkanMemoryEvent_AllocationScope = perfetto_pbzero_enum_VulkanMemoryEvent::AllocationScope;


constexpr VulkanMemoryEvent_AllocationScope VulkanMemoryEvent_AllocationScope_MIN = VulkanMemoryEvent_AllocationScope::SCOPE_UNSPECIFIED;
constexpr VulkanMemoryEvent_AllocationScope VulkanMemoryEvent_AllocationScope_MAX = VulkanMemoryEvent_AllocationScope::SCOPE_INSTANCE;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* VulkanMemoryEvent_AllocationScope_Name(::perfetto::protos::pbzero::VulkanMemoryEvent_AllocationScope value) {
  switch (value) {
  case ::perfetto::protos::pbzero::VulkanMemoryEvent_AllocationScope::SCOPE_UNSPECIFIED:
    return "SCOPE_UNSPECIFIED";

  case ::perfetto::protos::pbzero::VulkanMemoryEvent_AllocationScope::SCOPE_COMMAND:
    return "SCOPE_COMMAND";

  case ::perfetto::protos::pbzero::VulkanMemoryEvent_AllocationScope::SCOPE_OBJECT:
    return "SCOPE_OBJECT";

  case ::perfetto::protos::pbzero::VulkanMemoryEvent_AllocationScope::SCOPE_CACHE:
    return "SCOPE_CACHE";

  case ::perfetto::protos::pbzero::VulkanMemoryEvent_AllocationScope::SCOPE_DEVICE:
    return "SCOPE_DEVICE";

  case ::perfetto::protos::pbzero::VulkanMemoryEvent_AllocationScope::SCOPE_INSTANCE:
    return "SCOPE_INSTANCE";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

class VulkanMemoryEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/20, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  VulkanMemoryEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit VulkanMemoryEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit VulkanMemoryEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_source() const { return at<1>().valid(); }
  int32_t source() const { return at<1>().as_int32(); }
  bool has_operation() const { return at<2>().valid(); }
  int32_t operation() const { return at<2>().as_int32(); }
  bool has_timestamp() const { return at<3>().valid(); }
  int64_t timestamp() const { return at<3>().as_int64(); }
  bool has_pid() const { return at<4>().valid(); }
  uint32_t pid() const { return at<4>().as_uint32(); }
  bool has_memory_address() const { return at<5>().valid(); }
  uint64_t memory_address() const { return at<5>().as_uint64(); }
  bool has_memory_size() const { return at<6>().valid(); }
  uint64_t memory_size() const { return at<6>().as_uint64(); }
  bool has_caller_iid() const { return at<7>().valid(); }
  uint64_t caller_iid() const { return at<7>().as_uint64(); }
  bool has_allocation_scope() const { return at<8>().valid(); }
  int32_t allocation_scope() const { return at<8>().as_int32(); }
  bool has_annotations() const { return at<9>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> annotations() const { return GetRepeated<::protozero::ConstBytes>(9); }
  bool has_device() const { return at<16>().valid(); }
  uint64_t device() const { return at<16>().as_uint64(); }
  bool has_device_memory() const { return at<17>().valid(); }
  uint64_t device_memory() const { return at<17>().as_uint64(); }
  bool has_memory_type() const { return at<18>().valid(); }
  uint32_t memory_type() const { return at<18>().as_uint32(); }
  bool has_heap() const { return at<19>().valid(); }
  uint32_t heap() const { return at<19>().as_uint32(); }
  bool has_object_handle() const { return at<20>().valid(); }
  uint64_t object_handle() const { return at<20>().as_uint64(); }
};

class VulkanMemoryEvent : public ::protozero::Message {
 public:
  using Decoder = VulkanMemoryEvent_Decoder;
  enum : int32_t {
    kSourceFieldNumber = 1,
    kOperationFieldNumber = 2,
    kTimestampFieldNumber = 3,
    kPidFieldNumber = 4,
    kMemoryAddressFieldNumber = 5,
    kMemorySizeFieldNumber = 6,
    kCallerIidFieldNumber = 7,
    kAllocationScopeFieldNumber = 8,
    kAnnotationsFieldNumber = 9,
    kDeviceFieldNumber = 16,
    kDeviceMemoryFieldNumber = 17,
    kMemoryTypeFieldNumber = 18,
    kHeapFieldNumber = 19,
    kObjectHandleFieldNumber = 20,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.VulkanMemoryEvent"; }


  using Source = ::perfetto::protos::pbzero::VulkanMemoryEvent_Source;
  static inline const char* Source_Name(Source value) {
    return ::perfetto::protos::pbzero::VulkanMemoryEvent_Source_Name(value);
  }

  using Operation = ::perfetto::protos::pbzero::VulkanMemoryEvent_Operation;
  static inline const char* Operation_Name(Operation value) {
    return ::perfetto::protos::pbzero::VulkanMemoryEvent_Operation_Name(value);
  }

  using AllocationScope = ::perfetto::protos::pbzero::VulkanMemoryEvent_AllocationScope;
  static inline const char* AllocationScope_Name(AllocationScope value) {
    return ::perfetto::protos::pbzero::VulkanMemoryEvent_AllocationScope_Name(value);
  }
  static inline const Source SOURCE_UNSPECIFIED = Source::SOURCE_UNSPECIFIED;
  static inline const Source SOURCE_DRIVER = Source::SOURCE_DRIVER;
  static inline const Source SOURCE_DEVICE = Source::SOURCE_DEVICE;
  static inline const Source SOURCE_DEVICE_MEMORY = Source::SOURCE_DEVICE_MEMORY;
  static inline const Source SOURCE_BUFFER = Source::SOURCE_BUFFER;
  static inline const Source SOURCE_IMAGE = Source::SOURCE_IMAGE;
  static inline const Operation OP_UNSPECIFIED = Operation::OP_UNSPECIFIED;
  static inline const Operation OP_CREATE = Operation::OP_CREATE;
  static inline const Operation OP_DESTROY = Operation::OP_DESTROY;
  static inline const Operation OP_BIND = Operation::OP_BIND;
  static inline const Operation OP_DESTROY_BOUND = Operation::OP_DESTROY_BOUND;
  static inline const Operation OP_ANNOTATIONS = Operation::OP_ANNOTATIONS;
  static inline const AllocationScope SCOPE_UNSPECIFIED = AllocationScope::SCOPE_UNSPECIFIED;
  static inline const AllocationScope SCOPE_COMMAND = AllocationScope::SCOPE_COMMAND;
  static inline const AllocationScope SCOPE_OBJECT = AllocationScope::SCOPE_OBJECT;
  static inline const AllocationScope SCOPE_CACHE = AllocationScope::SCOPE_CACHE;
  static inline const AllocationScope SCOPE_DEVICE = AllocationScope::SCOPE_DEVICE;
  static inline const AllocationScope SCOPE_INSTANCE = AllocationScope::SCOPE_INSTANCE;

  using FieldMetadata_Source =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      VulkanMemoryEvent_Source,
      VulkanMemoryEvent>;

  static constexpr FieldMetadata_Source kSource{};
  void set_source(VulkanMemoryEvent_Source value) {
    static constexpr uint32_t field_id = FieldMetadata_Source::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Operation =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      VulkanMemoryEvent_Operation,
      VulkanMemoryEvent>;

  static constexpr FieldMetadata_Operation kOperation{};
  void set_operation(VulkanMemoryEvent_Operation value) {
    static constexpr uint32_t field_id = FieldMetadata_Operation::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Timestamp =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      VulkanMemoryEvent>;

  static constexpr FieldMetadata_Timestamp kTimestamp{};
  void set_timestamp(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Timestamp::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Pid =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      VulkanMemoryEvent>;

  static constexpr FieldMetadata_Pid kPid{};
  void set_pid(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Pid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_MemoryAddress =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kFixed64,
      uint64_t,
      VulkanMemoryEvent>;

  static constexpr FieldMetadata_MemoryAddress kMemoryAddress{};
  void set_memory_address(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_MemoryAddress::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kFixed64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_MemorySize =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      VulkanMemoryEvent>;

  static constexpr FieldMetadata_MemorySize kMemorySize{};
  void set_memory_size(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_MemorySize::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_CallerIid =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      VulkanMemoryEvent>;

  static constexpr FieldMetadata_CallerIid kCallerIid{};
  void set_caller_iid(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_CallerIid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_AllocationScope =
    ::protozero::proto_utils::FieldMetadata<
      8,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      VulkanMemoryEvent_AllocationScope,
      VulkanMemoryEvent>;

  static constexpr FieldMetadata_AllocationScope kAllocationScope{};
  void set_allocation_scope(VulkanMemoryEvent_AllocationScope value) {
    static constexpr uint32_t field_id = FieldMetadata_AllocationScope::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Annotations =
    ::protozero::proto_utils::FieldMetadata<
      9,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      VulkanMemoryEventAnnotation,
      VulkanMemoryEvent>;

  static constexpr FieldMetadata_Annotations kAnnotations{};
  template <typename T = VulkanMemoryEventAnnotation> T* add_annotations() {
    return BeginNestedMessage<T>(9);
  }


  using FieldMetadata_Device =
    ::protozero::proto_utils::FieldMetadata<
      16,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kFixed64,
      uint64_t,
      VulkanMemoryEvent>;

  static constexpr FieldMetadata_Device kDevice{};
  void set_device(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Device::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kFixed64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_DeviceMemory =
    ::protozero::proto_utils::FieldMetadata<
      17,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kFixed64,
      uint64_t,
      VulkanMemoryEvent>;

  static constexpr FieldMetadata_DeviceMemory kDeviceMemory{};
  void set_device_memory(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_DeviceMemory::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kFixed64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_MemoryType =
    ::protozero::proto_utils::FieldMetadata<
      18,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      VulkanMemoryEvent>;

  static constexpr FieldMetadata_MemoryType kMemoryType{};
  void set_memory_type(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_MemoryType::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Heap =
    ::protozero::proto_utils::FieldMetadata<
      19,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      VulkanMemoryEvent>;

  static constexpr FieldMetadata_Heap kHeap{};
  void set_heap(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Heap::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ObjectHandle =
    ::protozero::proto_utils::FieldMetadata<
      20,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kFixed64,
      uint64_t,
      VulkanMemoryEvent>;

  static constexpr FieldMetadata_ObjectHandle kObjectHandle{};
  void set_object_handle(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ObjectHandle::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kFixed64>
        ::Append(*this, field_id, value);
  }
};

class VulkanMemoryEventAnnotation_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  VulkanMemoryEventAnnotation_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit VulkanMemoryEventAnnotation_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit VulkanMemoryEventAnnotation_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_key_iid() const { return at<1>().valid(); }
  uint64_t key_iid() const { return at<1>().as_uint64(); }
  bool has_int_value() const { return at<2>().valid(); }
  int64_t int_value() const { return at<2>().as_int64(); }
  bool has_double_value() const { return at<3>().valid(); }
  double double_value() const { return at<3>().as_double(); }
  bool has_string_iid() const { return at<4>().valid(); }
  uint64_t string_iid() const { return at<4>().as_uint64(); }
};

class VulkanMemoryEventAnnotation : public ::protozero::Message {
 public:
  using Decoder = VulkanMemoryEventAnnotation_Decoder;
  enum : int32_t {
    kKeyIidFieldNumber = 1,
    kIntValueFieldNumber = 2,
    kDoubleValueFieldNumber = 3,
    kStringIidFieldNumber = 4,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.VulkanMemoryEventAnnotation"; }


  using FieldMetadata_KeyIid =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      VulkanMemoryEventAnnotation>;

  static constexpr FieldMetadata_KeyIid kKeyIid{};
  void set_key_iid(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_KeyIid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IntValue =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      VulkanMemoryEventAnnotation>;

  static constexpr FieldMetadata_IntValue kIntValue{};
  void set_int_value(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_IntValue::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_DoubleValue =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kDouble,
      double,
      VulkanMemoryEventAnnotation>;

  static constexpr FieldMetadata_DoubleValue kDoubleValue{};
  void set_double_value(double value) {
    static constexpr uint32_t field_id = FieldMetadata_DoubleValue::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kDouble>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_StringIid =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      VulkanMemoryEventAnnotation>;

  static constexpr FieldMetadata_StringIid kStringIid{};
  void set_string_iid(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_StringIid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
