// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACE_PACKET_DEFAULTS_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACE_PACKET_DEFAULTS_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class TracePacketDefaults;
class V8CodeDefaults;
class PerfSampleDefaults;
class PerfEvents_Timebase;
class PerfEvents_RawEvent;
class PerfEvents_Tracepoint;
class TrackEventDefaults;
enum PerfEvents_Counter : int;
enum PerfEvents_PerfClock : int;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {

class PERFETTO_EXPORT_COMPONENT TracePacketDefaults : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kTimestampClockIdFieldNumber = 58,
    kTrackEventDefaultsFieldNumber = 11,
    kPerfSampleDefaultsFieldNumber = 12,
    kV8CodeDefaultsFieldNumber = 99,
  };

  TracePacketDefaults();
  ~TracePacketDefaults() override;
  TracePacketDefaults(TracePacketDefaults&&) noexcept;
  TracePacketDefaults& operator=(TracePacketDefaults&&);
  TracePacketDefaults(const TracePacketDefaults&);
  TracePacketDefaults& operator=(const TracePacketDefaults&);
  bool operator==(const TracePacketDefaults&) const;
  bool operator!=(const TracePacketDefaults& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_timestamp_clock_id() const { return _has_field_[58]; }
  uint32_t timestamp_clock_id() const { return timestamp_clock_id_; }
  void set_timestamp_clock_id(uint32_t value) { timestamp_clock_id_ = value; _has_field_.set(58); }

  bool has_track_event_defaults() const { return _has_field_[11]; }
  const TrackEventDefaults& track_event_defaults() const { return *track_event_defaults_; }
  TrackEventDefaults* mutable_track_event_defaults() { _has_field_.set(11); return track_event_defaults_.get(); }

  bool has_perf_sample_defaults() const { return _has_field_[12]; }
  const PerfSampleDefaults& perf_sample_defaults() const { return *perf_sample_defaults_; }
  PerfSampleDefaults* mutable_perf_sample_defaults() { _has_field_.set(12); return perf_sample_defaults_.get(); }

  bool has_v8_code_defaults() const { return _has_field_[99]; }
  const V8CodeDefaults& v8_code_defaults() const { return *v8_code_defaults_; }
  V8CodeDefaults* mutable_v8_code_defaults() { _has_field_.set(99); return v8_code_defaults_.get(); }

 private:
  uint32_t timestamp_clock_id_{};
  ::protozero::CopyablePtr<TrackEventDefaults> track_event_defaults_;
  ::protozero::CopyablePtr<PerfSampleDefaults> perf_sample_defaults_;
  ::protozero::CopyablePtr<V8CodeDefaults> v8_code_defaults_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<100> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACE_PACKET_DEFAULTS_PROTO_CPP_H_
