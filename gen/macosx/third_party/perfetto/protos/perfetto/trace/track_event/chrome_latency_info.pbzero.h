// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_CHROME_LATENCY_INFO_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_CHROME_LATENCY_INFO_PROTO_H_

#include <stddef.h>
#include <stdint.h>

#include "perfetto/protozero/field_writer.h"
#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {
class ChromeLatencyInfo_ComponentInfo;
namespace perfetto_pbzero_enum_ChromeLatencyInfo {
enum LatencyComponentType : int32_t;
}  // namespace perfetto_pbzero_enum_ChromeLatencyInfo
using ChromeLatencyInfo_LatencyComponentType = perfetto_pbzero_enum_ChromeLatencyInfo::LatencyComponentType;
namespace perfetto_pbzero_enum_ChromeLatencyInfo {
enum Step : int32_t;
}  // namespace perfetto_pbzero_enum_ChromeLatencyInfo
using ChromeLatencyInfo_Step = perfetto_pbzero_enum_ChromeLatencyInfo::Step;
} // Namespace pbzero.
} // Namespace protos.
} // Namespace perfetto.

namespace perfetto {
namespace protos {
namespace pbzero {

namespace perfetto_pbzero_enum_ChromeLatencyInfo {
enum Step : int32_t {
  STEP_UNSPECIFIED = 0,
  STEP_SEND_INPUT_EVENT_UI = 3,
  STEP_HANDLE_INPUT_EVENT_IMPL = 5,
  STEP_DID_HANDLE_INPUT_AND_OVERSCROLL = 8,
  STEP_HANDLE_INPUT_EVENT_MAIN = 4,
  STEP_MAIN_THREAD_SCROLL_UPDATE = 2,
  STEP_HANDLE_INPUT_EVENT_MAIN_COMMIT = 1,
  STEP_HANDLED_INPUT_EVENT_MAIN_OR_IMPL = 9,
  STEP_HANDLED_INPUT_EVENT_IMPL = 10,
  STEP_SWAP_BUFFERS = 6,
  STEP_DRAW_AND_SWAP = 7,
  STEP_FINISHED_SWAP_BUFFERS = 11,
};
} // namespace perfetto_pbzero_enum_ChromeLatencyInfo
using ChromeLatencyInfo_Step = perfetto_pbzero_enum_ChromeLatencyInfo::Step;


constexpr ChromeLatencyInfo_Step ChromeLatencyInfo_Step_MIN = ChromeLatencyInfo_Step::STEP_UNSPECIFIED;
constexpr ChromeLatencyInfo_Step ChromeLatencyInfo_Step_MAX = ChromeLatencyInfo_Step::STEP_FINISHED_SWAP_BUFFERS;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* ChromeLatencyInfo_Step_Name(::perfetto::protos::pbzero::ChromeLatencyInfo_Step value) {
  switch (value) {
  case ::perfetto::protos::pbzero::ChromeLatencyInfo_Step::STEP_UNSPECIFIED:
    return "STEP_UNSPECIFIED";

  case ::perfetto::protos::pbzero::ChromeLatencyInfo_Step::STEP_SEND_INPUT_EVENT_UI:
    return "STEP_SEND_INPUT_EVENT_UI";

  case ::perfetto::protos::pbzero::ChromeLatencyInfo_Step::STEP_HANDLE_INPUT_EVENT_IMPL:
    return "STEP_HANDLE_INPUT_EVENT_IMPL";

  case ::perfetto::protos::pbzero::ChromeLatencyInfo_Step::STEP_DID_HANDLE_INPUT_AND_OVERSCROLL:
    return "STEP_DID_HANDLE_INPUT_AND_OVERSCROLL";

  case ::perfetto::protos::pbzero::ChromeLatencyInfo_Step::STEP_HANDLE_INPUT_EVENT_MAIN:
    return "STEP_HANDLE_INPUT_EVENT_MAIN";

  case ::perfetto::protos::pbzero::ChromeLatencyInfo_Step::STEP_MAIN_THREAD_SCROLL_UPDATE:
    return "STEP_MAIN_THREAD_SCROLL_UPDATE";

  case ::perfetto::protos::pbzero::ChromeLatencyInfo_Step::STEP_HANDLE_INPUT_EVENT_MAIN_COMMIT:
    return "STEP_HANDLE_INPUT_EVENT_MAIN_COMMIT";

  case ::perfetto::protos::pbzero::ChromeLatencyInfo_Step::STEP_HANDLED_INPUT_EVENT_MAIN_OR_IMPL:
    return "STEP_HANDLED_INPUT_EVENT_MAIN_OR_IMPL";

  case ::perfetto::protos::pbzero::ChromeLatencyInfo_Step::STEP_HANDLED_INPUT_EVENT_IMPL:
    return "STEP_HANDLED_INPUT_EVENT_IMPL";

  case ::perfetto::protos::pbzero::ChromeLatencyInfo_Step::STEP_SWAP_BUFFERS:
    return "STEP_SWAP_BUFFERS";

  case ::perfetto::protos::pbzero::ChromeLatencyInfo_Step::STEP_DRAW_AND_SWAP:
    return "STEP_DRAW_AND_SWAP";

  case ::perfetto::protos::pbzero::ChromeLatencyInfo_Step::STEP_FINISHED_SWAP_BUFFERS:
    return "STEP_FINISHED_SWAP_BUFFERS";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_ChromeLatencyInfo {
enum LatencyComponentType : int32_t {
  COMPONENT_UNSPECIFIED = 0,
  COMPONENT_INPUT_EVENT_LATENCY_BEGIN_RWH = 1,
  COMPONENT_INPUT_EVENT_LATENCY_SCROLL_UPDATE_ORIGINAL = 2,
  COMPONENT_INPUT_EVENT_LATENCY_FIRST_SCROLL_UPDATE_ORIGINAL = 3,
  COMPONENT_INPUT_EVENT_LATENCY_ORIGINAL = 4,
  COMPONENT_INPUT_EVENT_LATENCY_UI = 5,
  COMPONENT_INPUT_EVENT_LATENCY_RENDERER_MAIN = 6,
  COMPONENT_INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_MAIN = 7,
  COMPONENT_INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_IMPL = 8,
  COMPONENT_INPUT_EVENT_LATENCY_SCROLL_UPDATE_LAST_EVENT = 9,
  COMPONENT_INPUT_EVENT_LATENCY_ACK_RWH = 10,
  COMPONENT_INPUT_EVENT_LATENCY_RENDERER_SWAP = 11,
  COMPONENT_DISPLAY_COMPOSITOR_RECEIVED_FRAME = 12,
  COMPONENT_INPUT_EVENT_GPU_SWAP_BUFFER = 13,
  COMPONENT_INPUT_EVENT_LATENCY_FRAME_SWAP = 14,
};
} // namespace perfetto_pbzero_enum_ChromeLatencyInfo
using ChromeLatencyInfo_LatencyComponentType = perfetto_pbzero_enum_ChromeLatencyInfo::LatencyComponentType;


constexpr ChromeLatencyInfo_LatencyComponentType ChromeLatencyInfo_LatencyComponentType_MIN = ChromeLatencyInfo_LatencyComponentType::COMPONENT_UNSPECIFIED;
constexpr ChromeLatencyInfo_LatencyComponentType ChromeLatencyInfo_LatencyComponentType_MAX = ChromeLatencyInfo_LatencyComponentType::COMPONENT_INPUT_EVENT_LATENCY_FRAME_SWAP;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* ChromeLatencyInfo_LatencyComponentType_Name(::perfetto::protos::pbzero::ChromeLatencyInfo_LatencyComponentType value) {
  switch (value) {
  case ::perfetto::protos::pbzero::ChromeLatencyInfo_LatencyComponentType::COMPONENT_UNSPECIFIED:
    return "COMPONENT_UNSPECIFIED";

  case ::perfetto::protos::pbzero::ChromeLatencyInfo_LatencyComponentType::COMPONENT_INPUT_EVENT_LATENCY_BEGIN_RWH:
    return "COMPONENT_INPUT_EVENT_LATENCY_BEGIN_RWH";

  case ::perfetto::protos::pbzero::ChromeLatencyInfo_LatencyComponentType::COMPONENT_INPUT_EVENT_LATENCY_SCROLL_UPDATE_ORIGINAL:
    return "COMPONENT_INPUT_EVENT_LATENCY_SCROLL_UPDATE_ORIGINAL";

  case ::perfetto::protos::pbzero::ChromeLatencyInfo_LatencyComponentType::COMPONENT_INPUT_EVENT_LATENCY_FIRST_SCROLL_UPDATE_ORIGINAL:
    return "COMPONENT_INPUT_EVENT_LATENCY_FIRST_SCROLL_UPDATE_ORIGINAL";

  case ::perfetto::protos::pbzero::ChromeLatencyInfo_LatencyComponentType::COMPONENT_INPUT_EVENT_LATENCY_ORIGINAL:
    return "COMPONENT_INPUT_EVENT_LATENCY_ORIGINAL";

  case ::perfetto::protos::pbzero::ChromeLatencyInfo_LatencyComponentType::COMPONENT_INPUT_EVENT_LATENCY_UI:
    return "COMPONENT_INPUT_EVENT_LATENCY_UI";

  case ::perfetto::protos::pbzero::ChromeLatencyInfo_LatencyComponentType::COMPONENT_INPUT_EVENT_LATENCY_RENDERER_MAIN:
    return "COMPONENT_INPUT_EVENT_LATENCY_RENDERER_MAIN";

  case ::perfetto::protos::pbzero::ChromeLatencyInfo_LatencyComponentType::COMPONENT_INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_MAIN:
    return "COMPONENT_INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_MAIN";

  case ::perfetto::protos::pbzero::ChromeLatencyInfo_LatencyComponentType::COMPONENT_INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_IMPL:
    return "COMPONENT_INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_IMPL";

  case ::perfetto::protos::pbzero::ChromeLatencyInfo_LatencyComponentType::COMPONENT_INPUT_EVENT_LATENCY_SCROLL_UPDATE_LAST_EVENT:
    return "COMPONENT_INPUT_EVENT_LATENCY_SCROLL_UPDATE_LAST_EVENT";

  case ::perfetto::protos::pbzero::ChromeLatencyInfo_LatencyComponentType::COMPONENT_INPUT_EVENT_LATENCY_ACK_RWH:
    return "COMPONENT_INPUT_EVENT_LATENCY_ACK_RWH";

  case ::perfetto::protos::pbzero::ChromeLatencyInfo_LatencyComponentType::COMPONENT_INPUT_EVENT_LATENCY_RENDERER_SWAP:
    return "COMPONENT_INPUT_EVENT_LATENCY_RENDERER_SWAP";

  case ::perfetto::protos::pbzero::ChromeLatencyInfo_LatencyComponentType::COMPONENT_DISPLAY_COMPOSITOR_RECEIVED_FRAME:
    return "COMPONENT_DISPLAY_COMPOSITOR_RECEIVED_FRAME";

  case ::perfetto::protos::pbzero::ChromeLatencyInfo_LatencyComponentType::COMPONENT_INPUT_EVENT_GPU_SWAP_BUFFER:
    return "COMPONENT_INPUT_EVENT_GPU_SWAP_BUFFER";

  case ::perfetto::protos::pbzero::ChromeLatencyInfo_LatencyComponentType::COMPONENT_INPUT_EVENT_LATENCY_FRAME_SWAP:
    return "COMPONENT_INPUT_EVENT_LATENCY_FRAME_SWAP";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

class ChromeLatencyInfo_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ChromeLatencyInfo_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeLatencyInfo_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeLatencyInfo_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_trace_id() const { return at<1>().valid(); }
  int64_t trace_id() const { return at<1>().as_int64(); }
  bool has_step() const { return at<2>().valid(); }
  int32_t step() const { return at<2>().as_int32(); }
  bool has_frame_tree_node_id() const { return at<3>().valid(); }
  int32_t frame_tree_node_id() const { return at<3>().as_int32(); }
  bool has_component_info() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> component_info() const { return GetRepeated<::protozero::ConstBytes>(4); }
  bool has_is_coalesced() const { return at<5>().valid(); }
  bool is_coalesced() const { return at<5>().as_bool(); }
  bool has_gesture_scroll_id() const { return at<6>().valid(); }
  int64_t gesture_scroll_id() const { return at<6>().as_int64(); }
  bool has_touch_id() const { return at<7>().valid(); }
  int64_t touch_id() const { return at<7>().as_int64(); }
};

class ChromeLatencyInfo : public ::protozero::Message {
 public:
  using Decoder = ChromeLatencyInfo_Decoder;
  enum : int32_t {
    kTraceIdFieldNumber = 1,
    kStepFieldNumber = 2,
    kFrameTreeNodeIdFieldNumber = 3,
    kComponentInfoFieldNumber = 4,
    kIsCoalescedFieldNumber = 5,
    kGestureScrollIdFieldNumber = 6,
    kTouchIdFieldNumber = 7,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ChromeLatencyInfo"; }

  using ComponentInfo = ::perfetto::protos::pbzero::ChromeLatencyInfo_ComponentInfo;

  using Step = ::perfetto::protos::pbzero::ChromeLatencyInfo_Step;
  static inline const char* Step_Name(Step value) {
    return ::perfetto::protos::pbzero::ChromeLatencyInfo_Step_Name(value);
  }

  using LatencyComponentType = ::perfetto::protos::pbzero::ChromeLatencyInfo_LatencyComponentType;
  static inline const char* LatencyComponentType_Name(LatencyComponentType value) {
    return ::perfetto::protos::pbzero::ChromeLatencyInfo_LatencyComponentType_Name(value);
  }
  static inline const Step STEP_UNSPECIFIED = Step::STEP_UNSPECIFIED;
  static inline const Step STEP_SEND_INPUT_EVENT_UI = Step::STEP_SEND_INPUT_EVENT_UI;
  static inline const Step STEP_HANDLE_INPUT_EVENT_IMPL = Step::STEP_HANDLE_INPUT_EVENT_IMPL;
  static inline const Step STEP_DID_HANDLE_INPUT_AND_OVERSCROLL = Step::STEP_DID_HANDLE_INPUT_AND_OVERSCROLL;
  static inline const Step STEP_HANDLE_INPUT_EVENT_MAIN = Step::STEP_HANDLE_INPUT_EVENT_MAIN;
  static inline const Step STEP_MAIN_THREAD_SCROLL_UPDATE = Step::STEP_MAIN_THREAD_SCROLL_UPDATE;
  static inline const Step STEP_HANDLE_INPUT_EVENT_MAIN_COMMIT = Step::STEP_HANDLE_INPUT_EVENT_MAIN_COMMIT;
  static inline const Step STEP_HANDLED_INPUT_EVENT_MAIN_OR_IMPL = Step::STEP_HANDLED_INPUT_EVENT_MAIN_OR_IMPL;
  static inline const Step STEP_HANDLED_INPUT_EVENT_IMPL = Step::STEP_HANDLED_INPUT_EVENT_IMPL;
  static inline const Step STEP_SWAP_BUFFERS = Step::STEP_SWAP_BUFFERS;
  static inline const Step STEP_DRAW_AND_SWAP = Step::STEP_DRAW_AND_SWAP;
  static inline const Step STEP_FINISHED_SWAP_BUFFERS = Step::STEP_FINISHED_SWAP_BUFFERS;
  static inline const LatencyComponentType COMPONENT_UNSPECIFIED = LatencyComponentType::COMPONENT_UNSPECIFIED;
  static inline const LatencyComponentType COMPONENT_INPUT_EVENT_LATENCY_BEGIN_RWH = LatencyComponentType::COMPONENT_INPUT_EVENT_LATENCY_BEGIN_RWH;
  static inline const LatencyComponentType COMPONENT_INPUT_EVENT_LATENCY_SCROLL_UPDATE_ORIGINAL = LatencyComponentType::COMPONENT_INPUT_EVENT_LATENCY_SCROLL_UPDATE_ORIGINAL;
  static inline const LatencyComponentType COMPONENT_INPUT_EVENT_LATENCY_FIRST_SCROLL_UPDATE_ORIGINAL = LatencyComponentType::COMPONENT_INPUT_EVENT_LATENCY_FIRST_SCROLL_UPDATE_ORIGINAL;
  static inline const LatencyComponentType COMPONENT_INPUT_EVENT_LATENCY_ORIGINAL = LatencyComponentType::COMPONENT_INPUT_EVENT_LATENCY_ORIGINAL;
  static inline const LatencyComponentType COMPONENT_INPUT_EVENT_LATENCY_UI = LatencyComponentType::COMPONENT_INPUT_EVENT_LATENCY_UI;
  static inline const LatencyComponentType COMPONENT_INPUT_EVENT_LATENCY_RENDERER_MAIN = LatencyComponentType::COMPONENT_INPUT_EVENT_LATENCY_RENDERER_MAIN;
  static inline const LatencyComponentType COMPONENT_INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_MAIN = LatencyComponentType::COMPONENT_INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_MAIN;
  static inline const LatencyComponentType COMPONENT_INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_IMPL = LatencyComponentType::COMPONENT_INPUT_EVENT_LATENCY_RENDERING_SCHEDULED_IMPL;
  static inline const LatencyComponentType COMPONENT_INPUT_EVENT_LATENCY_SCROLL_UPDATE_LAST_EVENT = LatencyComponentType::COMPONENT_INPUT_EVENT_LATENCY_SCROLL_UPDATE_LAST_EVENT;
  static inline const LatencyComponentType COMPONENT_INPUT_EVENT_LATENCY_ACK_RWH = LatencyComponentType::COMPONENT_INPUT_EVENT_LATENCY_ACK_RWH;
  static inline const LatencyComponentType COMPONENT_INPUT_EVENT_LATENCY_RENDERER_SWAP = LatencyComponentType::COMPONENT_INPUT_EVENT_LATENCY_RENDERER_SWAP;
  static inline const LatencyComponentType COMPONENT_DISPLAY_COMPOSITOR_RECEIVED_FRAME = LatencyComponentType::COMPONENT_DISPLAY_COMPOSITOR_RECEIVED_FRAME;
  static inline const LatencyComponentType COMPONENT_INPUT_EVENT_GPU_SWAP_BUFFER = LatencyComponentType::COMPONENT_INPUT_EVENT_GPU_SWAP_BUFFER;
  static inline const LatencyComponentType COMPONENT_INPUT_EVENT_LATENCY_FRAME_SWAP = LatencyComponentType::COMPONENT_INPUT_EVENT_LATENCY_FRAME_SWAP;

  using FieldMetadata_TraceId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      ChromeLatencyInfo>;

  static constexpr FieldMetadata_TraceId kTraceId{};
  void set_trace_id(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_TraceId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Step =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ChromeLatencyInfo_Step,
      ChromeLatencyInfo>;

  static constexpr FieldMetadata_Step kStep{};
  void set_step(ChromeLatencyInfo_Step value) {
    static constexpr uint32_t field_id = FieldMetadata_Step::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_FrameTreeNodeId =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      ChromeLatencyInfo>;

  static constexpr FieldMetadata_FrameTreeNodeId kFrameTreeNodeId{};
  void set_frame_tree_node_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_FrameTreeNodeId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ComponentInfo =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ChromeLatencyInfo_ComponentInfo,
      ChromeLatencyInfo>;

  static constexpr FieldMetadata_ComponentInfo kComponentInfo{};
  template <typename T = ChromeLatencyInfo_ComponentInfo> T* add_component_info() {
    return BeginNestedMessage<T>(4);
  }


  using FieldMetadata_IsCoalesced =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ChromeLatencyInfo>;

  static constexpr FieldMetadata_IsCoalesced kIsCoalesced{};
  void set_is_coalesced(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsCoalesced::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_GestureScrollId =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      ChromeLatencyInfo>;

  static constexpr FieldMetadata_GestureScrollId kGestureScrollId{};
  void set_gesture_scroll_id(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_GestureScrollId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_TouchId =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      ChromeLatencyInfo>;

  static constexpr FieldMetadata_TouchId kTouchId{};
  void set_touch_id(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_TouchId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }
};

class ChromeLatencyInfo_ComponentInfo_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeLatencyInfo_ComponentInfo_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeLatencyInfo_ComponentInfo_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeLatencyInfo_ComponentInfo_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_component_type() const { return at<1>().valid(); }
  int32_t component_type() const { return at<1>().as_int32(); }
  bool has_time_us() const { return at<2>().valid(); }
  uint64_t time_us() const { return at<2>().as_uint64(); }
};

class ChromeLatencyInfo_ComponentInfo : public ::protozero::Message {
 public:
  using Decoder = ChromeLatencyInfo_ComponentInfo_Decoder;
  enum : int32_t {
    kComponentTypeFieldNumber = 1,
    kTimeUsFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ChromeLatencyInfo.ComponentInfo"; }


  using FieldMetadata_ComponentType =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ChromeLatencyInfo_LatencyComponentType,
      ChromeLatencyInfo_ComponentInfo>;

  static constexpr FieldMetadata_ComponentType kComponentType{};
  void set_component_type(ChromeLatencyInfo_LatencyComponentType value) {
    static constexpr uint32_t field_id = FieldMetadata_ComponentType::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_TimeUs =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      ChromeLatencyInfo_ComponentInfo>;

  static constexpr FieldMetadata_TimeUs kTimeUs{};
  void set_time_us(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_TimeUs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
