// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/trace/etw/etw.proto

#include "protos/perfetto/trace/etw/etw.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace perfetto {
namespace protos {
PROTOBUF_CONSTEXPR CSwitchEtwEvent::CSwitchEtwEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.new_thread_id_)*/0u
  , /*decltype(_impl_.old_thread_id_)*/0u
  , /*decltype(_impl_.new_thread_priority_)*/0
  , /*decltype(_impl_.old_thread_priority_)*/0
  , /*decltype(_impl_.previous_c_state_)*/0u
  , /*decltype(_impl_.old_thread_wait_reason_)*/0
  , /*decltype(_impl_.old_thread_wait_mode_)*/0
  , /*decltype(_impl_.old_thread_state_)*/0
  , /*decltype(_impl_.old_thread_wait_ideal_processor_)*/0
  , /*decltype(_impl_.new_thread_wait_time_)*/0u} {}
struct CSwitchEtwEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSwitchEtwEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSwitchEtwEventDefaultTypeInternal() {}
  union {
    CSwitchEtwEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSwitchEtwEventDefaultTypeInternal _CSwitchEtwEvent_default_instance_;
PROTOBUF_CONSTEXPR ReadyThreadEtwEvent::ReadyThreadEtwEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.t_thread_id_)*/0u
  , /*decltype(_impl_.adjust_reason_)*/0
  , /*decltype(_impl_.adjust_increment_)*/0
  , /*decltype(_impl_.flag_)*/0} {}
struct ReadyThreadEtwEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReadyThreadEtwEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReadyThreadEtwEventDefaultTypeInternal() {}
  union {
    ReadyThreadEtwEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReadyThreadEtwEventDefaultTypeInternal _ReadyThreadEtwEvent_default_instance_;
}  // namespace protos
}  // namespace perfetto
namespace perfetto {
namespace protos {
bool CSwitchEtwEvent_OldThreadWaitReason_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CSwitchEtwEvent_OldThreadWaitReason_strings[38] = {};

static const char CSwitchEtwEvent_OldThreadWaitReason_names[] =
  "DELAY_EXECUTION"
  "EXECUTIVE"
  "FREE_PAGE"
  "MAXIMUM_WAIT_REASON"
  "PAGE_IN"
  "POOL_ALLOCATION"
  "SUSPEND"
  "USER_REQUEST"
  "WR_CALLOUT_STACK"
  "WR_CPU_RATE_CONTROL"
  "WR_DELAY_EXECUTION"
  "WR_DISPATCH_INT"
  "WR_EVENT_PAIR"
  "WR_EXECUTIVE"
  "WR_FAST_MUTEX"
  "WR_FREE_PAGE"
  "WR_GUARD_MUTEX"
  "WR_KERNEL"
  "WR_KEYED_EVENT"
  "WR_LPC_RECEIVER"
  "WR_LPC_REPLY"
  "WR_MUTEX"
  "WR_PAGE_IN"
  "WR_PAGE_OUT"
  "WR_POOL_ALLOCATION"
  "WR_PREEMPTED"
  "WR_PROCESS_IN_SWAP"
  "WR_PUSH_LOCK"
  "WR_QUANTUM_END"
  "WR_QUEUE"
  "WR_RENDEZ_VOUS"
  "WR_RESOURCE"
  "WR_RUNDOWN"
  "WR_SUSPENDED"
  "WR_TERMINATED"
  "WR_USER_REQUEST"
  "WR_VIRTUAL_MEMORY"
  "WR_YIELD_EXECUTION";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CSwitchEtwEvent_OldThreadWaitReason_entries[] = {
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 0, 15}, 4 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 15, 9}, 0 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 24, 9}, 1 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 33, 19}, 37 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 52, 7}, 2 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 59, 15}, 3 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 74, 7}, 5 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 81, 12}, 6 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 93, 16}, 25 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 109, 19}, 24 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 128, 18}, 11 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 146, 15}, 31 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 161, 13}, 14 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 174, 12}, 7 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 186, 13}, 34 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 199, 12}, 8 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 211, 14}, 35 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 225, 9}, 26 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 234, 14}, 21 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 248, 15}, 16 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 263, 12}, 17 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 275, 8}, 29 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 283, 10}, 9 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 293, 11}, 19 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 304, 18}, 10 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 322, 12}, 32 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 334, 18}, 23 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 352, 12}, 28 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 364, 14}, 30 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 378, 8}, 15 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 386, 14}, 20 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 400, 11}, 27 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 411, 10}, 36 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 421, 12}, 12 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 433, 13}, 22 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 446, 15}, 13 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 461, 17}, 18 },
  { {CSwitchEtwEvent_OldThreadWaitReason_names + 478, 18}, 33 },
};

static const int CSwitchEtwEvent_OldThreadWaitReason_entries_by_number[] = {
  1, // 0 -> EXECUTIVE
  2, // 1 -> FREE_PAGE
  4, // 2 -> PAGE_IN
  5, // 3 -> POOL_ALLOCATION
  0, // 4 -> DELAY_EXECUTION
  6, // 5 -> SUSPEND
  7, // 6 -> USER_REQUEST
  13, // 7 -> WR_EXECUTIVE
  15, // 8 -> WR_FREE_PAGE
  22, // 9 -> WR_PAGE_IN
  24, // 10 -> WR_POOL_ALLOCATION
  10, // 11 -> WR_DELAY_EXECUTION
  33, // 12 -> WR_SUSPENDED
  35, // 13 -> WR_USER_REQUEST
  12, // 14 -> WR_EVENT_PAIR
  29, // 15 -> WR_QUEUE
  19, // 16 -> WR_LPC_RECEIVER
  20, // 17 -> WR_LPC_REPLY
  36, // 18 -> WR_VIRTUAL_MEMORY
  23, // 19 -> WR_PAGE_OUT
  30, // 20 -> WR_RENDEZ_VOUS
  18, // 21 -> WR_KEYED_EVENT
  34, // 22 -> WR_TERMINATED
  26, // 23 -> WR_PROCESS_IN_SWAP
  9, // 24 -> WR_CPU_RATE_CONTROL
  8, // 25 -> WR_CALLOUT_STACK
  17, // 26 -> WR_KERNEL
  31, // 27 -> WR_RESOURCE
  27, // 28 -> WR_PUSH_LOCK
  21, // 29 -> WR_MUTEX
  28, // 30 -> WR_QUANTUM_END
  11, // 31 -> WR_DISPATCH_INT
  25, // 32 -> WR_PREEMPTED
  37, // 33 -> WR_YIELD_EXECUTION
  14, // 34 -> WR_FAST_MUTEX
  16, // 35 -> WR_GUARD_MUTEX
  32, // 36 -> WR_RUNDOWN
  3, // 37 -> MAXIMUM_WAIT_REASON
};

const std::string& CSwitchEtwEvent_OldThreadWaitReason_Name(
    CSwitchEtwEvent_OldThreadWaitReason value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CSwitchEtwEvent_OldThreadWaitReason_entries,
          CSwitchEtwEvent_OldThreadWaitReason_entries_by_number,
          38, CSwitchEtwEvent_OldThreadWaitReason_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CSwitchEtwEvent_OldThreadWaitReason_entries,
      CSwitchEtwEvent_OldThreadWaitReason_entries_by_number,
      38, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CSwitchEtwEvent_OldThreadWaitReason_strings[idx].get();
}
bool CSwitchEtwEvent_OldThreadWaitReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CSwitchEtwEvent_OldThreadWaitReason* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CSwitchEtwEvent_OldThreadWaitReason_entries, 38, name, &int_value);
  if (success) {
    *value = static_cast<CSwitchEtwEvent_OldThreadWaitReason>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::EXECUTIVE;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::FREE_PAGE;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::PAGE_IN;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::POOL_ALLOCATION;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::DELAY_EXECUTION;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::SUSPEND;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::USER_REQUEST;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::WR_EXECUTIVE;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::WR_FREE_PAGE;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::WR_PAGE_IN;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::WR_POOL_ALLOCATION;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::WR_DELAY_EXECUTION;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::WR_SUSPENDED;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::WR_USER_REQUEST;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::WR_EVENT_PAIR;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::WR_QUEUE;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::WR_LPC_RECEIVER;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::WR_LPC_REPLY;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::WR_VIRTUAL_MEMORY;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::WR_PAGE_OUT;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::WR_RENDEZ_VOUS;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::WR_KEYED_EVENT;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::WR_TERMINATED;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::WR_PROCESS_IN_SWAP;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::WR_CPU_RATE_CONTROL;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::WR_CALLOUT_STACK;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::WR_KERNEL;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::WR_RESOURCE;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::WR_PUSH_LOCK;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::WR_MUTEX;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::WR_QUANTUM_END;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::WR_DISPATCH_INT;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::WR_PREEMPTED;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::WR_YIELD_EXECUTION;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::WR_FAST_MUTEX;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::WR_GUARD_MUTEX;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::WR_RUNDOWN;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::MAXIMUM_WAIT_REASON;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::OldThreadWaitReason_MIN;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent::OldThreadWaitReason_MAX;
constexpr int CSwitchEtwEvent::OldThreadWaitReason_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool CSwitchEtwEvent_OldThreadWaitMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CSwitchEtwEvent_OldThreadWaitMode_strings[2] = {};

static const char CSwitchEtwEvent_OldThreadWaitMode_names[] =
  "KERNEL_MODE"
  "USER_MODE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CSwitchEtwEvent_OldThreadWaitMode_entries[] = {
  { {CSwitchEtwEvent_OldThreadWaitMode_names + 0, 11}, 0 },
  { {CSwitchEtwEvent_OldThreadWaitMode_names + 11, 9}, 1 },
};

static const int CSwitchEtwEvent_OldThreadWaitMode_entries_by_number[] = {
  0, // 0 -> KERNEL_MODE
  1, // 1 -> USER_MODE
};

const std::string& CSwitchEtwEvent_OldThreadWaitMode_Name(
    CSwitchEtwEvent_OldThreadWaitMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CSwitchEtwEvent_OldThreadWaitMode_entries,
          CSwitchEtwEvent_OldThreadWaitMode_entries_by_number,
          2, CSwitchEtwEvent_OldThreadWaitMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CSwitchEtwEvent_OldThreadWaitMode_entries,
      CSwitchEtwEvent_OldThreadWaitMode_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CSwitchEtwEvent_OldThreadWaitMode_strings[idx].get();
}
bool CSwitchEtwEvent_OldThreadWaitMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CSwitchEtwEvent_OldThreadWaitMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CSwitchEtwEvent_OldThreadWaitMode_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<CSwitchEtwEvent_OldThreadWaitMode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CSwitchEtwEvent_OldThreadWaitMode CSwitchEtwEvent::KERNEL_MODE;
constexpr CSwitchEtwEvent_OldThreadWaitMode CSwitchEtwEvent::USER_MODE;
constexpr CSwitchEtwEvent_OldThreadWaitMode CSwitchEtwEvent::OldThreadWaitMode_MIN;
constexpr CSwitchEtwEvent_OldThreadWaitMode CSwitchEtwEvent::OldThreadWaitMode_MAX;
constexpr int CSwitchEtwEvent::OldThreadWaitMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool CSwitchEtwEvent_OldThreadState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CSwitchEtwEvent_OldThreadState_strings[8] = {};

static const char CSwitchEtwEvent_OldThreadState_names[] =
  "DEFERRED_READY"
  "INITIALIZED"
  "READY"
  "RUNNING"
  "STANDBY"
  "TERMINATED"
  "TRANSITION"
  "WAITING";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CSwitchEtwEvent_OldThreadState_entries[] = {
  { {CSwitchEtwEvent_OldThreadState_names + 0, 14}, 7 },
  { {CSwitchEtwEvent_OldThreadState_names + 14, 11}, 0 },
  { {CSwitchEtwEvent_OldThreadState_names + 25, 5}, 1 },
  { {CSwitchEtwEvent_OldThreadState_names + 30, 7}, 2 },
  { {CSwitchEtwEvent_OldThreadState_names + 37, 7}, 3 },
  { {CSwitchEtwEvent_OldThreadState_names + 44, 10}, 4 },
  { {CSwitchEtwEvent_OldThreadState_names + 54, 10}, 6 },
  { {CSwitchEtwEvent_OldThreadState_names + 64, 7}, 5 },
};

static const int CSwitchEtwEvent_OldThreadState_entries_by_number[] = {
  1, // 0 -> INITIALIZED
  2, // 1 -> READY
  3, // 2 -> RUNNING
  4, // 3 -> STANDBY
  5, // 4 -> TERMINATED
  7, // 5 -> WAITING
  6, // 6 -> TRANSITION
  0, // 7 -> DEFERRED_READY
};

const std::string& CSwitchEtwEvent_OldThreadState_Name(
    CSwitchEtwEvent_OldThreadState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CSwitchEtwEvent_OldThreadState_entries,
          CSwitchEtwEvent_OldThreadState_entries_by_number,
          8, CSwitchEtwEvent_OldThreadState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CSwitchEtwEvent_OldThreadState_entries,
      CSwitchEtwEvent_OldThreadState_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CSwitchEtwEvent_OldThreadState_strings[idx].get();
}
bool CSwitchEtwEvent_OldThreadState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CSwitchEtwEvent_OldThreadState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CSwitchEtwEvent_OldThreadState_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<CSwitchEtwEvent_OldThreadState>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CSwitchEtwEvent_OldThreadState CSwitchEtwEvent::INITIALIZED;
constexpr CSwitchEtwEvent_OldThreadState CSwitchEtwEvent::READY;
constexpr CSwitchEtwEvent_OldThreadState CSwitchEtwEvent::RUNNING;
constexpr CSwitchEtwEvent_OldThreadState CSwitchEtwEvent::STANDBY;
constexpr CSwitchEtwEvent_OldThreadState CSwitchEtwEvent::TERMINATED;
constexpr CSwitchEtwEvent_OldThreadState CSwitchEtwEvent::WAITING;
constexpr CSwitchEtwEvent_OldThreadState CSwitchEtwEvent::TRANSITION;
constexpr CSwitchEtwEvent_OldThreadState CSwitchEtwEvent::DEFERRED_READY;
constexpr CSwitchEtwEvent_OldThreadState CSwitchEtwEvent::OldThreadState_MIN;
constexpr CSwitchEtwEvent_OldThreadState CSwitchEtwEvent::OldThreadState_MAX;
constexpr int CSwitchEtwEvent::OldThreadState_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ReadyThreadEtwEvent_AdjustReason_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ReadyThreadEtwEvent_AdjustReason_strings[3] = {};

static const char ReadyThreadEtwEvent_AdjustReason_names[] =
  "APPLY_INCREMENT"
  "APPLY_INCREMENT_BOOST"
  "IGNORE_THE_INCREMENT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ReadyThreadEtwEvent_AdjustReason_entries[] = {
  { {ReadyThreadEtwEvent_AdjustReason_names + 0, 15}, 1 },
  { {ReadyThreadEtwEvent_AdjustReason_names + 15, 21}, 2 },
  { {ReadyThreadEtwEvent_AdjustReason_names + 36, 20}, 0 },
};

static const int ReadyThreadEtwEvent_AdjustReason_entries_by_number[] = {
  2, // 0 -> IGNORE_THE_INCREMENT
  0, // 1 -> APPLY_INCREMENT
  1, // 2 -> APPLY_INCREMENT_BOOST
};

const std::string& ReadyThreadEtwEvent_AdjustReason_Name(
    ReadyThreadEtwEvent_AdjustReason value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ReadyThreadEtwEvent_AdjustReason_entries,
          ReadyThreadEtwEvent_AdjustReason_entries_by_number,
          3, ReadyThreadEtwEvent_AdjustReason_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ReadyThreadEtwEvent_AdjustReason_entries,
      ReadyThreadEtwEvent_AdjustReason_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ReadyThreadEtwEvent_AdjustReason_strings[idx].get();
}
bool ReadyThreadEtwEvent_AdjustReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ReadyThreadEtwEvent_AdjustReason* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ReadyThreadEtwEvent_AdjustReason_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ReadyThreadEtwEvent_AdjustReason>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ReadyThreadEtwEvent_AdjustReason ReadyThreadEtwEvent::IGNORE_THE_INCREMENT;
constexpr ReadyThreadEtwEvent_AdjustReason ReadyThreadEtwEvent::APPLY_INCREMENT;
constexpr ReadyThreadEtwEvent_AdjustReason ReadyThreadEtwEvent::APPLY_INCREMENT_BOOST;
constexpr ReadyThreadEtwEvent_AdjustReason ReadyThreadEtwEvent::AdjustReason_MIN;
constexpr ReadyThreadEtwEvent_AdjustReason ReadyThreadEtwEvent::AdjustReason_MAX;
constexpr int ReadyThreadEtwEvent::AdjustReason_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ReadyThreadEtwEvent_TraceFlag_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ReadyThreadEtwEvent_TraceFlag_strings[4] = {};

static const char ReadyThreadEtwEvent_TraceFlag_names[] =
  "KERNEL_STACK_SWAPPED_OUT"
  "PROCESS_ADDRESS_SWAPPED_OUT"
  "THREAD_READIED"
  "TRACE_FLAG_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ReadyThreadEtwEvent_TraceFlag_entries[] = {
  { {ReadyThreadEtwEvent_TraceFlag_names + 0, 24}, 2 },
  { {ReadyThreadEtwEvent_TraceFlag_names + 24, 27}, 4 },
  { {ReadyThreadEtwEvent_TraceFlag_names + 51, 14}, 1 },
  { {ReadyThreadEtwEvent_TraceFlag_names + 65, 22}, 0 },
};

static const int ReadyThreadEtwEvent_TraceFlag_entries_by_number[] = {
  3, // 0 -> TRACE_FLAG_UNSPECIFIED
  2, // 1 -> THREAD_READIED
  0, // 2 -> KERNEL_STACK_SWAPPED_OUT
  1, // 4 -> PROCESS_ADDRESS_SWAPPED_OUT
};

const std::string& ReadyThreadEtwEvent_TraceFlag_Name(
    ReadyThreadEtwEvent_TraceFlag value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ReadyThreadEtwEvent_TraceFlag_entries,
          ReadyThreadEtwEvent_TraceFlag_entries_by_number,
          4, ReadyThreadEtwEvent_TraceFlag_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ReadyThreadEtwEvent_TraceFlag_entries,
      ReadyThreadEtwEvent_TraceFlag_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ReadyThreadEtwEvent_TraceFlag_strings[idx].get();
}
bool ReadyThreadEtwEvent_TraceFlag_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ReadyThreadEtwEvent_TraceFlag* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ReadyThreadEtwEvent_TraceFlag_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ReadyThreadEtwEvent_TraceFlag>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ReadyThreadEtwEvent_TraceFlag ReadyThreadEtwEvent::TRACE_FLAG_UNSPECIFIED;
constexpr ReadyThreadEtwEvent_TraceFlag ReadyThreadEtwEvent::THREAD_READIED;
constexpr ReadyThreadEtwEvent_TraceFlag ReadyThreadEtwEvent::KERNEL_STACK_SWAPPED_OUT;
constexpr ReadyThreadEtwEvent_TraceFlag ReadyThreadEtwEvent::PROCESS_ADDRESS_SWAPPED_OUT;
constexpr ReadyThreadEtwEvent_TraceFlag ReadyThreadEtwEvent::TraceFlag_MIN;
constexpr ReadyThreadEtwEvent_TraceFlag ReadyThreadEtwEvent::TraceFlag_MAX;
constexpr int ReadyThreadEtwEvent::TraceFlag_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class CSwitchEtwEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<CSwitchEtwEvent>()._impl_._has_bits_);
  static void set_has_new_thread_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_old_thread_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_new_thread_priority(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_old_thread_priority(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_previous_c_state(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_old_thread_wait_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_old_thread_wait_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_old_thread_state(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_old_thread_wait_ideal_processor(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_new_thread_wait_time(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

CSwitchEtwEvent::CSwitchEtwEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.CSwitchEtwEvent)
}
CSwitchEtwEvent::CSwitchEtwEvent(const CSwitchEtwEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CSwitchEtwEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.new_thread_id_){}
    , decltype(_impl_.old_thread_id_){}
    , decltype(_impl_.new_thread_priority_){}
    , decltype(_impl_.old_thread_priority_){}
    , decltype(_impl_.previous_c_state_){}
    , decltype(_impl_.old_thread_wait_reason_){}
    , decltype(_impl_.old_thread_wait_mode_){}
    , decltype(_impl_.old_thread_state_){}
    , decltype(_impl_.old_thread_wait_ideal_processor_){}
    , decltype(_impl_.new_thread_wait_time_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.new_thread_id_, &from._impl_.new_thread_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.new_thread_wait_time_) -
    reinterpret_cast<char*>(&_impl_.new_thread_id_)) + sizeof(_impl_.new_thread_wait_time_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.CSwitchEtwEvent)
}

inline void CSwitchEtwEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.new_thread_id_){0u}
    , decltype(_impl_.old_thread_id_){0u}
    , decltype(_impl_.new_thread_priority_){0}
    , decltype(_impl_.old_thread_priority_){0}
    , decltype(_impl_.previous_c_state_){0u}
    , decltype(_impl_.old_thread_wait_reason_){0}
    , decltype(_impl_.old_thread_wait_mode_){0}
    , decltype(_impl_.old_thread_state_){0}
    , decltype(_impl_.old_thread_wait_ideal_processor_){0}
    , decltype(_impl_.new_thread_wait_time_){0u}
  };
}

CSwitchEtwEvent::~CSwitchEtwEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.CSwitchEtwEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSwitchEtwEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSwitchEtwEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSwitchEtwEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.CSwitchEtwEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.new_thread_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.old_thread_state_) -
        reinterpret_cast<char*>(&_impl_.new_thread_id_)) + sizeof(_impl_.old_thread_state_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.old_thread_wait_ideal_processor_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.new_thread_wait_time_) -
        reinterpret_cast<char*>(&_impl_.old_thread_wait_ideal_processor_)) + sizeof(_impl_.new_thread_wait_time_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CSwitchEtwEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 new_thread_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_new_thread_id(&has_bits);
          _impl_.new_thread_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 old_thread_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_old_thread_id(&has_bits);
          _impl_.old_thread_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional sint32 new_thread_priority = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_new_thread_priority(&has_bits);
          _impl_.new_thread_priority_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional sint32 old_thread_priority = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_old_thread_priority(&has_bits);
          _impl_.old_thread_priority_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 previous_c_state = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_previous_c_state(&has_bits);
          _impl_.previous_c_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .perfetto.protos.CSwitchEtwEvent.OldThreadWaitReason old_thread_wait_reason = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::perfetto::protos::CSwitchEtwEvent_OldThreadWaitReason_IsValid(val))) {
            _internal_set_old_thread_wait_reason(static_cast<::perfetto::protos::CSwitchEtwEvent_OldThreadWaitReason>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .perfetto.protos.CSwitchEtwEvent.OldThreadWaitMode old_thread_wait_mode = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::perfetto::protos::CSwitchEtwEvent_OldThreadWaitMode_IsValid(val))) {
            _internal_set_old_thread_wait_mode(static_cast<::perfetto::protos::CSwitchEtwEvent_OldThreadWaitMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .perfetto.protos.CSwitchEtwEvent.OldThreadState old_thread_state = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::perfetto::protos::CSwitchEtwEvent_OldThreadState_IsValid(val))) {
            _internal_set_old_thread_state(static_cast<::perfetto::protos::CSwitchEtwEvent_OldThreadState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional sint32 old_thread_wait_ideal_processor = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_old_thread_wait_ideal_processor(&has_bits);
          _impl_.old_thread_wait_ideal_processor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 new_thread_wait_time = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_new_thread_wait_time(&has_bits);
          _impl_.new_thread_wait_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSwitchEtwEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.CSwitchEtwEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 new_thread_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_new_thread_id(), target);
  }

  // optional uint32 old_thread_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_old_thread_id(), target);
  }

  // optional sint32 new_thread_priority = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(3, this->_internal_new_thread_priority(), target);
  }

  // optional sint32 old_thread_priority = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(4, this->_internal_old_thread_priority(), target);
  }

  // optional uint32 previous_c_state = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_previous_c_state(), target);
  }

  // optional .perfetto.protos.CSwitchEtwEvent.OldThreadWaitReason old_thread_wait_reason = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_old_thread_wait_reason(), target);
  }

  // optional .perfetto.protos.CSwitchEtwEvent.OldThreadWaitMode old_thread_wait_mode = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_old_thread_wait_mode(), target);
  }

  // optional .perfetto.protos.CSwitchEtwEvent.OldThreadState old_thread_state = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_old_thread_state(), target);
  }

  // optional sint32 old_thread_wait_ideal_processor = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(9, this->_internal_old_thread_wait_ideal_processor(), target);
  }

  // optional uint32 new_thread_wait_time = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_new_thread_wait_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.CSwitchEtwEvent)
  return target;
}

size_t CSwitchEtwEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.CSwitchEtwEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 new_thread_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_new_thread_id());
    }

    // optional uint32 old_thread_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_old_thread_id());
    }

    // optional sint32 new_thread_priority = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(this->_internal_new_thread_priority());
    }

    // optional sint32 old_thread_priority = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(this->_internal_old_thread_priority());
    }

    // optional uint32 previous_c_state = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_previous_c_state());
    }

    // optional .perfetto.protos.CSwitchEtwEvent.OldThreadWaitReason old_thread_wait_reason = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_old_thread_wait_reason());
    }

    // optional .perfetto.protos.CSwitchEtwEvent.OldThreadWaitMode old_thread_wait_mode = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_old_thread_wait_mode());
    }

    // optional .perfetto.protos.CSwitchEtwEvent.OldThreadState old_thread_state = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_old_thread_state());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional sint32 old_thread_wait_ideal_processor = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(this->_internal_old_thread_wait_ideal_processor());
    }

    // optional uint32 new_thread_wait_time = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_new_thread_wait_time());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CSwitchEtwEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CSwitchEtwEvent*>(
      &from));
}

void CSwitchEtwEvent::MergeFrom(const CSwitchEtwEvent& from) {
  CSwitchEtwEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.CSwitchEtwEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.new_thread_id_ = from._impl_.new_thread_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.old_thread_id_ = from._impl_.old_thread_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.new_thread_priority_ = from._impl_.new_thread_priority_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.old_thread_priority_ = from._impl_.old_thread_priority_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.previous_c_state_ = from._impl_.previous_c_state_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.old_thread_wait_reason_ = from._impl_.old_thread_wait_reason_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.old_thread_wait_mode_ = from._impl_.old_thread_wait_mode_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.old_thread_state_ = from._impl_.old_thread_state_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.old_thread_wait_ideal_processor_ = from._impl_.old_thread_wait_ideal_processor_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.new_thread_wait_time_ = from._impl_.new_thread_wait_time_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CSwitchEtwEvent::CopyFrom(const CSwitchEtwEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.CSwitchEtwEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSwitchEtwEvent::IsInitialized() const {
  return true;
}

void CSwitchEtwEvent::InternalSwap(CSwitchEtwEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSwitchEtwEvent, _impl_.new_thread_wait_time_)
      + sizeof(CSwitchEtwEvent::_impl_.new_thread_wait_time_)
      - PROTOBUF_FIELD_OFFSET(CSwitchEtwEvent, _impl_.new_thread_id_)>(
          reinterpret_cast<char*>(&_impl_.new_thread_id_),
          reinterpret_cast<char*>(&other->_impl_.new_thread_id_));
}

std::string CSwitchEtwEvent::GetTypeName() const {
  return "perfetto.protos.CSwitchEtwEvent";
}


// ===================================================================

class ReadyThreadEtwEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<ReadyThreadEtwEvent>()._impl_._has_bits_);
  static void set_has_t_thread_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_adjust_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_adjust_increment(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_flag(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

ReadyThreadEtwEvent::ReadyThreadEtwEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:perfetto.protos.ReadyThreadEtwEvent)
}
ReadyThreadEtwEvent::ReadyThreadEtwEvent(const ReadyThreadEtwEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ReadyThreadEtwEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.t_thread_id_){}
    , decltype(_impl_.adjust_reason_){}
    , decltype(_impl_.adjust_increment_){}
    , decltype(_impl_.flag_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.t_thread_id_, &from._impl_.t_thread_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.flag_) -
    reinterpret_cast<char*>(&_impl_.t_thread_id_)) + sizeof(_impl_.flag_));
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.ReadyThreadEtwEvent)
}

inline void ReadyThreadEtwEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.t_thread_id_){0u}
    , decltype(_impl_.adjust_reason_){0}
    , decltype(_impl_.adjust_increment_){0}
    , decltype(_impl_.flag_){0}
  };
}

ReadyThreadEtwEvent::~ReadyThreadEtwEvent() {
  // @@protoc_insertion_point(destructor:perfetto.protos.ReadyThreadEtwEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReadyThreadEtwEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReadyThreadEtwEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReadyThreadEtwEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.ReadyThreadEtwEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.t_thread_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.flag_) -
        reinterpret_cast<char*>(&_impl_.t_thread_id_)) + sizeof(_impl_.flag_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ReadyThreadEtwEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 t_thread_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_t_thread_id(&has_bits);
          _impl_.t_thread_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .perfetto.protos.ReadyThreadEtwEvent.AdjustReason adjust_reason = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::perfetto::protos::ReadyThreadEtwEvent_AdjustReason_IsValid(val))) {
            _internal_set_adjust_reason(static_cast<::perfetto::protos::ReadyThreadEtwEvent_AdjustReason>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional sint32 adjust_increment = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_adjust_increment(&has_bits);
          _impl_.adjust_increment_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .perfetto.protos.ReadyThreadEtwEvent.TraceFlag flag = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::perfetto::protos::ReadyThreadEtwEvent_TraceFlag_IsValid(val))) {
            _internal_set_flag(static_cast<::perfetto::protos::ReadyThreadEtwEvent_TraceFlag>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReadyThreadEtwEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:perfetto.protos.ReadyThreadEtwEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 t_thread_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_t_thread_id(), target);
  }

  // optional .perfetto.protos.ReadyThreadEtwEvent.AdjustReason adjust_reason = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_adjust_reason(), target);
  }

  // optional sint32 adjust_increment = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(3, this->_internal_adjust_increment(), target);
  }

  // optional .perfetto.protos.ReadyThreadEtwEvent.TraceFlag flag = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_flag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:perfetto.protos.ReadyThreadEtwEvent)
  return target;
}

size_t ReadyThreadEtwEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.ReadyThreadEtwEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint32 t_thread_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_t_thread_id());
    }

    // optional .perfetto.protos.ReadyThreadEtwEvent.AdjustReason adjust_reason = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_adjust_reason());
    }

    // optional sint32 adjust_increment = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(this->_internal_adjust_increment());
    }

    // optional .perfetto.protos.ReadyThreadEtwEvent.TraceFlag flag = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_flag());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ReadyThreadEtwEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ReadyThreadEtwEvent*>(
      &from));
}

void ReadyThreadEtwEvent::MergeFrom(const ReadyThreadEtwEvent& from) {
  ReadyThreadEtwEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.ReadyThreadEtwEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.t_thread_id_ = from._impl_.t_thread_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.adjust_reason_ = from._impl_.adjust_reason_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.adjust_increment_ = from._impl_.adjust_increment_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.flag_ = from._impl_.flag_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ReadyThreadEtwEvent::CopyFrom(const ReadyThreadEtwEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.ReadyThreadEtwEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReadyThreadEtwEvent::IsInitialized() const {
  return true;
}

void ReadyThreadEtwEvent::InternalSwap(ReadyThreadEtwEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReadyThreadEtwEvent, _impl_.flag_)
      + sizeof(ReadyThreadEtwEvent::_impl_.flag_)
      - PROTOBUF_FIELD_OFFSET(ReadyThreadEtwEvent, _impl_.t_thread_id_)>(
          reinterpret_cast<char*>(&_impl_.t_thread_id_),
          reinterpret_cast<char*>(&other->_impl_.t_thread_id_));
}

std::string ReadyThreadEtwEvent::GetTypeName() const {
  return "perfetto.protos.ReadyThreadEtwEvent";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace protos
}  // namespace perfetto
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::perfetto::protos::CSwitchEtwEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::CSwitchEtwEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::CSwitchEtwEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::perfetto::protos::ReadyThreadEtwEvent*
Arena::CreateMaybeMessage< ::perfetto::protos::ReadyThreadEtwEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::perfetto::protos::ReadyThreadEtwEvent >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
