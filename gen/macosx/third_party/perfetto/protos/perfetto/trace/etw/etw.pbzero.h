// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ETW_ETW_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ETW_ETW_PROTO_H_

#include <stddef.h>
#include <stdint.h>

#include "perfetto/protozero/field_writer.h"
#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {
namespace perfetto_pbzero_enum_CSwitchEtwEvent {
enum OldThreadState : int32_t;
}  // namespace perfetto_pbzero_enum_CSwitchEtwEvent
using CSwitchEtwEvent_OldThreadState = perfetto_pbzero_enum_CSwitchEtwEvent::OldThreadState;
namespace perfetto_pbzero_enum_CSwitchEtwEvent {
enum OldThreadWaitMode : int32_t;
}  // namespace perfetto_pbzero_enum_CSwitchEtwEvent
using CSwitchEtwEvent_OldThreadWaitMode = perfetto_pbzero_enum_CSwitchEtwEvent::OldThreadWaitMode;
namespace perfetto_pbzero_enum_CSwitchEtwEvent {
enum OldThreadWaitReason : int32_t;
}  // namespace perfetto_pbzero_enum_CSwitchEtwEvent
using CSwitchEtwEvent_OldThreadWaitReason = perfetto_pbzero_enum_CSwitchEtwEvent::OldThreadWaitReason;
namespace perfetto_pbzero_enum_ReadyThreadEtwEvent {
enum AdjustReason : int32_t;
}  // namespace perfetto_pbzero_enum_ReadyThreadEtwEvent
using ReadyThreadEtwEvent_AdjustReason = perfetto_pbzero_enum_ReadyThreadEtwEvent::AdjustReason;
namespace perfetto_pbzero_enum_ReadyThreadEtwEvent {
enum TraceFlag : int32_t;
}  // namespace perfetto_pbzero_enum_ReadyThreadEtwEvent
using ReadyThreadEtwEvent_TraceFlag = perfetto_pbzero_enum_ReadyThreadEtwEvent::TraceFlag;
} // Namespace pbzero.
} // Namespace protos.
} // Namespace perfetto.

namespace perfetto {
namespace protos {
namespace pbzero {

namespace perfetto_pbzero_enum_ReadyThreadEtwEvent {
enum AdjustReason : int32_t {
  IGNORE_THE_INCREMENT = 0,
  APPLY_INCREMENT = 1,
  APPLY_INCREMENT_BOOST = 2,
};
} // namespace perfetto_pbzero_enum_ReadyThreadEtwEvent
using ReadyThreadEtwEvent_AdjustReason = perfetto_pbzero_enum_ReadyThreadEtwEvent::AdjustReason;


constexpr ReadyThreadEtwEvent_AdjustReason ReadyThreadEtwEvent_AdjustReason_MIN = ReadyThreadEtwEvent_AdjustReason::IGNORE_THE_INCREMENT;
constexpr ReadyThreadEtwEvent_AdjustReason ReadyThreadEtwEvent_AdjustReason_MAX = ReadyThreadEtwEvent_AdjustReason::APPLY_INCREMENT_BOOST;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* ReadyThreadEtwEvent_AdjustReason_Name(::perfetto::protos::pbzero::ReadyThreadEtwEvent_AdjustReason value) {
  switch (value) {
  case ::perfetto::protos::pbzero::ReadyThreadEtwEvent_AdjustReason::IGNORE_THE_INCREMENT:
    return "IGNORE_THE_INCREMENT";

  case ::perfetto::protos::pbzero::ReadyThreadEtwEvent_AdjustReason::APPLY_INCREMENT:
    return "APPLY_INCREMENT";

  case ::perfetto::protos::pbzero::ReadyThreadEtwEvent_AdjustReason::APPLY_INCREMENT_BOOST:
    return "APPLY_INCREMENT_BOOST";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_ReadyThreadEtwEvent {
enum TraceFlag : int32_t {
  TRACE_FLAG_UNSPECIFIED = 0,
  THREAD_READIED = 1,
  KERNEL_STACK_SWAPPED_OUT = 2,
  PROCESS_ADDRESS_SWAPPED_OUT = 4,
};
} // namespace perfetto_pbzero_enum_ReadyThreadEtwEvent
using ReadyThreadEtwEvent_TraceFlag = perfetto_pbzero_enum_ReadyThreadEtwEvent::TraceFlag;


constexpr ReadyThreadEtwEvent_TraceFlag ReadyThreadEtwEvent_TraceFlag_MIN = ReadyThreadEtwEvent_TraceFlag::TRACE_FLAG_UNSPECIFIED;
constexpr ReadyThreadEtwEvent_TraceFlag ReadyThreadEtwEvent_TraceFlag_MAX = ReadyThreadEtwEvent_TraceFlag::PROCESS_ADDRESS_SWAPPED_OUT;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* ReadyThreadEtwEvent_TraceFlag_Name(::perfetto::protos::pbzero::ReadyThreadEtwEvent_TraceFlag value) {
  switch (value) {
  case ::perfetto::protos::pbzero::ReadyThreadEtwEvent_TraceFlag::TRACE_FLAG_UNSPECIFIED:
    return "TRACE_FLAG_UNSPECIFIED";

  case ::perfetto::protos::pbzero::ReadyThreadEtwEvent_TraceFlag::THREAD_READIED:
    return "THREAD_READIED";

  case ::perfetto::protos::pbzero::ReadyThreadEtwEvent_TraceFlag::KERNEL_STACK_SWAPPED_OUT:
    return "KERNEL_STACK_SWAPPED_OUT";

  case ::perfetto::protos::pbzero::ReadyThreadEtwEvent_TraceFlag::PROCESS_ADDRESS_SWAPPED_OUT:
    return "PROCESS_ADDRESS_SWAPPED_OUT";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_CSwitchEtwEvent {
enum OldThreadWaitReason : int32_t {
  EXECUTIVE = 0,
  FREE_PAGE = 1,
  PAGE_IN = 2,
  POOL_ALLOCATION = 3,
  DELAY_EXECUTION = 4,
  SUSPEND = 5,
  USER_REQUEST = 6,
  WR_EXECUTIVE = 7,
  WR_FREE_PAGE = 8,
  WR_PAGE_IN = 9,
  WR_POOL_ALLOCATION = 10,
  WR_DELAY_EXECUTION = 11,
  WR_SUSPENDED = 12,
  WR_USER_REQUEST = 13,
  WR_EVENT_PAIR = 14,
  WR_QUEUE = 15,
  WR_LPC_RECEIVER = 16,
  WR_LPC_REPLY = 17,
  WR_VIRTUAL_MEMORY = 18,
  WR_PAGE_OUT = 19,
  WR_RENDEZ_VOUS = 20,
  WR_KEYED_EVENT = 21,
  WR_TERMINATED = 22,
  WR_PROCESS_IN_SWAP = 23,
  WR_CPU_RATE_CONTROL = 24,
  WR_CALLOUT_STACK = 25,
  WR_KERNEL = 26,
  WR_RESOURCE = 27,
  WR_PUSH_LOCK = 28,
  WR_MUTEX = 29,
  WR_QUANTUM_END = 30,
  WR_DISPATCH_INT = 31,
  WR_PREEMPTED = 32,
  WR_YIELD_EXECUTION = 33,
  WR_FAST_MUTEX = 34,
  WR_GUARD_MUTEX = 35,
  WR_RUNDOWN = 36,
  MAXIMUM_WAIT_REASON = 37,
};
} // namespace perfetto_pbzero_enum_CSwitchEtwEvent
using CSwitchEtwEvent_OldThreadWaitReason = perfetto_pbzero_enum_CSwitchEtwEvent::OldThreadWaitReason;


constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent_OldThreadWaitReason_MIN = CSwitchEtwEvent_OldThreadWaitReason::EXECUTIVE;
constexpr CSwitchEtwEvent_OldThreadWaitReason CSwitchEtwEvent_OldThreadWaitReason_MAX = CSwitchEtwEvent_OldThreadWaitReason::MAXIMUM_WAIT_REASON;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* CSwitchEtwEvent_OldThreadWaitReason_Name(::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason value) {
  switch (value) {
  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::EXECUTIVE:
    return "EXECUTIVE";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::FREE_PAGE:
    return "FREE_PAGE";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::PAGE_IN:
    return "PAGE_IN";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::POOL_ALLOCATION:
    return "POOL_ALLOCATION";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::DELAY_EXECUTION:
    return "DELAY_EXECUTION";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::SUSPEND:
    return "SUSPEND";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::USER_REQUEST:
    return "USER_REQUEST";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::WR_EXECUTIVE:
    return "WR_EXECUTIVE";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::WR_FREE_PAGE:
    return "WR_FREE_PAGE";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::WR_PAGE_IN:
    return "WR_PAGE_IN";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::WR_POOL_ALLOCATION:
    return "WR_POOL_ALLOCATION";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::WR_DELAY_EXECUTION:
    return "WR_DELAY_EXECUTION";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::WR_SUSPENDED:
    return "WR_SUSPENDED";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::WR_USER_REQUEST:
    return "WR_USER_REQUEST";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::WR_EVENT_PAIR:
    return "WR_EVENT_PAIR";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::WR_QUEUE:
    return "WR_QUEUE";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::WR_LPC_RECEIVER:
    return "WR_LPC_RECEIVER";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::WR_LPC_REPLY:
    return "WR_LPC_REPLY";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::WR_VIRTUAL_MEMORY:
    return "WR_VIRTUAL_MEMORY";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::WR_PAGE_OUT:
    return "WR_PAGE_OUT";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::WR_RENDEZ_VOUS:
    return "WR_RENDEZ_VOUS";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::WR_KEYED_EVENT:
    return "WR_KEYED_EVENT";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::WR_TERMINATED:
    return "WR_TERMINATED";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::WR_PROCESS_IN_SWAP:
    return "WR_PROCESS_IN_SWAP";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::WR_CPU_RATE_CONTROL:
    return "WR_CPU_RATE_CONTROL";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::WR_CALLOUT_STACK:
    return "WR_CALLOUT_STACK";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::WR_KERNEL:
    return "WR_KERNEL";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::WR_RESOURCE:
    return "WR_RESOURCE";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::WR_PUSH_LOCK:
    return "WR_PUSH_LOCK";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::WR_MUTEX:
    return "WR_MUTEX";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::WR_QUANTUM_END:
    return "WR_QUANTUM_END";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::WR_DISPATCH_INT:
    return "WR_DISPATCH_INT";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::WR_PREEMPTED:
    return "WR_PREEMPTED";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::WR_YIELD_EXECUTION:
    return "WR_YIELD_EXECUTION";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::WR_FAST_MUTEX:
    return "WR_FAST_MUTEX";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::WR_GUARD_MUTEX:
    return "WR_GUARD_MUTEX";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::WR_RUNDOWN:
    return "WR_RUNDOWN";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason::MAXIMUM_WAIT_REASON:
    return "MAXIMUM_WAIT_REASON";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_CSwitchEtwEvent {
enum OldThreadWaitMode : int32_t {
  KERNEL_MODE = 0,
  USER_MODE = 1,
};
} // namespace perfetto_pbzero_enum_CSwitchEtwEvent
using CSwitchEtwEvent_OldThreadWaitMode = perfetto_pbzero_enum_CSwitchEtwEvent::OldThreadWaitMode;


constexpr CSwitchEtwEvent_OldThreadWaitMode CSwitchEtwEvent_OldThreadWaitMode_MIN = CSwitchEtwEvent_OldThreadWaitMode::KERNEL_MODE;
constexpr CSwitchEtwEvent_OldThreadWaitMode CSwitchEtwEvent_OldThreadWaitMode_MAX = CSwitchEtwEvent_OldThreadWaitMode::USER_MODE;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* CSwitchEtwEvent_OldThreadWaitMode_Name(::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitMode value) {
  switch (value) {
  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitMode::KERNEL_MODE:
    return "KERNEL_MODE";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitMode::USER_MODE:
    return "USER_MODE";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_CSwitchEtwEvent {
enum OldThreadState : int32_t {
  INITIALIZED = 0,
  READY = 1,
  RUNNING = 2,
  STANDBY = 3,
  TERMINATED = 4,
  WAITING = 5,
  TRANSITION = 6,
  DEFERRED_READY = 7,
};
} // namespace perfetto_pbzero_enum_CSwitchEtwEvent
using CSwitchEtwEvent_OldThreadState = perfetto_pbzero_enum_CSwitchEtwEvent::OldThreadState;


constexpr CSwitchEtwEvent_OldThreadState CSwitchEtwEvent_OldThreadState_MIN = CSwitchEtwEvent_OldThreadState::INITIALIZED;
constexpr CSwitchEtwEvent_OldThreadState CSwitchEtwEvent_OldThreadState_MAX = CSwitchEtwEvent_OldThreadState::DEFERRED_READY;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* CSwitchEtwEvent_OldThreadState_Name(::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadState value) {
  switch (value) {
  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadState::INITIALIZED:
    return "INITIALIZED";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadState::READY:
    return "READY";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadState::RUNNING:
    return "RUNNING";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadState::STANDBY:
    return "STANDBY";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadState::TERMINATED:
    return "TERMINATED";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadState::WAITING:
    return "WAITING";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadState::TRANSITION:
    return "TRANSITION";

  case ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadState::DEFERRED_READY:
    return "DEFERRED_READY";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

class ReadyThreadEtwEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ReadyThreadEtwEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ReadyThreadEtwEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ReadyThreadEtwEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_t_thread_id() const { return at<1>().valid(); }
  uint32_t t_thread_id() const { return at<1>().as_uint32(); }
  bool has_adjust_reason() const { return at<2>().valid(); }
  int32_t adjust_reason() const { return at<2>().as_int32(); }
  bool has_adjust_increment() const { return at<3>().valid(); }
  int32_t adjust_increment() const { return at<3>().as_sint32(); }
  bool has_flag() const { return at<4>().valid(); }
  int32_t flag() const { return at<4>().as_int32(); }
};

class ReadyThreadEtwEvent : public ::protozero::Message {
 public:
  using Decoder = ReadyThreadEtwEvent_Decoder;
  enum : int32_t {
    kTThreadIdFieldNumber = 1,
    kAdjustReasonFieldNumber = 2,
    kAdjustIncrementFieldNumber = 3,
    kFlagFieldNumber = 4,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ReadyThreadEtwEvent"; }


  using AdjustReason = ::perfetto::protos::pbzero::ReadyThreadEtwEvent_AdjustReason;
  static inline const char* AdjustReason_Name(AdjustReason value) {
    return ::perfetto::protos::pbzero::ReadyThreadEtwEvent_AdjustReason_Name(value);
  }

  using TraceFlag = ::perfetto::protos::pbzero::ReadyThreadEtwEvent_TraceFlag;
  static inline const char* TraceFlag_Name(TraceFlag value) {
    return ::perfetto::protos::pbzero::ReadyThreadEtwEvent_TraceFlag_Name(value);
  }
  static inline const AdjustReason IGNORE_THE_INCREMENT = AdjustReason::IGNORE_THE_INCREMENT;
  static inline const AdjustReason APPLY_INCREMENT = AdjustReason::APPLY_INCREMENT;
  static inline const AdjustReason APPLY_INCREMENT_BOOST = AdjustReason::APPLY_INCREMENT_BOOST;
  static inline const TraceFlag TRACE_FLAG_UNSPECIFIED = TraceFlag::TRACE_FLAG_UNSPECIFIED;
  static inline const TraceFlag THREAD_READIED = TraceFlag::THREAD_READIED;
  static inline const TraceFlag KERNEL_STACK_SWAPPED_OUT = TraceFlag::KERNEL_STACK_SWAPPED_OUT;
  static inline const TraceFlag PROCESS_ADDRESS_SWAPPED_OUT = TraceFlag::PROCESS_ADDRESS_SWAPPED_OUT;

  using FieldMetadata_TThreadId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      ReadyThreadEtwEvent>;

  static constexpr FieldMetadata_TThreadId kTThreadId{};
  void set_t_thread_id(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_TThreadId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_AdjustReason =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ReadyThreadEtwEvent_AdjustReason,
      ReadyThreadEtwEvent>;

  static constexpr FieldMetadata_AdjustReason kAdjustReason{};
  void set_adjust_reason(ReadyThreadEtwEvent_AdjustReason value) {
    static constexpr uint32_t field_id = FieldMetadata_AdjustReason::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_AdjustIncrement =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kSint32,
      int32_t,
      ReadyThreadEtwEvent>;

  static constexpr FieldMetadata_AdjustIncrement kAdjustIncrement{};
  void set_adjust_increment(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_AdjustIncrement::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kSint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Flag =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ReadyThreadEtwEvent_TraceFlag,
      ReadyThreadEtwEvent>;

  static constexpr FieldMetadata_Flag kFlag{};
  void set_flag(ReadyThreadEtwEvent_TraceFlag value) {
    static constexpr uint32_t field_id = FieldMetadata_Flag::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }
};

class CSwitchEtwEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  CSwitchEtwEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit CSwitchEtwEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit CSwitchEtwEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_new_thread_id() const { return at<1>().valid(); }
  uint32_t new_thread_id() const { return at<1>().as_uint32(); }
  bool has_old_thread_id() const { return at<2>().valid(); }
  uint32_t old_thread_id() const { return at<2>().as_uint32(); }
  bool has_new_thread_priority() const { return at<3>().valid(); }
  int32_t new_thread_priority() const { return at<3>().as_sint32(); }
  bool has_old_thread_priority() const { return at<4>().valid(); }
  int32_t old_thread_priority() const { return at<4>().as_sint32(); }
  bool has_previous_c_state() const { return at<5>().valid(); }
  uint32_t previous_c_state() const { return at<5>().as_uint32(); }
  bool has_old_thread_wait_reason() const { return at<6>().valid(); }
  int32_t old_thread_wait_reason() const { return at<6>().as_int32(); }
  bool has_old_thread_wait_mode() const { return at<7>().valid(); }
  int32_t old_thread_wait_mode() const { return at<7>().as_int32(); }
  bool has_old_thread_state() const { return at<8>().valid(); }
  int32_t old_thread_state() const { return at<8>().as_int32(); }
  bool has_old_thread_wait_ideal_processor() const { return at<9>().valid(); }
  int32_t old_thread_wait_ideal_processor() const { return at<9>().as_sint32(); }
  bool has_new_thread_wait_time() const { return at<10>().valid(); }
  uint32_t new_thread_wait_time() const { return at<10>().as_uint32(); }
};

class CSwitchEtwEvent : public ::protozero::Message {
 public:
  using Decoder = CSwitchEtwEvent_Decoder;
  enum : int32_t {
    kNewThreadIdFieldNumber = 1,
    kOldThreadIdFieldNumber = 2,
    kNewThreadPriorityFieldNumber = 3,
    kOldThreadPriorityFieldNumber = 4,
    kPreviousCStateFieldNumber = 5,
    kOldThreadWaitReasonFieldNumber = 6,
    kOldThreadWaitModeFieldNumber = 7,
    kOldThreadStateFieldNumber = 8,
    kOldThreadWaitIdealProcessorFieldNumber = 9,
    kNewThreadWaitTimeFieldNumber = 10,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.CSwitchEtwEvent"; }


  using OldThreadWaitReason = ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason;
  static inline const char* OldThreadWaitReason_Name(OldThreadWaitReason value) {
    return ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitReason_Name(value);
  }

  using OldThreadWaitMode = ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitMode;
  static inline const char* OldThreadWaitMode_Name(OldThreadWaitMode value) {
    return ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadWaitMode_Name(value);
  }

  using OldThreadState = ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadState;
  static inline const char* OldThreadState_Name(OldThreadState value) {
    return ::perfetto::protos::pbzero::CSwitchEtwEvent_OldThreadState_Name(value);
  }
  static inline const OldThreadWaitReason EXECUTIVE = OldThreadWaitReason::EXECUTIVE;
  static inline const OldThreadWaitReason FREE_PAGE = OldThreadWaitReason::FREE_PAGE;
  static inline const OldThreadWaitReason PAGE_IN = OldThreadWaitReason::PAGE_IN;
  static inline const OldThreadWaitReason POOL_ALLOCATION = OldThreadWaitReason::POOL_ALLOCATION;
  static inline const OldThreadWaitReason DELAY_EXECUTION = OldThreadWaitReason::DELAY_EXECUTION;
  static inline const OldThreadWaitReason SUSPEND = OldThreadWaitReason::SUSPEND;
  static inline const OldThreadWaitReason USER_REQUEST = OldThreadWaitReason::USER_REQUEST;
  static inline const OldThreadWaitReason WR_EXECUTIVE = OldThreadWaitReason::WR_EXECUTIVE;
  static inline const OldThreadWaitReason WR_FREE_PAGE = OldThreadWaitReason::WR_FREE_PAGE;
  static inline const OldThreadWaitReason WR_PAGE_IN = OldThreadWaitReason::WR_PAGE_IN;
  static inline const OldThreadWaitReason WR_POOL_ALLOCATION = OldThreadWaitReason::WR_POOL_ALLOCATION;
  static inline const OldThreadWaitReason WR_DELAY_EXECUTION = OldThreadWaitReason::WR_DELAY_EXECUTION;
  static inline const OldThreadWaitReason WR_SUSPENDED = OldThreadWaitReason::WR_SUSPENDED;
  static inline const OldThreadWaitReason WR_USER_REQUEST = OldThreadWaitReason::WR_USER_REQUEST;
  static inline const OldThreadWaitReason WR_EVENT_PAIR = OldThreadWaitReason::WR_EVENT_PAIR;
  static inline const OldThreadWaitReason WR_QUEUE = OldThreadWaitReason::WR_QUEUE;
  static inline const OldThreadWaitReason WR_LPC_RECEIVER = OldThreadWaitReason::WR_LPC_RECEIVER;
  static inline const OldThreadWaitReason WR_LPC_REPLY = OldThreadWaitReason::WR_LPC_REPLY;
  static inline const OldThreadWaitReason WR_VIRTUAL_MEMORY = OldThreadWaitReason::WR_VIRTUAL_MEMORY;
  static inline const OldThreadWaitReason WR_PAGE_OUT = OldThreadWaitReason::WR_PAGE_OUT;
  static inline const OldThreadWaitReason WR_RENDEZ_VOUS = OldThreadWaitReason::WR_RENDEZ_VOUS;
  static inline const OldThreadWaitReason WR_KEYED_EVENT = OldThreadWaitReason::WR_KEYED_EVENT;
  static inline const OldThreadWaitReason WR_TERMINATED = OldThreadWaitReason::WR_TERMINATED;
  static inline const OldThreadWaitReason WR_PROCESS_IN_SWAP = OldThreadWaitReason::WR_PROCESS_IN_SWAP;
  static inline const OldThreadWaitReason WR_CPU_RATE_CONTROL = OldThreadWaitReason::WR_CPU_RATE_CONTROL;
  static inline const OldThreadWaitReason WR_CALLOUT_STACK = OldThreadWaitReason::WR_CALLOUT_STACK;
  static inline const OldThreadWaitReason WR_KERNEL = OldThreadWaitReason::WR_KERNEL;
  static inline const OldThreadWaitReason WR_RESOURCE = OldThreadWaitReason::WR_RESOURCE;
  static inline const OldThreadWaitReason WR_PUSH_LOCK = OldThreadWaitReason::WR_PUSH_LOCK;
  static inline const OldThreadWaitReason WR_MUTEX = OldThreadWaitReason::WR_MUTEX;
  static inline const OldThreadWaitReason WR_QUANTUM_END = OldThreadWaitReason::WR_QUANTUM_END;
  static inline const OldThreadWaitReason WR_DISPATCH_INT = OldThreadWaitReason::WR_DISPATCH_INT;
  static inline const OldThreadWaitReason WR_PREEMPTED = OldThreadWaitReason::WR_PREEMPTED;
  static inline const OldThreadWaitReason WR_YIELD_EXECUTION = OldThreadWaitReason::WR_YIELD_EXECUTION;
  static inline const OldThreadWaitReason WR_FAST_MUTEX = OldThreadWaitReason::WR_FAST_MUTEX;
  static inline const OldThreadWaitReason WR_GUARD_MUTEX = OldThreadWaitReason::WR_GUARD_MUTEX;
  static inline const OldThreadWaitReason WR_RUNDOWN = OldThreadWaitReason::WR_RUNDOWN;
  static inline const OldThreadWaitReason MAXIMUM_WAIT_REASON = OldThreadWaitReason::MAXIMUM_WAIT_REASON;
  static inline const OldThreadWaitMode KERNEL_MODE = OldThreadWaitMode::KERNEL_MODE;
  static inline const OldThreadWaitMode USER_MODE = OldThreadWaitMode::USER_MODE;
  static inline const OldThreadState INITIALIZED = OldThreadState::INITIALIZED;
  static inline const OldThreadState READY = OldThreadState::READY;
  static inline const OldThreadState RUNNING = OldThreadState::RUNNING;
  static inline const OldThreadState STANDBY = OldThreadState::STANDBY;
  static inline const OldThreadState TERMINATED = OldThreadState::TERMINATED;
  static inline const OldThreadState WAITING = OldThreadState::WAITING;
  static inline const OldThreadState TRANSITION = OldThreadState::TRANSITION;
  static inline const OldThreadState DEFERRED_READY = OldThreadState::DEFERRED_READY;

  using FieldMetadata_NewThreadId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      CSwitchEtwEvent>;

  static constexpr FieldMetadata_NewThreadId kNewThreadId{};
  void set_new_thread_id(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_NewThreadId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_OldThreadId =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      CSwitchEtwEvent>;

  static constexpr FieldMetadata_OldThreadId kOldThreadId{};
  void set_old_thread_id(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_OldThreadId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_NewThreadPriority =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kSint32,
      int32_t,
      CSwitchEtwEvent>;

  static constexpr FieldMetadata_NewThreadPriority kNewThreadPriority{};
  void set_new_thread_priority(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_NewThreadPriority::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kSint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_OldThreadPriority =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kSint32,
      int32_t,
      CSwitchEtwEvent>;

  static constexpr FieldMetadata_OldThreadPriority kOldThreadPriority{};
  void set_old_thread_priority(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_OldThreadPriority::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kSint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_PreviousCState =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      CSwitchEtwEvent>;

  static constexpr FieldMetadata_PreviousCState kPreviousCState{};
  void set_previous_c_state(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_PreviousCState::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_OldThreadWaitReason =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      CSwitchEtwEvent_OldThreadWaitReason,
      CSwitchEtwEvent>;

  static constexpr FieldMetadata_OldThreadWaitReason kOldThreadWaitReason{};
  void set_old_thread_wait_reason(CSwitchEtwEvent_OldThreadWaitReason value) {
    static constexpr uint32_t field_id = FieldMetadata_OldThreadWaitReason::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_OldThreadWaitMode =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      CSwitchEtwEvent_OldThreadWaitMode,
      CSwitchEtwEvent>;

  static constexpr FieldMetadata_OldThreadWaitMode kOldThreadWaitMode{};
  void set_old_thread_wait_mode(CSwitchEtwEvent_OldThreadWaitMode value) {
    static constexpr uint32_t field_id = FieldMetadata_OldThreadWaitMode::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_OldThreadState =
    ::protozero::proto_utils::FieldMetadata<
      8,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      CSwitchEtwEvent_OldThreadState,
      CSwitchEtwEvent>;

  static constexpr FieldMetadata_OldThreadState kOldThreadState{};
  void set_old_thread_state(CSwitchEtwEvent_OldThreadState value) {
    static constexpr uint32_t field_id = FieldMetadata_OldThreadState::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_OldThreadWaitIdealProcessor =
    ::protozero::proto_utils::FieldMetadata<
      9,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kSint32,
      int32_t,
      CSwitchEtwEvent>;

  static constexpr FieldMetadata_OldThreadWaitIdealProcessor kOldThreadWaitIdealProcessor{};
  void set_old_thread_wait_ideal_processor(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_OldThreadWaitIdealProcessor::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kSint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_NewThreadWaitTime =
    ::protozero::proto_utils::FieldMetadata<
      10,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      CSwitchEtwEvent>;

  static constexpr FieldMetadata_NewThreadWaitTime kNewThreadWaitTime{};
  void set_new_thread_wait_time(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_NewThreadWaitTime::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
