// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_CHROME_V8_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_CHROME_V8_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class V8CodeDefaults;
class V8CodeMove;
class V8RegExpCode;
class V8String;
class V8WasmCode;
class V8InternalCode;
class V8JsCode;
class InternedV8Isolate;
class InternedV8Isolate_CodeRange;
class InternedV8JsFunction;
class InternedV8WasmScript;
class InternedV8JsScript;
class InternedV8String;
enum V8WasmCode_Tier : int;
enum V8InternalCode_Type : int;
enum V8JsCode_Tier : int;
enum InternedV8JsFunction_Kind : int;
enum InternedV8JsScript_Type : int;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {
enum V8WasmCode_Tier : int {
  V8WasmCode_Tier_TIER_UNKNOWN = 0,
  V8WasmCode_Tier_TIER_LIFTOFF = 1,
  V8WasmCode_Tier_TIER_TURBOFAN = 2,
};
enum V8InternalCode_Type : int {
  V8InternalCode_Type_TYPE_UNKNOWN = 0,
  V8InternalCode_Type_TYPE_BYTECODE_HANDLER = 1,
  V8InternalCode_Type_TYPE_FOR_TESTING = 2,
  V8InternalCode_Type_TYPE_BUILTIN = 3,
  V8InternalCode_Type_TYPE_WASM_FUNCTION = 4,
  V8InternalCode_Type_TYPE_WASM_TO_CAPI_FUNCTION = 5,
  V8InternalCode_Type_TYPE_WASM_TO_JS_FUNCTION = 6,
  V8InternalCode_Type_TYPE_JS_TO_WASM_FUNCTION = 7,
  V8InternalCode_Type_TYPE_JS_TO_JS_FUNCTION = 8,
  V8InternalCode_Type_TYPE_C_WASM_ENTRY = 9,
};
enum V8JsCode_Tier : int {
  V8JsCode_Tier_TIER_UNKNOWN = 0,
  V8JsCode_Tier_TIER_IGNITION = 1,
  V8JsCode_Tier_TIER_SPARKPLUG = 2,
  V8JsCode_Tier_TIER_MAGLEV = 3,
  V8JsCode_Tier_TIER_TURBOSHAFT = 4,
  V8JsCode_Tier_TIER_TURBOFAN = 5,
};
enum InternedV8JsFunction_Kind : int {
  InternedV8JsFunction_Kind_KIND_UNKNOWN = 0,
  InternedV8JsFunction_Kind_KIND_NORMAL_FUNCTION = 1,
  InternedV8JsFunction_Kind_KIND_MODULE = 2,
  InternedV8JsFunction_Kind_KIND_ASYNC_MODULE = 3,
  InternedV8JsFunction_Kind_KIND_BASE_CONSTRUCTOR = 4,
  InternedV8JsFunction_Kind_KIND_DEFAULT_BASE_CONSTRUCTOR = 5,
  InternedV8JsFunction_Kind_KIND_DEFAULT_DERIVED_CONSTRUCTOR = 6,
  InternedV8JsFunction_Kind_KIND_DERIVED_CONSTRUCTOR = 7,
  InternedV8JsFunction_Kind_KIND_GETTER_FUNCTION = 8,
  InternedV8JsFunction_Kind_KIND_STATIC_GETTER_FUNCTION = 9,
  InternedV8JsFunction_Kind_KIND_SETTER_FUNCTION = 10,
  InternedV8JsFunction_Kind_KIND_STATIC_SETTER_FUNCTION = 11,
  InternedV8JsFunction_Kind_KIND_ARROW_FUNCTION = 12,
  InternedV8JsFunction_Kind_KIND_ASYNC_ARROW_FUNCTION = 13,
  InternedV8JsFunction_Kind_KIND_ASYNC_FUNCTION = 14,
  InternedV8JsFunction_Kind_KIND_ASYNC_CONCISE_METHOD = 15,
  InternedV8JsFunction_Kind_KIND_STATIC_ASYNC_CONCISE_METHOD = 16,
  InternedV8JsFunction_Kind_KIND_ASYNC_CONCISE_GENERATOR_METHOD = 17,
  InternedV8JsFunction_Kind_KIND_STATIC_ASYNC_CONCISE_GENERATOR_METHOD = 18,
  InternedV8JsFunction_Kind_KIND_ASYNC_GENERATOR_FUNCTION = 19,
  InternedV8JsFunction_Kind_KIND_GENERATOR_FUNCTION = 20,
  InternedV8JsFunction_Kind_KIND_CONCISE_GENERATOR_METHOD = 21,
  InternedV8JsFunction_Kind_KIND_STATIC_CONCISE_GENERATOR_METHOD = 22,
  InternedV8JsFunction_Kind_KIND_CONCISE_METHOD = 23,
  InternedV8JsFunction_Kind_KIND_STATIC_CONCISE_METHOD = 24,
  InternedV8JsFunction_Kind_KIND_CLASS_MEMBERS_INITIALIZER_FUNCTION = 25,
  InternedV8JsFunction_Kind_KIND_CLASS_STATIC_INITIALIZER_FUNCTION = 26,
  InternedV8JsFunction_Kind_KIND_INVALID = 27,
};
enum InternedV8JsScript_Type : int {
  InternedV8JsScript_Type_TYPE_UNKNOWN = 0,
  InternedV8JsScript_Type_TYPE_NORMAL = 1,
  InternedV8JsScript_Type_TYPE_EVAL = 2,
  InternedV8JsScript_Type_TYPE_MODULE = 3,
  InternedV8JsScript_Type_TYPE_NATIVE = 4,
  InternedV8JsScript_Type_TYPE_EXTENSION = 5,
  InternedV8JsScript_Type_TYPE_INSPECTOR = 6,
};

class PERFETTO_EXPORT_COMPONENT V8CodeDefaults : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kTidFieldNumber = 1,
  };

  V8CodeDefaults();
  ~V8CodeDefaults() override;
  V8CodeDefaults(V8CodeDefaults&&) noexcept;
  V8CodeDefaults& operator=(V8CodeDefaults&&);
  V8CodeDefaults(const V8CodeDefaults&);
  V8CodeDefaults& operator=(const V8CodeDefaults&);
  bool operator==(const V8CodeDefaults&) const;
  bool operator!=(const V8CodeDefaults& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_tid() const { return _has_field_[1]; }
  uint32_t tid() const { return tid_; }
  void set_tid(uint32_t value) { tid_ = value; _has_field_.set(1); }

 private:
  uint32_t tid_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT V8CodeMove : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kIsolateIidFieldNumber = 1,
    kTidFieldNumber = 2,
    kFromInstructionStartAddressFieldNumber = 3,
    kToInstructionStartAddressFieldNumber = 4,
    kInstructionSizeBytesFieldNumber = 5,
    kToMachineCodeFieldNumber = 6,
    kToBytecodeFieldNumber = 7,
  };

  V8CodeMove();
  ~V8CodeMove() override;
  V8CodeMove(V8CodeMove&&) noexcept;
  V8CodeMove& operator=(V8CodeMove&&);
  V8CodeMove(const V8CodeMove&);
  V8CodeMove& operator=(const V8CodeMove&);
  bool operator==(const V8CodeMove&) const;
  bool operator!=(const V8CodeMove& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_isolate_iid() const { return _has_field_[1]; }
  uint64_t isolate_iid() const { return isolate_iid_; }
  void set_isolate_iid(uint64_t value) { isolate_iid_ = value; _has_field_.set(1); }

  bool has_tid() const { return _has_field_[2]; }
  uint32_t tid() const { return tid_; }
  void set_tid(uint32_t value) { tid_ = value; _has_field_.set(2); }

  bool has_from_instruction_start_address() const { return _has_field_[3]; }
  uint64_t from_instruction_start_address() const { return from_instruction_start_address_; }
  void set_from_instruction_start_address(uint64_t value) { from_instruction_start_address_ = value; _has_field_.set(3); }

  bool has_to_instruction_start_address() const { return _has_field_[4]; }
  uint64_t to_instruction_start_address() const { return to_instruction_start_address_; }
  void set_to_instruction_start_address(uint64_t value) { to_instruction_start_address_ = value; _has_field_.set(4); }

  bool has_instruction_size_bytes() const { return _has_field_[5]; }
  uint64_t instruction_size_bytes() const { return instruction_size_bytes_; }
  void set_instruction_size_bytes(uint64_t value) { instruction_size_bytes_ = value; _has_field_.set(5); }

  bool has_to_machine_code() const { return _has_field_[6]; }
  const std::string& to_machine_code() const { return to_machine_code_; }
  void set_to_machine_code(const std::string& value) { to_machine_code_ = value; _has_field_.set(6); }
  void set_to_machine_code(const void* p, size_t s) { to_machine_code_.assign(reinterpret_cast<const char*>(p), s); _has_field_.set(6); }

  bool has_to_bytecode() const { return _has_field_[7]; }
  const std::string& to_bytecode() const { return to_bytecode_; }
  void set_to_bytecode(const std::string& value) { to_bytecode_ = value; _has_field_.set(7); }
  void set_to_bytecode(const void* p, size_t s) { to_bytecode_.assign(reinterpret_cast<const char*>(p), s); _has_field_.set(7); }

 private:
  uint64_t isolate_iid_{};
  uint32_t tid_{};
  uint64_t from_instruction_start_address_{};
  uint64_t to_instruction_start_address_{};
  uint64_t instruction_size_bytes_{};
  std::string to_machine_code_{};
  std::string to_bytecode_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<8> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT V8RegExpCode : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kV8IsolateIidFieldNumber = 1,
    kTidFieldNumber = 2,
    kPatternFieldNumber = 3,
    kInstructionStartFieldNumber = 4,
    kInstructionSizeBytesFieldNumber = 5,
    kMachineCodeFieldNumber = 6,
  };

  V8RegExpCode();
  ~V8RegExpCode() override;
  V8RegExpCode(V8RegExpCode&&) noexcept;
  V8RegExpCode& operator=(V8RegExpCode&&);
  V8RegExpCode(const V8RegExpCode&);
  V8RegExpCode& operator=(const V8RegExpCode&);
  bool operator==(const V8RegExpCode&) const;
  bool operator!=(const V8RegExpCode& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_v8_isolate_iid() const { return _has_field_[1]; }
  uint64_t v8_isolate_iid() const { return v8_isolate_iid_; }
  void set_v8_isolate_iid(uint64_t value) { v8_isolate_iid_ = value; _has_field_.set(1); }

  bool has_tid() const { return _has_field_[2]; }
  uint32_t tid() const { return tid_; }
  void set_tid(uint32_t value) { tid_ = value; _has_field_.set(2); }

  bool has_pattern() const { return _has_field_[3]; }
  const V8String& pattern() const { return *pattern_; }
  V8String* mutable_pattern() { _has_field_.set(3); return pattern_.get(); }

  bool has_instruction_start() const { return _has_field_[4]; }
  uint64_t instruction_start() const { return instruction_start_; }
  void set_instruction_start(uint64_t value) { instruction_start_ = value; _has_field_.set(4); }

  bool has_instruction_size_bytes() const { return _has_field_[5]; }
  uint64_t instruction_size_bytes() const { return instruction_size_bytes_; }
  void set_instruction_size_bytes(uint64_t value) { instruction_size_bytes_ = value; _has_field_.set(5); }

  bool has_machine_code() const { return _has_field_[6]; }
  const std::string& machine_code() const { return machine_code_; }
  void set_machine_code(const std::string& value) { machine_code_ = value; _has_field_.set(6); }
  void set_machine_code(const void* p, size_t s) { machine_code_.assign(reinterpret_cast<const char*>(p), s); _has_field_.set(6); }

 private:
  uint64_t v8_isolate_iid_{};
  uint32_t tid_{};
  ::protozero::CopyablePtr<V8String> pattern_;
  uint64_t instruction_start_{};
  uint64_t instruction_size_bytes_{};
  std::string machine_code_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<7> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT V8String : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kLatin1FieldNumber = 1,
    kUtf16LeFieldNumber = 2,
    kUtf16BeFieldNumber = 3,
  };

  V8String();
  ~V8String() override;
  V8String(V8String&&) noexcept;
  V8String& operator=(V8String&&);
  V8String(const V8String&);
  V8String& operator=(const V8String&);
  bool operator==(const V8String&) const;
  bool operator!=(const V8String& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_latin1() const { return _has_field_[1]; }
  const std::string& latin1() const { return latin1_; }
  void set_latin1(const std::string& value) { latin1_ = value; _has_field_.set(1); }
  void set_latin1(const void* p, size_t s) { latin1_.assign(reinterpret_cast<const char*>(p), s); _has_field_.set(1); }

  bool has_utf16_le() const { return _has_field_[2]; }
  const std::string& utf16_le() const { return utf16_le_; }
  void set_utf16_le(const std::string& value) { utf16_le_ = value; _has_field_.set(2); }
  void set_utf16_le(const void* p, size_t s) { utf16_le_.assign(reinterpret_cast<const char*>(p), s); _has_field_.set(2); }

  bool has_utf16_be() const { return _has_field_[3]; }
  const std::string& utf16_be() const { return utf16_be_; }
  void set_utf16_be(const std::string& value) { utf16_be_ = value; _has_field_.set(3); }
  void set_utf16_be(const void* p, size_t s) { utf16_be_.assign(reinterpret_cast<const char*>(p), s); _has_field_.set(3); }

 private:
  std::string latin1_{};
  std::string utf16_le_{};
  std::string utf16_be_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT V8WasmCode : public ::protozero::CppMessageObj {
 public:
  using Tier = V8WasmCode_Tier;
  static constexpr auto TIER_UNKNOWN = V8WasmCode_Tier_TIER_UNKNOWN;
  static constexpr auto TIER_LIFTOFF = V8WasmCode_Tier_TIER_LIFTOFF;
  static constexpr auto TIER_TURBOFAN = V8WasmCode_Tier_TIER_TURBOFAN;
  static constexpr auto Tier_MIN = V8WasmCode_Tier_TIER_UNKNOWN;
  static constexpr auto Tier_MAX = V8WasmCode_Tier_TIER_TURBOFAN;
  enum FieldNumbers {
    kV8IsolateIidFieldNumber = 1,
    kTidFieldNumber = 2,
    kV8WasmScriptIidFieldNumber = 3,
    kFunctionNameFieldNumber = 4,
    kTierFieldNumber = 5,
    kCodeOffsetInModuleFieldNumber = 6,
    kInstructionStartFieldNumber = 7,
    kInstructionSizeBytesFieldNumber = 8,
    kMachineCodeFieldNumber = 9,
  };

  V8WasmCode();
  ~V8WasmCode() override;
  V8WasmCode(V8WasmCode&&) noexcept;
  V8WasmCode& operator=(V8WasmCode&&);
  V8WasmCode(const V8WasmCode&);
  V8WasmCode& operator=(const V8WasmCode&);
  bool operator==(const V8WasmCode&) const;
  bool operator!=(const V8WasmCode& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_v8_isolate_iid() const { return _has_field_[1]; }
  uint64_t v8_isolate_iid() const { return v8_isolate_iid_; }
  void set_v8_isolate_iid(uint64_t value) { v8_isolate_iid_ = value; _has_field_.set(1); }

  bool has_tid() const { return _has_field_[2]; }
  uint32_t tid() const { return tid_; }
  void set_tid(uint32_t value) { tid_ = value; _has_field_.set(2); }

  bool has_v8_wasm_script_iid() const { return _has_field_[3]; }
  uint64_t v8_wasm_script_iid() const { return v8_wasm_script_iid_; }
  void set_v8_wasm_script_iid(uint64_t value) { v8_wasm_script_iid_ = value; _has_field_.set(3); }

  bool has_function_name() const { return _has_field_[4]; }
  const std::string& function_name() const { return function_name_; }
  void set_function_name(const std::string& value) { function_name_ = value; _has_field_.set(4); }

  bool has_tier() const { return _has_field_[5]; }
  V8WasmCode_Tier tier() const { return tier_; }
  void set_tier(V8WasmCode_Tier value) { tier_ = value; _has_field_.set(5); }

  bool has_code_offset_in_module() const { return _has_field_[6]; }
  int32_t code_offset_in_module() const { return code_offset_in_module_; }
  void set_code_offset_in_module(int32_t value) { code_offset_in_module_ = value; _has_field_.set(6); }

  bool has_instruction_start() const { return _has_field_[7]; }
  uint64_t instruction_start() const { return instruction_start_; }
  void set_instruction_start(uint64_t value) { instruction_start_ = value; _has_field_.set(7); }

  bool has_instruction_size_bytes() const { return _has_field_[8]; }
  uint64_t instruction_size_bytes() const { return instruction_size_bytes_; }
  void set_instruction_size_bytes(uint64_t value) { instruction_size_bytes_ = value; _has_field_.set(8); }

  bool has_machine_code() const { return _has_field_[9]; }
  const std::string& machine_code() const { return machine_code_; }
  void set_machine_code(const std::string& value) { machine_code_ = value; _has_field_.set(9); }
  void set_machine_code(const void* p, size_t s) { machine_code_.assign(reinterpret_cast<const char*>(p), s); _has_field_.set(9); }

 private:
  uint64_t v8_isolate_iid_{};
  uint32_t tid_{};
  uint64_t v8_wasm_script_iid_{};
  std::string function_name_{};
  V8WasmCode_Tier tier_{};
  int32_t code_offset_in_module_{};
  uint64_t instruction_start_{};
  uint64_t instruction_size_bytes_{};
  std::string machine_code_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<10> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT V8InternalCode : public ::protozero::CppMessageObj {
 public:
  using Type = V8InternalCode_Type;
  static constexpr auto TYPE_UNKNOWN = V8InternalCode_Type_TYPE_UNKNOWN;
  static constexpr auto TYPE_BYTECODE_HANDLER = V8InternalCode_Type_TYPE_BYTECODE_HANDLER;
  static constexpr auto TYPE_FOR_TESTING = V8InternalCode_Type_TYPE_FOR_TESTING;
  static constexpr auto TYPE_BUILTIN = V8InternalCode_Type_TYPE_BUILTIN;
  static constexpr auto TYPE_WASM_FUNCTION = V8InternalCode_Type_TYPE_WASM_FUNCTION;
  static constexpr auto TYPE_WASM_TO_CAPI_FUNCTION = V8InternalCode_Type_TYPE_WASM_TO_CAPI_FUNCTION;
  static constexpr auto TYPE_WASM_TO_JS_FUNCTION = V8InternalCode_Type_TYPE_WASM_TO_JS_FUNCTION;
  static constexpr auto TYPE_JS_TO_WASM_FUNCTION = V8InternalCode_Type_TYPE_JS_TO_WASM_FUNCTION;
  static constexpr auto TYPE_JS_TO_JS_FUNCTION = V8InternalCode_Type_TYPE_JS_TO_JS_FUNCTION;
  static constexpr auto TYPE_C_WASM_ENTRY = V8InternalCode_Type_TYPE_C_WASM_ENTRY;
  static constexpr auto Type_MIN = V8InternalCode_Type_TYPE_UNKNOWN;
  static constexpr auto Type_MAX = V8InternalCode_Type_TYPE_C_WASM_ENTRY;
  enum FieldNumbers {
    kV8IsolateIidFieldNumber = 1,
    kTidFieldNumber = 2,
    kNameFieldNumber = 3,
    kTypeFieldNumber = 4,
    kBuiltinIdFieldNumber = 5,
    kInstructionStartFieldNumber = 6,
    kInstructionSizeBytesFieldNumber = 7,
    kMachineCodeFieldNumber = 8,
  };

  V8InternalCode();
  ~V8InternalCode() override;
  V8InternalCode(V8InternalCode&&) noexcept;
  V8InternalCode& operator=(V8InternalCode&&);
  V8InternalCode(const V8InternalCode&);
  V8InternalCode& operator=(const V8InternalCode&);
  bool operator==(const V8InternalCode&) const;
  bool operator!=(const V8InternalCode& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_v8_isolate_iid() const { return _has_field_[1]; }
  uint64_t v8_isolate_iid() const { return v8_isolate_iid_; }
  void set_v8_isolate_iid(uint64_t value) { v8_isolate_iid_ = value; _has_field_.set(1); }

  bool has_tid() const { return _has_field_[2]; }
  uint32_t tid() const { return tid_; }
  void set_tid(uint32_t value) { tid_ = value; _has_field_.set(2); }

  bool has_name() const { return _has_field_[3]; }
  const std::string& name() const { return name_; }
  void set_name(const std::string& value) { name_ = value; _has_field_.set(3); }

  bool has_type() const { return _has_field_[4]; }
  V8InternalCode_Type type() const { return type_; }
  void set_type(V8InternalCode_Type value) { type_ = value; _has_field_.set(4); }

  bool has_builtin_id() const { return _has_field_[5]; }
  int32_t builtin_id() const { return builtin_id_; }
  void set_builtin_id(int32_t value) { builtin_id_ = value; _has_field_.set(5); }

  bool has_instruction_start() const { return _has_field_[6]; }
  uint64_t instruction_start() const { return instruction_start_; }
  void set_instruction_start(uint64_t value) { instruction_start_ = value; _has_field_.set(6); }

  bool has_instruction_size_bytes() const { return _has_field_[7]; }
  uint64_t instruction_size_bytes() const { return instruction_size_bytes_; }
  void set_instruction_size_bytes(uint64_t value) { instruction_size_bytes_ = value; _has_field_.set(7); }

  bool has_machine_code() const { return _has_field_[8]; }
  const std::string& machine_code() const { return machine_code_; }
  void set_machine_code(const std::string& value) { machine_code_ = value; _has_field_.set(8); }
  void set_machine_code(const void* p, size_t s) { machine_code_.assign(reinterpret_cast<const char*>(p), s); _has_field_.set(8); }

 private:
  uint64_t v8_isolate_iid_{};
  uint32_t tid_{};
  std::string name_{};
  V8InternalCode_Type type_{};
  int32_t builtin_id_{};
  uint64_t instruction_start_{};
  uint64_t instruction_size_bytes_{};
  std::string machine_code_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<9> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT V8JsCode : public ::protozero::CppMessageObj {
 public:
  using Tier = V8JsCode_Tier;
  static constexpr auto TIER_UNKNOWN = V8JsCode_Tier_TIER_UNKNOWN;
  static constexpr auto TIER_IGNITION = V8JsCode_Tier_TIER_IGNITION;
  static constexpr auto TIER_SPARKPLUG = V8JsCode_Tier_TIER_SPARKPLUG;
  static constexpr auto TIER_MAGLEV = V8JsCode_Tier_TIER_MAGLEV;
  static constexpr auto TIER_TURBOSHAFT = V8JsCode_Tier_TIER_TURBOSHAFT;
  static constexpr auto TIER_TURBOFAN = V8JsCode_Tier_TIER_TURBOFAN;
  static constexpr auto Tier_MIN = V8JsCode_Tier_TIER_UNKNOWN;
  static constexpr auto Tier_MAX = V8JsCode_Tier_TIER_TURBOFAN;
  enum FieldNumbers {
    kV8IsolateIidFieldNumber = 1,
    kTidFieldNumber = 2,
    kV8JsFunctionIidFieldNumber = 3,
    kTierFieldNumber = 4,
    kInstructionStartFieldNumber = 5,
    kInstructionSizeBytesFieldNumber = 6,
    kMachineCodeFieldNumber = 7,
    kBytecodeFieldNumber = 8,
  };

  V8JsCode();
  ~V8JsCode() override;
  V8JsCode(V8JsCode&&) noexcept;
  V8JsCode& operator=(V8JsCode&&);
  V8JsCode(const V8JsCode&);
  V8JsCode& operator=(const V8JsCode&);
  bool operator==(const V8JsCode&) const;
  bool operator!=(const V8JsCode& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_v8_isolate_iid() const { return _has_field_[1]; }
  uint64_t v8_isolate_iid() const { return v8_isolate_iid_; }
  void set_v8_isolate_iid(uint64_t value) { v8_isolate_iid_ = value; _has_field_.set(1); }

  bool has_tid() const { return _has_field_[2]; }
  uint32_t tid() const { return tid_; }
  void set_tid(uint32_t value) { tid_ = value; _has_field_.set(2); }

  bool has_v8_js_function_iid() const { return _has_field_[3]; }
  uint64_t v8_js_function_iid() const { return v8_js_function_iid_; }
  void set_v8_js_function_iid(uint64_t value) { v8_js_function_iid_ = value; _has_field_.set(3); }

  bool has_tier() const { return _has_field_[4]; }
  V8JsCode_Tier tier() const { return tier_; }
  void set_tier(V8JsCode_Tier value) { tier_ = value; _has_field_.set(4); }

  bool has_instruction_start() const { return _has_field_[5]; }
  uint64_t instruction_start() const { return instruction_start_; }
  void set_instruction_start(uint64_t value) { instruction_start_ = value; _has_field_.set(5); }

  bool has_instruction_size_bytes() const { return _has_field_[6]; }
  uint64_t instruction_size_bytes() const { return instruction_size_bytes_; }
  void set_instruction_size_bytes(uint64_t value) { instruction_size_bytes_ = value; _has_field_.set(6); }

  bool has_machine_code() const { return _has_field_[7]; }
  const std::string& machine_code() const { return machine_code_; }
  void set_machine_code(const std::string& value) { machine_code_ = value; _has_field_.set(7); }
  void set_machine_code(const void* p, size_t s) { machine_code_.assign(reinterpret_cast<const char*>(p), s); _has_field_.set(7); }

  bool has_bytecode() const { return _has_field_[8]; }
  const std::string& bytecode() const { return bytecode_; }
  void set_bytecode(const std::string& value) { bytecode_ = value; _has_field_.set(8); }
  void set_bytecode(const void* p, size_t s) { bytecode_.assign(reinterpret_cast<const char*>(p), s); _has_field_.set(8); }

 private:
  uint64_t v8_isolate_iid_{};
  uint32_t tid_{};
  uint64_t v8_js_function_iid_{};
  V8JsCode_Tier tier_{};
  uint64_t instruction_start_{};
  uint64_t instruction_size_bytes_{};
  std::string machine_code_{};
  std::string bytecode_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<9> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT InternedV8Isolate : public ::protozero::CppMessageObj {
 public:
  using CodeRange = InternedV8Isolate_CodeRange;
  enum FieldNumbers {
    kIidFieldNumber = 1,
    kPidFieldNumber = 2,
    kIsolateIdFieldNumber = 3,
    kCodeRangeFieldNumber = 4,
    kEmbeddedBlobCodeStartAddressFieldNumber = 5,
    kEmbeddedBlobCodeSizeFieldNumber = 6,
  };

  InternedV8Isolate();
  ~InternedV8Isolate() override;
  InternedV8Isolate(InternedV8Isolate&&) noexcept;
  InternedV8Isolate& operator=(InternedV8Isolate&&);
  InternedV8Isolate(const InternedV8Isolate&);
  InternedV8Isolate& operator=(const InternedV8Isolate&);
  bool operator==(const InternedV8Isolate&) const;
  bool operator!=(const InternedV8Isolate& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_iid() const { return _has_field_[1]; }
  uint64_t iid() const { return iid_; }
  void set_iid(uint64_t value) { iid_ = value; _has_field_.set(1); }

  bool has_pid() const { return _has_field_[2]; }
  uint32_t pid() const { return pid_; }
  void set_pid(uint32_t value) { pid_ = value; _has_field_.set(2); }

  bool has_isolate_id() const { return _has_field_[3]; }
  int32_t isolate_id() const { return isolate_id_; }
  void set_isolate_id(int32_t value) { isolate_id_ = value; _has_field_.set(3); }

  bool has_code_range() const { return _has_field_[4]; }
  const InternedV8Isolate_CodeRange& code_range() const { return *code_range_; }
  InternedV8Isolate_CodeRange* mutable_code_range() { _has_field_.set(4); return code_range_.get(); }

  bool has_embedded_blob_code_start_address() const { return _has_field_[5]; }
  uint64_t embedded_blob_code_start_address() const { return embedded_blob_code_start_address_; }
  void set_embedded_blob_code_start_address(uint64_t value) { embedded_blob_code_start_address_ = value; _has_field_.set(5); }

  bool has_embedded_blob_code_size() const { return _has_field_[6]; }
  uint64_t embedded_blob_code_size() const { return embedded_blob_code_size_; }
  void set_embedded_blob_code_size(uint64_t value) { embedded_blob_code_size_ = value; _has_field_.set(6); }

 private:
  uint64_t iid_{};
  uint32_t pid_{};
  int32_t isolate_id_{};
  ::protozero::CopyablePtr<InternedV8Isolate_CodeRange> code_range_;
  uint64_t embedded_blob_code_start_address_{};
  uint64_t embedded_blob_code_size_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<7> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT InternedV8Isolate_CodeRange : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kBaseAddressFieldNumber = 1,
    kSizeFieldNumber = 2,
    kEmbeddedBlobCodeCopyStartAddressFieldNumber = 3,
    kIsProcessWideFieldNumber = 4,
  };

  InternedV8Isolate_CodeRange();
  ~InternedV8Isolate_CodeRange() override;
  InternedV8Isolate_CodeRange(InternedV8Isolate_CodeRange&&) noexcept;
  InternedV8Isolate_CodeRange& operator=(InternedV8Isolate_CodeRange&&);
  InternedV8Isolate_CodeRange(const InternedV8Isolate_CodeRange&);
  InternedV8Isolate_CodeRange& operator=(const InternedV8Isolate_CodeRange&);
  bool operator==(const InternedV8Isolate_CodeRange&) const;
  bool operator!=(const InternedV8Isolate_CodeRange& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_base_address() const { return _has_field_[1]; }
  uint64_t base_address() const { return base_address_; }
  void set_base_address(uint64_t value) { base_address_ = value; _has_field_.set(1); }

  bool has_size() const { return _has_field_[2]; }
  uint64_t size() const { return size_; }
  void set_size(uint64_t value) { size_ = value; _has_field_.set(2); }

  bool has_embedded_blob_code_copy_start_address() const { return _has_field_[3]; }
  uint64_t embedded_blob_code_copy_start_address() const { return embedded_blob_code_copy_start_address_; }
  void set_embedded_blob_code_copy_start_address(uint64_t value) { embedded_blob_code_copy_start_address_ = value; _has_field_.set(3); }

  bool has_is_process_wide() const { return _has_field_[4]; }
  bool is_process_wide() const { return is_process_wide_; }
  void set_is_process_wide(bool value) { is_process_wide_ = value; _has_field_.set(4); }

 private:
  uint64_t base_address_{};
  uint64_t size_{};
  uint64_t embedded_blob_code_copy_start_address_{};
  bool is_process_wide_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT InternedV8JsFunction : public ::protozero::CppMessageObj {
 public:
  using Kind = InternedV8JsFunction_Kind;
  static constexpr auto KIND_UNKNOWN = InternedV8JsFunction_Kind_KIND_UNKNOWN;
  static constexpr auto KIND_NORMAL_FUNCTION = InternedV8JsFunction_Kind_KIND_NORMAL_FUNCTION;
  static constexpr auto KIND_MODULE = InternedV8JsFunction_Kind_KIND_MODULE;
  static constexpr auto KIND_ASYNC_MODULE = InternedV8JsFunction_Kind_KIND_ASYNC_MODULE;
  static constexpr auto KIND_BASE_CONSTRUCTOR = InternedV8JsFunction_Kind_KIND_BASE_CONSTRUCTOR;
  static constexpr auto KIND_DEFAULT_BASE_CONSTRUCTOR = InternedV8JsFunction_Kind_KIND_DEFAULT_BASE_CONSTRUCTOR;
  static constexpr auto KIND_DEFAULT_DERIVED_CONSTRUCTOR = InternedV8JsFunction_Kind_KIND_DEFAULT_DERIVED_CONSTRUCTOR;
  static constexpr auto KIND_DERIVED_CONSTRUCTOR = InternedV8JsFunction_Kind_KIND_DERIVED_CONSTRUCTOR;
  static constexpr auto KIND_GETTER_FUNCTION = InternedV8JsFunction_Kind_KIND_GETTER_FUNCTION;
  static constexpr auto KIND_STATIC_GETTER_FUNCTION = InternedV8JsFunction_Kind_KIND_STATIC_GETTER_FUNCTION;
  static constexpr auto KIND_SETTER_FUNCTION = InternedV8JsFunction_Kind_KIND_SETTER_FUNCTION;
  static constexpr auto KIND_STATIC_SETTER_FUNCTION = InternedV8JsFunction_Kind_KIND_STATIC_SETTER_FUNCTION;
  static constexpr auto KIND_ARROW_FUNCTION = InternedV8JsFunction_Kind_KIND_ARROW_FUNCTION;
  static constexpr auto KIND_ASYNC_ARROW_FUNCTION = InternedV8JsFunction_Kind_KIND_ASYNC_ARROW_FUNCTION;
  static constexpr auto KIND_ASYNC_FUNCTION = InternedV8JsFunction_Kind_KIND_ASYNC_FUNCTION;
  static constexpr auto KIND_ASYNC_CONCISE_METHOD = InternedV8JsFunction_Kind_KIND_ASYNC_CONCISE_METHOD;
  static constexpr auto KIND_STATIC_ASYNC_CONCISE_METHOD = InternedV8JsFunction_Kind_KIND_STATIC_ASYNC_CONCISE_METHOD;
  static constexpr auto KIND_ASYNC_CONCISE_GENERATOR_METHOD = InternedV8JsFunction_Kind_KIND_ASYNC_CONCISE_GENERATOR_METHOD;
  static constexpr auto KIND_STATIC_ASYNC_CONCISE_GENERATOR_METHOD = InternedV8JsFunction_Kind_KIND_STATIC_ASYNC_CONCISE_GENERATOR_METHOD;
  static constexpr auto KIND_ASYNC_GENERATOR_FUNCTION = InternedV8JsFunction_Kind_KIND_ASYNC_GENERATOR_FUNCTION;
  static constexpr auto KIND_GENERATOR_FUNCTION = InternedV8JsFunction_Kind_KIND_GENERATOR_FUNCTION;
  static constexpr auto KIND_CONCISE_GENERATOR_METHOD = InternedV8JsFunction_Kind_KIND_CONCISE_GENERATOR_METHOD;
  static constexpr auto KIND_STATIC_CONCISE_GENERATOR_METHOD = InternedV8JsFunction_Kind_KIND_STATIC_CONCISE_GENERATOR_METHOD;
  static constexpr auto KIND_CONCISE_METHOD = InternedV8JsFunction_Kind_KIND_CONCISE_METHOD;
  static constexpr auto KIND_STATIC_CONCISE_METHOD = InternedV8JsFunction_Kind_KIND_STATIC_CONCISE_METHOD;
  static constexpr auto KIND_CLASS_MEMBERS_INITIALIZER_FUNCTION = InternedV8JsFunction_Kind_KIND_CLASS_MEMBERS_INITIALIZER_FUNCTION;
  static constexpr auto KIND_CLASS_STATIC_INITIALIZER_FUNCTION = InternedV8JsFunction_Kind_KIND_CLASS_STATIC_INITIALIZER_FUNCTION;
  static constexpr auto KIND_INVALID = InternedV8JsFunction_Kind_KIND_INVALID;
  static constexpr auto Kind_MIN = InternedV8JsFunction_Kind_KIND_UNKNOWN;
  static constexpr auto Kind_MAX = InternedV8JsFunction_Kind_KIND_INVALID;
  enum FieldNumbers {
    kIidFieldNumber = 1,
    kV8JsFunctionNameIidFieldNumber = 2,
    kV8JsScriptIidFieldNumber = 3,
    kIsToplevelFieldNumber = 4,
    kKindFieldNumber = 5,
    kByteOffsetFieldNumber = 6,
  };

  InternedV8JsFunction();
  ~InternedV8JsFunction() override;
  InternedV8JsFunction(InternedV8JsFunction&&) noexcept;
  InternedV8JsFunction& operator=(InternedV8JsFunction&&);
  InternedV8JsFunction(const InternedV8JsFunction&);
  InternedV8JsFunction& operator=(const InternedV8JsFunction&);
  bool operator==(const InternedV8JsFunction&) const;
  bool operator!=(const InternedV8JsFunction& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_iid() const { return _has_field_[1]; }
  uint64_t iid() const { return iid_; }
  void set_iid(uint64_t value) { iid_ = value; _has_field_.set(1); }

  bool has_v8_js_function_name_iid() const { return _has_field_[2]; }
  uint64_t v8_js_function_name_iid() const { return v8_js_function_name_iid_; }
  void set_v8_js_function_name_iid(uint64_t value) { v8_js_function_name_iid_ = value; _has_field_.set(2); }

  bool has_v8_js_script_iid() const { return _has_field_[3]; }
  uint64_t v8_js_script_iid() const { return v8_js_script_iid_; }
  void set_v8_js_script_iid(uint64_t value) { v8_js_script_iid_ = value; _has_field_.set(3); }

  bool has_is_toplevel() const { return _has_field_[4]; }
  bool is_toplevel() const { return is_toplevel_; }
  void set_is_toplevel(bool value) { is_toplevel_ = value; _has_field_.set(4); }

  bool has_kind() const { return _has_field_[5]; }
  InternedV8JsFunction_Kind kind() const { return kind_; }
  void set_kind(InternedV8JsFunction_Kind value) { kind_ = value; _has_field_.set(5); }

  bool has_byte_offset() const { return _has_field_[6]; }
  uint32_t byte_offset() const { return byte_offset_; }
  void set_byte_offset(uint32_t value) { byte_offset_ = value; _has_field_.set(6); }

 private:
  uint64_t iid_{};
  uint64_t v8_js_function_name_iid_{};
  uint64_t v8_js_script_iid_{};
  bool is_toplevel_{};
  InternedV8JsFunction_Kind kind_{};
  uint32_t byte_offset_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<7> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT InternedV8WasmScript : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kIidFieldNumber = 1,
    kScriptIdFieldNumber = 2,
    kUrlFieldNumber = 3,
  };

  InternedV8WasmScript();
  ~InternedV8WasmScript() override;
  InternedV8WasmScript(InternedV8WasmScript&&) noexcept;
  InternedV8WasmScript& operator=(InternedV8WasmScript&&);
  InternedV8WasmScript(const InternedV8WasmScript&);
  InternedV8WasmScript& operator=(const InternedV8WasmScript&);
  bool operator==(const InternedV8WasmScript&) const;
  bool operator!=(const InternedV8WasmScript& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_iid() const { return _has_field_[1]; }
  uint64_t iid() const { return iid_; }
  void set_iid(uint64_t value) { iid_ = value; _has_field_.set(1); }

  bool has_script_id() const { return _has_field_[2]; }
  int32_t script_id() const { return script_id_; }
  void set_script_id(int32_t value) { script_id_ = value; _has_field_.set(2); }

  bool has_url() const { return _has_field_[3]; }
  const std::string& url() const { return url_; }
  void set_url(const std::string& value) { url_ = value; _has_field_.set(3); }

 private:
  uint64_t iid_{};
  int32_t script_id_{};
  std::string url_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT InternedV8JsScript : public ::protozero::CppMessageObj {
 public:
  using Type = InternedV8JsScript_Type;
  static constexpr auto TYPE_UNKNOWN = InternedV8JsScript_Type_TYPE_UNKNOWN;
  static constexpr auto TYPE_NORMAL = InternedV8JsScript_Type_TYPE_NORMAL;
  static constexpr auto TYPE_EVAL = InternedV8JsScript_Type_TYPE_EVAL;
  static constexpr auto TYPE_MODULE = InternedV8JsScript_Type_TYPE_MODULE;
  static constexpr auto TYPE_NATIVE = InternedV8JsScript_Type_TYPE_NATIVE;
  static constexpr auto TYPE_EXTENSION = InternedV8JsScript_Type_TYPE_EXTENSION;
  static constexpr auto TYPE_INSPECTOR = InternedV8JsScript_Type_TYPE_INSPECTOR;
  static constexpr auto Type_MIN = InternedV8JsScript_Type_TYPE_UNKNOWN;
  static constexpr auto Type_MAX = InternedV8JsScript_Type_TYPE_INSPECTOR;
  enum FieldNumbers {
    kIidFieldNumber = 1,
    kScriptIdFieldNumber = 2,
    kTypeFieldNumber = 3,
    kNameFieldNumber = 4,
    kSourceFieldNumber = 5,
  };

  InternedV8JsScript();
  ~InternedV8JsScript() override;
  InternedV8JsScript(InternedV8JsScript&&) noexcept;
  InternedV8JsScript& operator=(InternedV8JsScript&&);
  InternedV8JsScript(const InternedV8JsScript&);
  InternedV8JsScript& operator=(const InternedV8JsScript&);
  bool operator==(const InternedV8JsScript&) const;
  bool operator!=(const InternedV8JsScript& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_iid() const { return _has_field_[1]; }
  uint64_t iid() const { return iid_; }
  void set_iid(uint64_t value) { iid_ = value; _has_field_.set(1); }

  bool has_script_id() const { return _has_field_[2]; }
  int32_t script_id() const { return script_id_; }
  void set_script_id(int32_t value) { script_id_ = value; _has_field_.set(2); }

  bool has_type() const { return _has_field_[3]; }
  InternedV8JsScript_Type type() const { return type_; }
  void set_type(InternedV8JsScript_Type value) { type_ = value; _has_field_.set(3); }

  bool has_name() const { return _has_field_[4]; }
  const V8String& name() const { return *name_; }
  V8String* mutable_name() { _has_field_.set(4); return name_.get(); }

  bool has_source() const { return _has_field_[5]; }
  const V8String& source() const { return *source_; }
  V8String* mutable_source() { _has_field_.set(5); return source_.get(); }

 private:
  uint64_t iid_{};
  int32_t script_id_{};
  InternedV8JsScript_Type type_{};
  ::protozero::CopyablePtr<V8String> name_;
  ::protozero::CopyablePtr<V8String> source_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<6> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT InternedV8String : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kIidFieldNumber = 1,
    kLatin1FieldNumber = 2,
    kUtf16LeFieldNumber = 3,
    kUtf16BeFieldNumber = 4,
  };

  InternedV8String();
  ~InternedV8String() override;
  InternedV8String(InternedV8String&&) noexcept;
  InternedV8String& operator=(InternedV8String&&);
  InternedV8String(const InternedV8String&);
  InternedV8String& operator=(const InternedV8String&);
  bool operator==(const InternedV8String&) const;
  bool operator!=(const InternedV8String& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_iid() const { return _has_field_[1]; }
  uint64_t iid() const { return iid_; }
  void set_iid(uint64_t value) { iid_ = value; _has_field_.set(1); }

  bool has_latin1() const { return _has_field_[2]; }
  const std::string& latin1() const { return latin1_; }
  void set_latin1(const std::string& value) { latin1_ = value; _has_field_.set(2); }
  void set_latin1(const void* p, size_t s) { latin1_.assign(reinterpret_cast<const char*>(p), s); _has_field_.set(2); }

  bool has_utf16_le() const { return _has_field_[3]; }
  const std::string& utf16_le() const { return utf16_le_; }
  void set_utf16_le(const std::string& value) { utf16_le_ = value; _has_field_.set(3); }
  void set_utf16_le(const void* p, size_t s) { utf16_le_.assign(reinterpret_cast<const char*>(p), s); _has_field_.set(3); }

  bool has_utf16_be() const { return _has_field_[4]; }
  const std::string& utf16_be() const { return utf16_be_; }
  void set_utf16_be(const std::string& value) { utf16_be_ = value; _has_field_.set(4); }
  void set_utf16_be(const void* p, size_t s) { utf16_be_.assign(reinterpret_cast<const char*>(p), s); _has_field_.set(4); }

 private:
  uint64_t iid_{};
  std::string latin1_{};
  std::string utf16_le_{};
  std::string utf16_be_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_CHROME_V8_PROTO_CPP_H_
