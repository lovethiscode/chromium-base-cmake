#include "perfetto/protozero/gen_field_helpers.h"
#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/scattered_heap_buffer.h"
// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
#endif
#include "protos/perfetto/trace/chrome/v8.gen.h"

namespace perfetto {
namespace protos {
namespace gen {

V8CodeDefaults::V8CodeDefaults() = default;
V8CodeDefaults::~V8CodeDefaults() = default;
V8CodeDefaults::V8CodeDefaults(const V8CodeDefaults&) = default;
V8CodeDefaults& V8CodeDefaults::operator=(const V8CodeDefaults&) = default;
V8CodeDefaults::V8CodeDefaults(V8CodeDefaults&&) noexcept = default;
V8CodeDefaults& V8CodeDefaults::operator=(V8CodeDefaults&&) = default;

bool V8CodeDefaults::operator==(const V8CodeDefaults& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(tid_, other.tid_);
}

bool V8CodeDefaults::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* tid */:
        field.get(&tid_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string V8CodeDefaults::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> V8CodeDefaults::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void V8CodeDefaults::Serialize(::protozero::Message* msg) const {
  // Field 1: tid
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, tid_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


V8CodeMove::V8CodeMove() = default;
V8CodeMove::~V8CodeMove() = default;
V8CodeMove::V8CodeMove(const V8CodeMove&) = default;
V8CodeMove& V8CodeMove::operator=(const V8CodeMove&) = default;
V8CodeMove::V8CodeMove(V8CodeMove&&) noexcept = default;
V8CodeMove& V8CodeMove::operator=(V8CodeMove&&) = default;

bool V8CodeMove::operator==(const V8CodeMove& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(isolate_iid_, other.isolate_iid_)
   && ::protozero::internal::gen_helpers::EqualsField(tid_, other.tid_)
   && ::protozero::internal::gen_helpers::EqualsField(from_instruction_start_address_, other.from_instruction_start_address_)
   && ::protozero::internal::gen_helpers::EqualsField(to_instruction_start_address_, other.to_instruction_start_address_)
   && ::protozero::internal::gen_helpers::EqualsField(instruction_size_bytes_, other.instruction_size_bytes_)
   && ::protozero::internal::gen_helpers::EqualsField(to_machine_code_, other.to_machine_code_)
   && ::protozero::internal::gen_helpers::EqualsField(to_bytecode_, other.to_bytecode_);
}

bool V8CodeMove::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* isolate_iid */:
        field.get(&isolate_iid_);
        break;
      case 2 /* tid */:
        field.get(&tid_);
        break;
      case 3 /* from_instruction_start_address */:
        field.get(&from_instruction_start_address_);
        break;
      case 4 /* to_instruction_start_address */:
        field.get(&to_instruction_start_address_);
        break;
      case 5 /* instruction_size_bytes */:
        field.get(&instruction_size_bytes_);
        break;
      case 6 /* to_machine_code */:
        field.get(&to_machine_code_);
        break;
      case 7 /* to_bytecode */:
        field.get(&to_bytecode_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string V8CodeMove::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> V8CodeMove::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void V8CodeMove::Serialize(::protozero::Message* msg) const {
  // Field 1: isolate_iid
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, isolate_iid_, msg);
  }

  // Field 2: tid
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, tid_, msg);
  }

  // Field 3: from_instruction_start_address
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, from_instruction_start_address_, msg);
  }

  // Field 4: to_instruction_start_address
  if (_has_field_[4]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(4, to_instruction_start_address_, msg);
  }

  // Field 5: instruction_size_bytes
  if (_has_field_[5]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(5, instruction_size_bytes_, msg);
  }

  // Field 6: to_machine_code
  if (_has_field_[6]) {
    ::protozero::internal::gen_helpers::SerializeString(6, to_machine_code_, msg);
  }

  // Field 7: to_bytecode
  if (_has_field_[7]) {
    ::protozero::internal::gen_helpers::SerializeString(7, to_bytecode_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


V8RegExpCode::V8RegExpCode() = default;
V8RegExpCode::~V8RegExpCode() = default;
V8RegExpCode::V8RegExpCode(const V8RegExpCode&) = default;
V8RegExpCode& V8RegExpCode::operator=(const V8RegExpCode&) = default;
V8RegExpCode::V8RegExpCode(V8RegExpCode&&) noexcept = default;
V8RegExpCode& V8RegExpCode::operator=(V8RegExpCode&&) = default;

bool V8RegExpCode::operator==(const V8RegExpCode& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(v8_isolate_iid_, other.v8_isolate_iid_)
   && ::protozero::internal::gen_helpers::EqualsField(tid_, other.tid_)
   && ::protozero::internal::gen_helpers::EqualsField(pattern_, other.pattern_)
   && ::protozero::internal::gen_helpers::EqualsField(instruction_start_, other.instruction_start_)
   && ::protozero::internal::gen_helpers::EqualsField(instruction_size_bytes_, other.instruction_size_bytes_)
   && ::protozero::internal::gen_helpers::EqualsField(machine_code_, other.machine_code_);
}

bool V8RegExpCode::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* v8_isolate_iid */:
        field.get(&v8_isolate_iid_);
        break;
      case 2 /* tid */:
        field.get(&tid_);
        break;
      case 3 /* pattern */:
        (*pattern_).ParseFromArray(field.data(), field.size());
        break;
      case 4 /* instruction_start */:
        field.get(&instruction_start_);
        break;
      case 5 /* instruction_size_bytes */:
        field.get(&instruction_size_bytes_);
        break;
      case 6 /* machine_code */:
        field.get(&machine_code_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string V8RegExpCode::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> V8RegExpCode::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void V8RegExpCode::Serialize(::protozero::Message* msg) const {
  // Field 1: v8_isolate_iid
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, v8_isolate_iid_, msg);
  }

  // Field 2: tid
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, tid_, msg);
  }

  // Field 3: pattern
  if (_has_field_[3]) {
    (*pattern_).Serialize(msg->BeginNestedMessage<::protozero::Message>(3));
  }

  // Field 4: instruction_start
  if (_has_field_[4]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(4, instruction_start_, msg);
  }

  // Field 5: instruction_size_bytes
  if (_has_field_[5]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(5, instruction_size_bytes_, msg);
  }

  // Field 6: machine_code
  if (_has_field_[6]) {
    ::protozero::internal::gen_helpers::SerializeString(6, machine_code_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


V8String::V8String() = default;
V8String::~V8String() = default;
V8String::V8String(const V8String&) = default;
V8String& V8String::operator=(const V8String&) = default;
V8String::V8String(V8String&&) noexcept = default;
V8String& V8String::operator=(V8String&&) = default;

bool V8String::operator==(const V8String& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(latin1_, other.latin1_)
   && ::protozero::internal::gen_helpers::EqualsField(utf16_le_, other.utf16_le_)
   && ::protozero::internal::gen_helpers::EqualsField(utf16_be_, other.utf16_be_);
}

bool V8String::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* latin1 */:
        field.get(&latin1_);
        break;
      case 2 /* utf16_le */:
        field.get(&utf16_le_);
        break;
      case 3 /* utf16_be */:
        field.get(&utf16_be_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string V8String::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> V8String::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void V8String::Serialize(::protozero::Message* msg) const {
  // Field 1: latin1
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeString(1, latin1_, msg);
  }

  // Field 2: utf16_le
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeString(2, utf16_le_, msg);
  }

  // Field 3: utf16_be
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeString(3, utf16_be_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


V8WasmCode::V8WasmCode() = default;
V8WasmCode::~V8WasmCode() = default;
V8WasmCode::V8WasmCode(const V8WasmCode&) = default;
V8WasmCode& V8WasmCode::operator=(const V8WasmCode&) = default;
V8WasmCode::V8WasmCode(V8WasmCode&&) noexcept = default;
V8WasmCode& V8WasmCode::operator=(V8WasmCode&&) = default;

bool V8WasmCode::operator==(const V8WasmCode& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(v8_isolate_iid_, other.v8_isolate_iid_)
   && ::protozero::internal::gen_helpers::EqualsField(tid_, other.tid_)
   && ::protozero::internal::gen_helpers::EqualsField(v8_wasm_script_iid_, other.v8_wasm_script_iid_)
   && ::protozero::internal::gen_helpers::EqualsField(function_name_, other.function_name_)
   && ::protozero::internal::gen_helpers::EqualsField(tier_, other.tier_)
   && ::protozero::internal::gen_helpers::EqualsField(code_offset_in_module_, other.code_offset_in_module_)
   && ::protozero::internal::gen_helpers::EqualsField(instruction_start_, other.instruction_start_)
   && ::protozero::internal::gen_helpers::EqualsField(instruction_size_bytes_, other.instruction_size_bytes_)
   && ::protozero::internal::gen_helpers::EqualsField(machine_code_, other.machine_code_);
}

bool V8WasmCode::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* v8_isolate_iid */:
        field.get(&v8_isolate_iid_);
        break;
      case 2 /* tid */:
        field.get(&tid_);
        break;
      case 3 /* v8_wasm_script_iid */:
        field.get(&v8_wasm_script_iid_);
        break;
      case 4 /* function_name */:
        ::protozero::internal::gen_helpers::DeserializeString(field, &function_name_);
        break;
      case 5 /* tier */:
        field.get(&tier_);
        break;
      case 6 /* code_offset_in_module */:
        field.get(&code_offset_in_module_);
        break;
      case 7 /* instruction_start */:
        field.get(&instruction_start_);
        break;
      case 8 /* instruction_size_bytes */:
        field.get(&instruction_size_bytes_);
        break;
      case 9 /* machine_code */:
        field.get(&machine_code_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string V8WasmCode::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> V8WasmCode::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void V8WasmCode::Serialize(::protozero::Message* msg) const {
  // Field 1: v8_isolate_iid
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, v8_isolate_iid_, msg);
  }

  // Field 2: tid
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, tid_, msg);
  }

  // Field 3: v8_wasm_script_iid
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, v8_wasm_script_iid_, msg);
  }

  // Field 4: function_name
  if (_has_field_[4]) {
    ::protozero::internal::gen_helpers::SerializeString(4, function_name_, msg);
  }

  // Field 5: tier
  if (_has_field_[5]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(5, tier_, msg);
  }

  // Field 6: code_offset_in_module
  if (_has_field_[6]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(6, code_offset_in_module_, msg);
  }

  // Field 7: instruction_start
  if (_has_field_[7]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(7, instruction_start_, msg);
  }

  // Field 8: instruction_size_bytes
  if (_has_field_[8]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(8, instruction_size_bytes_, msg);
  }

  // Field 9: machine_code
  if (_has_field_[9]) {
    ::protozero::internal::gen_helpers::SerializeString(9, machine_code_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


V8InternalCode::V8InternalCode() = default;
V8InternalCode::~V8InternalCode() = default;
V8InternalCode::V8InternalCode(const V8InternalCode&) = default;
V8InternalCode& V8InternalCode::operator=(const V8InternalCode&) = default;
V8InternalCode::V8InternalCode(V8InternalCode&&) noexcept = default;
V8InternalCode& V8InternalCode::operator=(V8InternalCode&&) = default;

bool V8InternalCode::operator==(const V8InternalCode& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(v8_isolate_iid_, other.v8_isolate_iid_)
   && ::protozero::internal::gen_helpers::EqualsField(tid_, other.tid_)
   && ::protozero::internal::gen_helpers::EqualsField(name_, other.name_)
   && ::protozero::internal::gen_helpers::EqualsField(type_, other.type_)
   && ::protozero::internal::gen_helpers::EqualsField(builtin_id_, other.builtin_id_)
   && ::protozero::internal::gen_helpers::EqualsField(instruction_start_, other.instruction_start_)
   && ::protozero::internal::gen_helpers::EqualsField(instruction_size_bytes_, other.instruction_size_bytes_)
   && ::protozero::internal::gen_helpers::EqualsField(machine_code_, other.machine_code_);
}

bool V8InternalCode::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* v8_isolate_iid */:
        field.get(&v8_isolate_iid_);
        break;
      case 2 /* tid */:
        field.get(&tid_);
        break;
      case 3 /* name */:
        ::protozero::internal::gen_helpers::DeserializeString(field, &name_);
        break;
      case 4 /* type */:
        field.get(&type_);
        break;
      case 5 /* builtin_id */:
        field.get(&builtin_id_);
        break;
      case 6 /* instruction_start */:
        field.get(&instruction_start_);
        break;
      case 7 /* instruction_size_bytes */:
        field.get(&instruction_size_bytes_);
        break;
      case 8 /* machine_code */:
        field.get(&machine_code_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string V8InternalCode::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> V8InternalCode::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void V8InternalCode::Serialize(::protozero::Message* msg) const {
  // Field 1: v8_isolate_iid
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, v8_isolate_iid_, msg);
  }

  // Field 2: tid
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, tid_, msg);
  }

  // Field 3: name
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeString(3, name_, msg);
  }

  // Field 4: type
  if (_has_field_[4]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(4, type_, msg);
  }

  // Field 5: builtin_id
  if (_has_field_[5]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(5, builtin_id_, msg);
  }

  // Field 6: instruction_start
  if (_has_field_[6]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(6, instruction_start_, msg);
  }

  // Field 7: instruction_size_bytes
  if (_has_field_[7]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(7, instruction_size_bytes_, msg);
  }

  // Field 8: machine_code
  if (_has_field_[8]) {
    ::protozero::internal::gen_helpers::SerializeString(8, machine_code_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


V8JsCode::V8JsCode() = default;
V8JsCode::~V8JsCode() = default;
V8JsCode::V8JsCode(const V8JsCode&) = default;
V8JsCode& V8JsCode::operator=(const V8JsCode&) = default;
V8JsCode::V8JsCode(V8JsCode&&) noexcept = default;
V8JsCode& V8JsCode::operator=(V8JsCode&&) = default;

bool V8JsCode::operator==(const V8JsCode& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(v8_isolate_iid_, other.v8_isolate_iid_)
   && ::protozero::internal::gen_helpers::EqualsField(tid_, other.tid_)
   && ::protozero::internal::gen_helpers::EqualsField(v8_js_function_iid_, other.v8_js_function_iid_)
   && ::protozero::internal::gen_helpers::EqualsField(tier_, other.tier_)
   && ::protozero::internal::gen_helpers::EqualsField(instruction_start_, other.instruction_start_)
   && ::protozero::internal::gen_helpers::EqualsField(instruction_size_bytes_, other.instruction_size_bytes_)
   && ::protozero::internal::gen_helpers::EqualsField(machine_code_, other.machine_code_)
   && ::protozero::internal::gen_helpers::EqualsField(bytecode_, other.bytecode_);
}

bool V8JsCode::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* v8_isolate_iid */:
        field.get(&v8_isolate_iid_);
        break;
      case 2 /* tid */:
        field.get(&tid_);
        break;
      case 3 /* v8_js_function_iid */:
        field.get(&v8_js_function_iid_);
        break;
      case 4 /* tier */:
        field.get(&tier_);
        break;
      case 5 /* instruction_start */:
        field.get(&instruction_start_);
        break;
      case 6 /* instruction_size_bytes */:
        field.get(&instruction_size_bytes_);
        break;
      case 7 /* machine_code */:
        field.get(&machine_code_);
        break;
      case 8 /* bytecode */:
        field.get(&bytecode_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string V8JsCode::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> V8JsCode::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void V8JsCode::Serialize(::protozero::Message* msg) const {
  // Field 1: v8_isolate_iid
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, v8_isolate_iid_, msg);
  }

  // Field 2: tid
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, tid_, msg);
  }

  // Field 3: v8_js_function_iid
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, v8_js_function_iid_, msg);
  }

  // Field 4: tier
  if (_has_field_[4]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(4, tier_, msg);
  }

  // Field 5: instruction_start
  if (_has_field_[5]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(5, instruction_start_, msg);
  }

  // Field 6: instruction_size_bytes
  if (_has_field_[6]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(6, instruction_size_bytes_, msg);
  }

  // Field 7: machine_code
  if (_has_field_[7]) {
    ::protozero::internal::gen_helpers::SerializeString(7, machine_code_, msg);
  }

  // Field 8: bytecode
  if (_has_field_[8]) {
    ::protozero::internal::gen_helpers::SerializeString(8, bytecode_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


InternedV8Isolate::InternedV8Isolate() = default;
InternedV8Isolate::~InternedV8Isolate() = default;
InternedV8Isolate::InternedV8Isolate(const InternedV8Isolate&) = default;
InternedV8Isolate& InternedV8Isolate::operator=(const InternedV8Isolate&) = default;
InternedV8Isolate::InternedV8Isolate(InternedV8Isolate&&) noexcept = default;
InternedV8Isolate& InternedV8Isolate::operator=(InternedV8Isolate&&) = default;

bool InternedV8Isolate::operator==(const InternedV8Isolate& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(iid_, other.iid_)
   && ::protozero::internal::gen_helpers::EqualsField(pid_, other.pid_)
   && ::protozero::internal::gen_helpers::EqualsField(isolate_id_, other.isolate_id_)
   && ::protozero::internal::gen_helpers::EqualsField(code_range_, other.code_range_)
   && ::protozero::internal::gen_helpers::EqualsField(embedded_blob_code_start_address_, other.embedded_blob_code_start_address_)
   && ::protozero::internal::gen_helpers::EqualsField(embedded_blob_code_size_, other.embedded_blob_code_size_);
}

bool InternedV8Isolate::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* iid */:
        field.get(&iid_);
        break;
      case 2 /* pid */:
        field.get(&pid_);
        break;
      case 3 /* isolate_id */:
        field.get(&isolate_id_);
        break;
      case 4 /* code_range */:
        (*code_range_).ParseFromArray(field.data(), field.size());
        break;
      case 5 /* embedded_blob_code_start_address */:
        field.get(&embedded_blob_code_start_address_);
        break;
      case 6 /* embedded_blob_code_size */:
        field.get(&embedded_blob_code_size_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string InternedV8Isolate::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> InternedV8Isolate::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void InternedV8Isolate::Serialize(::protozero::Message* msg) const {
  // Field 1: iid
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, iid_, msg);
  }

  // Field 2: pid
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, pid_, msg);
  }

  // Field 3: isolate_id
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, isolate_id_, msg);
  }

  // Field 4: code_range
  if (_has_field_[4]) {
    (*code_range_).Serialize(msg->BeginNestedMessage<::protozero::Message>(4));
  }

  // Field 5: embedded_blob_code_start_address
  if (_has_field_[5]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(5, embedded_blob_code_start_address_, msg);
  }

  // Field 6: embedded_blob_code_size
  if (_has_field_[6]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(6, embedded_blob_code_size_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


InternedV8Isolate_CodeRange::InternedV8Isolate_CodeRange() = default;
InternedV8Isolate_CodeRange::~InternedV8Isolate_CodeRange() = default;
InternedV8Isolate_CodeRange::InternedV8Isolate_CodeRange(const InternedV8Isolate_CodeRange&) = default;
InternedV8Isolate_CodeRange& InternedV8Isolate_CodeRange::operator=(const InternedV8Isolate_CodeRange&) = default;
InternedV8Isolate_CodeRange::InternedV8Isolate_CodeRange(InternedV8Isolate_CodeRange&&) noexcept = default;
InternedV8Isolate_CodeRange& InternedV8Isolate_CodeRange::operator=(InternedV8Isolate_CodeRange&&) = default;

bool InternedV8Isolate_CodeRange::operator==(const InternedV8Isolate_CodeRange& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(base_address_, other.base_address_)
   && ::protozero::internal::gen_helpers::EqualsField(size_, other.size_)
   && ::protozero::internal::gen_helpers::EqualsField(embedded_blob_code_copy_start_address_, other.embedded_blob_code_copy_start_address_)
   && ::protozero::internal::gen_helpers::EqualsField(is_process_wide_, other.is_process_wide_);
}

bool InternedV8Isolate_CodeRange::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* base_address */:
        field.get(&base_address_);
        break;
      case 2 /* size */:
        field.get(&size_);
        break;
      case 3 /* embedded_blob_code_copy_start_address */:
        field.get(&embedded_blob_code_copy_start_address_);
        break;
      case 4 /* is_process_wide */:
        field.get(&is_process_wide_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string InternedV8Isolate_CodeRange::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> InternedV8Isolate_CodeRange::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void InternedV8Isolate_CodeRange::Serialize(::protozero::Message* msg) const {
  // Field 1: base_address
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, base_address_, msg);
  }

  // Field 2: size
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, size_, msg);
  }

  // Field 3: embedded_blob_code_copy_start_address
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, embedded_blob_code_copy_start_address_, msg);
  }

  // Field 4: is_process_wide
  if (_has_field_[4]) {
    ::protozero::internal::gen_helpers::SerializeTinyVarInt(4, is_process_wide_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


InternedV8JsFunction::InternedV8JsFunction() = default;
InternedV8JsFunction::~InternedV8JsFunction() = default;
InternedV8JsFunction::InternedV8JsFunction(const InternedV8JsFunction&) = default;
InternedV8JsFunction& InternedV8JsFunction::operator=(const InternedV8JsFunction&) = default;
InternedV8JsFunction::InternedV8JsFunction(InternedV8JsFunction&&) noexcept = default;
InternedV8JsFunction& InternedV8JsFunction::operator=(InternedV8JsFunction&&) = default;

bool InternedV8JsFunction::operator==(const InternedV8JsFunction& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(iid_, other.iid_)
   && ::protozero::internal::gen_helpers::EqualsField(v8_js_function_name_iid_, other.v8_js_function_name_iid_)
   && ::protozero::internal::gen_helpers::EqualsField(v8_js_script_iid_, other.v8_js_script_iid_)
   && ::protozero::internal::gen_helpers::EqualsField(is_toplevel_, other.is_toplevel_)
   && ::protozero::internal::gen_helpers::EqualsField(kind_, other.kind_)
   && ::protozero::internal::gen_helpers::EqualsField(byte_offset_, other.byte_offset_);
}

bool InternedV8JsFunction::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* iid */:
        field.get(&iid_);
        break;
      case 2 /* v8_js_function_name_iid */:
        field.get(&v8_js_function_name_iid_);
        break;
      case 3 /* v8_js_script_iid */:
        field.get(&v8_js_script_iid_);
        break;
      case 4 /* is_toplevel */:
        field.get(&is_toplevel_);
        break;
      case 5 /* kind */:
        field.get(&kind_);
        break;
      case 6 /* byte_offset */:
        field.get(&byte_offset_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string InternedV8JsFunction::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> InternedV8JsFunction::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void InternedV8JsFunction::Serialize(::protozero::Message* msg) const {
  // Field 1: iid
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, iid_, msg);
  }

  // Field 2: v8_js_function_name_iid
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, v8_js_function_name_iid_, msg);
  }

  // Field 3: v8_js_script_iid
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, v8_js_script_iid_, msg);
  }

  // Field 4: is_toplevel
  if (_has_field_[4]) {
    ::protozero::internal::gen_helpers::SerializeTinyVarInt(4, is_toplevel_, msg);
  }

  // Field 5: kind
  if (_has_field_[5]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(5, kind_, msg);
  }

  // Field 6: byte_offset
  if (_has_field_[6]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(6, byte_offset_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


InternedV8WasmScript::InternedV8WasmScript() = default;
InternedV8WasmScript::~InternedV8WasmScript() = default;
InternedV8WasmScript::InternedV8WasmScript(const InternedV8WasmScript&) = default;
InternedV8WasmScript& InternedV8WasmScript::operator=(const InternedV8WasmScript&) = default;
InternedV8WasmScript::InternedV8WasmScript(InternedV8WasmScript&&) noexcept = default;
InternedV8WasmScript& InternedV8WasmScript::operator=(InternedV8WasmScript&&) = default;

bool InternedV8WasmScript::operator==(const InternedV8WasmScript& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(iid_, other.iid_)
   && ::protozero::internal::gen_helpers::EqualsField(script_id_, other.script_id_)
   && ::protozero::internal::gen_helpers::EqualsField(url_, other.url_);
}

bool InternedV8WasmScript::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* iid */:
        field.get(&iid_);
        break;
      case 2 /* script_id */:
        field.get(&script_id_);
        break;
      case 3 /* url */:
        ::protozero::internal::gen_helpers::DeserializeString(field, &url_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string InternedV8WasmScript::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> InternedV8WasmScript::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void InternedV8WasmScript::Serialize(::protozero::Message* msg) const {
  // Field 1: iid
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, iid_, msg);
  }

  // Field 2: script_id
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, script_id_, msg);
  }

  // Field 3: url
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeString(3, url_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


InternedV8JsScript::InternedV8JsScript() = default;
InternedV8JsScript::~InternedV8JsScript() = default;
InternedV8JsScript::InternedV8JsScript(const InternedV8JsScript&) = default;
InternedV8JsScript& InternedV8JsScript::operator=(const InternedV8JsScript&) = default;
InternedV8JsScript::InternedV8JsScript(InternedV8JsScript&&) noexcept = default;
InternedV8JsScript& InternedV8JsScript::operator=(InternedV8JsScript&&) = default;

bool InternedV8JsScript::operator==(const InternedV8JsScript& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(iid_, other.iid_)
   && ::protozero::internal::gen_helpers::EqualsField(script_id_, other.script_id_)
   && ::protozero::internal::gen_helpers::EqualsField(type_, other.type_)
   && ::protozero::internal::gen_helpers::EqualsField(name_, other.name_)
   && ::protozero::internal::gen_helpers::EqualsField(source_, other.source_);
}

bool InternedV8JsScript::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* iid */:
        field.get(&iid_);
        break;
      case 2 /* script_id */:
        field.get(&script_id_);
        break;
      case 3 /* type */:
        field.get(&type_);
        break;
      case 4 /* name */:
        (*name_).ParseFromArray(field.data(), field.size());
        break;
      case 5 /* source */:
        (*source_).ParseFromArray(field.data(), field.size());
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string InternedV8JsScript::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> InternedV8JsScript::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void InternedV8JsScript::Serialize(::protozero::Message* msg) const {
  // Field 1: iid
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, iid_, msg);
  }

  // Field 2: script_id
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(2, script_id_, msg);
  }

  // Field 3: type
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(3, type_, msg);
  }

  // Field 4: name
  if (_has_field_[4]) {
    (*name_).Serialize(msg->BeginNestedMessage<::protozero::Message>(4));
  }

  // Field 5: source
  if (_has_field_[5]) {
    (*source_).Serialize(msg->BeginNestedMessage<::protozero::Message>(5));
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}


InternedV8String::InternedV8String() = default;
InternedV8String::~InternedV8String() = default;
InternedV8String::InternedV8String(const InternedV8String&) = default;
InternedV8String& InternedV8String::operator=(const InternedV8String&) = default;
InternedV8String::InternedV8String(InternedV8String&&) noexcept = default;
InternedV8String& InternedV8String::operator=(InternedV8String&&) = default;

bool InternedV8String::operator==(const InternedV8String& other) const {
  return ::protozero::internal::gen_helpers::EqualsField(unknown_fields_, other.unknown_fields_)
   && ::protozero::internal::gen_helpers::EqualsField(iid_, other.iid_)
   && ::protozero::internal::gen_helpers::EqualsField(latin1_, other.latin1_)
   && ::protozero::internal::gen_helpers::EqualsField(utf16_le_, other.utf16_le_)
   && ::protozero::internal::gen_helpers::EqualsField(utf16_be_, other.utf16_be_);
}

bool InternedV8String::ParseFromArray(const void* raw, size_t size) {
  unknown_fields_.clear();
  bool packed_error = false;

  ::protozero::ProtoDecoder dec(raw, size);
  for (auto field = dec.ReadField(); field.valid(); field = dec.ReadField()) {
    if (field.id() < _has_field_.size()) {
      _has_field_.set(field.id());
    }
    switch (field.id()) {
      case 1 /* iid */:
        field.get(&iid_);
        break;
      case 2 /* latin1 */:
        field.get(&latin1_);
        break;
      case 3 /* utf16_le */:
        field.get(&utf16_le_);
        break;
      case 4 /* utf16_be */:
        field.get(&utf16_be_);
        break;
      default:
        field.SerializeAndAppendTo(&unknown_fields_);
        break;
    }
  }
  return !packed_error && !dec.bytes_left();
}

std::string InternedV8String::SerializeAsString() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsString();
}

std::vector<uint8_t> InternedV8String::SerializeAsArray() const {
  ::protozero::internal::gen_helpers::MessageSerializer msg;
  Serialize(msg.get());
  return msg.SerializeAsArray();
}

void InternedV8String::Serialize(::protozero::Message* msg) const {
  // Field 1: iid
  if (_has_field_[1]) {
    ::protozero::internal::gen_helpers::SerializeVarInt(1, iid_, msg);
  }

  // Field 2: latin1
  if (_has_field_[2]) {
    ::protozero::internal::gen_helpers::SerializeString(2, latin1_, msg);
  }

  // Field 3: utf16_le
  if (_has_field_[3]) {
    ::protozero::internal::gen_helpers::SerializeString(3, utf16_le_, msg);
  }

  // Field 4: utf16_be
  if (_has_field_[4]) {
    ::protozero::internal::gen_helpers::SerializeString(4, utf16_be_, msg);
  }

  protozero::internal::gen_helpers::SerializeUnknownFields(unknown_fields_, msg);
}

}  // namespace perfetto
}  // namespace protos
}  // namespace gen
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif
