// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_CHROME_V8_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_CHROME_V8_PROTO_H_

#include <stddef.h>
#include <stdint.h>

#include "perfetto/protozero/field_writer.h"
#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {
class InternedV8Isolate_CodeRange;
class V8String;
namespace perfetto_pbzero_enum_InternedV8JsFunction {
enum Kind : int32_t;
}  // namespace perfetto_pbzero_enum_InternedV8JsFunction
using InternedV8JsFunction_Kind = perfetto_pbzero_enum_InternedV8JsFunction::Kind;
namespace perfetto_pbzero_enum_InternedV8JsScript {
enum Type : int32_t;
}  // namespace perfetto_pbzero_enum_InternedV8JsScript
using InternedV8JsScript_Type = perfetto_pbzero_enum_InternedV8JsScript::Type;
namespace perfetto_pbzero_enum_V8InternalCode {
enum Type : int32_t;
}  // namespace perfetto_pbzero_enum_V8InternalCode
using V8InternalCode_Type = perfetto_pbzero_enum_V8InternalCode::Type;
namespace perfetto_pbzero_enum_V8JsCode {
enum Tier : int32_t;
}  // namespace perfetto_pbzero_enum_V8JsCode
using V8JsCode_Tier = perfetto_pbzero_enum_V8JsCode::Tier;
namespace perfetto_pbzero_enum_V8WasmCode {
enum Tier : int32_t;
}  // namespace perfetto_pbzero_enum_V8WasmCode
using V8WasmCode_Tier = perfetto_pbzero_enum_V8WasmCode::Tier;
} // Namespace pbzero.
} // Namespace protos.
} // Namespace perfetto.

namespace perfetto {
namespace protos {
namespace pbzero {

namespace perfetto_pbzero_enum_V8WasmCode {
enum Tier : int32_t {
  TIER_UNKNOWN = 0,
  TIER_LIFTOFF = 1,
  TIER_TURBOFAN = 2,
};
} // namespace perfetto_pbzero_enum_V8WasmCode
using V8WasmCode_Tier = perfetto_pbzero_enum_V8WasmCode::Tier;


constexpr V8WasmCode_Tier V8WasmCode_Tier_MIN = V8WasmCode_Tier::TIER_UNKNOWN;
constexpr V8WasmCode_Tier V8WasmCode_Tier_MAX = V8WasmCode_Tier::TIER_TURBOFAN;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* V8WasmCode_Tier_Name(::perfetto::protos::pbzero::V8WasmCode_Tier value) {
  switch (value) {
  case ::perfetto::protos::pbzero::V8WasmCode_Tier::TIER_UNKNOWN:
    return "TIER_UNKNOWN";

  case ::perfetto::protos::pbzero::V8WasmCode_Tier::TIER_LIFTOFF:
    return "TIER_LIFTOFF";

  case ::perfetto::protos::pbzero::V8WasmCode_Tier::TIER_TURBOFAN:
    return "TIER_TURBOFAN";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_V8InternalCode {
enum Type : int32_t {
  TYPE_UNKNOWN = 0,
  TYPE_BYTECODE_HANDLER = 1,
  TYPE_FOR_TESTING = 2,
  TYPE_BUILTIN = 3,
  TYPE_WASM_FUNCTION = 4,
  TYPE_WASM_TO_CAPI_FUNCTION = 5,
  TYPE_WASM_TO_JS_FUNCTION = 6,
  TYPE_JS_TO_WASM_FUNCTION = 7,
  TYPE_JS_TO_JS_FUNCTION = 8,
  TYPE_C_WASM_ENTRY = 9,
};
} // namespace perfetto_pbzero_enum_V8InternalCode
using V8InternalCode_Type = perfetto_pbzero_enum_V8InternalCode::Type;


constexpr V8InternalCode_Type V8InternalCode_Type_MIN = V8InternalCode_Type::TYPE_UNKNOWN;
constexpr V8InternalCode_Type V8InternalCode_Type_MAX = V8InternalCode_Type::TYPE_C_WASM_ENTRY;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* V8InternalCode_Type_Name(::perfetto::protos::pbzero::V8InternalCode_Type value) {
  switch (value) {
  case ::perfetto::protos::pbzero::V8InternalCode_Type::TYPE_UNKNOWN:
    return "TYPE_UNKNOWN";

  case ::perfetto::protos::pbzero::V8InternalCode_Type::TYPE_BYTECODE_HANDLER:
    return "TYPE_BYTECODE_HANDLER";

  case ::perfetto::protos::pbzero::V8InternalCode_Type::TYPE_FOR_TESTING:
    return "TYPE_FOR_TESTING";

  case ::perfetto::protos::pbzero::V8InternalCode_Type::TYPE_BUILTIN:
    return "TYPE_BUILTIN";

  case ::perfetto::protos::pbzero::V8InternalCode_Type::TYPE_WASM_FUNCTION:
    return "TYPE_WASM_FUNCTION";

  case ::perfetto::protos::pbzero::V8InternalCode_Type::TYPE_WASM_TO_CAPI_FUNCTION:
    return "TYPE_WASM_TO_CAPI_FUNCTION";

  case ::perfetto::protos::pbzero::V8InternalCode_Type::TYPE_WASM_TO_JS_FUNCTION:
    return "TYPE_WASM_TO_JS_FUNCTION";

  case ::perfetto::protos::pbzero::V8InternalCode_Type::TYPE_JS_TO_WASM_FUNCTION:
    return "TYPE_JS_TO_WASM_FUNCTION";

  case ::perfetto::protos::pbzero::V8InternalCode_Type::TYPE_JS_TO_JS_FUNCTION:
    return "TYPE_JS_TO_JS_FUNCTION";

  case ::perfetto::protos::pbzero::V8InternalCode_Type::TYPE_C_WASM_ENTRY:
    return "TYPE_C_WASM_ENTRY";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_V8JsCode {
enum Tier : int32_t {
  TIER_UNKNOWN = 0,
  TIER_IGNITION = 1,
  TIER_SPARKPLUG = 2,
  TIER_MAGLEV = 3,
  TIER_TURBOSHAFT = 4,
  TIER_TURBOFAN = 5,
};
} // namespace perfetto_pbzero_enum_V8JsCode
using V8JsCode_Tier = perfetto_pbzero_enum_V8JsCode::Tier;


constexpr V8JsCode_Tier V8JsCode_Tier_MIN = V8JsCode_Tier::TIER_UNKNOWN;
constexpr V8JsCode_Tier V8JsCode_Tier_MAX = V8JsCode_Tier::TIER_TURBOFAN;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* V8JsCode_Tier_Name(::perfetto::protos::pbzero::V8JsCode_Tier value) {
  switch (value) {
  case ::perfetto::protos::pbzero::V8JsCode_Tier::TIER_UNKNOWN:
    return "TIER_UNKNOWN";

  case ::perfetto::protos::pbzero::V8JsCode_Tier::TIER_IGNITION:
    return "TIER_IGNITION";

  case ::perfetto::protos::pbzero::V8JsCode_Tier::TIER_SPARKPLUG:
    return "TIER_SPARKPLUG";

  case ::perfetto::protos::pbzero::V8JsCode_Tier::TIER_MAGLEV:
    return "TIER_MAGLEV";

  case ::perfetto::protos::pbzero::V8JsCode_Tier::TIER_TURBOSHAFT:
    return "TIER_TURBOSHAFT";

  case ::perfetto::protos::pbzero::V8JsCode_Tier::TIER_TURBOFAN:
    return "TIER_TURBOFAN";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_InternedV8JsFunction {
enum Kind : int32_t {
  KIND_UNKNOWN = 0,
  KIND_NORMAL_FUNCTION = 1,
  KIND_MODULE = 2,
  KIND_ASYNC_MODULE = 3,
  KIND_BASE_CONSTRUCTOR = 4,
  KIND_DEFAULT_BASE_CONSTRUCTOR = 5,
  KIND_DEFAULT_DERIVED_CONSTRUCTOR = 6,
  KIND_DERIVED_CONSTRUCTOR = 7,
  KIND_GETTER_FUNCTION = 8,
  KIND_STATIC_GETTER_FUNCTION = 9,
  KIND_SETTER_FUNCTION = 10,
  KIND_STATIC_SETTER_FUNCTION = 11,
  KIND_ARROW_FUNCTION = 12,
  KIND_ASYNC_ARROW_FUNCTION = 13,
  KIND_ASYNC_FUNCTION = 14,
  KIND_ASYNC_CONCISE_METHOD = 15,
  KIND_STATIC_ASYNC_CONCISE_METHOD = 16,
  KIND_ASYNC_CONCISE_GENERATOR_METHOD = 17,
  KIND_STATIC_ASYNC_CONCISE_GENERATOR_METHOD = 18,
  KIND_ASYNC_GENERATOR_FUNCTION = 19,
  KIND_GENERATOR_FUNCTION = 20,
  KIND_CONCISE_GENERATOR_METHOD = 21,
  KIND_STATIC_CONCISE_GENERATOR_METHOD = 22,
  KIND_CONCISE_METHOD = 23,
  KIND_STATIC_CONCISE_METHOD = 24,
  KIND_CLASS_MEMBERS_INITIALIZER_FUNCTION = 25,
  KIND_CLASS_STATIC_INITIALIZER_FUNCTION = 26,
  KIND_INVALID = 27,
};
} // namespace perfetto_pbzero_enum_InternedV8JsFunction
using InternedV8JsFunction_Kind = perfetto_pbzero_enum_InternedV8JsFunction::Kind;


constexpr InternedV8JsFunction_Kind InternedV8JsFunction_Kind_MIN = InternedV8JsFunction_Kind::KIND_UNKNOWN;
constexpr InternedV8JsFunction_Kind InternedV8JsFunction_Kind_MAX = InternedV8JsFunction_Kind::KIND_INVALID;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* InternedV8JsFunction_Kind_Name(::perfetto::protos::pbzero::InternedV8JsFunction_Kind value) {
  switch (value) {
  case ::perfetto::protos::pbzero::InternedV8JsFunction_Kind::KIND_UNKNOWN:
    return "KIND_UNKNOWN";

  case ::perfetto::protos::pbzero::InternedV8JsFunction_Kind::KIND_NORMAL_FUNCTION:
    return "KIND_NORMAL_FUNCTION";

  case ::perfetto::protos::pbzero::InternedV8JsFunction_Kind::KIND_MODULE:
    return "KIND_MODULE";

  case ::perfetto::protos::pbzero::InternedV8JsFunction_Kind::KIND_ASYNC_MODULE:
    return "KIND_ASYNC_MODULE";

  case ::perfetto::protos::pbzero::InternedV8JsFunction_Kind::KIND_BASE_CONSTRUCTOR:
    return "KIND_BASE_CONSTRUCTOR";

  case ::perfetto::protos::pbzero::InternedV8JsFunction_Kind::KIND_DEFAULT_BASE_CONSTRUCTOR:
    return "KIND_DEFAULT_BASE_CONSTRUCTOR";

  case ::perfetto::protos::pbzero::InternedV8JsFunction_Kind::KIND_DEFAULT_DERIVED_CONSTRUCTOR:
    return "KIND_DEFAULT_DERIVED_CONSTRUCTOR";

  case ::perfetto::protos::pbzero::InternedV8JsFunction_Kind::KIND_DERIVED_CONSTRUCTOR:
    return "KIND_DERIVED_CONSTRUCTOR";

  case ::perfetto::protos::pbzero::InternedV8JsFunction_Kind::KIND_GETTER_FUNCTION:
    return "KIND_GETTER_FUNCTION";

  case ::perfetto::protos::pbzero::InternedV8JsFunction_Kind::KIND_STATIC_GETTER_FUNCTION:
    return "KIND_STATIC_GETTER_FUNCTION";

  case ::perfetto::protos::pbzero::InternedV8JsFunction_Kind::KIND_SETTER_FUNCTION:
    return "KIND_SETTER_FUNCTION";

  case ::perfetto::protos::pbzero::InternedV8JsFunction_Kind::KIND_STATIC_SETTER_FUNCTION:
    return "KIND_STATIC_SETTER_FUNCTION";

  case ::perfetto::protos::pbzero::InternedV8JsFunction_Kind::KIND_ARROW_FUNCTION:
    return "KIND_ARROW_FUNCTION";

  case ::perfetto::protos::pbzero::InternedV8JsFunction_Kind::KIND_ASYNC_ARROW_FUNCTION:
    return "KIND_ASYNC_ARROW_FUNCTION";

  case ::perfetto::protos::pbzero::InternedV8JsFunction_Kind::KIND_ASYNC_FUNCTION:
    return "KIND_ASYNC_FUNCTION";

  case ::perfetto::protos::pbzero::InternedV8JsFunction_Kind::KIND_ASYNC_CONCISE_METHOD:
    return "KIND_ASYNC_CONCISE_METHOD";

  case ::perfetto::protos::pbzero::InternedV8JsFunction_Kind::KIND_STATIC_ASYNC_CONCISE_METHOD:
    return "KIND_STATIC_ASYNC_CONCISE_METHOD";

  case ::perfetto::protos::pbzero::InternedV8JsFunction_Kind::KIND_ASYNC_CONCISE_GENERATOR_METHOD:
    return "KIND_ASYNC_CONCISE_GENERATOR_METHOD";

  case ::perfetto::protos::pbzero::InternedV8JsFunction_Kind::KIND_STATIC_ASYNC_CONCISE_GENERATOR_METHOD:
    return "KIND_STATIC_ASYNC_CONCISE_GENERATOR_METHOD";

  case ::perfetto::protos::pbzero::InternedV8JsFunction_Kind::KIND_ASYNC_GENERATOR_FUNCTION:
    return "KIND_ASYNC_GENERATOR_FUNCTION";

  case ::perfetto::protos::pbzero::InternedV8JsFunction_Kind::KIND_GENERATOR_FUNCTION:
    return "KIND_GENERATOR_FUNCTION";

  case ::perfetto::protos::pbzero::InternedV8JsFunction_Kind::KIND_CONCISE_GENERATOR_METHOD:
    return "KIND_CONCISE_GENERATOR_METHOD";

  case ::perfetto::protos::pbzero::InternedV8JsFunction_Kind::KIND_STATIC_CONCISE_GENERATOR_METHOD:
    return "KIND_STATIC_CONCISE_GENERATOR_METHOD";

  case ::perfetto::protos::pbzero::InternedV8JsFunction_Kind::KIND_CONCISE_METHOD:
    return "KIND_CONCISE_METHOD";

  case ::perfetto::protos::pbzero::InternedV8JsFunction_Kind::KIND_STATIC_CONCISE_METHOD:
    return "KIND_STATIC_CONCISE_METHOD";

  case ::perfetto::protos::pbzero::InternedV8JsFunction_Kind::KIND_CLASS_MEMBERS_INITIALIZER_FUNCTION:
    return "KIND_CLASS_MEMBERS_INITIALIZER_FUNCTION";

  case ::perfetto::protos::pbzero::InternedV8JsFunction_Kind::KIND_CLASS_STATIC_INITIALIZER_FUNCTION:
    return "KIND_CLASS_STATIC_INITIALIZER_FUNCTION";

  case ::perfetto::protos::pbzero::InternedV8JsFunction_Kind::KIND_INVALID:
    return "KIND_INVALID";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_InternedV8JsScript {
enum Type : int32_t {
  TYPE_UNKNOWN = 0,
  TYPE_NORMAL = 1,
  TYPE_EVAL = 2,
  TYPE_MODULE = 3,
  TYPE_NATIVE = 4,
  TYPE_EXTENSION = 5,
  TYPE_INSPECTOR = 6,
};
} // namespace perfetto_pbzero_enum_InternedV8JsScript
using InternedV8JsScript_Type = perfetto_pbzero_enum_InternedV8JsScript::Type;


constexpr InternedV8JsScript_Type InternedV8JsScript_Type_MIN = InternedV8JsScript_Type::TYPE_UNKNOWN;
constexpr InternedV8JsScript_Type InternedV8JsScript_Type_MAX = InternedV8JsScript_Type::TYPE_INSPECTOR;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* InternedV8JsScript_Type_Name(::perfetto::protos::pbzero::InternedV8JsScript_Type value) {
  switch (value) {
  case ::perfetto::protos::pbzero::InternedV8JsScript_Type::TYPE_UNKNOWN:
    return "TYPE_UNKNOWN";

  case ::perfetto::protos::pbzero::InternedV8JsScript_Type::TYPE_NORMAL:
    return "TYPE_NORMAL";

  case ::perfetto::protos::pbzero::InternedV8JsScript_Type::TYPE_EVAL:
    return "TYPE_EVAL";

  case ::perfetto::protos::pbzero::InternedV8JsScript_Type::TYPE_MODULE:
    return "TYPE_MODULE";

  case ::perfetto::protos::pbzero::InternedV8JsScript_Type::TYPE_NATIVE:
    return "TYPE_NATIVE";

  case ::perfetto::protos::pbzero::InternedV8JsScript_Type::TYPE_EXTENSION:
    return "TYPE_EXTENSION";

  case ::perfetto::protos::pbzero::InternedV8JsScript_Type::TYPE_INSPECTOR:
    return "TYPE_INSPECTOR";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

class V8CodeDefaults_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  V8CodeDefaults_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit V8CodeDefaults_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit V8CodeDefaults_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_tid() const { return at<1>().valid(); }
  uint32_t tid() const { return at<1>().as_uint32(); }
};

class V8CodeDefaults : public ::protozero::Message {
 public:
  using Decoder = V8CodeDefaults_Decoder;
  enum : int32_t {
    kTidFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.V8CodeDefaults"; }


  using FieldMetadata_Tid =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      V8CodeDefaults>;

  static constexpr FieldMetadata_Tid kTid{};
  void set_tid(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Tid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }
};

class V8CodeMove_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  V8CodeMove_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit V8CodeMove_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit V8CodeMove_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_isolate_iid() const { return at<1>().valid(); }
  uint64_t isolate_iid() const { return at<1>().as_uint64(); }
  bool has_tid() const { return at<2>().valid(); }
  uint32_t tid() const { return at<2>().as_uint32(); }
  bool has_from_instruction_start_address() const { return at<3>().valid(); }
  uint64_t from_instruction_start_address() const { return at<3>().as_uint64(); }
  bool has_to_instruction_start_address() const { return at<4>().valid(); }
  uint64_t to_instruction_start_address() const { return at<4>().as_uint64(); }
  bool has_instruction_size_bytes() const { return at<5>().valid(); }
  uint64_t instruction_size_bytes() const { return at<5>().as_uint64(); }
  bool has_to_machine_code() const { return at<6>().valid(); }
  ::protozero::ConstBytes to_machine_code() const { return at<6>().as_bytes(); }
  bool has_to_bytecode() const { return at<7>().valid(); }
  ::protozero::ConstBytes to_bytecode() const { return at<7>().as_bytes(); }
};

class V8CodeMove : public ::protozero::Message {
 public:
  using Decoder = V8CodeMove_Decoder;
  enum : int32_t {
    kIsolateIidFieldNumber = 1,
    kTidFieldNumber = 2,
    kFromInstructionStartAddressFieldNumber = 3,
    kToInstructionStartAddressFieldNumber = 4,
    kInstructionSizeBytesFieldNumber = 5,
    kToMachineCodeFieldNumber = 6,
    kToBytecodeFieldNumber = 7,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.V8CodeMove"; }


  using FieldMetadata_IsolateIid =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      V8CodeMove>;

  static constexpr FieldMetadata_IsolateIid kIsolateIid{};
  void set_isolate_iid(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_IsolateIid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Tid =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      V8CodeMove>;

  static constexpr FieldMetadata_Tid kTid{};
  void set_tid(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Tid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_FromInstructionStartAddress =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      V8CodeMove>;

  static constexpr FieldMetadata_FromInstructionStartAddress kFromInstructionStartAddress{};
  void set_from_instruction_start_address(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_FromInstructionStartAddress::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ToInstructionStartAddress =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      V8CodeMove>;

  static constexpr FieldMetadata_ToInstructionStartAddress kToInstructionStartAddress{};
  void set_to_instruction_start_address(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ToInstructionStartAddress::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_InstructionSizeBytes =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      V8CodeMove>;

  static constexpr FieldMetadata_InstructionSizeBytes kInstructionSizeBytes{};
  void set_instruction_size_bytes(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_InstructionSizeBytes::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ToMachineCode =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBytes,
      std::string,
      V8CodeMove>;

  static constexpr FieldMetadata_ToMachineCode kToMachineCode{};
  void set_to_machine_code(const uint8_t* data, size_t size) {
    AppendBytes(FieldMetadata_ToMachineCode::kFieldId, data, size);
  }
  void set_to_machine_code(::protozero::ConstBytes bytes) {
    AppendBytes(FieldMetadata_ToMachineCode::kFieldId, bytes.data, bytes.size);
  }
  void set_to_machine_code(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_ToMachineCode::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBytes>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ToBytecode =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBytes,
      std::string,
      V8CodeMove>;

  static constexpr FieldMetadata_ToBytecode kToBytecode{};
  void set_to_bytecode(const uint8_t* data, size_t size) {
    AppendBytes(FieldMetadata_ToBytecode::kFieldId, data, size);
  }
  void set_to_bytecode(::protozero::ConstBytes bytes) {
    AppendBytes(FieldMetadata_ToBytecode::kFieldId, bytes.data, bytes.size);
  }
  void set_to_bytecode(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_ToBytecode::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBytes>
        ::Append(*this, field_id, value);
  }
};

class V8RegExpCode_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  V8RegExpCode_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit V8RegExpCode_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit V8RegExpCode_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_v8_isolate_iid() const { return at<1>().valid(); }
  uint64_t v8_isolate_iid() const { return at<1>().as_uint64(); }
  bool has_tid() const { return at<2>().valid(); }
  uint32_t tid() const { return at<2>().as_uint32(); }
  bool has_pattern() const { return at<3>().valid(); }
  ::protozero::ConstBytes pattern() const { return at<3>().as_bytes(); }
  bool has_instruction_start() const { return at<4>().valid(); }
  uint64_t instruction_start() const { return at<4>().as_uint64(); }
  bool has_instruction_size_bytes() const { return at<5>().valid(); }
  uint64_t instruction_size_bytes() const { return at<5>().as_uint64(); }
  bool has_machine_code() const { return at<6>().valid(); }
  ::protozero::ConstBytes machine_code() const { return at<6>().as_bytes(); }
};

class V8RegExpCode : public ::protozero::Message {
 public:
  using Decoder = V8RegExpCode_Decoder;
  enum : int32_t {
    kV8IsolateIidFieldNumber = 1,
    kTidFieldNumber = 2,
    kPatternFieldNumber = 3,
    kInstructionStartFieldNumber = 4,
    kInstructionSizeBytesFieldNumber = 5,
    kMachineCodeFieldNumber = 6,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.V8RegExpCode"; }


  using FieldMetadata_V8IsolateIid =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      V8RegExpCode>;

  static constexpr FieldMetadata_V8IsolateIid kV8IsolateIid{};
  void set_v8_isolate_iid(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_V8IsolateIid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Tid =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      V8RegExpCode>;

  static constexpr FieldMetadata_Tid kTid{};
  void set_tid(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Tid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Pattern =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      V8String,
      V8RegExpCode>;

  static constexpr FieldMetadata_Pattern kPattern{};
  template <typename T = V8String> T* set_pattern() {
    return BeginNestedMessage<T>(3);
  }


  using FieldMetadata_InstructionStart =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      V8RegExpCode>;

  static constexpr FieldMetadata_InstructionStart kInstructionStart{};
  void set_instruction_start(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_InstructionStart::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_InstructionSizeBytes =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      V8RegExpCode>;

  static constexpr FieldMetadata_InstructionSizeBytes kInstructionSizeBytes{};
  void set_instruction_size_bytes(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_InstructionSizeBytes::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_MachineCode =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBytes,
      std::string,
      V8RegExpCode>;

  static constexpr FieldMetadata_MachineCode kMachineCode{};
  void set_machine_code(const uint8_t* data, size_t size) {
    AppendBytes(FieldMetadata_MachineCode::kFieldId, data, size);
  }
  void set_machine_code(::protozero::ConstBytes bytes) {
    AppendBytes(FieldMetadata_MachineCode::kFieldId, bytes.data, bytes.size);
  }
  void set_machine_code(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_MachineCode::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBytes>
        ::Append(*this, field_id, value);
  }
};

class V8WasmCode_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/9, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  V8WasmCode_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit V8WasmCode_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit V8WasmCode_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_v8_isolate_iid() const { return at<1>().valid(); }
  uint64_t v8_isolate_iid() const { return at<1>().as_uint64(); }
  bool has_tid() const { return at<2>().valid(); }
  uint32_t tid() const { return at<2>().as_uint32(); }
  bool has_v8_wasm_script_iid() const { return at<3>().valid(); }
  uint64_t v8_wasm_script_iid() const { return at<3>().as_uint64(); }
  bool has_function_name() const { return at<4>().valid(); }
  ::protozero::ConstChars function_name() const { return at<4>().as_string(); }
  bool has_tier() const { return at<5>().valid(); }
  int32_t tier() const { return at<5>().as_int32(); }
  bool has_code_offset_in_module() const { return at<6>().valid(); }
  int32_t code_offset_in_module() const { return at<6>().as_int32(); }
  bool has_instruction_start() const { return at<7>().valid(); }
  uint64_t instruction_start() const { return at<7>().as_uint64(); }
  bool has_instruction_size_bytes() const { return at<8>().valid(); }
  uint64_t instruction_size_bytes() const { return at<8>().as_uint64(); }
  bool has_machine_code() const { return at<9>().valid(); }
  ::protozero::ConstBytes machine_code() const { return at<9>().as_bytes(); }
};

class V8WasmCode : public ::protozero::Message {
 public:
  using Decoder = V8WasmCode_Decoder;
  enum : int32_t {
    kV8IsolateIidFieldNumber = 1,
    kTidFieldNumber = 2,
    kV8WasmScriptIidFieldNumber = 3,
    kFunctionNameFieldNumber = 4,
    kTierFieldNumber = 5,
    kCodeOffsetInModuleFieldNumber = 6,
    kInstructionStartFieldNumber = 7,
    kInstructionSizeBytesFieldNumber = 8,
    kMachineCodeFieldNumber = 9,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.V8WasmCode"; }


  using Tier = ::perfetto::protos::pbzero::V8WasmCode_Tier;
  static inline const char* Tier_Name(Tier value) {
    return ::perfetto::protos::pbzero::V8WasmCode_Tier_Name(value);
  }
  static inline const Tier TIER_UNKNOWN = Tier::TIER_UNKNOWN;
  static inline const Tier TIER_LIFTOFF = Tier::TIER_LIFTOFF;
  static inline const Tier TIER_TURBOFAN = Tier::TIER_TURBOFAN;

  using FieldMetadata_V8IsolateIid =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      V8WasmCode>;

  static constexpr FieldMetadata_V8IsolateIid kV8IsolateIid{};
  void set_v8_isolate_iid(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_V8IsolateIid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Tid =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      V8WasmCode>;

  static constexpr FieldMetadata_Tid kTid{};
  void set_tid(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Tid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_V8WasmScriptIid =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      V8WasmCode>;

  static constexpr FieldMetadata_V8WasmScriptIid kV8WasmScriptIid{};
  void set_v8_wasm_script_iid(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_V8WasmScriptIid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_FunctionName =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      V8WasmCode>;

  static constexpr FieldMetadata_FunctionName kFunctionName{};
  void set_function_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_FunctionName::kFieldId, data, size);
  }
  void set_function_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_FunctionName::kFieldId, chars.data, chars.size);
  }
  void set_function_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_FunctionName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Tier =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      V8WasmCode_Tier,
      V8WasmCode>;

  static constexpr FieldMetadata_Tier kTier{};
  void set_tier(V8WasmCode_Tier value) {
    static constexpr uint32_t field_id = FieldMetadata_Tier::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_CodeOffsetInModule =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      V8WasmCode>;

  static constexpr FieldMetadata_CodeOffsetInModule kCodeOffsetInModule{};
  void set_code_offset_in_module(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_CodeOffsetInModule::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_InstructionStart =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      V8WasmCode>;

  static constexpr FieldMetadata_InstructionStart kInstructionStart{};
  void set_instruction_start(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_InstructionStart::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_InstructionSizeBytes =
    ::protozero::proto_utils::FieldMetadata<
      8,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      V8WasmCode>;

  static constexpr FieldMetadata_InstructionSizeBytes kInstructionSizeBytes{};
  void set_instruction_size_bytes(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_InstructionSizeBytes::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_MachineCode =
    ::protozero::proto_utils::FieldMetadata<
      9,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBytes,
      std::string,
      V8WasmCode>;

  static constexpr FieldMetadata_MachineCode kMachineCode{};
  void set_machine_code(const uint8_t* data, size_t size) {
    AppendBytes(FieldMetadata_MachineCode::kFieldId, data, size);
  }
  void set_machine_code(::protozero::ConstBytes bytes) {
    AppendBytes(FieldMetadata_MachineCode::kFieldId, bytes.data, bytes.size);
  }
  void set_machine_code(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_MachineCode::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBytes>
        ::Append(*this, field_id, value);
  }
};

class V8InternalCode_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  V8InternalCode_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit V8InternalCode_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit V8InternalCode_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_v8_isolate_iid() const { return at<1>().valid(); }
  uint64_t v8_isolate_iid() const { return at<1>().as_uint64(); }
  bool has_tid() const { return at<2>().valid(); }
  uint32_t tid() const { return at<2>().as_uint32(); }
  bool has_name() const { return at<3>().valid(); }
  ::protozero::ConstChars name() const { return at<3>().as_string(); }
  bool has_type() const { return at<4>().valid(); }
  int32_t type() const { return at<4>().as_int32(); }
  bool has_builtin_id() const { return at<5>().valid(); }
  int32_t builtin_id() const { return at<5>().as_int32(); }
  bool has_instruction_start() const { return at<6>().valid(); }
  uint64_t instruction_start() const { return at<6>().as_uint64(); }
  bool has_instruction_size_bytes() const { return at<7>().valid(); }
  uint64_t instruction_size_bytes() const { return at<7>().as_uint64(); }
  bool has_machine_code() const { return at<8>().valid(); }
  ::protozero::ConstBytes machine_code() const { return at<8>().as_bytes(); }
};

class V8InternalCode : public ::protozero::Message {
 public:
  using Decoder = V8InternalCode_Decoder;
  enum : int32_t {
    kV8IsolateIidFieldNumber = 1,
    kTidFieldNumber = 2,
    kNameFieldNumber = 3,
    kTypeFieldNumber = 4,
    kBuiltinIdFieldNumber = 5,
    kInstructionStartFieldNumber = 6,
    kInstructionSizeBytesFieldNumber = 7,
    kMachineCodeFieldNumber = 8,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.V8InternalCode"; }


  using Type = ::perfetto::protos::pbzero::V8InternalCode_Type;
  static inline const char* Type_Name(Type value) {
    return ::perfetto::protos::pbzero::V8InternalCode_Type_Name(value);
  }
  static inline const Type TYPE_UNKNOWN = Type::TYPE_UNKNOWN;
  static inline const Type TYPE_BYTECODE_HANDLER = Type::TYPE_BYTECODE_HANDLER;
  static inline const Type TYPE_FOR_TESTING = Type::TYPE_FOR_TESTING;
  static inline const Type TYPE_BUILTIN = Type::TYPE_BUILTIN;
  static inline const Type TYPE_WASM_FUNCTION = Type::TYPE_WASM_FUNCTION;
  static inline const Type TYPE_WASM_TO_CAPI_FUNCTION = Type::TYPE_WASM_TO_CAPI_FUNCTION;
  static inline const Type TYPE_WASM_TO_JS_FUNCTION = Type::TYPE_WASM_TO_JS_FUNCTION;
  static inline const Type TYPE_JS_TO_WASM_FUNCTION = Type::TYPE_JS_TO_WASM_FUNCTION;
  static inline const Type TYPE_JS_TO_JS_FUNCTION = Type::TYPE_JS_TO_JS_FUNCTION;
  static inline const Type TYPE_C_WASM_ENTRY = Type::TYPE_C_WASM_ENTRY;

  using FieldMetadata_V8IsolateIid =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      V8InternalCode>;

  static constexpr FieldMetadata_V8IsolateIid kV8IsolateIid{};
  void set_v8_isolate_iid(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_V8IsolateIid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Tid =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      V8InternalCode>;

  static constexpr FieldMetadata_Tid kTid{};
  void set_tid(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Tid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Name =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      V8InternalCode>;

  static constexpr FieldMetadata_Name kName{};
  void set_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Name::kFieldId, data, size);
  }
  void set_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Name::kFieldId, chars.data, chars.size);
  }
  void set_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Name::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Type =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      V8InternalCode_Type,
      V8InternalCode>;

  static constexpr FieldMetadata_Type kType{};
  void set_type(V8InternalCode_Type value) {
    static constexpr uint32_t field_id = FieldMetadata_Type::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_BuiltinId =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      V8InternalCode>;

  static constexpr FieldMetadata_BuiltinId kBuiltinId{};
  void set_builtin_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_BuiltinId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_InstructionStart =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      V8InternalCode>;

  static constexpr FieldMetadata_InstructionStart kInstructionStart{};
  void set_instruction_start(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_InstructionStart::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_InstructionSizeBytes =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      V8InternalCode>;

  static constexpr FieldMetadata_InstructionSizeBytes kInstructionSizeBytes{};
  void set_instruction_size_bytes(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_InstructionSizeBytes::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_MachineCode =
    ::protozero::proto_utils::FieldMetadata<
      8,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBytes,
      std::string,
      V8InternalCode>;

  static constexpr FieldMetadata_MachineCode kMachineCode{};
  void set_machine_code(const uint8_t* data, size_t size) {
    AppendBytes(FieldMetadata_MachineCode::kFieldId, data, size);
  }
  void set_machine_code(::protozero::ConstBytes bytes) {
    AppendBytes(FieldMetadata_MachineCode::kFieldId, bytes.data, bytes.size);
  }
  void set_machine_code(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_MachineCode::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBytes>
        ::Append(*this, field_id, value);
  }
};

class V8JsCode_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  V8JsCode_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit V8JsCode_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit V8JsCode_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_v8_isolate_iid() const { return at<1>().valid(); }
  uint64_t v8_isolate_iid() const { return at<1>().as_uint64(); }
  bool has_tid() const { return at<2>().valid(); }
  uint32_t tid() const { return at<2>().as_uint32(); }
  bool has_v8_js_function_iid() const { return at<3>().valid(); }
  uint64_t v8_js_function_iid() const { return at<3>().as_uint64(); }
  bool has_tier() const { return at<4>().valid(); }
  int32_t tier() const { return at<4>().as_int32(); }
  bool has_instruction_start() const { return at<5>().valid(); }
  uint64_t instruction_start() const { return at<5>().as_uint64(); }
  bool has_instruction_size_bytes() const { return at<6>().valid(); }
  uint64_t instruction_size_bytes() const { return at<6>().as_uint64(); }
  bool has_machine_code() const { return at<7>().valid(); }
  ::protozero::ConstBytes machine_code() const { return at<7>().as_bytes(); }
  bool has_bytecode() const { return at<8>().valid(); }
  ::protozero::ConstBytes bytecode() const { return at<8>().as_bytes(); }
};

class V8JsCode : public ::protozero::Message {
 public:
  using Decoder = V8JsCode_Decoder;
  enum : int32_t {
    kV8IsolateIidFieldNumber = 1,
    kTidFieldNumber = 2,
    kV8JsFunctionIidFieldNumber = 3,
    kTierFieldNumber = 4,
    kInstructionStartFieldNumber = 5,
    kInstructionSizeBytesFieldNumber = 6,
    kMachineCodeFieldNumber = 7,
    kBytecodeFieldNumber = 8,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.V8JsCode"; }


  using Tier = ::perfetto::protos::pbzero::V8JsCode_Tier;
  static inline const char* Tier_Name(Tier value) {
    return ::perfetto::protos::pbzero::V8JsCode_Tier_Name(value);
  }
  static inline const Tier TIER_UNKNOWN = Tier::TIER_UNKNOWN;
  static inline const Tier TIER_IGNITION = Tier::TIER_IGNITION;
  static inline const Tier TIER_SPARKPLUG = Tier::TIER_SPARKPLUG;
  static inline const Tier TIER_MAGLEV = Tier::TIER_MAGLEV;
  static inline const Tier TIER_TURBOSHAFT = Tier::TIER_TURBOSHAFT;
  static inline const Tier TIER_TURBOFAN = Tier::TIER_TURBOFAN;

  using FieldMetadata_V8IsolateIid =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      V8JsCode>;

  static constexpr FieldMetadata_V8IsolateIid kV8IsolateIid{};
  void set_v8_isolate_iid(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_V8IsolateIid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Tid =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      V8JsCode>;

  static constexpr FieldMetadata_Tid kTid{};
  void set_tid(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Tid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_V8JsFunctionIid =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      V8JsCode>;

  static constexpr FieldMetadata_V8JsFunctionIid kV8JsFunctionIid{};
  void set_v8_js_function_iid(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_V8JsFunctionIid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Tier =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      V8JsCode_Tier,
      V8JsCode>;

  static constexpr FieldMetadata_Tier kTier{};
  void set_tier(V8JsCode_Tier value) {
    static constexpr uint32_t field_id = FieldMetadata_Tier::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_InstructionStart =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      V8JsCode>;

  static constexpr FieldMetadata_InstructionStart kInstructionStart{};
  void set_instruction_start(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_InstructionStart::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_InstructionSizeBytes =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      V8JsCode>;

  static constexpr FieldMetadata_InstructionSizeBytes kInstructionSizeBytes{};
  void set_instruction_size_bytes(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_InstructionSizeBytes::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_MachineCode =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBytes,
      std::string,
      V8JsCode>;

  static constexpr FieldMetadata_MachineCode kMachineCode{};
  void set_machine_code(const uint8_t* data, size_t size) {
    AppendBytes(FieldMetadata_MachineCode::kFieldId, data, size);
  }
  void set_machine_code(::protozero::ConstBytes bytes) {
    AppendBytes(FieldMetadata_MachineCode::kFieldId, bytes.data, bytes.size);
  }
  void set_machine_code(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_MachineCode::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBytes>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Bytecode =
    ::protozero::proto_utils::FieldMetadata<
      8,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBytes,
      std::string,
      V8JsCode>;

  static constexpr FieldMetadata_Bytecode kBytecode{};
  void set_bytecode(const uint8_t* data, size_t size) {
    AppendBytes(FieldMetadata_Bytecode::kFieldId, data, size);
  }
  void set_bytecode(::protozero::ConstBytes bytes) {
    AppendBytes(FieldMetadata_Bytecode::kFieldId, bytes.data, bytes.size);
  }
  void set_bytecode(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Bytecode::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBytes>
        ::Append(*this, field_id, value);
  }
};

class InternedV8Isolate_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  InternedV8Isolate_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit InternedV8Isolate_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit InternedV8Isolate_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_iid() const { return at<1>().valid(); }
  uint64_t iid() const { return at<1>().as_uint64(); }
  bool has_pid() const { return at<2>().valid(); }
  uint32_t pid() const { return at<2>().as_uint32(); }
  bool has_isolate_id() const { return at<3>().valid(); }
  int32_t isolate_id() const { return at<3>().as_int32(); }
  bool has_code_range() const { return at<4>().valid(); }
  ::protozero::ConstBytes code_range() const { return at<4>().as_bytes(); }
  bool has_embedded_blob_code_start_address() const { return at<5>().valid(); }
  uint64_t embedded_blob_code_start_address() const { return at<5>().as_uint64(); }
  bool has_embedded_blob_code_size() const { return at<6>().valid(); }
  uint64_t embedded_blob_code_size() const { return at<6>().as_uint64(); }
};

class InternedV8Isolate : public ::protozero::Message {
 public:
  using Decoder = InternedV8Isolate_Decoder;
  enum : int32_t {
    kIidFieldNumber = 1,
    kPidFieldNumber = 2,
    kIsolateIdFieldNumber = 3,
    kCodeRangeFieldNumber = 4,
    kEmbeddedBlobCodeStartAddressFieldNumber = 5,
    kEmbeddedBlobCodeSizeFieldNumber = 6,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.InternedV8Isolate"; }

  using CodeRange = ::perfetto::protos::pbzero::InternedV8Isolate_CodeRange;

  using FieldMetadata_Iid =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      InternedV8Isolate>;

  static constexpr FieldMetadata_Iid kIid{};
  void set_iid(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Iid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Pid =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      InternedV8Isolate>;

  static constexpr FieldMetadata_Pid kPid{};
  void set_pid(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Pid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IsolateId =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      InternedV8Isolate>;

  static constexpr FieldMetadata_IsolateId kIsolateId{};
  void set_isolate_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_IsolateId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_CodeRange =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      InternedV8Isolate_CodeRange,
      InternedV8Isolate>;

  static constexpr FieldMetadata_CodeRange kCodeRange{};
  template <typename T = InternedV8Isolate_CodeRange> T* set_code_range() {
    return BeginNestedMessage<T>(4);
  }


  using FieldMetadata_EmbeddedBlobCodeStartAddress =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      InternedV8Isolate>;

  static constexpr FieldMetadata_EmbeddedBlobCodeStartAddress kEmbeddedBlobCodeStartAddress{};
  void set_embedded_blob_code_start_address(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_EmbeddedBlobCodeStartAddress::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_EmbeddedBlobCodeSize =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      InternedV8Isolate>;

  static constexpr FieldMetadata_EmbeddedBlobCodeSize kEmbeddedBlobCodeSize{};
  void set_embedded_blob_code_size(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_EmbeddedBlobCodeSize::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }
};

class InternedV8Isolate_CodeRange_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  InternedV8Isolate_CodeRange_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit InternedV8Isolate_CodeRange_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit InternedV8Isolate_CodeRange_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_base_address() const { return at<1>().valid(); }
  uint64_t base_address() const { return at<1>().as_uint64(); }
  bool has_size() const { return at<2>().valid(); }
  uint64_t size() const { return at<2>().as_uint64(); }
  bool has_embedded_blob_code_copy_start_address() const { return at<3>().valid(); }
  uint64_t embedded_blob_code_copy_start_address() const { return at<3>().as_uint64(); }
  bool has_is_process_wide() const { return at<4>().valid(); }
  bool is_process_wide() const { return at<4>().as_bool(); }
};

class InternedV8Isolate_CodeRange : public ::protozero::Message {
 public:
  using Decoder = InternedV8Isolate_CodeRange_Decoder;
  enum : int32_t {
    kBaseAddressFieldNumber = 1,
    kSizeFieldNumber = 2,
    kEmbeddedBlobCodeCopyStartAddressFieldNumber = 3,
    kIsProcessWideFieldNumber = 4,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.InternedV8Isolate.CodeRange"; }


  using FieldMetadata_BaseAddress =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      InternedV8Isolate_CodeRange>;

  static constexpr FieldMetadata_BaseAddress kBaseAddress{};
  void set_base_address(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_BaseAddress::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Size =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      InternedV8Isolate_CodeRange>;

  static constexpr FieldMetadata_Size kSize{};
  void set_size(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Size::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_EmbeddedBlobCodeCopyStartAddress =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      InternedV8Isolate_CodeRange>;

  static constexpr FieldMetadata_EmbeddedBlobCodeCopyStartAddress kEmbeddedBlobCodeCopyStartAddress{};
  void set_embedded_blob_code_copy_start_address(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_EmbeddedBlobCodeCopyStartAddress::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IsProcessWide =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      InternedV8Isolate_CodeRange>;

  static constexpr FieldMetadata_IsProcessWide kIsProcessWide{};
  void set_is_process_wide(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsProcessWide::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }
};

class InternedV8JsFunction_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  InternedV8JsFunction_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit InternedV8JsFunction_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit InternedV8JsFunction_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_iid() const { return at<1>().valid(); }
  uint64_t iid() const { return at<1>().as_uint64(); }
  bool has_v8_js_function_name_iid() const { return at<2>().valid(); }
  uint64_t v8_js_function_name_iid() const { return at<2>().as_uint64(); }
  bool has_v8_js_script_iid() const { return at<3>().valid(); }
  uint64_t v8_js_script_iid() const { return at<3>().as_uint64(); }
  bool has_is_toplevel() const { return at<4>().valid(); }
  bool is_toplevel() const { return at<4>().as_bool(); }
  bool has_kind() const { return at<5>().valid(); }
  int32_t kind() const { return at<5>().as_int32(); }
  bool has_byte_offset() const { return at<6>().valid(); }
  uint32_t byte_offset() const { return at<6>().as_uint32(); }
};

class InternedV8JsFunction : public ::protozero::Message {
 public:
  using Decoder = InternedV8JsFunction_Decoder;
  enum : int32_t {
    kIidFieldNumber = 1,
    kV8JsFunctionNameIidFieldNumber = 2,
    kV8JsScriptIidFieldNumber = 3,
    kIsToplevelFieldNumber = 4,
    kKindFieldNumber = 5,
    kByteOffsetFieldNumber = 6,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.InternedV8JsFunction"; }


  using Kind = ::perfetto::protos::pbzero::InternedV8JsFunction_Kind;
  static inline const char* Kind_Name(Kind value) {
    return ::perfetto::protos::pbzero::InternedV8JsFunction_Kind_Name(value);
  }
  static inline const Kind KIND_UNKNOWN = Kind::KIND_UNKNOWN;
  static inline const Kind KIND_NORMAL_FUNCTION = Kind::KIND_NORMAL_FUNCTION;
  static inline const Kind KIND_MODULE = Kind::KIND_MODULE;
  static inline const Kind KIND_ASYNC_MODULE = Kind::KIND_ASYNC_MODULE;
  static inline const Kind KIND_BASE_CONSTRUCTOR = Kind::KIND_BASE_CONSTRUCTOR;
  static inline const Kind KIND_DEFAULT_BASE_CONSTRUCTOR = Kind::KIND_DEFAULT_BASE_CONSTRUCTOR;
  static inline const Kind KIND_DEFAULT_DERIVED_CONSTRUCTOR = Kind::KIND_DEFAULT_DERIVED_CONSTRUCTOR;
  static inline const Kind KIND_DERIVED_CONSTRUCTOR = Kind::KIND_DERIVED_CONSTRUCTOR;
  static inline const Kind KIND_GETTER_FUNCTION = Kind::KIND_GETTER_FUNCTION;
  static inline const Kind KIND_STATIC_GETTER_FUNCTION = Kind::KIND_STATIC_GETTER_FUNCTION;
  static inline const Kind KIND_SETTER_FUNCTION = Kind::KIND_SETTER_FUNCTION;
  static inline const Kind KIND_STATIC_SETTER_FUNCTION = Kind::KIND_STATIC_SETTER_FUNCTION;
  static inline const Kind KIND_ARROW_FUNCTION = Kind::KIND_ARROW_FUNCTION;
  static inline const Kind KIND_ASYNC_ARROW_FUNCTION = Kind::KIND_ASYNC_ARROW_FUNCTION;
  static inline const Kind KIND_ASYNC_FUNCTION = Kind::KIND_ASYNC_FUNCTION;
  static inline const Kind KIND_ASYNC_CONCISE_METHOD = Kind::KIND_ASYNC_CONCISE_METHOD;
  static inline const Kind KIND_STATIC_ASYNC_CONCISE_METHOD = Kind::KIND_STATIC_ASYNC_CONCISE_METHOD;
  static inline const Kind KIND_ASYNC_CONCISE_GENERATOR_METHOD = Kind::KIND_ASYNC_CONCISE_GENERATOR_METHOD;
  static inline const Kind KIND_STATIC_ASYNC_CONCISE_GENERATOR_METHOD = Kind::KIND_STATIC_ASYNC_CONCISE_GENERATOR_METHOD;
  static inline const Kind KIND_ASYNC_GENERATOR_FUNCTION = Kind::KIND_ASYNC_GENERATOR_FUNCTION;
  static inline const Kind KIND_GENERATOR_FUNCTION = Kind::KIND_GENERATOR_FUNCTION;
  static inline const Kind KIND_CONCISE_GENERATOR_METHOD = Kind::KIND_CONCISE_GENERATOR_METHOD;
  static inline const Kind KIND_STATIC_CONCISE_GENERATOR_METHOD = Kind::KIND_STATIC_CONCISE_GENERATOR_METHOD;
  static inline const Kind KIND_CONCISE_METHOD = Kind::KIND_CONCISE_METHOD;
  static inline const Kind KIND_STATIC_CONCISE_METHOD = Kind::KIND_STATIC_CONCISE_METHOD;
  static inline const Kind KIND_CLASS_MEMBERS_INITIALIZER_FUNCTION = Kind::KIND_CLASS_MEMBERS_INITIALIZER_FUNCTION;
  static inline const Kind KIND_CLASS_STATIC_INITIALIZER_FUNCTION = Kind::KIND_CLASS_STATIC_INITIALIZER_FUNCTION;
  static inline const Kind KIND_INVALID = Kind::KIND_INVALID;

  using FieldMetadata_Iid =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      InternedV8JsFunction>;

  static constexpr FieldMetadata_Iid kIid{};
  void set_iid(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Iid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_V8JsFunctionNameIid =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      InternedV8JsFunction>;

  static constexpr FieldMetadata_V8JsFunctionNameIid kV8JsFunctionNameIid{};
  void set_v8_js_function_name_iid(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_V8JsFunctionNameIid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_V8JsScriptIid =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      InternedV8JsFunction>;

  static constexpr FieldMetadata_V8JsScriptIid kV8JsScriptIid{};
  void set_v8_js_script_iid(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_V8JsScriptIid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IsToplevel =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      InternedV8JsFunction>;

  static constexpr FieldMetadata_IsToplevel kIsToplevel{};
  void set_is_toplevel(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsToplevel::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Kind =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      InternedV8JsFunction_Kind,
      InternedV8JsFunction>;

  static constexpr FieldMetadata_Kind kKind{};
  void set_kind(InternedV8JsFunction_Kind value) {
    static constexpr uint32_t field_id = FieldMetadata_Kind::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ByteOffset =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      InternedV8JsFunction>;

  static constexpr FieldMetadata_ByteOffset kByteOffset{};
  void set_byte_offset(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ByteOffset::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }
};

class InternedV8WasmScript_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  InternedV8WasmScript_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit InternedV8WasmScript_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit InternedV8WasmScript_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_iid() const { return at<1>().valid(); }
  uint64_t iid() const { return at<1>().as_uint64(); }
  bool has_script_id() const { return at<2>().valid(); }
  int32_t script_id() const { return at<2>().as_int32(); }
  bool has_url() const { return at<3>().valid(); }
  ::protozero::ConstChars url() const { return at<3>().as_string(); }
};

class InternedV8WasmScript : public ::protozero::Message {
 public:
  using Decoder = InternedV8WasmScript_Decoder;
  enum : int32_t {
    kIidFieldNumber = 1,
    kScriptIdFieldNumber = 2,
    kUrlFieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.InternedV8WasmScript"; }


  using FieldMetadata_Iid =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      InternedV8WasmScript>;

  static constexpr FieldMetadata_Iid kIid{};
  void set_iid(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Iid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ScriptId =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      InternedV8WasmScript>;

  static constexpr FieldMetadata_ScriptId kScriptId{};
  void set_script_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ScriptId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Url =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      InternedV8WasmScript>;

  static constexpr FieldMetadata_Url kUrl{};
  void set_url(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Url::kFieldId, data, size);
  }
  void set_url(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Url::kFieldId, chars.data, chars.size);
  }
  void set_url(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Url::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }
};

class InternedV8JsScript_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  InternedV8JsScript_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit InternedV8JsScript_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit InternedV8JsScript_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_iid() const { return at<1>().valid(); }
  uint64_t iid() const { return at<1>().as_uint64(); }
  bool has_script_id() const { return at<2>().valid(); }
  int32_t script_id() const { return at<2>().as_int32(); }
  bool has_type() const { return at<3>().valid(); }
  int32_t type() const { return at<3>().as_int32(); }
  bool has_name() const { return at<4>().valid(); }
  ::protozero::ConstBytes name() const { return at<4>().as_bytes(); }
  bool has_source() const { return at<5>().valid(); }
  ::protozero::ConstBytes source() const { return at<5>().as_bytes(); }
};

class InternedV8JsScript : public ::protozero::Message {
 public:
  using Decoder = InternedV8JsScript_Decoder;
  enum : int32_t {
    kIidFieldNumber = 1,
    kScriptIdFieldNumber = 2,
    kTypeFieldNumber = 3,
    kNameFieldNumber = 4,
    kSourceFieldNumber = 5,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.InternedV8JsScript"; }


  using Type = ::perfetto::protos::pbzero::InternedV8JsScript_Type;
  static inline const char* Type_Name(Type value) {
    return ::perfetto::protos::pbzero::InternedV8JsScript_Type_Name(value);
  }
  static inline const Type TYPE_UNKNOWN = Type::TYPE_UNKNOWN;
  static inline const Type TYPE_NORMAL = Type::TYPE_NORMAL;
  static inline const Type TYPE_EVAL = Type::TYPE_EVAL;
  static inline const Type TYPE_MODULE = Type::TYPE_MODULE;
  static inline const Type TYPE_NATIVE = Type::TYPE_NATIVE;
  static inline const Type TYPE_EXTENSION = Type::TYPE_EXTENSION;
  static inline const Type TYPE_INSPECTOR = Type::TYPE_INSPECTOR;

  using FieldMetadata_Iid =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      InternedV8JsScript>;

  static constexpr FieldMetadata_Iid kIid{};
  void set_iid(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Iid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ScriptId =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      InternedV8JsScript>;

  static constexpr FieldMetadata_ScriptId kScriptId{};
  void set_script_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ScriptId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Type =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      InternedV8JsScript_Type,
      InternedV8JsScript>;

  static constexpr FieldMetadata_Type kType{};
  void set_type(InternedV8JsScript_Type value) {
    static constexpr uint32_t field_id = FieldMetadata_Type::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Name =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      V8String,
      InternedV8JsScript>;

  static constexpr FieldMetadata_Name kName{};
  template <typename T = V8String> T* set_name() {
    return BeginNestedMessage<T>(4);
  }


  using FieldMetadata_Source =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      V8String,
      InternedV8JsScript>;

  static constexpr FieldMetadata_Source kSource{};
  template <typename T = V8String> T* set_source() {
    return BeginNestedMessage<T>(5);
  }

};

class InternedV8String_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  InternedV8String_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit InternedV8String_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit InternedV8String_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_iid() const { return at<1>().valid(); }
  uint64_t iid() const { return at<1>().as_uint64(); }
  bool has_latin1() const { return at<2>().valid(); }
  ::protozero::ConstBytes latin1() const { return at<2>().as_bytes(); }
  bool has_utf16_le() const { return at<3>().valid(); }
  ::protozero::ConstBytes utf16_le() const { return at<3>().as_bytes(); }
  bool has_utf16_be() const { return at<4>().valid(); }
  ::protozero::ConstBytes utf16_be() const { return at<4>().as_bytes(); }
};

class InternedV8String : public ::protozero::Message {
 public:
  using Decoder = InternedV8String_Decoder;
  enum : int32_t {
    kIidFieldNumber = 1,
    kLatin1FieldNumber = 2,
    kUtf16LeFieldNumber = 3,
    kUtf16BeFieldNumber = 4,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.InternedV8String"; }


  using FieldMetadata_Iid =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      InternedV8String>;

  static constexpr FieldMetadata_Iid kIid{};
  void set_iid(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Iid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Latin1 =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBytes,
      std::string,
      InternedV8String>;

  static constexpr FieldMetadata_Latin1 kLatin1{};
  void set_latin1(const uint8_t* data, size_t size) {
    AppendBytes(FieldMetadata_Latin1::kFieldId, data, size);
  }
  void set_latin1(::protozero::ConstBytes bytes) {
    AppendBytes(FieldMetadata_Latin1::kFieldId, bytes.data, bytes.size);
  }
  void set_latin1(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Latin1::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBytes>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Utf16Le =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBytes,
      std::string,
      InternedV8String>;

  static constexpr FieldMetadata_Utf16Le kUtf16Le{};
  void set_utf16_le(const uint8_t* data, size_t size) {
    AppendBytes(FieldMetadata_Utf16Le::kFieldId, data, size);
  }
  void set_utf16_le(::protozero::ConstBytes bytes) {
    AppendBytes(FieldMetadata_Utf16Le::kFieldId, bytes.data, bytes.size);
  }
  void set_utf16_le(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Utf16Le::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBytes>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Utf16Be =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBytes,
      std::string,
      InternedV8String>;

  static constexpr FieldMetadata_Utf16Be kUtf16Be{};
  void set_utf16_be(const uint8_t* data, size_t size) {
    AppendBytes(FieldMetadata_Utf16Be::kFieldId, data, size);
  }
  void set_utf16_be(::protozero::ConstBytes bytes) {
    AppendBytes(FieldMetadata_Utf16Be::kFieldId, bytes.data, bytes.size);
  }
  void set_utf16_be(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Utf16Be::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBytes>
        ::Append(*this, field_id, value);
  }
};

class V8String_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  V8String_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit V8String_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit V8String_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_latin1() const { return at<1>().valid(); }
  ::protozero::ConstBytes latin1() const { return at<1>().as_bytes(); }
  bool has_utf16_le() const { return at<2>().valid(); }
  ::protozero::ConstBytes utf16_le() const { return at<2>().as_bytes(); }
  bool has_utf16_be() const { return at<3>().valid(); }
  ::protozero::ConstBytes utf16_be() const { return at<3>().as_bytes(); }
};

class V8String : public ::protozero::Message {
 public:
  using Decoder = V8String_Decoder;
  enum : int32_t {
    kLatin1FieldNumber = 1,
    kUtf16LeFieldNumber = 2,
    kUtf16BeFieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.V8String"; }


  using FieldMetadata_Latin1 =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBytes,
      std::string,
      V8String>;

  static constexpr FieldMetadata_Latin1 kLatin1{};
  void set_latin1(const uint8_t* data, size_t size) {
    AppendBytes(FieldMetadata_Latin1::kFieldId, data, size);
  }
  void set_latin1(::protozero::ConstBytes bytes) {
    AppendBytes(FieldMetadata_Latin1::kFieldId, bytes.data, bytes.size);
  }
  void set_latin1(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Latin1::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBytes>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Utf16Le =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBytes,
      std::string,
      V8String>;

  static constexpr FieldMetadata_Utf16Le kUtf16Le{};
  void set_utf16_le(const uint8_t* data, size_t size) {
    AppendBytes(FieldMetadata_Utf16Le::kFieldId, data, size);
  }
  void set_utf16_le(::protozero::ConstBytes bytes) {
    AppendBytes(FieldMetadata_Utf16Le::kFieldId, bytes.data, bytes.size);
  }
  void set_utf16_le(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Utf16Le::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBytes>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Utf16Be =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBytes,
      std::string,
      V8String>;

  static constexpr FieldMetadata_Utf16Be kUtf16Be{};
  void set_utf16_be(const uint8_t* data, size_t size) {
    AppendBytes(FieldMetadata_Utf16Be::kFieldId, data, size);
  }
  void set_utf16_be(::protozero::ConstBytes bytes) {
    AppendBytes(FieldMetadata_Utf16Be::kFieldId, bytes.data, bytes.size);
  }
  void set_utf16_be(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Utf16Be::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBytes>
        ::Append(*this, field_id, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
