// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PROCESSOR_TRACE_PROCESSOR_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PROCESSOR_TRACE_PROCESSOR_PROTO_H_

#include <stddef.h>
#include <stdint.h>

#include "perfetto/protozero/field_writer.h"
#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {
class AppendTraceDataResult;
class ComputeMetricArgs;
class ComputeMetricResult;
class DescriptorProto;
class DescriptorSet;
class DisableAndReadMetatraceResult;
class EnableMetatraceArgs;
class QueryArgs;
class QueryResult;
class QueryResult_CellsBatch;
class ResetTraceProcessorArgs;
class StatusResult;
class TraceProcessorRpc;
namespace perfetto_pbzero_enum_ComputeMetricArgs {
enum ResultFormat : int32_t;
}  // namespace perfetto_pbzero_enum_ComputeMetricArgs
using ComputeMetricArgs_ResultFormat = perfetto_pbzero_enum_ComputeMetricArgs::ResultFormat;
enum MetatraceCategories : int32_t;
namespace perfetto_pbzero_enum_QueryResult_CellsBatch {
enum CellType : int32_t;
}  // namespace perfetto_pbzero_enum_QueryResult_CellsBatch
using QueryResult_CellsBatch_CellType = perfetto_pbzero_enum_QueryResult_CellsBatch::CellType;
namespace perfetto_pbzero_enum_ResetTraceProcessorArgs {
enum DropTrackEventDataBefore : int32_t;
}  // namespace perfetto_pbzero_enum_ResetTraceProcessorArgs
using ResetTraceProcessorArgs_DropTrackEventDataBefore = perfetto_pbzero_enum_ResetTraceProcessorArgs::DropTrackEventDataBefore;
namespace perfetto_pbzero_enum_TraceProcessorRpc {
enum TraceProcessorMethod : int32_t;
}  // namespace perfetto_pbzero_enum_TraceProcessorRpc
using TraceProcessorRpc_TraceProcessorMethod = perfetto_pbzero_enum_TraceProcessorRpc::TraceProcessorMethod;
} // Namespace pbzero.
} // Namespace protos.
} // Namespace perfetto.

namespace perfetto {
namespace protos {
namespace pbzero {

enum TraceProcessorApiVersion : int32_t {
  TRACE_PROCESSOR_CURRENT_API_VERSION = 12,
};

constexpr TraceProcessorApiVersion TraceProcessorApiVersion_MIN = TraceProcessorApiVersion::TRACE_PROCESSOR_CURRENT_API_VERSION;
constexpr TraceProcessorApiVersion TraceProcessorApiVersion_MAX = TraceProcessorApiVersion::TRACE_PROCESSOR_CURRENT_API_VERSION;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* TraceProcessorApiVersion_Name(::perfetto::protos::pbzero::TraceProcessorApiVersion value) {
  switch (value) {
  case ::perfetto::protos::pbzero::TraceProcessorApiVersion::TRACE_PROCESSOR_CURRENT_API_VERSION:
    return "TRACE_PROCESSOR_CURRENT_API_VERSION";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_ResetTraceProcessorArgs {
enum DropTrackEventDataBefore : int32_t {
  NO_DROP = 0,
  TRACK_EVENT_RANGE_OF_INTEREST = 1,
};
} // namespace perfetto_pbzero_enum_ResetTraceProcessorArgs
using ResetTraceProcessorArgs_DropTrackEventDataBefore = perfetto_pbzero_enum_ResetTraceProcessorArgs::DropTrackEventDataBefore;


constexpr ResetTraceProcessorArgs_DropTrackEventDataBefore ResetTraceProcessorArgs_DropTrackEventDataBefore_MIN = ResetTraceProcessorArgs_DropTrackEventDataBefore::NO_DROP;
constexpr ResetTraceProcessorArgs_DropTrackEventDataBefore ResetTraceProcessorArgs_DropTrackEventDataBefore_MAX = ResetTraceProcessorArgs_DropTrackEventDataBefore::TRACK_EVENT_RANGE_OF_INTEREST;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* ResetTraceProcessorArgs_DropTrackEventDataBefore_Name(::perfetto::protos::pbzero::ResetTraceProcessorArgs_DropTrackEventDataBefore value) {
  switch (value) {
  case ::perfetto::protos::pbzero::ResetTraceProcessorArgs_DropTrackEventDataBefore::NO_DROP:
    return "NO_DROP";

  case ::perfetto::protos::pbzero::ResetTraceProcessorArgs_DropTrackEventDataBefore::TRACK_EVENT_RANGE_OF_INTEREST:
    return "TRACK_EVENT_RANGE_OF_INTEREST";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_ComputeMetricArgs {
enum ResultFormat : int32_t {
  BINARY_PROTOBUF = 0,
  TEXTPROTO = 1,
  JSON = 2,
};
} // namespace perfetto_pbzero_enum_ComputeMetricArgs
using ComputeMetricArgs_ResultFormat = perfetto_pbzero_enum_ComputeMetricArgs::ResultFormat;


constexpr ComputeMetricArgs_ResultFormat ComputeMetricArgs_ResultFormat_MIN = ComputeMetricArgs_ResultFormat::BINARY_PROTOBUF;
constexpr ComputeMetricArgs_ResultFormat ComputeMetricArgs_ResultFormat_MAX = ComputeMetricArgs_ResultFormat::JSON;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* ComputeMetricArgs_ResultFormat_Name(::perfetto::protos::pbzero::ComputeMetricArgs_ResultFormat value) {
  switch (value) {
  case ::perfetto::protos::pbzero::ComputeMetricArgs_ResultFormat::BINARY_PROTOBUF:
    return "BINARY_PROTOBUF";

  case ::perfetto::protos::pbzero::ComputeMetricArgs_ResultFormat::TEXTPROTO:
    return "TEXTPROTO";

  case ::perfetto::protos::pbzero::ComputeMetricArgs_ResultFormat::JSON:
    return "JSON";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_QueryResult_CellsBatch {
enum CellType : int32_t {
  CELL_INVALID = 0,
  CELL_NULL = 1,
  CELL_VARINT = 2,
  CELL_FLOAT64 = 3,
  CELL_STRING = 4,
  CELL_BLOB = 5,
};
} // namespace perfetto_pbzero_enum_QueryResult_CellsBatch
using QueryResult_CellsBatch_CellType = perfetto_pbzero_enum_QueryResult_CellsBatch::CellType;


constexpr QueryResult_CellsBatch_CellType QueryResult_CellsBatch_CellType_MIN = QueryResult_CellsBatch_CellType::CELL_INVALID;
constexpr QueryResult_CellsBatch_CellType QueryResult_CellsBatch_CellType_MAX = QueryResult_CellsBatch_CellType::CELL_BLOB;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* QueryResult_CellsBatch_CellType_Name(::perfetto::protos::pbzero::QueryResult_CellsBatch_CellType value) {
  switch (value) {
  case ::perfetto::protos::pbzero::QueryResult_CellsBatch_CellType::CELL_INVALID:
    return "CELL_INVALID";

  case ::perfetto::protos::pbzero::QueryResult_CellsBatch_CellType::CELL_NULL:
    return "CELL_NULL";

  case ::perfetto::protos::pbzero::QueryResult_CellsBatch_CellType::CELL_VARINT:
    return "CELL_VARINT";

  case ::perfetto::protos::pbzero::QueryResult_CellsBatch_CellType::CELL_FLOAT64:
    return "CELL_FLOAT64";

  case ::perfetto::protos::pbzero::QueryResult_CellsBatch_CellType::CELL_STRING:
    return "CELL_STRING";

  case ::perfetto::protos::pbzero::QueryResult_CellsBatch_CellType::CELL_BLOB:
    return "CELL_BLOB";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_TraceProcessorRpc {
enum TraceProcessorMethod : int32_t {
  TPM_UNSPECIFIED = 0,
  TPM_APPEND_TRACE_DATA = 1,
  TPM_FINALIZE_TRACE_DATA = 2,
  TPM_QUERY_STREAMING = 3,
  TPM_COMPUTE_METRIC = 5,
  TPM_GET_METRIC_DESCRIPTORS = 6,
  TPM_RESTORE_INITIAL_TABLES = 7,
  TPM_ENABLE_METATRACE = 8,
  TPM_DISABLE_AND_READ_METATRACE = 9,
  TPM_GET_STATUS = 10,
  TPM_RESET_TRACE_PROCESSOR = 11,
};
} // namespace perfetto_pbzero_enum_TraceProcessorRpc
using TraceProcessorRpc_TraceProcessorMethod = perfetto_pbzero_enum_TraceProcessorRpc::TraceProcessorMethod;


constexpr TraceProcessorRpc_TraceProcessorMethod TraceProcessorRpc_TraceProcessorMethod_MIN = TraceProcessorRpc_TraceProcessorMethod::TPM_UNSPECIFIED;
constexpr TraceProcessorRpc_TraceProcessorMethod TraceProcessorRpc_TraceProcessorMethod_MAX = TraceProcessorRpc_TraceProcessorMethod::TPM_RESET_TRACE_PROCESSOR;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* TraceProcessorRpc_TraceProcessorMethod_Name(::perfetto::protos::pbzero::TraceProcessorRpc_TraceProcessorMethod value) {
  switch (value) {
  case ::perfetto::protos::pbzero::TraceProcessorRpc_TraceProcessorMethod::TPM_UNSPECIFIED:
    return "TPM_UNSPECIFIED";

  case ::perfetto::protos::pbzero::TraceProcessorRpc_TraceProcessorMethod::TPM_APPEND_TRACE_DATA:
    return "TPM_APPEND_TRACE_DATA";

  case ::perfetto::protos::pbzero::TraceProcessorRpc_TraceProcessorMethod::TPM_FINALIZE_TRACE_DATA:
    return "TPM_FINALIZE_TRACE_DATA";

  case ::perfetto::protos::pbzero::TraceProcessorRpc_TraceProcessorMethod::TPM_QUERY_STREAMING:
    return "TPM_QUERY_STREAMING";

  case ::perfetto::protos::pbzero::TraceProcessorRpc_TraceProcessorMethod::TPM_COMPUTE_METRIC:
    return "TPM_COMPUTE_METRIC";

  case ::perfetto::protos::pbzero::TraceProcessorRpc_TraceProcessorMethod::TPM_GET_METRIC_DESCRIPTORS:
    return "TPM_GET_METRIC_DESCRIPTORS";

  case ::perfetto::protos::pbzero::TraceProcessorRpc_TraceProcessorMethod::TPM_RESTORE_INITIAL_TABLES:
    return "TPM_RESTORE_INITIAL_TABLES";

  case ::perfetto::protos::pbzero::TraceProcessorRpc_TraceProcessorMethod::TPM_ENABLE_METATRACE:
    return "TPM_ENABLE_METATRACE";

  case ::perfetto::protos::pbzero::TraceProcessorRpc_TraceProcessorMethod::TPM_DISABLE_AND_READ_METATRACE:
    return "TPM_DISABLE_AND_READ_METATRACE";

  case ::perfetto::protos::pbzero::TraceProcessorRpc_TraceProcessorMethod::TPM_GET_STATUS:
    return "TPM_GET_STATUS";

  case ::perfetto::protos::pbzero::TraceProcessorRpc_TraceProcessorMethod::TPM_RESET_TRACE_PROCESSOR:
    return "TPM_RESET_TRACE_PROCESSOR";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

class ResetTraceProcessorArgs_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ResetTraceProcessorArgs_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ResetTraceProcessorArgs_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ResetTraceProcessorArgs_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_drop_track_event_data_before() const { return at<1>().valid(); }
  int32_t drop_track_event_data_before() const { return at<1>().as_int32(); }
  bool has_ingest_ftrace_in_raw_table() const { return at<2>().valid(); }
  bool ingest_ftrace_in_raw_table() const { return at<2>().as_bool(); }
  bool has_analyze_trace_proto_content() const { return at<3>().valid(); }
  bool analyze_trace_proto_content() const { return at<3>().as_bool(); }
  bool has_ftrace_drop_until_all_cpus_valid() const { return at<4>().valid(); }
  bool ftrace_drop_until_all_cpus_valid() const { return at<4>().as_bool(); }
};

class ResetTraceProcessorArgs : public ::protozero::Message {
 public:
  using Decoder = ResetTraceProcessorArgs_Decoder;
  enum : int32_t {
    kDropTrackEventDataBeforeFieldNumber = 1,
    kIngestFtraceInRawTableFieldNumber = 2,
    kAnalyzeTraceProtoContentFieldNumber = 3,
    kFtraceDropUntilAllCpusValidFieldNumber = 4,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ResetTraceProcessorArgs"; }


  using DropTrackEventDataBefore = ::perfetto::protos::pbzero::ResetTraceProcessorArgs_DropTrackEventDataBefore;
  static inline const char* DropTrackEventDataBefore_Name(DropTrackEventDataBefore value) {
    return ::perfetto::protos::pbzero::ResetTraceProcessorArgs_DropTrackEventDataBefore_Name(value);
  }
  static inline const DropTrackEventDataBefore NO_DROP = DropTrackEventDataBefore::NO_DROP;
  static inline const DropTrackEventDataBefore TRACK_EVENT_RANGE_OF_INTEREST = DropTrackEventDataBefore::TRACK_EVENT_RANGE_OF_INTEREST;

  using FieldMetadata_DropTrackEventDataBefore =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ResetTraceProcessorArgs_DropTrackEventDataBefore,
      ResetTraceProcessorArgs>;

  static constexpr FieldMetadata_DropTrackEventDataBefore kDropTrackEventDataBefore{};
  void set_drop_track_event_data_before(ResetTraceProcessorArgs_DropTrackEventDataBefore value) {
    static constexpr uint32_t field_id = FieldMetadata_DropTrackEventDataBefore::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IngestFtraceInRawTable =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ResetTraceProcessorArgs>;

  static constexpr FieldMetadata_IngestFtraceInRawTable kIngestFtraceInRawTable{};
  void set_ingest_ftrace_in_raw_table(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IngestFtraceInRawTable::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_AnalyzeTraceProtoContent =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ResetTraceProcessorArgs>;

  static constexpr FieldMetadata_AnalyzeTraceProtoContent kAnalyzeTraceProtoContent{};
  void set_analyze_trace_proto_content(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_AnalyzeTraceProtoContent::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_FtraceDropUntilAllCpusValid =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ResetTraceProcessorArgs>;

  static constexpr FieldMetadata_FtraceDropUntilAllCpusValid kFtraceDropUntilAllCpusValid{};
  void set_ftrace_drop_until_all_cpus_valid(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_FtraceDropUntilAllCpusValid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }
};

class DescriptorSet_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  DescriptorSet_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DescriptorSet_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DescriptorSet_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_descriptors() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> descriptors() const { return GetRepeated<::protozero::ConstBytes>(1); }
};

class DescriptorSet : public ::protozero::Message {
 public:
  using Decoder = DescriptorSet_Decoder;
  enum : int32_t {
    kDescriptorsFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.DescriptorSet"; }


  using FieldMetadata_Descriptors =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DescriptorProto,
      DescriptorSet>;

  static constexpr FieldMetadata_Descriptors kDescriptors{};
  template <typename T = DescriptorProto> T* add_descriptors() {
    return BeginNestedMessage<T>(1);
  }

};

class DisableAndReadMetatraceResult_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  DisableAndReadMetatraceResult_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DisableAndReadMetatraceResult_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DisableAndReadMetatraceResult_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_metatrace() const { return at<1>().valid(); }
  ::protozero::ConstBytes metatrace() const { return at<1>().as_bytes(); }
  bool has_error() const { return at<2>().valid(); }
  ::protozero::ConstChars error() const { return at<2>().as_string(); }
};

class DisableAndReadMetatraceResult : public ::protozero::Message {
 public:
  using Decoder = DisableAndReadMetatraceResult_Decoder;
  enum : int32_t {
    kMetatraceFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.DisableAndReadMetatraceResult"; }


  using FieldMetadata_Metatrace =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBytes,
      std::string,
      DisableAndReadMetatraceResult>;

  static constexpr FieldMetadata_Metatrace kMetatrace{};
  void set_metatrace(const uint8_t* data, size_t size) {
    AppendBytes(FieldMetadata_Metatrace::kFieldId, data, size);
  }
  void set_metatrace(::protozero::ConstBytes bytes) {
    AppendBytes(FieldMetadata_Metatrace::kFieldId, bytes.data, bytes.size);
  }
  void set_metatrace(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Metatrace::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBytes>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Error =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      DisableAndReadMetatraceResult>;

  static constexpr FieldMetadata_Error kError{};
  void set_error(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Error::kFieldId, data, size);
  }
  void set_error(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Error::kFieldId, chars.data, chars.size);
  }
  void set_error(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Error::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }
};

class DisableAndReadMetatraceArgs_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/0, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  DisableAndReadMetatraceArgs_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DisableAndReadMetatraceArgs_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DisableAndReadMetatraceArgs_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
};

class DisableAndReadMetatraceArgs : public ::protozero::Message {
 public:
  using Decoder = DisableAndReadMetatraceArgs_Decoder;
  static constexpr const char* GetName() { return ".perfetto.protos.DisableAndReadMetatraceArgs"; }

};

class EnableMetatraceResult_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/0, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  EnableMetatraceResult_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit EnableMetatraceResult_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit EnableMetatraceResult_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
};

class EnableMetatraceResult : public ::protozero::Message {
 public:
  using Decoder = EnableMetatraceResult_Decoder;
  static constexpr const char* GetName() { return ".perfetto.protos.EnableMetatraceResult"; }

};

class EnableMetatraceArgs_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  EnableMetatraceArgs_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit EnableMetatraceArgs_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit EnableMetatraceArgs_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_categories() const { return at<1>().valid(); }
  int32_t categories() const { return at<1>().as_int32(); }
};

class EnableMetatraceArgs : public ::protozero::Message {
 public:
  using Decoder = EnableMetatraceArgs_Decoder;
  enum : int32_t {
    kCategoriesFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.EnableMetatraceArgs"; }


  using FieldMetadata_Categories =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      MetatraceCategories,
      EnableMetatraceArgs>;

  static constexpr FieldMetadata_Categories kCategories{};
  void set_categories(MetatraceCategories value) {
    static constexpr uint32_t field_id = FieldMetadata_Categories::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }
};

class ComputeMetricResult_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ComputeMetricResult_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ComputeMetricResult_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ComputeMetricResult_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_metrics() const { return at<1>().valid(); }
  ::protozero::ConstBytes metrics() const { return at<1>().as_bytes(); }
  bool has_metrics_as_prototext() const { return at<3>().valid(); }
  ::protozero::ConstChars metrics_as_prototext() const { return at<3>().as_string(); }
  bool has_metrics_as_json() const { return at<4>().valid(); }
  ::protozero::ConstChars metrics_as_json() const { return at<4>().as_string(); }
  bool has_error() const { return at<2>().valid(); }
  ::protozero::ConstChars error() const { return at<2>().as_string(); }
};

class ComputeMetricResult : public ::protozero::Message {
 public:
  using Decoder = ComputeMetricResult_Decoder;
  enum : int32_t {
    kMetricsFieldNumber = 1,
    kMetricsAsPrototextFieldNumber = 3,
    kMetricsAsJsonFieldNumber = 4,
    kErrorFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ComputeMetricResult"; }


  using FieldMetadata_Metrics =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBytes,
      std::string,
      ComputeMetricResult>;

  static constexpr FieldMetadata_Metrics kMetrics{};
  void set_metrics(const uint8_t* data, size_t size) {
    AppendBytes(FieldMetadata_Metrics::kFieldId, data, size);
  }
  void set_metrics(::protozero::ConstBytes bytes) {
    AppendBytes(FieldMetadata_Metrics::kFieldId, bytes.data, bytes.size);
  }
  void set_metrics(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Metrics::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBytes>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_MetricsAsPrototext =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      ComputeMetricResult>;

  static constexpr FieldMetadata_MetricsAsPrototext kMetricsAsPrototext{};
  void set_metrics_as_prototext(const char* data, size_t size) {
    AppendBytes(FieldMetadata_MetricsAsPrototext::kFieldId, data, size);
  }
  void set_metrics_as_prototext(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_MetricsAsPrototext::kFieldId, chars.data, chars.size);
  }
  void set_metrics_as_prototext(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_MetricsAsPrototext::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_MetricsAsJson =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      ComputeMetricResult>;

  static constexpr FieldMetadata_MetricsAsJson kMetricsAsJson{};
  void set_metrics_as_json(const char* data, size_t size) {
    AppendBytes(FieldMetadata_MetricsAsJson::kFieldId, data, size);
  }
  void set_metrics_as_json(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_MetricsAsJson::kFieldId, chars.data, chars.size);
  }
  void set_metrics_as_json(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_MetricsAsJson::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Error =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      ComputeMetricResult>;

  static constexpr FieldMetadata_Error kError{};
  void set_error(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Error::kFieldId, data, size);
  }
  void set_error(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Error::kFieldId, chars.data, chars.size);
  }
  void set_error(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Error::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }
};

class ComputeMetricArgs_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ComputeMetricArgs_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ComputeMetricArgs_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ComputeMetricArgs_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_metric_names() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> metric_names() const { return GetRepeated<::protozero::ConstChars>(1); }
  bool has_format() const { return at<2>().valid(); }
  int32_t format() const { return at<2>().as_int32(); }
};

class ComputeMetricArgs : public ::protozero::Message {
 public:
  using Decoder = ComputeMetricArgs_Decoder;
  enum : int32_t {
    kMetricNamesFieldNumber = 1,
    kFormatFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ComputeMetricArgs"; }


  using ResultFormat = ::perfetto::protos::pbzero::ComputeMetricArgs_ResultFormat;
  static inline const char* ResultFormat_Name(ResultFormat value) {
    return ::perfetto::protos::pbzero::ComputeMetricArgs_ResultFormat_Name(value);
  }
  static inline const ResultFormat BINARY_PROTOBUF = ResultFormat::BINARY_PROTOBUF;
  static inline const ResultFormat TEXTPROTO = ResultFormat::TEXTPROTO;
  static inline const ResultFormat JSON = ResultFormat::JSON;

  using FieldMetadata_MetricNames =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      ComputeMetricArgs>;

  static constexpr FieldMetadata_MetricNames kMetricNames{};
  void add_metric_names(const char* data, size_t size) {
    AppendBytes(FieldMetadata_MetricNames::kFieldId, data, size);
  }
  void add_metric_names(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_MetricNames::kFieldId, chars.data, chars.size);
  }
  void add_metric_names(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_MetricNames::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Format =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ComputeMetricArgs_ResultFormat,
      ComputeMetricArgs>;

  static constexpr FieldMetadata_Format kFormat{};
  void set_format(ComputeMetricArgs_ResultFormat value) {
    static constexpr uint32_t field_id = FieldMetadata_Format::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }
};

class StatusResult_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  StatusResult_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit StatusResult_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit StatusResult_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_loaded_trace_name() const { return at<1>().valid(); }
  ::protozero::ConstChars loaded_trace_name() const { return at<1>().as_string(); }
  bool has_human_readable_version() const { return at<2>().valid(); }
  ::protozero::ConstChars human_readable_version() const { return at<2>().as_string(); }
  bool has_api_version() const { return at<3>().valid(); }
  int32_t api_version() const { return at<3>().as_int32(); }
  bool has_version_code() const { return at<4>().valid(); }
  ::protozero::ConstChars version_code() const { return at<4>().as_string(); }
};

class StatusResult : public ::protozero::Message {
 public:
  using Decoder = StatusResult_Decoder;
  enum : int32_t {
    kLoadedTraceNameFieldNumber = 1,
    kHumanReadableVersionFieldNumber = 2,
    kApiVersionFieldNumber = 3,
    kVersionCodeFieldNumber = 4,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.StatusResult"; }


  using FieldMetadata_LoadedTraceName =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      StatusResult>;

  static constexpr FieldMetadata_LoadedTraceName kLoadedTraceName{};
  void set_loaded_trace_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_LoadedTraceName::kFieldId, data, size);
  }
  void set_loaded_trace_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_LoadedTraceName::kFieldId, chars.data, chars.size);
  }
  void set_loaded_trace_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_LoadedTraceName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_HumanReadableVersion =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      StatusResult>;

  static constexpr FieldMetadata_HumanReadableVersion kHumanReadableVersion{};
  void set_human_readable_version(const char* data, size_t size) {
    AppendBytes(FieldMetadata_HumanReadableVersion::kFieldId, data, size);
  }
  void set_human_readable_version(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_HumanReadableVersion::kFieldId, chars.data, chars.size);
  }
  void set_human_readable_version(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_HumanReadableVersion::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ApiVersion =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      StatusResult>;

  static constexpr FieldMetadata_ApiVersion kApiVersion{};
  void set_api_version(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ApiVersion::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_VersionCode =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      StatusResult>;

  static constexpr FieldMetadata_VersionCode kVersionCode{};
  void set_version_code(const char* data, size_t size) {
    AppendBytes(FieldMetadata_VersionCode::kFieldId, data, size);
  }
  void set_version_code(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_VersionCode::kFieldId, chars.data, chars.size);
  }
  void set_version_code(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_VersionCode::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }
};

class StatusArgs_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/0, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  StatusArgs_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit StatusArgs_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit StatusArgs_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
};

class StatusArgs : public ::protozero::Message {
 public:
  using Decoder = StatusArgs_Decoder;
  static constexpr const char* GetName() { return ".perfetto.protos.StatusArgs"; }

};

class QueryResult_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  QueryResult_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit QueryResult_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit QueryResult_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_column_names() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> column_names() const { return GetRepeated<::protozero::ConstChars>(1); }
  bool has_error() const { return at<2>().valid(); }
  ::protozero::ConstChars error() const { return at<2>().as_string(); }
  bool has_batch() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> batch() const { return GetRepeated<::protozero::ConstBytes>(3); }
  bool has_statement_count() const { return at<4>().valid(); }
  uint32_t statement_count() const { return at<4>().as_uint32(); }
  bool has_statement_with_output_count() const { return at<5>().valid(); }
  uint32_t statement_with_output_count() const { return at<5>().as_uint32(); }
  bool has_last_statement_sql() const { return at<6>().valid(); }
  ::protozero::ConstChars last_statement_sql() const { return at<6>().as_string(); }
};

class QueryResult : public ::protozero::Message {
 public:
  using Decoder = QueryResult_Decoder;
  enum : int32_t {
    kColumnNamesFieldNumber = 1,
    kErrorFieldNumber = 2,
    kBatchFieldNumber = 3,
    kStatementCountFieldNumber = 4,
    kStatementWithOutputCountFieldNumber = 5,
    kLastStatementSqlFieldNumber = 6,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.QueryResult"; }

  using CellsBatch = ::perfetto::protos::pbzero::QueryResult_CellsBatch;

  using FieldMetadata_ColumnNames =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      QueryResult>;

  static constexpr FieldMetadata_ColumnNames kColumnNames{};
  void add_column_names(const char* data, size_t size) {
    AppendBytes(FieldMetadata_ColumnNames::kFieldId, data, size);
  }
  void add_column_names(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_ColumnNames::kFieldId, chars.data, chars.size);
  }
  void add_column_names(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_ColumnNames::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Error =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      QueryResult>;

  static constexpr FieldMetadata_Error kError{};
  void set_error(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Error::kFieldId, data, size);
  }
  void set_error(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Error::kFieldId, chars.data, chars.size);
  }
  void set_error(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Error::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Batch =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      QueryResult_CellsBatch,
      QueryResult>;

  static constexpr FieldMetadata_Batch kBatch{};
  template <typename T = QueryResult_CellsBatch> T* add_batch() {
    return BeginNestedMessage<T>(3);
  }


  using FieldMetadata_StatementCount =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      QueryResult>;

  static constexpr FieldMetadata_StatementCount kStatementCount{};
  void set_statement_count(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_StatementCount::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_StatementWithOutputCount =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      QueryResult>;

  static constexpr FieldMetadata_StatementWithOutputCount kStatementWithOutputCount{};
  void set_statement_with_output_count(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_StatementWithOutputCount::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_LastStatementSql =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      QueryResult>;

  static constexpr FieldMetadata_LastStatementSql kLastStatementSql{};
  void set_last_statement_sql(const char* data, size_t size) {
    AppendBytes(FieldMetadata_LastStatementSql::kFieldId, data, size);
  }
  void set_last_statement_sql(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_LastStatementSql::kFieldId, chars.data, chars.size);
  }
  void set_last_statement_sql(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_LastStatementSql::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }
};

class QueryResult_CellsBatch_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  QueryResult_CellsBatch_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit QueryResult_CellsBatch_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit QueryResult_CellsBatch_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_cells() const { return at<1>().valid(); }
  ::protozero::PackedRepeatedFieldIterator<::protozero::proto_utils::ProtoWireType::kVarInt, int32_t> cells(bool* parse_error_ptr) const { return GetPackedRepeated<::protozero::proto_utils::ProtoWireType::kVarInt, int32_t>(1, parse_error_ptr); }
  bool has_varint_cells() const { return at<2>().valid(); }
  ::protozero::PackedRepeatedFieldIterator<::protozero::proto_utils::ProtoWireType::kVarInt, int64_t> varint_cells(bool* parse_error_ptr) const { return GetPackedRepeated<::protozero::proto_utils::ProtoWireType::kVarInt, int64_t>(2, parse_error_ptr); }
  bool has_float64_cells() const { return at<3>().valid(); }
  ::protozero::PackedRepeatedFieldIterator<::protozero::proto_utils::ProtoWireType::kFixed64, double> float64_cells(bool* parse_error_ptr) const { return GetPackedRepeated<::protozero::proto_utils::ProtoWireType::kFixed64, double>(3, parse_error_ptr); }
  bool has_blob_cells() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> blob_cells() const { return GetRepeated<::protozero::ConstBytes>(4); }
  bool has_string_cells() const { return at<5>().valid(); }
  ::protozero::ConstChars string_cells() const { return at<5>().as_string(); }
  bool has_is_last_batch() const { return at<6>().valid(); }
  bool is_last_batch() const { return at<6>().as_bool(); }
};

class QueryResult_CellsBatch : public ::protozero::Message {
 public:
  using Decoder = QueryResult_CellsBatch_Decoder;
  enum : int32_t {
    kCellsFieldNumber = 1,
    kVarintCellsFieldNumber = 2,
    kFloat64CellsFieldNumber = 3,
    kBlobCellsFieldNumber = 4,
    kStringCellsFieldNumber = 5,
    kIsLastBatchFieldNumber = 6,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.QueryResult.CellsBatch"; }


  using CellType = ::perfetto::protos::pbzero::QueryResult_CellsBatch_CellType;
  static inline const char* CellType_Name(CellType value) {
    return ::perfetto::protos::pbzero::QueryResult_CellsBatch_CellType_Name(value);
  }
  static inline const CellType CELL_INVALID = CellType::CELL_INVALID;
  static inline const CellType CELL_NULL = CellType::CELL_NULL;
  static inline const CellType CELL_VARINT = CellType::CELL_VARINT;
  static inline const CellType CELL_FLOAT64 = CellType::CELL_FLOAT64;
  static inline const CellType CELL_STRING = CellType::CELL_STRING;
  static inline const CellType CELL_BLOB = CellType::CELL_BLOB;

  using FieldMetadata_Cells =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kRepeatedPacked,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      QueryResult_CellsBatch_CellType,
      QueryResult_CellsBatch>;

  static constexpr FieldMetadata_Cells kCells{};
  void set_cells(const ::protozero::PackedVarInt& packed_buffer) {
    AppendBytes(FieldMetadata_Cells::kFieldId, packed_buffer.data(),
                packed_buffer.size());
  }

  using FieldMetadata_VarintCells =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kRepeatedPacked,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      QueryResult_CellsBatch>;

  static constexpr FieldMetadata_VarintCells kVarintCells{};
  void set_varint_cells(const ::protozero::PackedVarInt& packed_buffer) {
    AppendBytes(FieldMetadata_VarintCells::kFieldId, packed_buffer.data(),
                packed_buffer.size());
  }

  using FieldMetadata_Float64Cells =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kRepeatedPacked,
      ::protozero::proto_utils::ProtoSchemaType::kDouble,
      double,
      QueryResult_CellsBatch>;

  static constexpr FieldMetadata_Float64Cells kFloat64Cells{};
  void set_float64_cells(const ::protozero::PackedFixedSizeInt<double>& packed_buffer) {
    AppendBytes(FieldMetadata_Float64Cells::kFieldId, packed_buffer.data(),
                packed_buffer.size());
  }

  using FieldMetadata_BlobCells =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kBytes,
      std::string,
      QueryResult_CellsBatch>;

  static constexpr FieldMetadata_BlobCells kBlobCells{};
  void add_blob_cells(const uint8_t* data, size_t size) {
    AppendBytes(FieldMetadata_BlobCells::kFieldId, data, size);
  }
  void add_blob_cells(::protozero::ConstBytes bytes) {
    AppendBytes(FieldMetadata_BlobCells::kFieldId, bytes.data, bytes.size);
  }
  void add_blob_cells(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_BlobCells::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBytes>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_StringCells =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      QueryResult_CellsBatch>;

  static constexpr FieldMetadata_StringCells kStringCells{};
  void set_string_cells(const char* data, size_t size) {
    AppendBytes(FieldMetadata_StringCells::kFieldId, data, size);
  }
  void set_string_cells(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_StringCells::kFieldId, chars.data, chars.size);
  }
  void set_string_cells(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_StringCells::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IsLastBatch =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      QueryResult_CellsBatch>;

  static constexpr FieldMetadata_IsLastBatch kIsLastBatch{};
  void set_is_last_batch(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsLastBatch::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }
};

class QueryArgs_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  QueryArgs_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit QueryArgs_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit QueryArgs_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_sql_query() const { return at<1>().valid(); }
  ::protozero::ConstChars sql_query() const { return at<1>().as_string(); }
  bool has_tag() const { return at<3>().valid(); }
  ::protozero::ConstChars tag() const { return at<3>().as_string(); }
};

class QueryArgs : public ::protozero::Message {
 public:
  using Decoder = QueryArgs_Decoder;
  enum : int32_t {
    kSqlQueryFieldNumber = 1,
    kTagFieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.QueryArgs"; }


  using FieldMetadata_SqlQuery =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      QueryArgs>;

  static constexpr FieldMetadata_SqlQuery kSqlQuery{};
  void set_sql_query(const char* data, size_t size) {
    AppendBytes(FieldMetadata_SqlQuery::kFieldId, data, size);
  }
  void set_sql_query(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_SqlQuery::kFieldId, chars.data, chars.size);
  }
  void set_sql_query(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_SqlQuery::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Tag =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      QueryArgs>;

  static constexpr FieldMetadata_Tag kTag{};
  void set_tag(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Tag::kFieldId, data, size);
  }
  void set_tag(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Tag::kFieldId, chars.data, chars.size);
  }
  void set_tag(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Tag::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }
};

class AppendTraceDataResult_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  AppendTraceDataResult_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AppendTraceDataResult_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AppendTraceDataResult_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_total_bytes_parsed() const { return at<1>().valid(); }
  int64_t total_bytes_parsed() const { return at<1>().as_int64(); }
  bool has_error() const { return at<2>().valid(); }
  ::protozero::ConstChars error() const { return at<2>().as_string(); }
};

class AppendTraceDataResult : public ::protozero::Message {
 public:
  using Decoder = AppendTraceDataResult_Decoder;
  enum : int32_t {
    kTotalBytesParsedFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.AppendTraceDataResult"; }


  using FieldMetadata_TotalBytesParsed =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      AppendTraceDataResult>;

  static constexpr FieldMetadata_TotalBytesParsed kTotalBytesParsed{};
  void set_total_bytes_parsed(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_TotalBytesParsed::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Error =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      AppendTraceDataResult>;

  static constexpr FieldMetadata_Error kError{};
  void set_error(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Error::kFieldId, data, size);
  }
  void set_error(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Error::kFieldId, chars.data, chars.size);
  }
  void set_error(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Error::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }
};

class TraceProcessorRpc_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/210, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TraceProcessorRpc_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TraceProcessorRpc_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TraceProcessorRpc_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_seq() const { return at<1>().valid(); }
  int64_t seq() const { return at<1>().as_int64(); }
  bool has_fatal_error() const { return at<5>().valid(); }
  ::protozero::ConstChars fatal_error() const { return at<5>().as_string(); }
  bool has_request() const { return at<2>().valid(); }
  int32_t request() const { return at<2>().as_int32(); }
  bool has_response() const { return at<3>().valid(); }
  int32_t response() const { return at<3>().as_int32(); }
  bool has_invalid_request() const { return at<4>().valid(); }
  int32_t invalid_request() const { return at<4>().as_int32(); }
  bool has_append_trace_data() const { return at<101>().valid(); }
  ::protozero::ConstBytes append_trace_data() const { return at<101>().as_bytes(); }
  bool has_query_args() const { return at<103>().valid(); }
  ::protozero::ConstBytes query_args() const { return at<103>().as_bytes(); }
  bool has_compute_metric_args() const { return at<105>().valid(); }
  ::protozero::ConstBytes compute_metric_args() const { return at<105>().as_bytes(); }
  bool has_enable_metatrace_args() const { return at<106>().valid(); }
  ::protozero::ConstBytes enable_metatrace_args() const { return at<106>().as_bytes(); }
  bool has_reset_trace_processor_args() const { return at<107>().valid(); }
  ::protozero::ConstBytes reset_trace_processor_args() const { return at<107>().as_bytes(); }
  bool has_append_result() const { return at<201>().valid(); }
  ::protozero::ConstBytes append_result() const { return at<201>().as_bytes(); }
  bool has_query_result() const { return at<203>().valid(); }
  ::protozero::ConstBytes query_result() const { return at<203>().as_bytes(); }
  bool has_metric_result() const { return at<205>().valid(); }
  ::protozero::ConstBytes metric_result() const { return at<205>().as_bytes(); }
  bool has_metric_descriptors() const { return at<206>().valid(); }
  ::protozero::ConstBytes metric_descriptors() const { return at<206>().as_bytes(); }
  bool has_metatrace() const { return at<209>().valid(); }
  ::protozero::ConstBytes metatrace() const { return at<209>().as_bytes(); }
  bool has_status() const { return at<210>().valid(); }
  ::protozero::ConstBytes status() const { return at<210>().as_bytes(); }
};

class TraceProcessorRpc : public ::protozero::Message {
 public:
  using Decoder = TraceProcessorRpc_Decoder;
  enum : int32_t {
    kSeqFieldNumber = 1,
    kFatalErrorFieldNumber = 5,
    kRequestFieldNumber = 2,
    kResponseFieldNumber = 3,
    kInvalidRequestFieldNumber = 4,
    kAppendTraceDataFieldNumber = 101,
    kQueryArgsFieldNumber = 103,
    kComputeMetricArgsFieldNumber = 105,
    kEnableMetatraceArgsFieldNumber = 106,
    kResetTraceProcessorArgsFieldNumber = 107,
    kAppendResultFieldNumber = 201,
    kQueryResultFieldNumber = 203,
    kMetricResultFieldNumber = 205,
    kMetricDescriptorsFieldNumber = 206,
    kMetatraceFieldNumber = 209,
    kStatusFieldNumber = 210,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.TraceProcessorRpc"; }


  using TraceProcessorMethod = ::perfetto::protos::pbzero::TraceProcessorRpc_TraceProcessorMethod;
  static inline const char* TraceProcessorMethod_Name(TraceProcessorMethod value) {
    return ::perfetto::protos::pbzero::TraceProcessorRpc_TraceProcessorMethod_Name(value);
  }
  static inline const TraceProcessorMethod TPM_UNSPECIFIED = TraceProcessorMethod::TPM_UNSPECIFIED;
  static inline const TraceProcessorMethod TPM_APPEND_TRACE_DATA = TraceProcessorMethod::TPM_APPEND_TRACE_DATA;
  static inline const TraceProcessorMethod TPM_FINALIZE_TRACE_DATA = TraceProcessorMethod::TPM_FINALIZE_TRACE_DATA;
  static inline const TraceProcessorMethod TPM_QUERY_STREAMING = TraceProcessorMethod::TPM_QUERY_STREAMING;
  static inline const TraceProcessorMethod TPM_COMPUTE_METRIC = TraceProcessorMethod::TPM_COMPUTE_METRIC;
  static inline const TraceProcessorMethod TPM_GET_METRIC_DESCRIPTORS = TraceProcessorMethod::TPM_GET_METRIC_DESCRIPTORS;
  static inline const TraceProcessorMethod TPM_RESTORE_INITIAL_TABLES = TraceProcessorMethod::TPM_RESTORE_INITIAL_TABLES;
  static inline const TraceProcessorMethod TPM_ENABLE_METATRACE = TraceProcessorMethod::TPM_ENABLE_METATRACE;
  static inline const TraceProcessorMethod TPM_DISABLE_AND_READ_METATRACE = TraceProcessorMethod::TPM_DISABLE_AND_READ_METATRACE;
  static inline const TraceProcessorMethod TPM_GET_STATUS = TraceProcessorMethod::TPM_GET_STATUS;
  static inline const TraceProcessorMethod TPM_RESET_TRACE_PROCESSOR = TraceProcessorMethod::TPM_RESET_TRACE_PROCESSOR;

  using FieldMetadata_Seq =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      TraceProcessorRpc>;

  static constexpr FieldMetadata_Seq kSeq{};
  void set_seq(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Seq::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_FatalError =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      TraceProcessorRpc>;

  static constexpr FieldMetadata_FatalError kFatalError{};
  void set_fatal_error(const char* data, size_t size) {
    AppendBytes(FieldMetadata_FatalError::kFieldId, data, size);
  }
  void set_fatal_error(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_FatalError::kFieldId, chars.data, chars.size);
  }
  void set_fatal_error(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_FatalError::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Request =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      TraceProcessorRpc_TraceProcessorMethod,
      TraceProcessorRpc>;

  static constexpr FieldMetadata_Request kRequest{};
  void set_request(TraceProcessorRpc_TraceProcessorMethod value) {
    static constexpr uint32_t field_id = FieldMetadata_Request::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Response =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      TraceProcessorRpc_TraceProcessorMethod,
      TraceProcessorRpc>;

  static constexpr FieldMetadata_Response kResponse{};
  void set_response(TraceProcessorRpc_TraceProcessorMethod value) {
    static constexpr uint32_t field_id = FieldMetadata_Response::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_InvalidRequest =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      TraceProcessorRpc_TraceProcessorMethod,
      TraceProcessorRpc>;

  static constexpr FieldMetadata_InvalidRequest kInvalidRequest{};
  void set_invalid_request(TraceProcessorRpc_TraceProcessorMethod value) {
    static constexpr uint32_t field_id = FieldMetadata_InvalidRequest::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_AppendTraceData =
    ::protozero::proto_utils::FieldMetadata<
      101,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBytes,
      std::string,
      TraceProcessorRpc>;

  static constexpr FieldMetadata_AppendTraceData kAppendTraceData{};
  void set_append_trace_data(const uint8_t* data, size_t size) {
    AppendBytes(FieldMetadata_AppendTraceData::kFieldId, data, size);
  }
  void set_append_trace_data(::protozero::ConstBytes bytes) {
    AppendBytes(FieldMetadata_AppendTraceData::kFieldId, bytes.data, bytes.size);
  }
  void set_append_trace_data(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_AppendTraceData::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBytes>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_QueryArgs =
    ::protozero::proto_utils::FieldMetadata<
      103,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      QueryArgs,
      TraceProcessorRpc>;

  static constexpr FieldMetadata_QueryArgs kQueryArgs{};
  template <typename T = QueryArgs> T* set_query_args() {
    return BeginNestedMessage<T>(103);
  }


  using FieldMetadata_ComputeMetricArgs =
    ::protozero::proto_utils::FieldMetadata<
      105,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ComputeMetricArgs,
      TraceProcessorRpc>;

  static constexpr FieldMetadata_ComputeMetricArgs kComputeMetricArgs{};
  template <typename T = ComputeMetricArgs> T* set_compute_metric_args() {
    return BeginNestedMessage<T>(105);
  }


  using FieldMetadata_EnableMetatraceArgs =
    ::protozero::proto_utils::FieldMetadata<
      106,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      EnableMetatraceArgs,
      TraceProcessorRpc>;

  static constexpr FieldMetadata_EnableMetatraceArgs kEnableMetatraceArgs{};
  template <typename T = EnableMetatraceArgs> T* set_enable_metatrace_args() {
    return BeginNestedMessage<T>(106);
  }


  using FieldMetadata_ResetTraceProcessorArgs =
    ::protozero::proto_utils::FieldMetadata<
      107,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ResetTraceProcessorArgs,
      TraceProcessorRpc>;

  static constexpr FieldMetadata_ResetTraceProcessorArgs kResetTraceProcessorArgs{};
  template <typename T = ResetTraceProcessorArgs> T* set_reset_trace_processor_args() {
    return BeginNestedMessage<T>(107);
  }


  using FieldMetadata_AppendResult =
    ::protozero::proto_utils::FieldMetadata<
      201,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      AppendTraceDataResult,
      TraceProcessorRpc>;

  static constexpr FieldMetadata_AppendResult kAppendResult{};
  template <typename T = AppendTraceDataResult> T* set_append_result() {
    return BeginNestedMessage<T>(201);
  }


  using FieldMetadata_QueryResult =
    ::protozero::proto_utils::FieldMetadata<
      203,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      QueryResult,
      TraceProcessorRpc>;

  static constexpr FieldMetadata_QueryResult kQueryResult{};
  template <typename T = QueryResult> T* set_query_result() {
    return BeginNestedMessage<T>(203);
  }


  using FieldMetadata_MetricResult =
    ::protozero::proto_utils::FieldMetadata<
      205,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ComputeMetricResult,
      TraceProcessorRpc>;

  static constexpr FieldMetadata_MetricResult kMetricResult{};
  template <typename T = ComputeMetricResult> T* set_metric_result() {
    return BeginNestedMessage<T>(205);
  }


  using FieldMetadata_MetricDescriptors =
    ::protozero::proto_utils::FieldMetadata<
      206,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DescriptorSet,
      TraceProcessorRpc>;

  static constexpr FieldMetadata_MetricDescriptors kMetricDescriptors{};
  template <typename T = DescriptorSet> T* set_metric_descriptors() {
    return BeginNestedMessage<T>(206);
  }


  using FieldMetadata_Metatrace =
    ::protozero::proto_utils::FieldMetadata<
      209,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DisableAndReadMetatraceResult,
      TraceProcessorRpc>;

  static constexpr FieldMetadata_Metatrace kMetatrace{};
  template <typename T = DisableAndReadMetatraceResult> T* set_metatrace() {
    return BeginNestedMessage<T>(209);
  }


  using FieldMetadata_Status =
    ::protozero::proto_utils::FieldMetadata<
      210,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      StatusResult,
      TraceProcessorRpc>;

  static constexpr FieldMetadata_Status kStatus{};
  template <typename T = StatusResult> T* set_status() {
    return BeginNestedMessage<T>(210);
  }

};

class TraceProcessorRpcStream_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  TraceProcessorRpcStream_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TraceProcessorRpcStream_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TraceProcessorRpcStream_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_msg() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> msg() const { return GetRepeated<::protozero::ConstBytes>(1); }
};

class TraceProcessorRpcStream : public ::protozero::Message {
 public:
  using Decoder = TraceProcessorRpcStream_Decoder;
  enum : int32_t {
    kMsgFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.TraceProcessorRpcStream"; }


  using FieldMetadata_Msg =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      TraceProcessorRpc,
      TraceProcessorRpcStream>;

  static constexpr FieldMetadata_Msg kMsg{};
  template <typename T = TraceProcessorRpc> T* add_msg() {
    return BeginNestedMessage<T>(1);
  }

};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
