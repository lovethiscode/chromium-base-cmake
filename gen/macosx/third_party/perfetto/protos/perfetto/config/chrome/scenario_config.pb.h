// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/config/chrome/scenario_config.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_protos_2fperfetto_2fconfig_2fchrome_2fscenario_5fconfig_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_protos_2fperfetto_2fconfig_2fchrome_2fscenario_5fconfig_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include "protos/perfetto/config/trace_config.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_protos_2fperfetto_2fconfig_2fchrome_2fscenario_5fconfig_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_protos_2fperfetto_2fconfig_2fchrome_2fscenario_5fconfig_2eproto {
  static const uint32_t offsets[];
};
namespace perfetto {
namespace protos {
class ChromeFieldTracingConfig;
struct ChromeFieldTracingConfigDefaultTypeInternal;
extern ChromeFieldTracingConfigDefaultTypeInternal _ChromeFieldTracingConfig_default_instance_;
class NestedScenarioConfig;
struct NestedScenarioConfigDefaultTypeInternal;
extern NestedScenarioConfigDefaultTypeInternal _NestedScenarioConfig_default_instance_;
class ScenarioConfig;
struct ScenarioConfigDefaultTypeInternal;
extern ScenarioConfigDefaultTypeInternal _ScenarioConfig_default_instance_;
class TracingTriggerRulesConfig;
struct TracingTriggerRulesConfigDefaultTypeInternal;
extern TracingTriggerRulesConfigDefaultTypeInternal _TracingTriggerRulesConfig_default_instance_;
class TriggerRule;
struct TriggerRuleDefaultTypeInternal;
extern TriggerRuleDefaultTypeInternal _TriggerRule_default_instance_;
class TriggerRule_HistogramTrigger;
struct TriggerRule_HistogramTriggerDefaultTypeInternal;
extern TriggerRule_HistogramTriggerDefaultTypeInternal _TriggerRule_HistogramTrigger_default_instance_;
class TriggerRule_RepeatingInterval;
struct TriggerRule_RepeatingIntervalDefaultTypeInternal;
extern TriggerRule_RepeatingIntervalDefaultTypeInternal _TriggerRule_RepeatingInterval_default_instance_;
}  // namespace protos
}  // namespace perfetto
PROTOBUF_NAMESPACE_OPEN
template<> ::perfetto::protos::ChromeFieldTracingConfig* Arena::CreateMaybeMessage<::perfetto::protos::ChromeFieldTracingConfig>(Arena*);
template<> ::perfetto::protos::NestedScenarioConfig* Arena::CreateMaybeMessage<::perfetto::protos::NestedScenarioConfig>(Arena*);
template<> ::perfetto::protos::ScenarioConfig* Arena::CreateMaybeMessage<::perfetto::protos::ScenarioConfig>(Arena*);
template<> ::perfetto::protos::TracingTriggerRulesConfig* Arena::CreateMaybeMessage<::perfetto::protos::TracingTriggerRulesConfig>(Arena*);
template<> ::perfetto::protos::TriggerRule* Arena::CreateMaybeMessage<::perfetto::protos::TriggerRule>(Arena*);
template<> ::perfetto::protos::TriggerRule_HistogramTrigger* Arena::CreateMaybeMessage<::perfetto::protos::TriggerRule_HistogramTrigger>(Arena*);
template<> ::perfetto::protos::TriggerRule_RepeatingInterval* Arena::CreateMaybeMessage<::perfetto::protos::TriggerRule_RepeatingInterval>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace perfetto {
namespace protos {

// ===================================================================

class TriggerRule_HistogramTrigger final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.TriggerRule.HistogramTrigger) */ {
 public:
  inline TriggerRule_HistogramTrigger() : TriggerRule_HistogramTrigger(nullptr) {}
  ~TriggerRule_HistogramTrigger() override;
  explicit PROTOBUF_CONSTEXPR TriggerRule_HistogramTrigger(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TriggerRule_HistogramTrigger(const TriggerRule_HistogramTrigger& from);
  TriggerRule_HistogramTrigger(TriggerRule_HistogramTrigger&& from) noexcept
    : TriggerRule_HistogramTrigger() {
    *this = ::std::move(from);
  }

  inline TriggerRule_HistogramTrigger& operator=(const TriggerRule_HistogramTrigger& from) {
    CopyFrom(from);
    return *this;
  }
  inline TriggerRule_HistogramTrigger& operator=(TriggerRule_HistogramTrigger&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TriggerRule_HistogramTrigger& default_instance() {
    return *internal_default_instance();
  }
  static inline const TriggerRule_HistogramTrigger* internal_default_instance() {
    return reinterpret_cast<const TriggerRule_HistogramTrigger*>(
               &_TriggerRule_HistogramTrigger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TriggerRule_HistogramTrigger& a, TriggerRule_HistogramTrigger& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TriggerRule_HistogramTrigger* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TriggerRule_HistogramTrigger* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TriggerRule_HistogramTrigger* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TriggerRule_HistogramTrigger>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TriggerRule_HistogramTrigger& from);
  void MergeFrom(const TriggerRule_HistogramTrigger& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TriggerRule_HistogramTrigger* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.TriggerRule.HistogramTrigger";
  }
  protected:
  explicit TriggerRule_HistogramTrigger(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHistogramNameFieldNumber = 1,
    kMinValueFieldNumber = 2,
    kMaxValueFieldNumber = 3,
  };
  // optional string histogram_name = 1;
  bool has_histogram_name() const;
  private:
  bool _internal_has_histogram_name() const;
  public:
  void clear_histogram_name();
  const std::string& histogram_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_histogram_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_histogram_name();
  PROTOBUF_NODISCARD std::string* release_histogram_name();
  void set_allocated_histogram_name(std::string* histogram_name);
  private:
  const std::string& _internal_histogram_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_histogram_name(const std::string& value);
  std::string* _internal_mutable_histogram_name();
  public:

  // optional int64 min_value = 2;
  bool has_min_value() const;
  private:
  bool _internal_has_min_value() const;
  public:
  void clear_min_value();
  int64_t min_value() const;
  void set_min_value(int64_t value);
  private:
  int64_t _internal_min_value() const;
  void _internal_set_min_value(int64_t value);
  public:

  // optional int64 max_value = 3;
  bool has_max_value() const;
  private:
  bool _internal_has_max_value() const;
  public:
  void clear_max_value();
  int64_t max_value() const;
  void set_max_value(int64_t value);
  private:
  int64_t _internal_max_value() const;
  void _internal_set_max_value(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:perfetto.protos.TriggerRule.HistogramTrigger)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr histogram_name_;
    int64_t min_value_;
    int64_t max_value_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2fconfig_2fchrome_2fscenario_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class TriggerRule_RepeatingInterval final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.TriggerRule.RepeatingInterval) */ {
 public:
  inline TriggerRule_RepeatingInterval() : TriggerRule_RepeatingInterval(nullptr) {}
  ~TriggerRule_RepeatingInterval() override;
  explicit PROTOBUF_CONSTEXPR TriggerRule_RepeatingInterval(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TriggerRule_RepeatingInterval(const TriggerRule_RepeatingInterval& from);
  TriggerRule_RepeatingInterval(TriggerRule_RepeatingInterval&& from) noexcept
    : TriggerRule_RepeatingInterval() {
    *this = ::std::move(from);
  }

  inline TriggerRule_RepeatingInterval& operator=(const TriggerRule_RepeatingInterval& from) {
    CopyFrom(from);
    return *this;
  }
  inline TriggerRule_RepeatingInterval& operator=(TriggerRule_RepeatingInterval&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TriggerRule_RepeatingInterval& default_instance() {
    return *internal_default_instance();
  }
  static inline const TriggerRule_RepeatingInterval* internal_default_instance() {
    return reinterpret_cast<const TriggerRule_RepeatingInterval*>(
               &_TriggerRule_RepeatingInterval_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TriggerRule_RepeatingInterval& a, TriggerRule_RepeatingInterval& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TriggerRule_RepeatingInterval* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TriggerRule_RepeatingInterval* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TriggerRule_RepeatingInterval* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TriggerRule_RepeatingInterval>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TriggerRule_RepeatingInterval& from);
  void MergeFrom(const TriggerRule_RepeatingInterval& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TriggerRule_RepeatingInterval* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.TriggerRule.RepeatingInterval";
  }
  protected:
  explicit TriggerRule_RepeatingInterval(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeriodMsFieldNumber = 1,
    kRandomizedFieldNumber = 2,
  };
  // optional uint64 period_ms = 1;
  bool has_period_ms() const;
  private:
  bool _internal_has_period_ms() const;
  public:
  void clear_period_ms();
  uint64_t period_ms() const;
  void set_period_ms(uint64_t value);
  private:
  uint64_t _internal_period_ms() const;
  void _internal_set_period_ms(uint64_t value);
  public:

  // optional bool randomized = 2;
  bool has_randomized() const;
  private:
  bool _internal_has_randomized() const;
  public:
  void clear_randomized();
  bool randomized() const;
  void set_randomized(bool value);
  private:
  bool _internal_randomized() const;
  void _internal_set_randomized(bool value);
  public:

  // @@protoc_insertion_point(class_scope:perfetto.protos.TriggerRule.RepeatingInterval)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t period_ms_;
    bool randomized_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2fconfig_2fchrome_2fscenario_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class TriggerRule final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.TriggerRule) */ {
 public:
  inline TriggerRule() : TriggerRule(nullptr) {}
  ~TriggerRule() override;
  explicit PROTOBUF_CONSTEXPR TriggerRule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TriggerRule(const TriggerRule& from);
  TriggerRule(TriggerRule&& from) noexcept
    : TriggerRule() {
    *this = ::std::move(from);
  }

  inline TriggerRule& operator=(const TriggerRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline TriggerRule& operator=(TriggerRule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TriggerRule& default_instance() {
    return *internal_default_instance();
  }
  enum TriggerCase {
    kManualTriggerName = 4,
    kHistogram = 5,
    kRepeatingInterval = 6,
    TRIGGER_NOT_SET = 0,
  };

  static inline const TriggerRule* internal_default_instance() {
    return reinterpret_cast<const TriggerRule*>(
               &_TriggerRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TriggerRule& a, TriggerRule& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TriggerRule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TriggerRule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TriggerRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TriggerRule>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TriggerRule& from);
  void MergeFrom(const TriggerRule& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TriggerRule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.TriggerRule";
  }
  protected:
  explicit TriggerRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef TriggerRule_HistogramTrigger HistogramTrigger;
  typedef TriggerRule_RepeatingInterval RepeatingInterval;

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDelayMsFieldNumber = 3,
    kActivationDelayMsFieldNumber = 8,
    kTriggerChanceFieldNumber = 2,
    kManualTriggerNameFieldNumber = 4,
    kHistogramFieldNumber = 5,
    kRepeatingIntervalFieldNumber = 6,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional uint64 delay_ms = 3;
  bool has_delay_ms() const;
  private:
  bool _internal_has_delay_ms() const;
  public:
  void clear_delay_ms();
  uint64_t delay_ms() const;
  void set_delay_ms(uint64_t value);
  private:
  uint64_t _internal_delay_ms() const;
  void _internal_set_delay_ms(uint64_t value);
  public:

  // optional uint64 activation_delay_ms = 8;
  bool has_activation_delay_ms() const;
  private:
  bool _internal_has_activation_delay_ms() const;
  public:
  void clear_activation_delay_ms();
  uint64_t activation_delay_ms() const;
  void set_activation_delay_ms(uint64_t value);
  private:
  uint64_t _internal_activation_delay_ms() const;
  void _internal_set_activation_delay_ms(uint64_t value);
  public:

  // optional float trigger_chance = 2;
  bool has_trigger_chance() const;
  private:
  bool _internal_has_trigger_chance() const;
  public:
  void clear_trigger_chance();
  float trigger_chance() const;
  void set_trigger_chance(float value);
  private:
  float _internal_trigger_chance() const;
  void _internal_set_trigger_chance(float value);
  public:

  // string manual_trigger_name = 4;
  bool has_manual_trigger_name() const;
  private:
  bool _internal_has_manual_trigger_name() const;
  public:
  void clear_manual_trigger_name();
  const std::string& manual_trigger_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_manual_trigger_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_manual_trigger_name();
  PROTOBUF_NODISCARD std::string* release_manual_trigger_name();
  void set_allocated_manual_trigger_name(std::string* manual_trigger_name);
  private:
  const std::string& _internal_manual_trigger_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_manual_trigger_name(const std::string& value);
  std::string* _internal_mutable_manual_trigger_name();
  public:

  // .perfetto.protos.TriggerRule.HistogramTrigger histogram = 5;
  bool has_histogram() const;
  private:
  bool _internal_has_histogram() const;
  public:
  void clear_histogram();
  const ::perfetto::protos::TriggerRule_HistogramTrigger& histogram() const;
  PROTOBUF_NODISCARD ::perfetto::protos::TriggerRule_HistogramTrigger* release_histogram();
  ::perfetto::protos::TriggerRule_HistogramTrigger* mutable_histogram();
  void set_allocated_histogram(::perfetto::protos::TriggerRule_HistogramTrigger* histogram);
  private:
  const ::perfetto::protos::TriggerRule_HistogramTrigger& _internal_histogram() const;
  ::perfetto::protos::TriggerRule_HistogramTrigger* _internal_mutable_histogram();
  public:
  void unsafe_arena_set_allocated_histogram(
      ::perfetto::protos::TriggerRule_HistogramTrigger* histogram);
  ::perfetto::protos::TriggerRule_HistogramTrigger* unsafe_arena_release_histogram();

  // .perfetto.protos.TriggerRule.RepeatingInterval repeating_interval = 6;
  bool has_repeating_interval() const;
  private:
  bool _internal_has_repeating_interval() const;
  public:
  void clear_repeating_interval();
  const ::perfetto::protos::TriggerRule_RepeatingInterval& repeating_interval() const;
  PROTOBUF_NODISCARD ::perfetto::protos::TriggerRule_RepeatingInterval* release_repeating_interval();
  ::perfetto::protos::TriggerRule_RepeatingInterval* mutable_repeating_interval();
  void set_allocated_repeating_interval(::perfetto::protos::TriggerRule_RepeatingInterval* repeating_interval);
  private:
  const ::perfetto::protos::TriggerRule_RepeatingInterval& _internal_repeating_interval() const;
  ::perfetto::protos::TriggerRule_RepeatingInterval* _internal_mutable_repeating_interval();
  public:
  void unsafe_arena_set_allocated_repeating_interval(
      ::perfetto::protos::TriggerRule_RepeatingInterval* repeating_interval);
  ::perfetto::protos::TriggerRule_RepeatingInterval* unsafe_arena_release_repeating_interval();

  void clear_trigger();
  TriggerCase trigger_case() const;
  // @@protoc_insertion_point(class_scope:perfetto.protos.TriggerRule)
 private:
  class _Internal;
  void set_has_manual_trigger_name();
  void set_has_histogram();
  void set_has_repeating_interval();

  inline bool has_trigger() const;
  inline void clear_has_trigger();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint64_t delay_ms_;
    uint64_t activation_delay_ms_;
    float trigger_chance_;
    union TriggerUnion {
      constexpr TriggerUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manual_trigger_name_;
      ::perfetto::protos::TriggerRule_HistogramTrigger* histogram_;
      ::perfetto::protos::TriggerRule_RepeatingInterval* repeating_interval_;
    } trigger_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2fconfig_2fchrome_2fscenario_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class NestedScenarioConfig final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.NestedScenarioConfig) */ {
 public:
  inline NestedScenarioConfig() : NestedScenarioConfig(nullptr) {}
  ~NestedScenarioConfig() override;
  explicit PROTOBUF_CONSTEXPR NestedScenarioConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NestedScenarioConfig(const NestedScenarioConfig& from);
  NestedScenarioConfig(NestedScenarioConfig&& from) noexcept
    : NestedScenarioConfig() {
    *this = ::std::move(from);
  }

  inline NestedScenarioConfig& operator=(const NestedScenarioConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline NestedScenarioConfig& operator=(NestedScenarioConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const NestedScenarioConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const NestedScenarioConfig* internal_default_instance() {
    return reinterpret_cast<const NestedScenarioConfig*>(
               &_NestedScenarioConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(NestedScenarioConfig& a, NestedScenarioConfig& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(NestedScenarioConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NestedScenarioConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NestedScenarioConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NestedScenarioConfig>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const NestedScenarioConfig& from);
  void MergeFrom(const NestedScenarioConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NestedScenarioConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.NestedScenarioConfig";
  }
  protected:
  explicit NestedScenarioConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartRulesFieldNumber = 2,
    kStopRulesFieldNumber = 3,
    kUploadRulesFieldNumber = 4,
    kScenarioNameFieldNumber = 1,
  };
  // repeated .perfetto.protos.TriggerRule start_rules = 2;
  int start_rules_size() const;
  private:
  int _internal_start_rules_size() const;
  public:
  void clear_start_rules();
  ::perfetto::protos::TriggerRule* mutable_start_rules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule >*
      mutable_start_rules();
  private:
  const ::perfetto::protos::TriggerRule& _internal_start_rules(int index) const;
  ::perfetto::protos::TriggerRule* _internal_add_start_rules();
  public:
  const ::perfetto::protos::TriggerRule& start_rules(int index) const;
  ::perfetto::protos::TriggerRule* add_start_rules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule >&
      start_rules() const;

  // repeated .perfetto.protos.TriggerRule stop_rules = 3;
  int stop_rules_size() const;
  private:
  int _internal_stop_rules_size() const;
  public:
  void clear_stop_rules();
  ::perfetto::protos::TriggerRule* mutable_stop_rules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule >*
      mutable_stop_rules();
  private:
  const ::perfetto::protos::TriggerRule& _internal_stop_rules(int index) const;
  ::perfetto::protos::TriggerRule* _internal_add_stop_rules();
  public:
  const ::perfetto::protos::TriggerRule& stop_rules(int index) const;
  ::perfetto::protos::TriggerRule* add_stop_rules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule >&
      stop_rules() const;

  // repeated .perfetto.protos.TriggerRule upload_rules = 4;
  int upload_rules_size() const;
  private:
  int _internal_upload_rules_size() const;
  public:
  void clear_upload_rules();
  ::perfetto::protos::TriggerRule* mutable_upload_rules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule >*
      mutable_upload_rules();
  private:
  const ::perfetto::protos::TriggerRule& _internal_upload_rules(int index) const;
  ::perfetto::protos::TriggerRule* _internal_add_upload_rules();
  public:
  const ::perfetto::protos::TriggerRule& upload_rules(int index) const;
  ::perfetto::protos::TriggerRule* add_upload_rules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule >&
      upload_rules() const;

  // optional string scenario_name = 1;
  bool has_scenario_name() const;
  private:
  bool _internal_has_scenario_name() const;
  public:
  void clear_scenario_name();
  const std::string& scenario_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_scenario_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_scenario_name();
  PROTOBUF_NODISCARD std::string* release_scenario_name();
  void set_allocated_scenario_name(std::string* scenario_name);
  private:
  const std::string& _internal_scenario_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_scenario_name(const std::string& value);
  std::string* _internal_mutable_scenario_name();
  public:

  // @@protoc_insertion_point(class_scope:perfetto.protos.NestedScenarioConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule > start_rules_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule > stop_rules_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule > upload_rules_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scenario_name_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2fconfig_2fchrome_2fscenario_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ScenarioConfig final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.ScenarioConfig) */ {
 public:
  inline ScenarioConfig() : ScenarioConfig(nullptr) {}
  ~ScenarioConfig() override;
  explicit PROTOBUF_CONSTEXPR ScenarioConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScenarioConfig(const ScenarioConfig& from);
  ScenarioConfig(ScenarioConfig&& from) noexcept
    : ScenarioConfig() {
    *this = ::std::move(from);
  }

  inline ScenarioConfig& operator=(const ScenarioConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScenarioConfig& operator=(ScenarioConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ScenarioConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScenarioConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioConfig*>(
               &_ScenarioConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ScenarioConfig& a, ScenarioConfig& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ScenarioConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScenarioConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScenarioConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScenarioConfig>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ScenarioConfig& from);
  void MergeFrom(const ScenarioConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ScenarioConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.ScenarioConfig";
  }
  protected:
  explicit ScenarioConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartRulesFieldNumber = 2,
    kStopRulesFieldNumber = 3,
    kUploadRulesFieldNumber = 4,
    kSetupRulesFieldNumber = 5,
    kNestedScenariosFieldNumber = 7,
    kScenarioNameFieldNumber = 1,
    kTraceConfigFieldNumber = 6,
  };
  // repeated .perfetto.protos.TriggerRule start_rules = 2;
  int start_rules_size() const;
  private:
  int _internal_start_rules_size() const;
  public:
  void clear_start_rules();
  ::perfetto::protos::TriggerRule* mutable_start_rules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule >*
      mutable_start_rules();
  private:
  const ::perfetto::protos::TriggerRule& _internal_start_rules(int index) const;
  ::perfetto::protos::TriggerRule* _internal_add_start_rules();
  public:
  const ::perfetto::protos::TriggerRule& start_rules(int index) const;
  ::perfetto::protos::TriggerRule* add_start_rules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule >&
      start_rules() const;

  // repeated .perfetto.protos.TriggerRule stop_rules = 3;
  int stop_rules_size() const;
  private:
  int _internal_stop_rules_size() const;
  public:
  void clear_stop_rules();
  ::perfetto::protos::TriggerRule* mutable_stop_rules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule >*
      mutable_stop_rules();
  private:
  const ::perfetto::protos::TriggerRule& _internal_stop_rules(int index) const;
  ::perfetto::protos::TriggerRule* _internal_add_stop_rules();
  public:
  const ::perfetto::protos::TriggerRule& stop_rules(int index) const;
  ::perfetto::protos::TriggerRule* add_stop_rules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule >&
      stop_rules() const;

  // repeated .perfetto.protos.TriggerRule upload_rules = 4;
  int upload_rules_size() const;
  private:
  int _internal_upload_rules_size() const;
  public:
  void clear_upload_rules();
  ::perfetto::protos::TriggerRule* mutable_upload_rules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule >*
      mutable_upload_rules();
  private:
  const ::perfetto::protos::TriggerRule& _internal_upload_rules(int index) const;
  ::perfetto::protos::TriggerRule* _internal_add_upload_rules();
  public:
  const ::perfetto::protos::TriggerRule& upload_rules(int index) const;
  ::perfetto::protos::TriggerRule* add_upload_rules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule >&
      upload_rules() const;

  // repeated .perfetto.protos.TriggerRule setup_rules = 5;
  int setup_rules_size() const;
  private:
  int _internal_setup_rules_size() const;
  public:
  void clear_setup_rules();
  ::perfetto::protos::TriggerRule* mutable_setup_rules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule >*
      mutable_setup_rules();
  private:
  const ::perfetto::protos::TriggerRule& _internal_setup_rules(int index) const;
  ::perfetto::protos::TriggerRule* _internal_add_setup_rules();
  public:
  const ::perfetto::protos::TriggerRule& setup_rules(int index) const;
  ::perfetto::protos::TriggerRule* add_setup_rules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule >&
      setup_rules() const;

  // repeated .perfetto.protos.NestedScenarioConfig nested_scenarios = 7;
  int nested_scenarios_size() const;
  private:
  int _internal_nested_scenarios_size() const;
  public:
  void clear_nested_scenarios();
  ::perfetto::protos::NestedScenarioConfig* mutable_nested_scenarios(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::NestedScenarioConfig >*
      mutable_nested_scenarios();
  private:
  const ::perfetto::protos::NestedScenarioConfig& _internal_nested_scenarios(int index) const;
  ::perfetto::protos::NestedScenarioConfig* _internal_add_nested_scenarios();
  public:
  const ::perfetto::protos::NestedScenarioConfig& nested_scenarios(int index) const;
  ::perfetto::protos::NestedScenarioConfig* add_nested_scenarios();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::NestedScenarioConfig >&
      nested_scenarios() const;

  // optional string scenario_name = 1;
  bool has_scenario_name() const;
  private:
  bool _internal_has_scenario_name() const;
  public:
  void clear_scenario_name();
  const std::string& scenario_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_scenario_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_scenario_name();
  PROTOBUF_NODISCARD std::string* release_scenario_name();
  void set_allocated_scenario_name(std::string* scenario_name);
  private:
  const std::string& _internal_scenario_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_scenario_name(const std::string& value);
  std::string* _internal_mutable_scenario_name();
  public:

  // optional .perfetto.protos.TraceConfig trace_config = 6;
  bool has_trace_config() const;
  private:
  bool _internal_has_trace_config() const;
  public:
  void clear_trace_config();
  const ::perfetto::protos::TraceConfig& trace_config() const;
  PROTOBUF_NODISCARD ::perfetto::protos::TraceConfig* release_trace_config();
  ::perfetto::protos::TraceConfig* mutable_trace_config();
  void set_allocated_trace_config(::perfetto::protos::TraceConfig* trace_config);
  private:
  const ::perfetto::protos::TraceConfig& _internal_trace_config() const;
  ::perfetto::protos::TraceConfig* _internal_mutable_trace_config();
  public:
  void unsafe_arena_set_allocated_trace_config(
      ::perfetto::protos::TraceConfig* trace_config);
  ::perfetto::protos::TraceConfig* unsafe_arena_release_trace_config();

  // @@protoc_insertion_point(class_scope:perfetto.protos.ScenarioConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule > start_rules_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule > stop_rules_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule > upload_rules_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule > setup_rules_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::NestedScenarioConfig > nested_scenarios_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scenario_name_;
    ::perfetto::protos::TraceConfig* trace_config_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2fconfig_2fchrome_2fscenario_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ChromeFieldTracingConfig final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.ChromeFieldTracingConfig) */ {
 public:
  inline ChromeFieldTracingConfig() : ChromeFieldTracingConfig(nullptr) {}
  ~ChromeFieldTracingConfig() override;
  explicit PROTOBUF_CONSTEXPR ChromeFieldTracingConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChromeFieldTracingConfig(const ChromeFieldTracingConfig& from);
  ChromeFieldTracingConfig(ChromeFieldTracingConfig&& from) noexcept
    : ChromeFieldTracingConfig() {
    *this = ::std::move(from);
  }

  inline ChromeFieldTracingConfig& operator=(const ChromeFieldTracingConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChromeFieldTracingConfig& operator=(ChromeFieldTracingConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ChromeFieldTracingConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChromeFieldTracingConfig* internal_default_instance() {
    return reinterpret_cast<const ChromeFieldTracingConfig*>(
               &_ChromeFieldTracingConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ChromeFieldTracingConfig& a, ChromeFieldTracingConfig& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ChromeFieldTracingConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChromeFieldTracingConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChromeFieldTracingConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChromeFieldTracingConfig>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ChromeFieldTracingConfig& from);
  void MergeFrom(const ChromeFieldTracingConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChromeFieldTracingConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.ChromeFieldTracingConfig";
  }
  protected:
  explicit ChromeFieldTracingConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScenariosFieldNumber = 1,
  };
  // repeated .perfetto.protos.ScenarioConfig scenarios = 1;
  int scenarios_size() const;
  private:
  int _internal_scenarios_size() const;
  public:
  void clear_scenarios();
  ::perfetto::protos::ScenarioConfig* mutable_scenarios(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::ScenarioConfig >*
      mutable_scenarios();
  private:
  const ::perfetto::protos::ScenarioConfig& _internal_scenarios(int index) const;
  ::perfetto::protos::ScenarioConfig* _internal_add_scenarios();
  public:
  const ::perfetto::protos::ScenarioConfig& scenarios(int index) const;
  ::perfetto::protos::ScenarioConfig* add_scenarios();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::ScenarioConfig >&
      scenarios() const;

  // @@protoc_insertion_point(class_scope:perfetto.protos.ChromeFieldTracingConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::ScenarioConfig > scenarios_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2fconfig_2fchrome_2fscenario_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class TracingTriggerRulesConfig final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:perfetto.protos.TracingTriggerRulesConfig) */ {
 public:
  inline TracingTriggerRulesConfig() : TracingTriggerRulesConfig(nullptr) {}
  ~TracingTriggerRulesConfig() override;
  explicit PROTOBUF_CONSTEXPR TracingTriggerRulesConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TracingTriggerRulesConfig(const TracingTriggerRulesConfig& from);
  TracingTriggerRulesConfig(TracingTriggerRulesConfig&& from) noexcept
    : TracingTriggerRulesConfig() {
    *this = ::std::move(from);
  }

  inline TracingTriggerRulesConfig& operator=(const TracingTriggerRulesConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline TracingTriggerRulesConfig& operator=(TracingTriggerRulesConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TracingTriggerRulesConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const TracingTriggerRulesConfig* internal_default_instance() {
    return reinterpret_cast<const TracingTriggerRulesConfig*>(
               &_TracingTriggerRulesConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TracingTriggerRulesConfig& a, TracingTriggerRulesConfig& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TracingTriggerRulesConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TracingTriggerRulesConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TracingTriggerRulesConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TracingTriggerRulesConfig>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TracingTriggerRulesConfig& from);
  void MergeFrom(const TracingTriggerRulesConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TracingTriggerRulesConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "perfetto.protos.TracingTriggerRulesConfig";
  }
  protected:
  explicit TracingTriggerRulesConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRulesFieldNumber = 1,
  };
  // repeated .perfetto.protos.TriggerRule rules = 1;
  int rules_size() const;
  private:
  int _internal_rules_size() const;
  public:
  void clear_rules();
  ::perfetto::protos::TriggerRule* mutable_rules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule >*
      mutable_rules();
  private:
  const ::perfetto::protos::TriggerRule& _internal_rules(int index) const;
  ::perfetto::protos::TriggerRule* _internal_add_rules();
  public:
  const ::perfetto::protos::TriggerRule& rules(int index) const;
  ::perfetto::protos::TriggerRule* add_rules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule >&
      rules() const;

  // @@protoc_insertion_point(class_scope:perfetto.protos.TracingTriggerRulesConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule > rules_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_protos_2fperfetto_2fconfig_2fchrome_2fscenario_5fconfig_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TriggerRule_HistogramTrigger

// optional string histogram_name = 1;
inline bool TriggerRule_HistogramTrigger::_internal_has_histogram_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TriggerRule_HistogramTrigger::has_histogram_name() const {
  return _internal_has_histogram_name();
}
inline void TriggerRule_HistogramTrigger::clear_histogram_name() {
  _impl_.histogram_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TriggerRule_HistogramTrigger::histogram_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TriggerRule.HistogramTrigger.histogram_name)
  return _internal_histogram_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TriggerRule_HistogramTrigger::set_histogram_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.histogram_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.TriggerRule.HistogramTrigger.histogram_name)
}
inline std::string* TriggerRule_HistogramTrigger::mutable_histogram_name() {
  std::string* _s = _internal_mutable_histogram_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TriggerRule.HistogramTrigger.histogram_name)
  return _s;
}
inline const std::string& TriggerRule_HistogramTrigger::_internal_histogram_name() const {
  return _impl_.histogram_name_.Get();
}
inline void TriggerRule_HistogramTrigger::_internal_set_histogram_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.histogram_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TriggerRule_HistogramTrigger::_internal_mutable_histogram_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.histogram_name_.Mutable(GetArenaForAllocation());
}
inline std::string* TriggerRule_HistogramTrigger::release_histogram_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TriggerRule.HistogramTrigger.histogram_name)
  if (!_internal_has_histogram_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.histogram_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.histogram_name_.IsDefault()) {
    _impl_.histogram_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TriggerRule_HistogramTrigger::set_allocated_histogram_name(std::string* histogram_name) {
  if (histogram_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.histogram_name_.SetAllocated(histogram_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.histogram_name_.IsDefault()) {
    _impl_.histogram_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TriggerRule.HistogramTrigger.histogram_name)
}

// optional int64 min_value = 2;
inline bool TriggerRule_HistogramTrigger::_internal_has_min_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TriggerRule_HistogramTrigger::has_min_value() const {
  return _internal_has_min_value();
}
inline void TriggerRule_HistogramTrigger::clear_min_value() {
  _impl_.min_value_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t TriggerRule_HistogramTrigger::_internal_min_value() const {
  return _impl_.min_value_;
}
inline int64_t TriggerRule_HistogramTrigger::min_value() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TriggerRule.HistogramTrigger.min_value)
  return _internal_min_value();
}
inline void TriggerRule_HistogramTrigger::_internal_set_min_value(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.min_value_ = value;
}
inline void TriggerRule_HistogramTrigger::set_min_value(int64_t value) {
  _internal_set_min_value(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TriggerRule.HistogramTrigger.min_value)
}

// optional int64 max_value = 3;
inline bool TriggerRule_HistogramTrigger::_internal_has_max_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TriggerRule_HistogramTrigger::has_max_value() const {
  return _internal_has_max_value();
}
inline void TriggerRule_HistogramTrigger::clear_max_value() {
  _impl_.max_value_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t TriggerRule_HistogramTrigger::_internal_max_value() const {
  return _impl_.max_value_;
}
inline int64_t TriggerRule_HistogramTrigger::max_value() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TriggerRule.HistogramTrigger.max_value)
  return _internal_max_value();
}
inline void TriggerRule_HistogramTrigger::_internal_set_max_value(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.max_value_ = value;
}
inline void TriggerRule_HistogramTrigger::set_max_value(int64_t value) {
  _internal_set_max_value(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TriggerRule.HistogramTrigger.max_value)
}

// -------------------------------------------------------------------

// TriggerRule_RepeatingInterval

// optional uint64 period_ms = 1;
inline bool TriggerRule_RepeatingInterval::_internal_has_period_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TriggerRule_RepeatingInterval::has_period_ms() const {
  return _internal_has_period_ms();
}
inline void TriggerRule_RepeatingInterval::clear_period_ms() {
  _impl_.period_ms_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t TriggerRule_RepeatingInterval::_internal_period_ms() const {
  return _impl_.period_ms_;
}
inline uint64_t TriggerRule_RepeatingInterval::period_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TriggerRule.RepeatingInterval.period_ms)
  return _internal_period_ms();
}
inline void TriggerRule_RepeatingInterval::_internal_set_period_ms(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.period_ms_ = value;
}
inline void TriggerRule_RepeatingInterval::set_period_ms(uint64_t value) {
  _internal_set_period_ms(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TriggerRule.RepeatingInterval.period_ms)
}

// optional bool randomized = 2;
inline bool TriggerRule_RepeatingInterval::_internal_has_randomized() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TriggerRule_RepeatingInterval::has_randomized() const {
  return _internal_has_randomized();
}
inline void TriggerRule_RepeatingInterval::clear_randomized() {
  _impl_.randomized_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool TriggerRule_RepeatingInterval::_internal_randomized() const {
  return _impl_.randomized_;
}
inline bool TriggerRule_RepeatingInterval::randomized() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TriggerRule.RepeatingInterval.randomized)
  return _internal_randomized();
}
inline void TriggerRule_RepeatingInterval::_internal_set_randomized(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.randomized_ = value;
}
inline void TriggerRule_RepeatingInterval::set_randomized(bool value) {
  _internal_set_randomized(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TriggerRule.RepeatingInterval.randomized)
}

// -------------------------------------------------------------------

// TriggerRule

// optional string name = 1;
inline bool TriggerRule::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TriggerRule::has_name() const {
  return _internal_has_name();
}
inline void TriggerRule::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TriggerRule::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TriggerRule.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TriggerRule::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.TriggerRule.name)
}
inline std::string* TriggerRule::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TriggerRule.name)
  return _s;
}
inline const std::string& TriggerRule::_internal_name() const {
  return _impl_.name_.Get();
}
inline void TriggerRule::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TriggerRule::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* TriggerRule::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TriggerRule.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TriggerRule::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TriggerRule.name)
}

// optional float trigger_chance = 2;
inline bool TriggerRule::_internal_has_trigger_chance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TriggerRule::has_trigger_chance() const {
  return _internal_has_trigger_chance();
}
inline void TriggerRule::clear_trigger_chance() {
  _impl_.trigger_chance_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float TriggerRule::_internal_trigger_chance() const {
  return _impl_.trigger_chance_;
}
inline float TriggerRule::trigger_chance() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TriggerRule.trigger_chance)
  return _internal_trigger_chance();
}
inline void TriggerRule::_internal_set_trigger_chance(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.trigger_chance_ = value;
}
inline void TriggerRule::set_trigger_chance(float value) {
  _internal_set_trigger_chance(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TriggerRule.trigger_chance)
}

// optional uint64 delay_ms = 3;
inline bool TriggerRule::_internal_has_delay_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TriggerRule::has_delay_ms() const {
  return _internal_has_delay_ms();
}
inline void TriggerRule::clear_delay_ms() {
  _impl_.delay_ms_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t TriggerRule::_internal_delay_ms() const {
  return _impl_.delay_ms_;
}
inline uint64_t TriggerRule::delay_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TriggerRule.delay_ms)
  return _internal_delay_ms();
}
inline void TriggerRule::_internal_set_delay_ms(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.delay_ms_ = value;
}
inline void TriggerRule::set_delay_ms(uint64_t value) {
  _internal_set_delay_ms(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TriggerRule.delay_ms)
}

// optional uint64 activation_delay_ms = 8;
inline bool TriggerRule::_internal_has_activation_delay_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TriggerRule::has_activation_delay_ms() const {
  return _internal_has_activation_delay_ms();
}
inline void TriggerRule::clear_activation_delay_ms() {
  _impl_.activation_delay_ms_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t TriggerRule::_internal_activation_delay_ms() const {
  return _impl_.activation_delay_ms_;
}
inline uint64_t TriggerRule::activation_delay_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TriggerRule.activation_delay_ms)
  return _internal_activation_delay_ms();
}
inline void TriggerRule::_internal_set_activation_delay_ms(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.activation_delay_ms_ = value;
}
inline void TriggerRule::set_activation_delay_ms(uint64_t value) {
  _internal_set_activation_delay_ms(value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TriggerRule.activation_delay_ms)
}

// string manual_trigger_name = 4;
inline bool TriggerRule::_internal_has_manual_trigger_name() const {
  return trigger_case() == kManualTriggerName;
}
inline bool TriggerRule::has_manual_trigger_name() const {
  return _internal_has_manual_trigger_name();
}
inline void TriggerRule::set_has_manual_trigger_name() {
  _impl_._oneof_case_[0] = kManualTriggerName;
}
inline void TriggerRule::clear_manual_trigger_name() {
  if (_internal_has_manual_trigger_name()) {
    _impl_.trigger_.manual_trigger_name_.Destroy();
    clear_has_trigger();
  }
}
inline const std::string& TriggerRule::manual_trigger_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TriggerRule.manual_trigger_name)
  return _internal_manual_trigger_name();
}
template <typename ArgT0, typename... ArgT>
inline void TriggerRule::set_manual_trigger_name(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_manual_trigger_name()) {
    clear_trigger();
    set_has_manual_trigger_name();
    _impl_.trigger_.manual_trigger_name_.InitDefault();
  }
  _impl_.trigger_.manual_trigger_name_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.TriggerRule.manual_trigger_name)
}
inline std::string* TriggerRule::mutable_manual_trigger_name() {
  std::string* _s = _internal_mutable_manual_trigger_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TriggerRule.manual_trigger_name)
  return _s;
}
inline const std::string& TriggerRule::_internal_manual_trigger_name() const {
  if (_internal_has_manual_trigger_name()) {
    return _impl_.trigger_.manual_trigger_name_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void TriggerRule::_internal_set_manual_trigger_name(const std::string& value) {
  if (!_internal_has_manual_trigger_name()) {
    clear_trigger();
    set_has_manual_trigger_name();
    _impl_.trigger_.manual_trigger_name_.InitDefault();
  }
  _impl_.trigger_.manual_trigger_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TriggerRule::_internal_mutable_manual_trigger_name() {
  if (!_internal_has_manual_trigger_name()) {
    clear_trigger();
    set_has_manual_trigger_name();
    _impl_.trigger_.manual_trigger_name_.InitDefault();
  }
  return _impl_.trigger_.manual_trigger_name_.Mutable(      GetArenaForAllocation());
}
inline std::string* TriggerRule::release_manual_trigger_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TriggerRule.manual_trigger_name)
  if (_internal_has_manual_trigger_name()) {
    clear_has_trigger();
    return _impl_.trigger_.manual_trigger_name_.Release();
  } else {
    return nullptr;
  }
}
inline void TriggerRule::set_allocated_manual_trigger_name(std::string* manual_trigger_name) {
  if (has_trigger()) {
    clear_trigger();
  }
  if (manual_trigger_name != nullptr) {
    set_has_manual_trigger_name();
    _impl_.trigger_.manual_trigger_name_.InitAllocated(manual_trigger_name, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TriggerRule.manual_trigger_name)
}

// .perfetto.protos.TriggerRule.HistogramTrigger histogram = 5;
inline bool TriggerRule::_internal_has_histogram() const {
  return trigger_case() == kHistogram;
}
inline bool TriggerRule::has_histogram() const {
  return _internal_has_histogram();
}
inline void TriggerRule::set_has_histogram() {
  _impl_._oneof_case_[0] = kHistogram;
}
inline void TriggerRule::clear_histogram() {
  if (_internal_has_histogram()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.trigger_.histogram_;
    }
    clear_has_trigger();
  }
}
inline ::perfetto::protos::TriggerRule_HistogramTrigger* TriggerRule::release_histogram() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TriggerRule.histogram)
  if (_internal_has_histogram()) {
    clear_has_trigger();
    ::perfetto::protos::TriggerRule_HistogramTrigger* temp = _impl_.trigger_.histogram_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.trigger_.histogram_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::perfetto::protos::TriggerRule_HistogramTrigger& TriggerRule::_internal_histogram() const {
  return _internal_has_histogram()
      ? *_impl_.trigger_.histogram_
      : reinterpret_cast< ::perfetto::protos::TriggerRule_HistogramTrigger&>(::perfetto::protos::_TriggerRule_HistogramTrigger_default_instance_);
}
inline const ::perfetto::protos::TriggerRule_HistogramTrigger& TriggerRule::histogram() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TriggerRule.histogram)
  return _internal_histogram();
}
inline ::perfetto::protos::TriggerRule_HistogramTrigger* TriggerRule::unsafe_arena_release_histogram() {
  // @@protoc_insertion_point(field_unsafe_arena_release:perfetto.protos.TriggerRule.histogram)
  if (_internal_has_histogram()) {
    clear_has_trigger();
    ::perfetto::protos::TriggerRule_HistogramTrigger* temp = _impl_.trigger_.histogram_;
    _impl_.trigger_.histogram_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TriggerRule::unsafe_arena_set_allocated_histogram(::perfetto::protos::TriggerRule_HistogramTrigger* histogram) {
  clear_trigger();
  if (histogram) {
    set_has_histogram();
    _impl_.trigger_.histogram_ = histogram;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perfetto.protos.TriggerRule.histogram)
}
inline ::perfetto::protos::TriggerRule_HistogramTrigger* TriggerRule::_internal_mutable_histogram() {
  if (!_internal_has_histogram()) {
    clear_trigger();
    set_has_histogram();
    _impl_.trigger_.histogram_ = CreateMaybeMessage< ::perfetto::protos::TriggerRule_HistogramTrigger >(GetArenaForAllocation());
  }
  return _impl_.trigger_.histogram_;
}
inline ::perfetto::protos::TriggerRule_HistogramTrigger* TriggerRule::mutable_histogram() {
  ::perfetto::protos::TriggerRule_HistogramTrigger* _msg = _internal_mutable_histogram();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TriggerRule.histogram)
  return _msg;
}

// .perfetto.protos.TriggerRule.RepeatingInterval repeating_interval = 6;
inline bool TriggerRule::_internal_has_repeating_interval() const {
  return trigger_case() == kRepeatingInterval;
}
inline bool TriggerRule::has_repeating_interval() const {
  return _internal_has_repeating_interval();
}
inline void TriggerRule::set_has_repeating_interval() {
  _impl_._oneof_case_[0] = kRepeatingInterval;
}
inline void TriggerRule::clear_repeating_interval() {
  if (_internal_has_repeating_interval()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.trigger_.repeating_interval_;
    }
    clear_has_trigger();
  }
}
inline ::perfetto::protos::TriggerRule_RepeatingInterval* TriggerRule::release_repeating_interval() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TriggerRule.repeating_interval)
  if (_internal_has_repeating_interval()) {
    clear_has_trigger();
    ::perfetto::protos::TriggerRule_RepeatingInterval* temp = _impl_.trigger_.repeating_interval_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.trigger_.repeating_interval_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::perfetto::protos::TriggerRule_RepeatingInterval& TriggerRule::_internal_repeating_interval() const {
  return _internal_has_repeating_interval()
      ? *_impl_.trigger_.repeating_interval_
      : reinterpret_cast< ::perfetto::protos::TriggerRule_RepeatingInterval&>(::perfetto::protos::_TriggerRule_RepeatingInterval_default_instance_);
}
inline const ::perfetto::protos::TriggerRule_RepeatingInterval& TriggerRule::repeating_interval() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TriggerRule.repeating_interval)
  return _internal_repeating_interval();
}
inline ::perfetto::protos::TriggerRule_RepeatingInterval* TriggerRule::unsafe_arena_release_repeating_interval() {
  // @@protoc_insertion_point(field_unsafe_arena_release:perfetto.protos.TriggerRule.repeating_interval)
  if (_internal_has_repeating_interval()) {
    clear_has_trigger();
    ::perfetto::protos::TriggerRule_RepeatingInterval* temp = _impl_.trigger_.repeating_interval_;
    _impl_.trigger_.repeating_interval_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TriggerRule::unsafe_arena_set_allocated_repeating_interval(::perfetto::protos::TriggerRule_RepeatingInterval* repeating_interval) {
  clear_trigger();
  if (repeating_interval) {
    set_has_repeating_interval();
    _impl_.trigger_.repeating_interval_ = repeating_interval;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perfetto.protos.TriggerRule.repeating_interval)
}
inline ::perfetto::protos::TriggerRule_RepeatingInterval* TriggerRule::_internal_mutable_repeating_interval() {
  if (!_internal_has_repeating_interval()) {
    clear_trigger();
    set_has_repeating_interval();
    _impl_.trigger_.repeating_interval_ = CreateMaybeMessage< ::perfetto::protos::TriggerRule_RepeatingInterval >(GetArenaForAllocation());
  }
  return _impl_.trigger_.repeating_interval_;
}
inline ::perfetto::protos::TriggerRule_RepeatingInterval* TriggerRule::mutable_repeating_interval() {
  ::perfetto::protos::TriggerRule_RepeatingInterval* _msg = _internal_mutable_repeating_interval();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TriggerRule.repeating_interval)
  return _msg;
}

inline bool TriggerRule::has_trigger() const {
  return trigger_case() != TRIGGER_NOT_SET;
}
inline void TriggerRule::clear_has_trigger() {
  _impl_._oneof_case_[0] = TRIGGER_NOT_SET;
}
inline TriggerRule::TriggerCase TriggerRule::trigger_case() const {
  return TriggerRule::TriggerCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// NestedScenarioConfig

// optional string scenario_name = 1;
inline bool NestedScenarioConfig::_internal_has_scenario_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NestedScenarioConfig::has_scenario_name() const {
  return _internal_has_scenario_name();
}
inline void NestedScenarioConfig::clear_scenario_name() {
  _impl_.scenario_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NestedScenarioConfig::scenario_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.NestedScenarioConfig.scenario_name)
  return _internal_scenario_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NestedScenarioConfig::set_scenario_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.scenario_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.NestedScenarioConfig.scenario_name)
}
inline std::string* NestedScenarioConfig::mutable_scenario_name() {
  std::string* _s = _internal_mutable_scenario_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.NestedScenarioConfig.scenario_name)
  return _s;
}
inline const std::string& NestedScenarioConfig::_internal_scenario_name() const {
  return _impl_.scenario_name_.Get();
}
inline void NestedScenarioConfig::_internal_set_scenario_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.scenario_name_.Set(value, GetArenaForAllocation());
}
inline std::string* NestedScenarioConfig::_internal_mutable_scenario_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.scenario_name_.Mutable(GetArenaForAllocation());
}
inline std::string* NestedScenarioConfig::release_scenario_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.NestedScenarioConfig.scenario_name)
  if (!_internal_has_scenario_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.scenario_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.scenario_name_.IsDefault()) {
    _impl_.scenario_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NestedScenarioConfig::set_allocated_scenario_name(std::string* scenario_name) {
  if (scenario_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.scenario_name_.SetAllocated(scenario_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.scenario_name_.IsDefault()) {
    _impl_.scenario_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.NestedScenarioConfig.scenario_name)
}

// repeated .perfetto.protos.TriggerRule start_rules = 2;
inline int NestedScenarioConfig::_internal_start_rules_size() const {
  return _impl_.start_rules_.size();
}
inline int NestedScenarioConfig::start_rules_size() const {
  return _internal_start_rules_size();
}
inline void NestedScenarioConfig::clear_start_rules() {
  _impl_.start_rules_.Clear();
}
inline ::perfetto::protos::TriggerRule* NestedScenarioConfig::mutable_start_rules(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.NestedScenarioConfig.start_rules)
  return _impl_.start_rules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule >*
NestedScenarioConfig::mutable_start_rules() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.NestedScenarioConfig.start_rules)
  return &_impl_.start_rules_;
}
inline const ::perfetto::protos::TriggerRule& NestedScenarioConfig::_internal_start_rules(int index) const {
  return _impl_.start_rules_.Get(index);
}
inline const ::perfetto::protos::TriggerRule& NestedScenarioConfig::start_rules(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.NestedScenarioConfig.start_rules)
  return _internal_start_rules(index);
}
inline ::perfetto::protos::TriggerRule* NestedScenarioConfig::_internal_add_start_rules() {
  return _impl_.start_rules_.Add();
}
inline ::perfetto::protos::TriggerRule* NestedScenarioConfig::add_start_rules() {
  ::perfetto::protos::TriggerRule* _add = _internal_add_start_rules();
  // @@protoc_insertion_point(field_add:perfetto.protos.NestedScenarioConfig.start_rules)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule >&
NestedScenarioConfig::start_rules() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.NestedScenarioConfig.start_rules)
  return _impl_.start_rules_;
}

// repeated .perfetto.protos.TriggerRule stop_rules = 3;
inline int NestedScenarioConfig::_internal_stop_rules_size() const {
  return _impl_.stop_rules_.size();
}
inline int NestedScenarioConfig::stop_rules_size() const {
  return _internal_stop_rules_size();
}
inline void NestedScenarioConfig::clear_stop_rules() {
  _impl_.stop_rules_.Clear();
}
inline ::perfetto::protos::TriggerRule* NestedScenarioConfig::mutable_stop_rules(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.NestedScenarioConfig.stop_rules)
  return _impl_.stop_rules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule >*
NestedScenarioConfig::mutable_stop_rules() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.NestedScenarioConfig.stop_rules)
  return &_impl_.stop_rules_;
}
inline const ::perfetto::protos::TriggerRule& NestedScenarioConfig::_internal_stop_rules(int index) const {
  return _impl_.stop_rules_.Get(index);
}
inline const ::perfetto::protos::TriggerRule& NestedScenarioConfig::stop_rules(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.NestedScenarioConfig.stop_rules)
  return _internal_stop_rules(index);
}
inline ::perfetto::protos::TriggerRule* NestedScenarioConfig::_internal_add_stop_rules() {
  return _impl_.stop_rules_.Add();
}
inline ::perfetto::protos::TriggerRule* NestedScenarioConfig::add_stop_rules() {
  ::perfetto::protos::TriggerRule* _add = _internal_add_stop_rules();
  // @@protoc_insertion_point(field_add:perfetto.protos.NestedScenarioConfig.stop_rules)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule >&
NestedScenarioConfig::stop_rules() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.NestedScenarioConfig.stop_rules)
  return _impl_.stop_rules_;
}

// repeated .perfetto.protos.TriggerRule upload_rules = 4;
inline int NestedScenarioConfig::_internal_upload_rules_size() const {
  return _impl_.upload_rules_.size();
}
inline int NestedScenarioConfig::upload_rules_size() const {
  return _internal_upload_rules_size();
}
inline void NestedScenarioConfig::clear_upload_rules() {
  _impl_.upload_rules_.Clear();
}
inline ::perfetto::protos::TriggerRule* NestedScenarioConfig::mutable_upload_rules(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.NestedScenarioConfig.upload_rules)
  return _impl_.upload_rules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule >*
NestedScenarioConfig::mutable_upload_rules() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.NestedScenarioConfig.upload_rules)
  return &_impl_.upload_rules_;
}
inline const ::perfetto::protos::TriggerRule& NestedScenarioConfig::_internal_upload_rules(int index) const {
  return _impl_.upload_rules_.Get(index);
}
inline const ::perfetto::protos::TriggerRule& NestedScenarioConfig::upload_rules(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.NestedScenarioConfig.upload_rules)
  return _internal_upload_rules(index);
}
inline ::perfetto::protos::TriggerRule* NestedScenarioConfig::_internal_add_upload_rules() {
  return _impl_.upload_rules_.Add();
}
inline ::perfetto::protos::TriggerRule* NestedScenarioConfig::add_upload_rules() {
  ::perfetto::protos::TriggerRule* _add = _internal_add_upload_rules();
  // @@protoc_insertion_point(field_add:perfetto.protos.NestedScenarioConfig.upload_rules)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule >&
NestedScenarioConfig::upload_rules() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.NestedScenarioConfig.upload_rules)
  return _impl_.upload_rules_;
}

// -------------------------------------------------------------------

// ScenarioConfig

// optional string scenario_name = 1;
inline bool ScenarioConfig::_internal_has_scenario_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ScenarioConfig::has_scenario_name() const {
  return _internal_has_scenario_name();
}
inline void ScenarioConfig::clear_scenario_name() {
  _impl_.scenario_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ScenarioConfig::scenario_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ScenarioConfig.scenario_name)
  return _internal_scenario_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ScenarioConfig::set_scenario_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.scenario_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:perfetto.protos.ScenarioConfig.scenario_name)
}
inline std::string* ScenarioConfig::mutable_scenario_name() {
  std::string* _s = _internal_mutable_scenario_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ScenarioConfig.scenario_name)
  return _s;
}
inline const std::string& ScenarioConfig::_internal_scenario_name() const {
  return _impl_.scenario_name_.Get();
}
inline void ScenarioConfig::_internal_set_scenario_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.scenario_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ScenarioConfig::_internal_mutable_scenario_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.scenario_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ScenarioConfig::release_scenario_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.ScenarioConfig.scenario_name)
  if (!_internal_has_scenario_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.scenario_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.scenario_name_.IsDefault()) {
    _impl_.scenario_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ScenarioConfig::set_allocated_scenario_name(std::string* scenario_name) {
  if (scenario_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.scenario_name_.SetAllocated(scenario_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.scenario_name_.IsDefault()) {
    _impl_.scenario_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.ScenarioConfig.scenario_name)
}

// repeated .perfetto.protos.TriggerRule start_rules = 2;
inline int ScenarioConfig::_internal_start_rules_size() const {
  return _impl_.start_rules_.size();
}
inline int ScenarioConfig::start_rules_size() const {
  return _internal_start_rules_size();
}
inline void ScenarioConfig::clear_start_rules() {
  _impl_.start_rules_.Clear();
}
inline ::perfetto::protos::TriggerRule* ScenarioConfig::mutable_start_rules(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ScenarioConfig.start_rules)
  return _impl_.start_rules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule >*
ScenarioConfig::mutable_start_rules() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.ScenarioConfig.start_rules)
  return &_impl_.start_rules_;
}
inline const ::perfetto::protos::TriggerRule& ScenarioConfig::_internal_start_rules(int index) const {
  return _impl_.start_rules_.Get(index);
}
inline const ::perfetto::protos::TriggerRule& ScenarioConfig::start_rules(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ScenarioConfig.start_rules)
  return _internal_start_rules(index);
}
inline ::perfetto::protos::TriggerRule* ScenarioConfig::_internal_add_start_rules() {
  return _impl_.start_rules_.Add();
}
inline ::perfetto::protos::TriggerRule* ScenarioConfig::add_start_rules() {
  ::perfetto::protos::TriggerRule* _add = _internal_add_start_rules();
  // @@protoc_insertion_point(field_add:perfetto.protos.ScenarioConfig.start_rules)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule >&
ScenarioConfig::start_rules() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.ScenarioConfig.start_rules)
  return _impl_.start_rules_;
}

// repeated .perfetto.protos.TriggerRule stop_rules = 3;
inline int ScenarioConfig::_internal_stop_rules_size() const {
  return _impl_.stop_rules_.size();
}
inline int ScenarioConfig::stop_rules_size() const {
  return _internal_stop_rules_size();
}
inline void ScenarioConfig::clear_stop_rules() {
  _impl_.stop_rules_.Clear();
}
inline ::perfetto::protos::TriggerRule* ScenarioConfig::mutable_stop_rules(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ScenarioConfig.stop_rules)
  return _impl_.stop_rules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule >*
ScenarioConfig::mutable_stop_rules() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.ScenarioConfig.stop_rules)
  return &_impl_.stop_rules_;
}
inline const ::perfetto::protos::TriggerRule& ScenarioConfig::_internal_stop_rules(int index) const {
  return _impl_.stop_rules_.Get(index);
}
inline const ::perfetto::protos::TriggerRule& ScenarioConfig::stop_rules(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ScenarioConfig.stop_rules)
  return _internal_stop_rules(index);
}
inline ::perfetto::protos::TriggerRule* ScenarioConfig::_internal_add_stop_rules() {
  return _impl_.stop_rules_.Add();
}
inline ::perfetto::protos::TriggerRule* ScenarioConfig::add_stop_rules() {
  ::perfetto::protos::TriggerRule* _add = _internal_add_stop_rules();
  // @@protoc_insertion_point(field_add:perfetto.protos.ScenarioConfig.stop_rules)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule >&
ScenarioConfig::stop_rules() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.ScenarioConfig.stop_rules)
  return _impl_.stop_rules_;
}

// repeated .perfetto.protos.TriggerRule upload_rules = 4;
inline int ScenarioConfig::_internal_upload_rules_size() const {
  return _impl_.upload_rules_.size();
}
inline int ScenarioConfig::upload_rules_size() const {
  return _internal_upload_rules_size();
}
inline void ScenarioConfig::clear_upload_rules() {
  _impl_.upload_rules_.Clear();
}
inline ::perfetto::protos::TriggerRule* ScenarioConfig::mutable_upload_rules(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ScenarioConfig.upload_rules)
  return _impl_.upload_rules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule >*
ScenarioConfig::mutable_upload_rules() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.ScenarioConfig.upload_rules)
  return &_impl_.upload_rules_;
}
inline const ::perfetto::protos::TriggerRule& ScenarioConfig::_internal_upload_rules(int index) const {
  return _impl_.upload_rules_.Get(index);
}
inline const ::perfetto::protos::TriggerRule& ScenarioConfig::upload_rules(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ScenarioConfig.upload_rules)
  return _internal_upload_rules(index);
}
inline ::perfetto::protos::TriggerRule* ScenarioConfig::_internal_add_upload_rules() {
  return _impl_.upload_rules_.Add();
}
inline ::perfetto::protos::TriggerRule* ScenarioConfig::add_upload_rules() {
  ::perfetto::protos::TriggerRule* _add = _internal_add_upload_rules();
  // @@protoc_insertion_point(field_add:perfetto.protos.ScenarioConfig.upload_rules)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule >&
ScenarioConfig::upload_rules() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.ScenarioConfig.upload_rules)
  return _impl_.upload_rules_;
}

// repeated .perfetto.protos.TriggerRule setup_rules = 5;
inline int ScenarioConfig::_internal_setup_rules_size() const {
  return _impl_.setup_rules_.size();
}
inline int ScenarioConfig::setup_rules_size() const {
  return _internal_setup_rules_size();
}
inline void ScenarioConfig::clear_setup_rules() {
  _impl_.setup_rules_.Clear();
}
inline ::perfetto::protos::TriggerRule* ScenarioConfig::mutable_setup_rules(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ScenarioConfig.setup_rules)
  return _impl_.setup_rules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule >*
ScenarioConfig::mutable_setup_rules() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.ScenarioConfig.setup_rules)
  return &_impl_.setup_rules_;
}
inline const ::perfetto::protos::TriggerRule& ScenarioConfig::_internal_setup_rules(int index) const {
  return _impl_.setup_rules_.Get(index);
}
inline const ::perfetto::protos::TriggerRule& ScenarioConfig::setup_rules(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ScenarioConfig.setup_rules)
  return _internal_setup_rules(index);
}
inline ::perfetto::protos::TriggerRule* ScenarioConfig::_internal_add_setup_rules() {
  return _impl_.setup_rules_.Add();
}
inline ::perfetto::protos::TriggerRule* ScenarioConfig::add_setup_rules() {
  ::perfetto::protos::TriggerRule* _add = _internal_add_setup_rules();
  // @@protoc_insertion_point(field_add:perfetto.protos.ScenarioConfig.setup_rules)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule >&
ScenarioConfig::setup_rules() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.ScenarioConfig.setup_rules)
  return _impl_.setup_rules_;
}

// optional .perfetto.protos.TraceConfig trace_config = 6;
inline bool ScenarioConfig::_internal_has_trace_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trace_config_ != nullptr);
  return value;
}
inline bool ScenarioConfig::has_trace_config() const {
  return _internal_has_trace_config();
}
inline const ::perfetto::protos::TraceConfig& ScenarioConfig::_internal_trace_config() const {
  const ::perfetto::protos::TraceConfig* p = _impl_.trace_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::perfetto::protos::TraceConfig&>(
      ::perfetto::protos::_TraceConfig_default_instance_);
}
inline const ::perfetto::protos::TraceConfig& ScenarioConfig::trace_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ScenarioConfig.trace_config)
  return _internal_trace_config();
}
inline void ScenarioConfig::unsafe_arena_set_allocated_trace_config(
    ::perfetto::protos::TraceConfig* trace_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trace_config_);
  }
  _impl_.trace_config_ = trace_config;
  if (trace_config) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:perfetto.protos.ScenarioConfig.trace_config)
}
inline ::perfetto::protos::TraceConfig* ScenarioConfig::release_trace_config() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::perfetto::protos::TraceConfig* temp = _impl_.trace_config_;
  _impl_.trace_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::perfetto::protos::TraceConfig* ScenarioConfig::unsafe_arena_release_trace_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.ScenarioConfig.trace_config)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::perfetto::protos::TraceConfig* temp = _impl_.trace_config_;
  _impl_.trace_config_ = nullptr;
  return temp;
}
inline ::perfetto::protos::TraceConfig* ScenarioConfig::_internal_mutable_trace_config() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.trace_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::perfetto::protos::TraceConfig>(GetArenaForAllocation());
    _impl_.trace_config_ = p;
  }
  return _impl_.trace_config_;
}
inline ::perfetto::protos::TraceConfig* ScenarioConfig::mutable_trace_config() {
  ::perfetto::protos::TraceConfig* _msg = _internal_mutable_trace_config();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ScenarioConfig.trace_config)
  return _msg;
}
inline void ScenarioConfig::set_allocated_trace_config(::perfetto::protos::TraceConfig* trace_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trace_config_);
  }
  if (trace_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(trace_config));
    if (message_arena != submessage_arena) {
      trace_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trace_config, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.trace_config_ = trace_config;
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.ScenarioConfig.trace_config)
}

// repeated .perfetto.protos.NestedScenarioConfig nested_scenarios = 7;
inline int ScenarioConfig::_internal_nested_scenarios_size() const {
  return _impl_.nested_scenarios_.size();
}
inline int ScenarioConfig::nested_scenarios_size() const {
  return _internal_nested_scenarios_size();
}
inline void ScenarioConfig::clear_nested_scenarios() {
  _impl_.nested_scenarios_.Clear();
}
inline ::perfetto::protos::NestedScenarioConfig* ScenarioConfig::mutable_nested_scenarios(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ScenarioConfig.nested_scenarios)
  return _impl_.nested_scenarios_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::NestedScenarioConfig >*
ScenarioConfig::mutable_nested_scenarios() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.ScenarioConfig.nested_scenarios)
  return &_impl_.nested_scenarios_;
}
inline const ::perfetto::protos::NestedScenarioConfig& ScenarioConfig::_internal_nested_scenarios(int index) const {
  return _impl_.nested_scenarios_.Get(index);
}
inline const ::perfetto::protos::NestedScenarioConfig& ScenarioConfig::nested_scenarios(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ScenarioConfig.nested_scenarios)
  return _internal_nested_scenarios(index);
}
inline ::perfetto::protos::NestedScenarioConfig* ScenarioConfig::_internal_add_nested_scenarios() {
  return _impl_.nested_scenarios_.Add();
}
inline ::perfetto::protos::NestedScenarioConfig* ScenarioConfig::add_nested_scenarios() {
  ::perfetto::protos::NestedScenarioConfig* _add = _internal_add_nested_scenarios();
  // @@protoc_insertion_point(field_add:perfetto.protos.ScenarioConfig.nested_scenarios)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::NestedScenarioConfig >&
ScenarioConfig::nested_scenarios() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.ScenarioConfig.nested_scenarios)
  return _impl_.nested_scenarios_;
}

// -------------------------------------------------------------------

// ChromeFieldTracingConfig

// repeated .perfetto.protos.ScenarioConfig scenarios = 1;
inline int ChromeFieldTracingConfig::_internal_scenarios_size() const {
  return _impl_.scenarios_.size();
}
inline int ChromeFieldTracingConfig::scenarios_size() const {
  return _internal_scenarios_size();
}
inline void ChromeFieldTracingConfig::clear_scenarios() {
  _impl_.scenarios_.Clear();
}
inline ::perfetto::protos::ScenarioConfig* ChromeFieldTracingConfig::mutable_scenarios(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ChromeFieldTracingConfig.scenarios)
  return _impl_.scenarios_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::ScenarioConfig >*
ChromeFieldTracingConfig::mutable_scenarios() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.ChromeFieldTracingConfig.scenarios)
  return &_impl_.scenarios_;
}
inline const ::perfetto::protos::ScenarioConfig& ChromeFieldTracingConfig::_internal_scenarios(int index) const {
  return _impl_.scenarios_.Get(index);
}
inline const ::perfetto::protos::ScenarioConfig& ChromeFieldTracingConfig::scenarios(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ChromeFieldTracingConfig.scenarios)
  return _internal_scenarios(index);
}
inline ::perfetto::protos::ScenarioConfig* ChromeFieldTracingConfig::_internal_add_scenarios() {
  return _impl_.scenarios_.Add();
}
inline ::perfetto::protos::ScenarioConfig* ChromeFieldTracingConfig::add_scenarios() {
  ::perfetto::protos::ScenarioConfig* _add = _internal_add_scenarios();
  // @@protoc_insertion_point(field_add:perfetto.protos.ChromeFieldTracingConfig.scenarios)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::ScenarioConfig >&
ChromeFieldTracingConfig::scenarios() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.ChromeFieldTracingConfig.scenarios)
  return _impl_.scenarios_;
}

// -------------------------------------------------------------------

// TracingTriggerRulesConfig

// repeated .perfetto.protos.TriggerRule rules = 1;
inline int TracingTriggerRulesConfig::_internal_rules_size() const {
  return _impl_.rules_.size();
}
inline int TracingTriggerRulesConfig::rules_size() const {
  return _internal_rules_size();
}
inline void TracingTriggerRulesConfig::clear_rules() {
  _impl_.rules_.Clear();
}
inline ::perfetto::protos::TriggerRule* TracingTriggerRulesConfig::mutable_rules(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TracingTriggerRulesConfig.rules)
  return _impl_.rules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule >*
TracingTriggerRulesConfig::mutable_rules() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TracingTriggerRulesConfig.rules)
  return &_impl_.rules_;
}
inline const ::perfetto::protos::TriggerRule& TracingTriggerRulesConfig::_internal_rules(int index) const {
  return _impl_.rules_.Get(index);
}
inline const ::perfetto::protos::TriggerRule& TracingTriggerRulesConfig::rules(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingTriggerRulesConfig.rules)
  return _internal_rules(index);
}
inline ::perfetto::protos::TriggerRule* TracingTriggerRulesConfig::_internal_add_rules() {
  return _impl_.rules_.Add();
}
inline ::perfetto::protos::TriggerRule* TracingTriggerRulesConfig::add_rules() {
  ::perfetto::protos::TriggerRule* _add = _internal_add_rules();
  // @@protoc_insertion_point(field_add:perfetto.protos.TracingTriggerRulesConfig.rules)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::perfetto::protos::TriggerRule >&
TracingTriggerRulesConfig::rules() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TracingTriggerRulesConfig.rules)
  return _impl_.rules_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_protos_2fperfetto_2fconfig_2fchrome_2fscenario_5fconfig_2eproto
