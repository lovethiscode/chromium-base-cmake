// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_STATSD_STATSD_TRACING_CONFIG_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_STATSD_STATSD_TRACING_CONFIG_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class StatsdPullAtomConfig;
class StatsdTracingConfig;
enum AtomId : int;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {

class PERFETTO_EXPORT_COMPONENT StatsdPullAtomConfig : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kPullAtomIdFieldNumber = 1,
    kRawPullAtomIdFieldNumber = 2,
    kPullFrequencyMsFieldNumber = 3,
    kPackagesFieldNumber = 4,
  };

  StatsdPullAtomConfig();
  ~StatsdPullAtomConfig() override;
  StatsdPullAtomConfig(StatsdPullAtomConfig&&) noexcept;
  StatsdPullAtomConfig& operator=(StatsdPullAtomConfig&&);
  StatsdPullAtomConfig(const StatsdPullAtomConfig&);
  StatsdPullAtomConfig& operator=(const StatsdPullAtomConfig&);
  bool operator==(const StatsdPullAtomConfig&) const;
  bool operator!=(const StatsdPullAtomConfig& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  const std::vector<AtomId>& pull_atom_id() const { return pull_atom_id_; }
  std::vector<AtomId>* mutable_pull_atom_id() { return &pull_atom_id_; }
  int pull_atom_id_size() const { return static_cast<int>(pull_atom_id_.size()); }
  void clear_pull_atom_id() { pull_atom_id_.clear(); }
  void add_pull_atom_id(AtomId value) { pull_atom_id_.emplace_back(value); }
  AtomId* add_pull_atom_id() { pull_atom_id_.emplace_back(); return &pull_atom_id_.back(); }

  const std::vector<int32_t>& raw_pull_atom_id() const { return raw_pull_atom_id_; }
  std::vector<int32_t>* mutable_raw_pull_atom_id() { return &raw_pull_atom_id_; }
  int raw_pull_atom_id_size() const { return static_cast<int>(raw_pull_atom_id_.size()); }
  void clear_raw_pull_atom_id() { raw_pull_atom_id_.clear(); }
  void add_raw_pull_atom_id(int32_t value) { raw_pull_atom_id_.emplace_back(value); }
  int32_t* add_raw_pull_atom_id() { raw_pull_atom_id_.emplace_back(); return &raw_pull_atom_id_.back(); }

  bool has_pull_frequency_ms() const { return _has_field_[3]; }
  int32_t pull_frequency_ms() const { return pull_frequency_ms_; }
  void set_pull_frequency_ms(int32_t value) { pull_frequency_ms_ = value; _has_field_.set(3); }

  const std::vector<std::string>& packages() const { return packages_; }
  std::vector<std::string>* mutable_packages() { return &packages_; }
  int packages_size() const { return static_cast<int>(packages_.size()); }
  void clear_packages() { packages_.clear(); }
  void add_packages(std::string value) { packages_.emplace_back(value); }
  std::string* add_packages() { packages_.emplace_back(); return &packages_.back(); }

 private:
  std::vector<AtomId> pull_atom_id_;
  std::vector<int32_t> raw_pull_atom_id_;
  int32_t pull_frequency_ms_{};
  std::vector<std::string> packages_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT StatsdTracingConfig : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kPushAtomIdFieldNumber = 1,
    kRawPushAtomIdFieldNumber = 2,
    kPullConfigFieldNumber = 3,
  };

  StatsdTracingConfig();
  ~StatsdTracingConfig() override;
  StatsdTracingConfig(StatsdTracingConfig&&) noexcept;
  StatsdTracingConfig& operator=(StatsdTracingConfig&&);
  StatsdTracingConfig(const StatsdTracingConfig&);
  StatsdTracingConfig& operator=(const StatsdTracingConfig&);
  bool operator==(const StatsdTracingConfig&) const;
  bool operator!=(const StatsdTracingConfig& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  const std::vector<AtomId>& push_atom_id() const { return push_atom_id_; }
  std::vector<AtomId>* mutable_push_atom_id() { return &push_atom_id_; }
  int push_atom_id_size() const { return static_cast<int>(push_atom_id_.size()); }
  void clear_push_atom_id() { push_atom_id_.clear(); }
  void add_push_atom_id(AtomId value) { push_atom_id_.emplace_back(value); }
  AtomId* add_push_atom_id() { push_atom_id_.emplace_back(); return &push_atom_id_.back(); }

  const std::vector<int32_t>& raw_push_atom_id() const { return raw_push_atom_id_; }
  std::vector<int32_t>* mutable_raw_push_atom_id() { return &raw_push_atom_id_; }
  int raw_push_atom_id_size() const { return static_cast<int>(raw_push_atom_id_.size()); }
  void clear_raw_push_atom_id() { raw_push_atom_id_.clear(); }
  void add_raw_push_atom_id(int32_t value) { raw_push_atom_id_.emplace_back(value); }
  int32_t* add_raw_push_atom_id() { raw_push_atom_id_.emplace_back(); return &raw_push_atom_id_.back(); }

  const std::vector<StatsdPullAtomConfig>& pull_config() const { return pull_config_; }
  std::vector<StatsdPullAtomConfig>* mutable_pull_config() { return &pull_config_; }
  int pull_config_size() const;
  void clear_pull_config();
  StatsdPullAtomConfig* add_pull_config();

 private:
  std::vector<AtomId> push_atom_id_;
  std::vector<int32_t> raw_push_atom_id_;
  std::vector<StatsdPullAtomConfig> pull_config_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_STATSD_STATSD_TRACING_CONFIG_PROTO_CPP_H_
