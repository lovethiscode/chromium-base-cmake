// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_THIRD_PARTY_PERFTOOLS_PROFILES_PROTOS_THIRD_PARTY_PPROF_PROFILE_PROTO_H_
#define PERFETTO_THIRD_PARTY_PERFTOOLS_PROFILES_PROTOS_THIRD_PARTY_PPROF_PROFILE_PROTO_H_

#include <stddef.h>
#include <stdint.h>

#include "perfetto/protozero/field_writer.h"
#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace third_party {
namespace perftools {
namespace profiles {
namespace pbzero {
class Function;
class Label;
class Line;
class Location;
class Mapping;
class Sample;
class ValueType;
} // Namespace pbzero.
} // Namespace profiles.
} // Namespace perftools.
} // Namespace third_party.
} // Namespace perfetto.

namespace perfetto {
namespace third_party {
namespace perftools {
namespace profiles {
namespace pbzero {

class Function_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Function_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Function_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Function_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_id() const { return at<1>().valid(); }
  uint64_t id() const { return at<1>().as_uint64(); }
  bool has_name() const { return at<2>().valid(); }
  int64_t name() const { return at<2>().as_int64(); }
  bool has_system_name() const { return at<3>().valid(); }
  int64_t system_name() const { return at<3>().as_int64(); }
  bool has_filename() const { return at<4>().valid(); }
  int64_t filename() const { return at<4>().as_int64(); }
  bool has_start_line() const { return at<5>().valid(); }
  int64_t start_line() const { return at<5>().as_int64(); }
};

class Function : public ::protozero::Message {
 public:
  using Decoder = Function_Decoder;
  enum : int32_t {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kSystemNameFieldNumber = 3,
    kFilenameFieldNumber = 4,
    kStartLineFieldNumber = 5,
  };
  static constexpr const char* GetName() { return ".perfetto.third_party.perftools.profiles.Function"; }


  using FieldMetadata_Id =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      Function>;

  static constexpr FieldMetadata_Id kId{};
  void set_id(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Id::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Name =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      Function>;

  static constexpr FieldMetadata_Name kName{};
  void set_name(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Name::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SystemName =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      Function>;

  static constexpr FieldMetadata_SystemName kSystemName{};
  void set_system_name(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SystemName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Filename =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      Function>;

  static constexpr FieldMetadata_Filename kFilename{};
  void set_filename(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Filename::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_StartLine =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      Function>;

  static constexpr FieldMetadata_StartLine kStartLine{};
  void set_start_line(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_StartLine::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }
};

class Line_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Line_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Line_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Line_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_function_id() const { return at<1>().valid(); }
  uint64_t function_id() const { return at<1>().as_uint64(); }
  bool has_line() const { return at<2>().valid(); }
  int64_t line() const { return at<2>().as_int64(); }
};

class Line : public ::protozero::Message {
 public:
  using Decoder = Line_Decoder;
  enum : int32_t {
    kFunctionIdFieldNumber = 1,
    kLineFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.third_party.perftools.profiles.Line"; }


  using FieldMetadata_FunctionId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      Line>;

  static constexpr FieldMetadata_FunctionId kFunctionId{};
  void set_function_id(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_FunctionId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Line =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      Line>;

  static constexpr FieldMetadata_Line kLine{};
  void set_line(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Line::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }
};

class Location_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  Location_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Location_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Location_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_id() const { return at<1>().valid(); }
  uint64_t id() const { return at<1>().as_uint64(); }
  bool has_mapping_id() const { return at<2>().valid(); }
  uint64_t mapping_id() const { return at<2>().as_uint64(); }
  bool has_address() const { return at<3>().valid(); }
  uint64_t address() const { return at<3>().as_uint64(); }
  bool has_line() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> line() const { return GetRepeated<::protozero::ConstBytes>(4); }
  bool has_is_folded() const { return at<5>().valid(); }
  bool is_folded() const { return at<5>().as_bool(); }
};

class Location : public ::protozero::Message {
 public:
  using Decoder = Location_Decoder;
  enum : int32_t {
    kIdFieldNumber = 1,
    kMappingIdFieldNumber = 2,
    kAddressFieldNumber = 3,
    kLineFieldNumber = 4,
    kIsFoldedFieldNumber = 5,
  };
  static constexpr const char* GetName() { return ".perfetto.third_party.perftools.profiles.Location"; }


  using FieldMetadata_Id =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      Location>;

  static constexpr FieldMetadata_Id kId{};
  void set_id(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Id::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_MappingId =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      Location>;

  static constexpr FieldMetadata_MappingId kMappingId{};
  void set_mapping_id(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_MappingId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Address =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      Location>;

  static constexpr FieldMetadata_Address kAddress{};
  void set_address(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Address::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Line =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Line,
      Location>;

  static constexpr FieldMetadata_Line kLine{};
  template <typename T = Line> T* add_line() {
    return BeginNestedMessage<T>(4);
  }


  using FieldMetadata_IsFolded =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      Location>;

  static constexpr FieldMetadata_IsFolded kIsFolded{};
  void set_is_folded(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsFolded::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }
};

class Mapping_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Mapping_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Mapping_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Mapping_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_id() const { return at<1>().valid(); }
  uint64_t id() const { return at<1>().as_uint64(); }
  bool has_memory_start() const { return at<2>().valid(); }
  uint64_t memory_start() const { return at<2>().as_uint64(); }
  bool has_memory_limit() const { return at<3>().valid(); }
  uint64_t memory_limit() const { return at<3>().as_uint64(); }
  bool has_file_offset() const { return at<4>().valid(); }
  uint64_t file_offset() const { return at<4>().as_uint64(); }
  bool has_filename() const { return at<5>().valid(); }
  int64_t filename() const { return at<5>().as_int64(); }
  bool has_build_id() const { return at<6>().valid(); }
  int64_t build_id() const { return at<6>().as_int64(); }
  bool has_has_functions() const { return at<7>().valid(); }
  bool has_functions() const { return at<7>().as_bool(); }
  bool has_has_filenames() const { return at<8>().valid(); }
  bool has_filenames() const { return at<8>().as_bool(); }
  bool has_has_line_numbers() const { return at<9>().valid(); }
  bool has_line_numbers() const { return at<9>().as_bool(); }
  bool has_has_inline_frames() const { return at<10>().valid(); }
  bool has_inline_frames() const { return at<10>().as_bool(); }
};

class Mapping : public ::protozero::Message {
 public:
  using Decoder = Mapping_Decoder;
  enum : int32_t {
    kIdFieldNumber = 1,
    kMemoryStartFieldNumber = 2,
    kMemoryLimitFieldNumber = 3,
    kFileOffsetFieldNumber = 4,
    kFilenameFieldNumber = 5,
    kBuildIdFieldNumber = 6,
    kHasFunctionsFieldNumber = 7,
    kHasFilenamesFieldNumber = 8,
    kHasLineNumbersFieldNumber = 9,
    kHasInlineFramesFieldNumber = 10,
  };
  static constexpr const char* GetName() { return ".perfetto.third_party.perftools.profiles.Mapping"; }


  using FieldMetadata_Id =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      Mapping>;

  static constexpr FieldMetadata_Id kId{};
  void set_id(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Id::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_MemoryStart =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      Mapping>;

  static constexpr FieldMetadata_MemoryStart kMemoryStart{};
  void set_memory_start(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_MemoryStart::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_MemoryLimit =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      Mapping>;

  static constexpr FieldMetadata_MemoryLimit kMemoryLimit{};
  void set_memory_limit(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_MemoryLimit::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_FileOffset =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      Mapping>;

  static constexpr FieldMetadata_FileOffset kFileOffset{};
  void set_file_offset(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_FileOffset::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Filename =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      Mapping>;

  static constexpr FieldMetadata_Filename kFilename{};
  void set_filename(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Filename::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_BuildId =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      Mapping>;

  static constexpr FieldMetadata_BuildId kBuildId{};
  void set_build_id(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_BuildId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_HasFunctions =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      Mapping>;

  static constexpr FieldMetadata_HasFunctions kHasFunctions{};
  void set_has_functions(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_HasFunctions::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_HasFilenames =
    ::protozero::proto_utils::FieldMetadata<
      8,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      Mapping>;

  static constexpr FieldMetadata_HasFilenames kHasFilenames{};
  void set_has_filenames(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_HasFilenames::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_HasLineNumbers =
    ::protozero::proto_utils::FieldMetadata<
      9,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      Mapping>;

  static constexpr FieldMetadata_HasLineNumbers kHasLineNumbers{};
  void set_has_line_numbers(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_HasLineNumbers::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_HasInlineFrames =
    ::protozero::proto_utils::FieldMetadata<
      10,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      Mapping>;

  static constexpr FieldMetadata_HasInlineFrames kHasInlineFrames{};
  void set_has_inline_frames(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_HasInlineFrames::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }
};

class Label_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Label_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Label_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Label_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_key() const { return at<1>().valid(); }
  int64_t key() const { return at<1>().as_int64(); }
  bool has_str() const { return at<2>().valid(); }
  int64_t str() const { return at<2>().as_int64(); }
  bool has_num() const { return at<3>().valid(); }
  int64_t num() const { return at<3>().as_int64(); }
  bool has_num_unit() const { return at<4>().valid(); }
  int64_t num_unit() const { return at<4>().as_int64(); }
};

class Label : public ::protozero::Message {
 public:
  using Decoder = Label_Decoder;
  enum : int32_t {
    kKeyFieldNumber = 1,
    kStrFieldNumber = 2,
    kNumFieldNumber = 3,
    kNumUnitFieldNumber = 4,
  };
  static constexpr const char* GetName() { return ".perfetto.third_party.perftools.profiles.Label"; }


  using FieldMetadata_Key =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      Label>;

  static constexpr FieldMetadata_Key kKey{};
  void set_key(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Key::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Str =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      Label>;

  static constexpr FieldMetadata_Str kStr{};
  void set_str(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Str::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Num =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      Label>;

  static constexpr FieldMetadata_Num kNum{};
  void set_num(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Num::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_NumUnit =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      Label>;

  static constexpr FieldMetadata_NumUnit kNumUnit{};
  void set_num_unit(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_NumUnit::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }
};

class Sample_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  Sample_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Sample_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Sample_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_location_id() const { return at<1>().valid(); }
  ::protozero::PackedRepeatedFieldIterator<::protozero::proto_utils::ProtoWireType::kVarInt, uint64_t> location_id(bool* parse_error_ptr) const { return GetPackedRepeated<::protozero::proto_utils::ProtoWireType::kVarInt, uint64_t>(1, parse_error_ptr); }
  bool has_value() const { return at<2>().valid(); }
  ::protozero::PackedRepeatedFieldIterator<::protozero::proto_utils::ProtoWireType::kVarInt, int64_t> value(bool* parse_error_ptr) const { return GetPackedRepeated<::protozero::proto_utils::ProtoWireType::kVarInt, int64_t>(2, parse_error_ptr); }
  bool has_label() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> label() const { return GetRepeated<::protozero::ConstBytes>(3); }
};

class Sample : public ::protozero::Message {
 public:
  using Decoder = Sample_Decoder;
  enum : int32_t {
    kLocationIdFieldNumber = 1,
    kValueFieldNumber = 2,
    kLabelFieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.third_party.perftools.profiles.Sample"; }


  using FieldMetadata_LocationId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kRepeatedPacked,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      Sample>;

  static constexpr FieldMetadata_LocationId kLocationId{};
  void set_location_id(const ::protozero::PackedVarInt& packed_buffer) {
    AppendBytes(FieldMetadata_LocationId::kFieldId, packed_buffer.data(),
                packed_buffer.size());
  }

  using FieldMetadata_Value =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kRepeatedPacked,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      Sample>;

  static constexpr FieldMetadata_Value kValue{};
  void set_value(const ::protozero::PackedVarInt& packed_buffer) {
    AppendBytes(FieldMetadata_Value::kFieldId, packed_buffer.data(),
                packed_buffer.size());
  }

  using FieldMetadata_Label =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Label,
      Sample>;

  static constexpr FieldMetadata_Label kLabel{};
  template <typename T = Label> T* add_label() {
    return BeginNestedMessage<T>(3);
  }

};

class ValueType_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ValueType_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ValueType_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ValueType_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_type() const { return at<1>().valid(); }
  int64_t type() const { return at<1>().as_int64(); }
  bool has_unit() const { return at<2>().valid(); }
  int64_t unit() const { return at<2>().as_int64(); }
};

class ValueType : public ::protozero::Message {
 public:
  using Decoder = ValueType_Decoder;
  enum : int32_t {
    kTypeFieldNumber = 1,
    kUnitFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.third_party.perftools.profiles.ValueType"; }


  using FieldMetadata_Type =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      ValueType>;

  static constexpr FieldMetadata_Type kType{};
  void set_type(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Type::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Unit =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      ValueType>;

  static constexpr FieldMetadata_Unit kUnit{};
  void set_unit(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Unit::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }
};

class Profile_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/14, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  Profile_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Profile_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Profile_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_sample_type() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> sample_type() const { return GetRepeated<::protozero::ConstBytes>(1); }
  bool has_sample() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> sample() const { return GetRepeated<::protozero::ConstBytes>(2); }
  bool has_mapping() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> mapping() const { return GetRepeated<::protozero::ConstBytes>(3); }
  bool has_location() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> location() const { return GetRepeated<::protozero::ConstBytes>(4); }
  bool has_function() const { return at<5>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> function() const { return GetRepeated<::protozero::ConstBytes>(5); }
  bool has_string_table() const { return at<6>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> string_table() const { return GetRepeated<::protozero::ConstChars>(6); }
  bool has_drop_frames() const { return at<7>().valid(); }
  int64_t drop_frames() const { return at<7>().as_int64(); }
  bool has_keep_frames() const { return at<8>().valid(); }
  int64_t keep_frames() const { return at<8>().as_int64(); }
  bool has_time_nanos() const { return at<9>().valid(); }
  int64_t time_nanos() const { return at<9>().as_int64(); }
  bool has_duration_nanos() const { return at<10>().valid(); }
  int64_t duration_nanos() const { return at<10>().as_int64(); }
  bool has_period_type() const { return at<11>().valid(); }
  ::protozero::ConstBytes period_type() const { return at<11>().as_bytes(); }
  bool has_period() const { return at<12>().valid(); }
  int64_t period() const { return at<12>().as_int64(); }
  bool has_comment() const { return at<13>().valid(); }
  ::protozero::PackedRepeatedFieldIterator<::protozero::proto_utils::ProtoWireType::kVarInt, int64_t> comment(bool* parse_error_ptr) const { return GetPackedRepeated<::protozero::proto_utils::ProtoWireType::kVarInt, int64_t>(13, parse_error_ptr); }
  bool has_default_sample_type() const { return at<14>().valid(); }
  int64_t default_sample_type() const { return at<14>().as_int64(); }
};

class Profile : public ::protozero::Message {
 public:
  using Decoder = Profile_Decoder;
  enum : int32_t {
    kSampleTypeFieldNumber = 1,
    kSampleFieldNumber = 2,
    kMappingFieldNumber = 3,
    kLocationFieldNumber = 4,
    kFunctionFieldNumber = 5,
    kStringTableFieldNumber = 6,
    kDropFramesFieldNumber = 7,
    kKeepFramesFieldNumber = 8,
    kTimeNanosFieldNumber = 9,
    kDurationNanosFieldNumber = 10,
    kPeriodTypeFieldNumber = 11,
    kPeriodFieldNumber = 12,
    kCommentFieldNumber = 13,
    kDefaultSampleTypeFieldNumber = 14,
  };
  static constexpr const char* GetName() { return ".perfetto.third_party.perftools.profiles.Profile"; }


  using FieldMetadata_SampleType =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ValueType,
      Profile>;

  static constexpr FieldMetadata_SampleType kSampleType{};
  template <typename T = ValueType> T* add_sample_type() {
    return BeginNestedMessage<T>(1);
  }


  using FieldMetadata_Sample =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Sample,
      Profile>;

  static constexpr FieldMetadata_Sample kSample{};
  template <typename T = Sample> T* add_sample() {
    return BeginNestedMessage<T>(2);
  }


  using FieldMetadata_Mapping =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Mapping,
      Profile>;

  static constexpr FieldMetadata_Mapping kMapping{};
  template <typename T = Mapping> T* add_mapping() {
    return BeginNestedMessage<T>(3);
  }


  using FieldMetadata_Location =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Location,
      Profile>;

  static constexpr FieldMetadata_Location kLocation{};
  template <typename T = Location> T* add_location() {
    return BeginNestedMessage<T>(4);
  }


  using FieldMetadata_Function =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Function,
      Profile>;

  static constexpr FieldMetadata_Function kFunction{};
  template <typename T = Function> T* add_function() {
    return BeginNestedMessage<T>(5);
  }


  using FieldMetadata_StringTable =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      Profile>;

  static constexpr FieldMetadata_StringTable kStringTable{};
  void add_string_table(const char* data, size_t size) {
    AppendBytes(FieldMetadata_StringTable::kFieldId, data, size);
  }
  void add_string_table(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_StringTable::kFieldId, chars.data, chars.size);
  }
  void add_string_table(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_StringTable::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_DropFrames =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      Profile>;

  static constexpr FieldMetadata_DropFrames kDropFrames{};
  void set_drop_frames(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_DropFrames::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_KeepFrames =
    ::protozero::proto_utils::FieldMetadata<
      8,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      Profile>;

  static constexpr FieldMetadata_KeepFrames kKeepFrames{};
  void set_keep_frames(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_KeepFrames::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_TimeNanos =
    ::protozero::proto_utils::FieldMetadata<
      9,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      Profile>;

  static constexpr FieldMetadata_TimeNanos kTimeNanos{};
  void set_time_nanos(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_TimeNanos::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_DurationNanos =
    ::protozero::proto_utils::FieldMetadata<
      10,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      Profile>;

  static constexpr FieldMetadata_DurationNanos kDurationNanos{};
  void set_duration_nanos(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_DurationNanos::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_PeriodType =
    ::protozero::proto_utils::FieldMetadata<
      11,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ValueType,
      Profile>;

  static constexpr FieldMetadata_PeriodType kPeriodType{};
  template <typename T = ValueType> T* set_period_type() {
    return BeginNestedMessage<T>(11);
  }


  using FieldMetadata_Period =
    ::protozero::proto_utils::FieldMetadata<
      12,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      Profile>;

  static constexpr FieldMetadata_Period kPeriod{};
  void set_period(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Period::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Comment =
    ::protozero::proto_utils::FieldMetadata<
      13,
      ::protozero::proto_utils::RepetitionType::kRepeatedPacked,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      Profile>;

  static constexpr FieldMetadata_Comment kComment{};
  void set_comment(const ::protozero::PackedVarInt& packed_buffer) {
    AppendBytes(FieldMetadata_Comment::kFieldId, packed_buffer.data(),
                packed_buffer.size());
  }

  using FieldMetadata_DefaultSampleType =
    ::protozero::proto_utils::FieldMetadata<
      14,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      Profile>;

  static constexpr FieldMetadata_DefaultSampleType kDefaultSampleType{};
  void set_default_sample_type(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_DefaultSampleType::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
