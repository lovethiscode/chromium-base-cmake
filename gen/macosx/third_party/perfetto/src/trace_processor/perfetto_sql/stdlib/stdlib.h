/*
 * Copyright (C) 2023 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 *******************************************************************************
 * AUTOGENERATED BY tools/gen_amalgamated_sql.py - DO NOT EDIT
 *******************************************************************************
 */

 #include <string.h>

namespace perfetto {
namespace trace_processor {
namespace stdlib {

const char kAndroidAutoMultiuser[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE android.startup.startups;

-- Time elapsed between the latest user start
-- and the specific end event
-- like package startup(ex carlauncher) or previous user stop.
CREATE PERFETTO TABLE android_auto_multiuser_timing(
    -- Id of the started android user
    event_start_user_id STRING,
    -- Start event time
    event_start_time INT,
    -- End event time
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    event_end_time INT,
    -- End event name
    event_end_name STRING,
    -- Start event name
    event_start_name STRING,
    -- User switch duration from start event
    -- to end event
    duration LONG
) AS
-- The last ts for user switch event.
WITH auto_multiuser_user_start AS (
    SELECT
      slice.name as event_start_name,
      slice.ts AS user_start_time,
      -- Ex.: UserController.startUser-11-fg-start-mode-1
      -- User is enclosed in dashes and will be at most 2 characters(10, 11, etc.)
      SUBSTR(name, INSTR(name, '-') + 1, 2) as started_user_id
    FROM slice
    WHERE (
        slice.name GLOB "UserController.startUser*"
        AND slice.name NOT GLOB "UserController.startUser-10*"
    )
    ORDER BY ts DESC
    LIMIT 1
)
SELECT
  started_user_id AS event_start_user_id,
  user_start_time AS event_start_time,
  event_end_time,
  event_end_name,
  event_start_name,
  (event_end_time - user_start_time) as duration
FROM (
  SELECT
    ts_end AS event_end_time,
    package as event_end_name
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  FROM android_startups
  UNION
  SELECT
    slice.ts + slice.dur as event_end_time,
    slice.name as event_end_name
  FROM slice
  WHERE slice.name GLOB "finishUserStopped-10*"
) as a
JOIN auto_multiuser_user_start as b
ON a.event_end_time > b.user_start_time;

-- Previous user(user 10) total CPU time
CREATE PERFETTO VIEW _android_auto_user_10_total_cpu_time AS
SELECT
  SUM(dur) as total_cpu_time,
  (uid - android_appid) / 100000 as user_id,
  event_end_name
FROM sched_slice
  JOIN thread USING (utid)
  JOIN process USING (upid),
  android_auto_multiuser_timing
WHERE
  user_id = 10
  AND ts >= android_auto_multiuser_timing.event_start_time
  AND ts <= android_auto_multiuser_timing.event_end_time
GROUP BY event_end_name;

-- Previous user(user 10) total memory usage
CREATE PERFETTO VIEW _android_auto_user_10_total_memory AS
WITH filtered_process AS (
    SELECT
      c.ts,
      c.value,
      p.name AS proc_name,
      (uid - android_appid) / 100000 as user_id,
      event_end_name
    FROM counter AS c
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      LEFT JOIN process_counter_track AS t
        ON c.track_id = t.id
      LEFT JOIN process AS p USING (upid),
      android_auto_multiuser_timing
    WHERE
      t.name GLOB "mem.rss"
      AND user_id = 10
      AND c.ts >= android_auto_multiuser_timing.event_start_time
      AND c.ts <= android_auto_multiuser_timing.event_end_time
),
process_rss AS (
    SELECT
      *,
      ifnull(
        lag(value) OVER (PARTITION BY proc_name, event_end_name ORDER BY ts), value
      ) AS prev_value
    FROM filtered_process
),
per_process_allocations AS (
    SELECT
      proc_name,
      SUM(value - prev_value) / 1e3 AS alloc_value_kb,
      user_id,
      event_end_name
    FROM process_rss
    WHERE value - prev_value > 0
    GROUP BY proc_name, event_end_name
    ORDER BY alloc_value_kb DESC
)
SELECT
  cast_int!(SUM(alloc_value_kb)) AS total_memory_usage_kb,
  user_id,
  event_end_name
FROM per_process_allocations
GROUP BY event_end_name;

-- This table extends `android_auto_multiuser_timing` table with previous user resource usage.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO VIEW android_auto_multiuser_timing_with_previous_user_resource_usage(
    -- Start user id
    event_start_user_id STRING,
    -- Start event time
    event_start_time INT,
    -- End event time
    event_end_time INT,
    -- End event name
    event_end_name STRING,
    -- Start event name
    event_start_name STRING,
    -- User switch duration from start event
    -- to end event
    duration LONG,
    -- User id
    user_id INT,
    -- Total CPU time for a user
    total_cpu_time LONG,
    -- Total memory user for a user
    total_memory_usage_kb LONG
) AS
SELECT
    a.event_start_user_id,
    a.event_start_time,
    a.event_end_time,
    a.event_end_name,
    a.event_start_name,
    a.duration,
    b.user_id,
    b.total_cpu_time,
    c.total_memory_usage_kb
FROM android_auto_multiuser_timing as a
LEFT JOIN _android_auto_user_10_total_cpu_time as b
    ON a.event_end_name = b.event_end_name
LEFT JOIN _android_auto_user_10_total_memory as c
    ON a.event_end_name = c.event_end_name;
)_d3l1m1t3r_"
R"_d3l1m1t3r_()_d3l1m1t3r_"
;

const char kAndroidFramesPerFrameMetrics[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE time.conversion;
INCLUDE PERFETTO MODULE android.frames.timeline;

-- The amount by which each frame missed of hit its deadline. Positive if the
-- deadline was not missed. Frames are considered janky if `overrun` is
-- negative.
-- Calculated as the difference between the end of the
-- `expected_frame_timeline_slice` and `actual_frame_timeline_slice` for the
-- frame.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- Availability: from S (API 31).
-- For Googlers: more details in go/android-performance-metrics-glossary.
CREATE PERFETTO TABLE android_frames_overrun(
    -- Frame id.
    frame_id INT,
    -- Difference between `expected` and `actual` frame ends. Positive if frame
    -- didn't miss deadline.
    overrun INT
) AS
SELECT
    frame_id,
    (exp_slice.ts + exp_slice.dur) - (act_slice.ts + act_slice.dur) AS overrun
FROM _distinct_from_actual_timeline_slice act
JOIN _distinct_from_expected_timeline_slice exp USING (frame_id)
JOIN slice act_slice ON (act.id = act_slice.id)
JOIN slice exp_slice ON (exp.id = exp_slice.id);

-- How much time did the frame's Choreographer callbacks take.
CREATE PERFETTO TABLE android_frames_ui_time(
    -- Frame id
    frame_id INT,
    -- UI time duration
    ui_time INT
) AS
SELECT
    frame_id,
    dur AS ui_time
FROM android_frames_choreographer_do_frame f
JOIN slice USING (id);

-- App Vsync delay for a frame. The time between the VSYNC-app signal and the
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- start of Choreographer work.
-- Calculated as time difference between the actual frame start (from
-- `actual_frame_timeline_slice`) and start of the `Choreographer#doFrame`
-- slice.
-- NOTE: Sometimes because of data losses `app_vsync_delay` can be negative.
-- The frames where it happens are filtered out.
-- For Googlers: more details in go/android-performance-metrics-glossary.
CREATE PERFETTO TABLE android_app_vsync_delay_per_frame(
    -- Frame id
    frame_id INT,
    -- App VSYNC delay.
    app_vsync_delay INT
) AS
-- As there can be multiple `DrawFrame` slices, the `frames_surface_slices`
-- table contains multiple rows for the same `frame_id` which only differ on
-- `draw_frame_id`. As we don't care about `draw_frame_id` we can just collapse
-- them.
WITH distinct_frames AS (
    SELECT
        frame_id,
        do_frame_id,
        actual_frame_timeline_id
    FROM android_frames
    GROUP BY 1
)
SELECT
    frame_id,
    act.ts - do_frame.ts AS app_vsync_delay
FROM distinct_frames f
)_d3l1m1t3r_"
R"_d3l1m1t3r_(JOIN slice act ON (f.actual_frame_timeline_id = act.id)
JOIN slice do_frame ON (f.do_frame_id = do_frame.id)
WHERE act.ts >= do_frame.ts;

-- How much time did the frame take across the UI Thread + RenderThread.
-- Calculated as sum of `app VSYNC delay` `Choreographer#doFrame` slice
-- duration and summed durations of all `DrawFrame` slices associated with this
-- frame.
-- Availability: from N (API 24).
-- For Googlers: more details in go/android-performance-metrics-glossary.
CREATE PERFETTO TABLE android_cpu_time_per_frame(
    -- Frame id
    frame_id INT,
    -- Difference between actual timeline of the frame and
    -- `Choreographer#doFrame`. See `android_app_vsync_delay_per_frame` table for more details.
    app_vsync_delay INT,
    -- Duration of `Choreographer#doFrame` slice.
    do_frame_dur INT,
    -- Duration of `DrawFrame` slice. Summed duration of all `DrawFrame`
    -- slices, if more than one. See `android_frames_draw_frame` for more details.
    draw_frame_dur INT,
    -- CPU time across the UI Thread + RenderThread.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    cpu_time INT
) AS
WITH all_draw_frames AS (
SELECT
    frame_id,
    SUM(dur) as draw_frame_dur
FROM android_frames_draw_frame
JOIN slice USING (id)
GROUP BY frame_id
),
distinct_frames AS (
    SELECT
        frame_id,
        do_frame_id,
        actual_frame_timeline_id
    FROM android_frames
    GROUP BY 1
)
SELECT
    frame_id,
    app_vsync_delay,
    do_frame.dur AS do_frame_dur,
    draw_frame_dur,
    app_vsync_delay + do_frame.dur + draw_frame_dur AS cpu_time
FROM android_app_vsync_delay_per_frame
JOIN all_draw_frames USING (frame_id)
JOIN distinct_frames f USING (frame_id)
JOIN slice do_frame ON (f.do_frame_id = do_frame.id);

-- CPU time of frames which don't have `android_cpu_time_per_frame` available.
-- Calculated as UI time of the frame + 5ms.
-- For Googlers: more details in go/android-performance-metrics-glossary.
CREATE PERFETTO TABLE _cpu_time_per_frame_fallback(
    -- Frame id.
    frame_id INT,
    -- Estimated cpu time.
    estimated_cpu_time INT
) AS
SELECT
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    frame_id,
    ui_time + time_from_ms(5) AS estimated_cpu_time
FROM android_frames_ui_time;

CREATE PERFETTO TABLE _estimated_cpu_time_per_frame(
    frame_id INT,
    cpu_time INT
) AS
SELECT
    frame_id,
    IIF(r.cpu_time IS NULL, f.estimated_cpu_time, r.cpu_time) AS cpu_time
FROM _cpu_time_per_frame_fallback f
LEFT JOIN android_cpu_time_per_frame r USING (frame_id);

-- Aggregated stats of the frame.
--
-- For Googlers: more details in go/android-performance-metrics-glossary.
CREATE PERFETTO TABLE android_frame_stats(
    -- Frame id.
    frame_id INT,
    -- The amount by which each frame missed of hit its deadline. See
    -- `android_frames_overrun` for details.
    overrun INT,
    -- How much time did the frame take across the UI Thread + RenderThread.
    cpu_time INT,
    -- How much time did the frame's Choreographer callbacks take.
    ui_time INT,
    -- Was frame janky.
    was_jank BOOL,
    -- CPU time of the frame took over 20ms.
    was_slow_frame BOOL,
    -- CPU time of the frame took over 50ms.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    was_big_jank BOOL,
    -- CPU time of the frame took over 200ms.
    was_huge_jank BOOL
) AS
SELECT
    frame_id,
    overrun,
    cpu_time,
    ui_time,
    IIF(overrun < 0, 1, NULL) AS was_jank,
    IIF(cpu_time > time_from_ms(20), 1, NULL) AS was_slow_frame,
    IIF(cpu_time > time_from_ms(50), 1, NULL) AS was_big_jank,
    IIF(cpu_time > time_from_ms(200), 1, NULL) AS was_huge_jank
FROM android_frames_overrun
JOIN android_frames_ui_time USING (frame_id)
-- Because some frames might not have CPU time calculated properly (data loss
-- or too old API), we will use fallback cpu time from
-- `_cpu_time_per_frame_fallback`.
JOIN _estimated_cpu_time_per_frame USING (frame_id);


)_d3l1m1t3r_"
;

const char kAndroidFramesTimeline[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE slices.with_context;
INCLUDE PERFETTO MODULE android.frames.timeline_maxsdk28;

-- Parses the slice name to fetch `frame_id` from `slice` table.
-- Use with caution. Slice names are a flaky source of ids and the resulting
-- table might require some further operations.
CREATE PERFETTO FUNCTION _get_frame_table_with_id(
    -- String just before id.
    glob_str STRING
)_d3l1m1t3r_"
R"_d3l1m1t3r_() RETURNS TABLE (
    -- `slice.id` of the frame slice.
    id INT,
    -- Parsed frame id.
    frame_id INT,
    -- Utid.
    utid INT,
    -- Upid.
    upid INT
) AS
WITH all_found AS (
    SELECT
        id,
        cast_int!(STR_SPLIT(name, ' ', 1)) AS frame_id,
        utid,
        upid
    FROM thread_slice
    WHERE name GLOB $glob_str AND depth = 0
)
SELECT *
FROM all_found
-- Casting string to int returns 0 if the string can't be cast.
WHERE frame_id != 0;

-- All of the `Choreographer#doFrame` slices with their frame id.
CREATE PERFETTO TABLE android_frames_choreographer_do_frame(
    -- `slice.id`
    id INT,
    -- Frame id
    frame_id INT,
    -- Utid of the UI thread
    ui_thread_utid INT,
    -- Upid of application process
    upid INT
) AS
SELECT
    id,
    frame_id,
    utid AS ui_thread_utid,
    upid
-- Some OEMs have customized `doFrame` to add more information, but we've only
-- observed it added after the frame ID (b/303823815).
FROM _get_frame_table_with_id('Choreographer#doFrame*');
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- All of the `DrawFrame` slices with their frame id and render thread.
-- There might be multiple DrawFrames slices for a single vsync (frame id).
-- This happens when we are drawing multiple layers (e.g. status bar and
-- notifications).
CREATE PERFETTO TABLE android_frames_draw_frame(
    -- `slice.id`
    id INT,
    -- Frame id
    frame_id INT,
    -- Utid of the render thread
    render_thread_utid INT,
    -- Upid of application process
    upid INT
) AS
SELECT
    id,
    frame_id,
    utid AS render_thread_utid,
    upid
FROM _get_frame_table_with_id('DrawFrame*');

-- `actual_frame_timeline_slice` returns the same slice on different tracks.
-- We are getting the first slice with one frame id.
CREATE PERFETTO TABLE _distinct_from_actual_timeline_slice AS
SELECT
    id,
    cast_int!(name) AS frame_id,
    ts,
    dur
FROM actual_frame_timeline_slice
GROUP BY 2;

-- `expected_frame_timeline_slice` returns the same slice on different tracks.
-- We are getting the first slice with one frame id.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO TABLE _distinct_from_expected_timeline_slice AS
SELECT
    id,
    cast_int!(name) AS frame_id
FROM expected_frame_timeline_slice
GROUP BY 2;

-- All slices related to one frame. Aggregates `Choreographer#doFrame`,
-- `DrawFrame`, `actual_frame_timeline_slice` and
-- `expected_frame_timeline_slice` slices.
-- See https://perfetto.dev/docs/data-sources/frametimeline for details.
CREATE PERFETTO TABLE android_frames(
    -- Frame id.
    frame_id INT,
    -- Timestamp of the frame. Start of the frame as defined by the start of
    -- "Choreographer#doFrame" slice and the same as the start of the frame in
    -- `actual_frame_timeline_slice if present.
    ts INT,
    -- Duration of the frame, as defined by the duration of the corresponding
    -- `actual_frame_timeline_slice` or, if not present the time between the
    -- `ts` and the end of the final `DrawFrame`.
    dur INT,
    -- `slice.id` of "Choreographer#doFrame" slice.
    do_frame_id INT,
    -- `slice.id` of "DrawFrame" slice.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    draw_frame_id INT,
    -- `slice.id` from `actual_frame_timeline_slice`
    actual_frame_timeline_id INT,
    -- `slice.id` from `expected_frame_timeline_slice`
    expected_frame_timeline_id INT,
    -- `utid` of the render thread.
    render_thread_utid INT,
    -- `utid` of the UI thread.
    ui_thread_utid INT
) AS
WITH fallback AS MATERIALIZED (
    SELECT
        frame_id,
        do_frame_slice.ts AS ts,
        MAX(draw_frame_slice.ts + draw_frame_slice.dur) - do_frame_slice.ts AS dur
    FROM android_frames_choreographer_do_frame do_frame
    JOIN android_frames_draw_frame draw_frame USING (frame_id, upid)
    JOIN slice do_frame_slice ON (do_frame.id = do_frame_slice.id)
    JOIN slice draw_frame_slice ON (draw_frame.id = draw_frame_slice.id)
GROUP BY 1
),
frames_sdk_after_28 AS (
SELECT
    frame_id,
    COALESCE(act.ts, fallback.ts) AS ts,
    COALESCE(act.dur, fallback.dur) AS dur,
    do_frame.id AS do_frame_id,
    draw_frame.id AS draw_frame_id,
    draw_frame.render_thread_utid,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    do_frame.ui_thread_utid,
    "after_28" AS sdk,
    act.id AS actual_frame_timeline_id,
    exp.id AS expected_frame_timeline_id
FROM android_frames_choreographer_do_frame do_frame
JOIN android_frames_draw_frame draw_frame USING (frame_id, upid)
JOIN fallback USING (frame_id)
LEFT JOIN _distinct_from_actual_timeline_slice act USING (frame_id)
LEFT JOIN _distinct_from_expected_timeline_slice exp USING (frame_id)
ORDER BY frame_id
),
all_frames AS (
    SELECT * FROM frames_sdk_after_28
    UNION
    SELECT
        *,
        NULL AS actual_frame_timeline_id,
        NULL AS expected_frame_timeline_id
    FROM _frames_maxsdk_28
)
SELECT
    frame_id,
    ts,
    dur,
    do_frame_id,
    draw_frame_id,
    actual_frame_timeline_id,
    expected_frame_timeline_id,
    render_thread_utid,
    ui_thread_utid
FROM all_frames
WHERE sdk = IIF(
    (SELECT COUNT(1) FROM actual_frame_timeline_slice) > 0,
    "after_28", "maxsdk28");

-- Returns first frame after the provided timestamp. The returning table has at
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- most one row.
CREATE PERFETTO FUNCTION android_first_frame_after(
    -- Timestamp.
    ts INT)
RETURNS TABLE (
    -- Frame id.
    frame_id INT,
    -- Start of the frame, the timestamp of the "Choreographer#doFrame" slice.
    ts INT,
    -- Duration of the frame.
    dur INT,
    -- `slice.id` of "Choreographer#doFrame" slice.
    do_frame_id INT,
    -- `slice.id` of "DrawFrame" slice.
    draw_frame_id INT,
    -- `slice.id` from `actual_frame_timeline_slice`
    actual_frame_timeline_id INT,
    -- `slice.id` from `expected_frame_timeline_slice`
    expected_frame_timeline_id INT,
    -- `utid` of the render thread.
    render_thread_utid INT,
    -- `utid` of the UI thread.
    ui_thread_utid INT
) AS
SELECT * FROM android_frames
WHERE ts > $ts
ORDER BY ts
LIMIT 1;
)_d3l1m1t3r_"
;

const char kAndroidFramesTimelineMaxsdk28[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE slices.with_context;

-- All slices related to one frame for max SDK 28. Aggregates
-- "Choreographer#doFrame" and "DrawFrame". Tries to guess the `ts` and `dur`
-- of the frame by first guessing which "DrawFrame" slices are related to which
-- "Choreographer#doSlice".
CREATE PERFETTO TABLE _frames_maxsdk_28(
    -- Frame id. Created manually starting from 0.
    frame_id INT,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    -- Timestamp of the frame. Start of "Choreographer#doFrame" slice.
    ts INT,
    -- Duration of the frame, defined as the duration until the last
    -- "DrawFrame" of this frame finishes.
    dur INT,
    -- `slice.id` of "Choreographer#doFrame" slice.
    do_frame_id INT,
    -- `slice.id` of "DrawFrame" slice. Fetched as one of the "DrawFrame"
    -- slices that happen for the same process as "Choreographer#doFrame" slice
    -- and start after it started and before the next "doFrame" started.
    draw_frame_id INT,
    -- `utid` of the render thread.
    render_thread_utid INT,
    -- `utid` of the UI thread.
    ui_thread_utid INT,
    -- "maxsdk28"
    sdk STRING
) AS
WITH choreographer AS (
  SELECT id
  FROM slice
  WHERE name = 'Choreographer#doFrame'
),
do_frames AS (
    SELECT
        id,
        ts,
        LEAD(ts, 1, TRACE_END()) OVER (PARTITION BY upid ORDER BY ts) AS next_do_frame,
        utid,
        upid
    FROM choreographer
    JOIN thread_slice USING (id)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    WHERE is_main_thread = 1
    ORDER BY ts
),
draw_frames AS (
    SELECT
        id,
        ts,
        dur,
        ts + dur AS ts_end,
        utid,
        upid
    FROM thread_slice
    WHERE name = 'DrawFrame'
)
SELECT
  ROW_NUMBER() OVER () AS frame_id,
  do.ts,
  MAX(draw.ts_end) OVER (PARTITION BY do.id) - do.ts AS dur,
  do.id AS do_frame_id,
  draw.id AS draw_frame_id,
  draw.utid AS render_thread_utid,
  do.utid AS ui_thread_utid,
  "maxsdk28" AS sdk
FROM do_frames do
JOIN draw_frames draw ON (do.upid = draw.upid AND draw.ts >= do.ts AND draw.ts < next_do_frame)
ORDER BY do.ts;
)_d3l1m1t3r_"
;

const char kAndroidStartupStartupEvents[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE slices.with_context;

-- All activity startup events.
CREATE PERFETTO TABLE _startup_events AS
SELECT
  ts,
  dur,
  ts + dur AS ts_end,
  STR_SPLIT(s.name, ": ", 1) AS package_name
FROM process_slice s
WHERE
  s.name GLOB 'launching: *'
  AND (process_name IS NULL OR process_name = 'system_server');

)_d3l1m1t3r_"
;

const char kAndroidStartupStartups[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE android.process_metadata;
INCLUDE PERFETTO MODULE android.startup.startups_maxsdk28;
INCLUDE PERFETTO MODULE android.startup.startups_minsdk29;
INCLUDE PERFETTO MODULE android.startup.startups_minsdk33;

CREATE PERFETTO FUNCTION _slice_count(
  -- Name of the slices to counted.
  slice_glob STRING)
-- Number of slices with the name.
RETURNS INT AS
SELECT COUNT(1) FROM slice WHERE name GLOB $slice_glob;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Gather all startup data. Populate by different sdks.
CREATE PERFETTO TABLE _all_startups AS
SELECT sdk, startup_id, ts, ts_end, dur, package, startup_type FROM _startups_maxsdk28
UNION ALL
SELECT sdk, startup_id, ts, ts_end, dur, package, startup_type FROM _startups_minsdk29
UNION ALL
SELECT sdk, startup_id, ts, ts_end, dur, package, startup_type FROM _startups_minsdk33;

-- All activity startups in the trace by startup id.
-- Populated by different scripts depending on the platform version/contents.
CREATE PERFETTO TABLE android_startups(
  -- Startup id.
  startup_id INT,
  -- Timestamp of startup start.
  ts INT,
  -- Timestamp of startup end.
  ts_end INT,
  -- Startup duration.
  dur INT,
  -- Package name.
  package STRING,
  -- Startup type.
  startup_type STRING
) AS
SELECT startup_id, ts, ts_end, dur, package, startup_type FROM
_all_startups WHERE ( CASE
  WHEN _slice_count('launchingActivity#*:*') > 0
    THEN sdk = "minsdk33"
  WHEN _slice_count('MetricsLogger:*') > 0
    THEN sdk = "minsdk29"
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ELSE sdk = "maxsdk28"
  END);

-- Create a table containing only the slices which are necessary for determining
-- whether a startup happened.
CREATE PERFETTO TABLE _startup_indicator_slices AS
SELECT ts, name, track_id
FROM slice
WHERE name IN ('bindApplication', 'activityStart', 'activityResume');

CREATE PERFETTO FUNCTION _startup_indicator_slice_count(start_ts LONG,
                                                                end_ts LONG,
                                                                utid INT,
                                                                name STRING)
RETURNS INT AS
SELECT COUNT(1)
FROM thread_track t
JOIN _startup_indicator_slices s ON s.track_id = t.id
WHERE
  t.utid = $utid AND
  s.ts >= $start_ts AND
  s.ts < $end_ts AND
  s.name = $name;

-- Maps a startup to the set of processes that handled the activity start.
--
-- The vast majority of cases should be a single process. However it is
-- possible that the process dies during the activity startup and is respawned.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO TABLE android_startup_processes(
  -- Startup id.
  startup_id INT,
  -- Upid of process on which activity started.
  upid INT,
  -- Type of the startup.
  startup_type INT
) AS
-- This is intentionally a materialized query. For some reason, if we don't
-- materialize, we end up with a query which is an order of magnitude slower :(
WITH startup_with_type AS MATERIALIZED (
  SELECT
    startup_id,
    upid,
    CASE
      -- type parsed from platform event takes precedence if available
      WHEN startup_type IS NOT NULL THEN startup_type
      WHEN bind_app > 0 AND a_start > 0 AND a_resume > 0 THEN 'cold'
      WHEN a_start > 0 AND a_resume > 0 THEN 'warm'
      WHEN a_resume > 0 THEN 'hot'
      ELSE NULL
    END AS startup_type
  FROM (
    SELECT
      l.startup_id,
      l.startup_type,
      p.upid,
      _startup_indicator_slice_count(l.ts, l.ts_end, t.utid, 'bindApplication') AS bind_app,
      _startup_indicator_slice_count(l.ts, l.ts_end, t.utid, 'activityStart') AS a_start,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      _startup_indicator_slice_count(l.ts, l.ts_end, t.utid, 'activityResume') AS a_resume
    FROM android_startups l
    JOIN android_process_metadata p ON (
      l.package = p.package_name
      -- If the package list data source was not enabled in the trace, nothing
      -- will match the above constraint so also match any process whose name
      -- is a prefix of the package name.
      OR (
        (SELECT COUNT(1) = 0 FROM package_list)
        AND p.process_name GLOB l.package || '*'
      )
      )
    JOIN thread t ON (p.upid = t.upid AND t.is_main_thread)
    -- Filter out the non-startup processes with the same package name as that of a startup.
    WHERE a_resume > 0
  )
)
SELECT *
FROM startup_with_type
WHERE startup_type IS NOT NULL;


-- Maps a startup to the set of threads on processes that handled the
-- activity start.
CREATE PERFETTO VIEW android_startup_threads(
  -- Startup id.
  startup_id INT,
  -- Timestamp of start.
  ts INT,
  -- Duration of startup.
  dur INT,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Upid of process involved in startup.
  upid INT,
  -- Utid of the thread.
  utid INT,
  -- Name of the thread.
  thread_name STRING,
  -- Thread is a main thread.
  is_main_thread BOOL
) AS
SELECT
  startups.startup_id,
  startups.ts,
  startups.dur,
  android_startup_processes.upid,
  thread.utid,
  thread.name AS thread_name,
  thread.is_main_thread AS is_main_thread
FROM android_startups startups
JOIN android_startup_processes USING (startup_id)
JOIN thread USING (upid);

---
--- Functions
---

-- All the slices for all startups in trace.
--
-- Generally, this view should not be used. Instead, use one of the view functions related
-- to the startup slices which are created from this table.
CREATE PERFETTO VIEW android_thread_slices_for_all_startups(
  -- Timestamp of startup.
  startup_ts INT,
  -- Timestamp of startup end.
  startup_ts_end INT,
  -- Startup id.
  startup_id INT,
  -- UTID of thread with slice.
  utid INT,
  -- Name of thread.
  thread_name STRING,
  -- Whether it is main thread.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  is_main_thread BOOL,
  -- Arg set id.
  arg_set_id INT,
  -- Slice id.
  slice_id INT,
  -- Name of slice.
  slice_name STRING,
  -- Timestamp of slice start.
  slice_ts INT,
  -- Slice duration.
  slice_dur INT
) AS
SELECT
  st.ts AS startup_ts,
  st.ts + st.dur AS startup_ts_end,
  st.startup_id,
  st.utid,
  st.thread_name,
  st.is_main_thread,
  slice.arg_set_id,
  slice.id as slice_id,
  slice.name AS slice_name,
  slice.ts AS slice_ts,
  slice.dur AS slice_dur
FROM android_startup_threads st
JOIN thread_track USING (utid)
JOIN slice ON (slice.track_id = thread_track.id)
WHERE slice.ts BETWEEN st.ts AND st.ts + st.dur;

-- Given a startup id and GLOB for a slice name, returns matching slices with data.
CREATE PERFETTO FUNCTION android_slices_for_startup_and_slice_name(
  -- Startup id.
  startup_id INT,
  -- Glob of the slice.
  slice_name STRING)
RETURNS TABLE(
  -- Id of the slice.
  slice_id INT,
  -- Name of the slice.
  slice_name STRING,
  -- Timestamp of start of the slice.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  slice_ts INT,
  -- Duration of the slice.
  slice_dur INT,
  -- Name of the thread with the slice.
  thread_name STRING,
  -- Arg set id.
  arg_set_id INT
) AS
SELECT slice_id, slice_name, slice_ts, slice_dur, thread_name, arg_set_id
FROM android_thread_slices_for_all_startups
WHERE startup_id = $startup_id AND slice_name GLOB $slice_name;

-- Returns binder transaction slices for a given startup id with duration over threshold.
CREATE PERFETTO FUNCTION android_binder_transaction_slices_for_startup(
  -- Startup id.
  startup_id INT,
  -- Only return slices with duration over threshold.
  threshold DOUBLE)
RETURNS TABLE(
  -- Slice id.
  id INT,
  -- Slice duration.
  slice_dur INT,
  -- Name of the thread with slice.
  thread_name STRING,
  -- Name of the process with slice.
  process STRING,
  -- Arg set id.
  arg_set_id INT,
  -- Whether is main thread.
  is_main_thread BOOL
) AS
SELECT
  slice_id as id,
  slice_dur,
  thread_name,
  process.name as process,
  s.arg_set_id,
  is_main_thread
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM android_thread_slices_for_all_startups s
JOIN process ON (
  EXTRACT_ARG(s.arg_set_id, "destination process") = process.pid
)
WHERE startup_id = $startup_id
  AND slice_name GLOB "binder transaction"
  AND slice_dur > $threshold;

-- Returns duration of startup for slice name.
--
-- Sums duration of all slices of startup with provided name.
CREATE PERFETTO FUNCTION android_sum_dur_for_startup_and_slice(
  -- Startup id.
  startup_id LONG,
  -- Slice name.
  slice_name STRING)
-- Sum of duration.
RETURNS INT AS
SELECT SUM(slice_dur)
FROM android_thread_slices_for_all_startups
WHERE startup_id = $startup_id
  AND slice_name GLOB $slice_name;

-- Returns duration of startup for slice name on main thread.
--
-- Sums duration of all slices of startup with provided name only on main thread.
CREATE PERFETTO FUNCTION android_sum_dur_on_main_thread_for_startup_and_slice(
  -- Startup id.
  startup_id LONG,
  -- Slice name.
  slice_name STRING)
-- Sum of duration.
RETURNS INT AS
SELECT SUM(slice_dur)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM android_thread_slices_for_all_startups
WHERE startup_id = $startup_id
  AND slice_name GLOB $slice_name
  AND is_main_thread;

)_d3l1m1t3r_"
;

const char kAndroidStartupStartupsMaxsdk28[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE slices.with_context;
INCLUDE PERFETTO MODULE android.startup.startup_events;
INCLUDE PERFETTO MODULE android.frames.timeline;

CREATE PERFETTO TABLE _startups_maxsdk28 AS
-- Warm and cold starts only are based on the launching slice
WITH warm_and_cold AS (
  SELECT
    le.ts,
    le.ts_end AS ts_end,
    package_name AS package,
    NULL AS startup_type
  FROM _startup_events le
)_d3l1m1t3r_"
R"_d3l1m1t3r_(),
-- Hot starts donâ€™t have a launching slice so we use activityResume as a
-- proxy.
--
-- Note that this implementation will also count warm and cold starts but
-- we will remove those below.
maybe_hot AS (
  SELECT
    sl.ts,
    rs.ts + rs.dur AS ts_end,
    -- We use the process name as the package as we have no better option.
    COALESCE(process_name, thread_name, 'unknown') AS package,
    "hot" AS startup_type
  FROM thread_slice sl
  JOIN android_first_frame_after(sl.ts) rs
  WHERE name = 'activityResume'
  AND sl.is_main_thread
  -- Remove any launches here where the activityResume slices happens during
  -- a warm/cold startup.
  AND NOT EXISTS (
    SELECT 1
    FROM warm_and_cold wac
    WHERE sl.ts BETWEEN wac.ts AND wac.ts_end
    LIMIT 1)
),
cold_warm_hot AS (
  SELECT * FROM warm_and_cold
  UNION ALL
  SELECT * FROM maybe_hot

)
SELECT
  "maxsdk28" AS sdk,
  ROW_NUMBER() OVER(ORDER BY ts) AS startup_id,
  ts,
  ts_end,
  ts_end - ts AS dur,
  package,
  startup_type
FROM cold_warm_hot;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(


)_d3l1m1t3r_"
;

const char kAndroidStartupStartupsMinsdk29[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE android.startup.startup_events;

-- Marks the beginning of the trace and is equivalent to when the statsd startup
-- logging begins.
CREATE PERFETTO VIEW _activity_intent_received AS
SELECT ts FROM slice
WHERE name = 'MetricsLogger:launchObserverNotifyIntentStarted';

-- We partition the trace into spans based on posted activity intents.
-- We will refine these progressively in the next steps to only encompass
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- activity starts.
CREATE PERFETTO TABLE _activity_intent_recv_spans AS
SELECT
  ROW_NUMBER()
  OVER(ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS startup_id,
  ts,
  LEAD(ts, 1, trace_end()) OVER(ORDER BY ts) - ts AS dur
FROM _activity_intent_received
ORDER BY ts;

-- Filter activity_intent_recv_spans, keeping only the ones that triggered
-- a startup.
CREATE PERFETTO VIEW _startup_partitions AS
SELECT * FROM _activity_intent_recv_spans AS spans
WHERE 1 = (
  SELECT COUNT(1)
  FROM _startup_events
  WHERE _startup_events.ts BETWEEN spans.ts AND spans.ts + spans.dur);

-- Successful activity startup. The end of the 'launching' event is not related
-- to whether it actually succeeded or not.
CREATE PERFETTO VIEW _activity_intent_startup_successful AS
SELECT ts FROM slice
WHERE name = 'MetricsLogger:launchObserverNotifyActivityLaunchFinished';

-- Use the starting event package name. The finish event package name
-- is not reliable in the case of failed startups.
CREATE PERFETTO TABLE _startups_minsdk29 AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  "minsdk29" as sdk,
  lpart.startup_id,
  lpart.ts,
  le.ts_end,
  le.ts_end - lpart.ts AS dur,
  package_name AS package,
  NULL AS startup_type
FROM _startup_partitions AS lpart
JOIN _startup_events le ON
  (le.ts BETWEEN lpart.ts AND lpart.ts + lpart.dur)
  AND (le.ts_end BETWEEN lpart.ts AND lpart.ts + lpart.dur)
WHERE (
  SELECT COUNT(1)
  FROM _activity_intent_startup_successful AS successful
  WHERE successful.ts BETWEEN lpart.ts AND lpart.ts + lpart.dur
) > 0;

)_d3l1m1t3r_"
;

const char kAndroidStartupStartupsMinsdk33[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE android.startup.startup_events;

CREATE PERFETTO VIEW _startup_async_events AS
SELECT
  ts,
  dur,
  CAST(SUBSTR(name, 19) AS INT) AS startup_id
FROM slice
WHERE
  name GLOB 'launchingActivity#*'
  AND dur != 0
  AND INSTR(name, ':') = 0;

CREATE PERFETTO VIEW _startup_complete_events AS
SELECT
  CAST(STR_SPLIT(completed, ':', 0) AS INT) AS startup_id,
  STR_SPLIT(completed, ':', 2) AS package_name,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  CASE
    WHEN STR_SPLIT(completed, ':', 1) = 'completed-hot' THEN 'hot'
    WHEN STR_SPLIT(completed, ':', 1) = 'completed-warm' THEN 'warm'
    WHEN STR_SPLIT(completed, ':', 1) = 'completed-cold' THEN 'cold'
    ELSE NULL
  END AS startup_type,
  MIN(ts)
FROM (
  SELECT ts, SUBSTR(name, 19) AS completed
  FROM slice
  WHERE
    dur = 0
    -- Originally completed was unqualified, but at some point we introduced
    -- the startup type as well
    AND name GLOB 'launchingActivity#*:completed*:*'
)
GROUP BY 1, 2, 3;

CREATE PERFETTO TABLE _startups_minsdk33 AS
SELECT
  "minsdk33" as sdk,
  startup_id,
  ts,
  ts + dur AS ts_end,
  dur,
  package_name AS package,
  startup_type
FROM _startup_async_events
JOIN _startup_complete_events USING (startup_id);




)_d3l1m1t3r_"
;

const char kAndroidStartupTimeToDisplay[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE android.startup.startups;
INCLUDE PERFETTO MODULE android.frames.timeline;
INCLUDE PERFETTO MODULE slices.with_context;

CREATE PERFETTO VIEW _startups_with_upid AS
WITH joined_with_processes AS (
  SELECT
    s.*,
    p.upid
  FROM android_startups s
  LEFT JOIN android_startup_processes p USING (startup_id)
),
fallback AS (
  SELECT
    s.*,
    upid FROM android_startups s
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  JOIN process p ON (p.name glob s.package)
)
  SELECT
    j.startup_id,
    j.ts,
    j.ts_end,
    j.dur,
    j.package,
    j.startup_type,
    COALESCE(j.upid, f.upid) AS upid
  FROM joined_with_processes j
  LEFT JOIN fallback f ON (j.upid IS NULL AND j.startup_id = f.startup_id);

-- Get Time To Initial Display of the startup calculated as time between the
-- startup started and the first frame that was started by Choreographer on the
-- UI thread of the startup finished drawing.
-- TTID (https://developer.android.com/topic/performance/vitals/launch-time#time-initial)
-- Googlers: see go/android-performance-metrics-glossary for details.
CREATE PERFETTO TABLE _ttid AS
WITH frames_with_upid AS (
  SELECT
  f.*,
  upid
  FROM android_frames f
  JOIN thread t ON (f.ui_thread_utid = t.utid)
),
  -- First `DrawFrame` on Render Thread after the startup.
first_frame_for_startup AS (
  SELECT
    startup_id,
    frame_id,
    s.ts AS startup_ts,
    draw_frame_id,
    s.upid
  FROM _startups_with_upid s
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  JOIN frames_with_upid f ON (s.upid = f.upid AND s.ts <= f.ts)
  GROUP BY startup_id
  ORDER BY startup_id, f.ts)
SELECT
  startup_id,
  frame_id,
  draw_frame_id,
  ts + dur - startup_ts AS ttid,
  upid
FROM first_frame_for_startup
JOIN slice ON (slice.id = draw_frame_id);

-- Get Time To Full Display of the startup calculated as time between the
-- startup started and the first frame that was started by Choreographer after
-- or containing the `reportFullyDrawn()` slice on the UI thread of the startup
-- finished drawing.
-- TTFD (https://developer.android.com/topic/performance/vitals/launch-time#retrieve-TTFD)
-- Googlers: see go/android-performance-metrics-glossary for details.
CREATE PERFETTO TABLE _ttfd AS
-- First `reportFullyDrawn` slice for each startup.
WITH first_report_fully_drawn_for_startup AS (
  SELECT
  startup_id,
  s.ts AS startup_ts,
  t.ts AS report_fully_drawn_ts,
  t.utid,
  s.upid
FROM _startups_with_upid s
JOIN thread_slice t ON (s.upid = t.upid AND t.ts >= s.ts)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(WHERE name GLOB "reportFullyDrawn*" AND t.is_main_thread = 1
GROUP BY startup_id
ORDER BY startup_id, t.ts),
-- After the first `reportFullyDrawn` find the first `Choreographer#DoFrame` on
-- the UI thread and it's first `DrawFrame` on Render Thread.
first_frame_after_report_for_startup AS (
  SELECT
    startup_id,
    frame_id,
    startup_ts,
    draw_frame_id,
    s.upid
  FROM first_report_fully_drawn_for_startup s
  JOIN android_frames f ON (
    s.utid = f.ui_thread_utid
    -- We are looking for the first DrawFrame that was started by the first
    -- "Choreographer#DoFrame" on UI thread after or containing
    -- reportFullyDrawn. In Android UIs, it's common to have UI code happen
    -- either before a frame, or during it, and generally non-trivial amounts
    -- of "update UI model" code doesn't try to differentiate these. We account
    -- for both of these by looking for the first UI slice that ends after the
    -- "reportFullyDrawnSlice" begins.
    AND report_fully_drawn_ts < (f.ts + f.dur))
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  GROUP BY startup_id
  ORDER BY startup_id, f.ts
)
-- Get TTFD as the difference between the start of the startup and the end of
-- `DrawFrame` slice we previously found.
SELECT
  startup_id,
  frame_id,
  draw_frame_id,
  ts + dur - startup_ts AS ttfd,
  upid
FROM first_frame_after_report_for_startup
JOIN slice ON (slice.id = draw_frame_id);

-- Startup metric defintions, which focus on the observable time range:
-- TTID - Time To Initial Display
-- * https://developer.android.com/topic/performance/vitals/launch-time#time-initial
-- * end of first RenderThread.DrawFrame - bindApplication
-- TTFD - Time To Full Display
-- * https://developer.android.com/topic/performance/vitals/launch-time#retrieve-TTFD
-- * end of next RT.DrawFrame, after reportFullyDrawn called - bindApplication
-- Googlers: see go/android-performance-metrics-glossary for details.
CREATE PERFETTO TABLE android_startup_time_to_display(
  -- Startup id.
  startup_id INT,
  -- Time to initial display (TTID)
  time_to_initial_display INT,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Time to full display (TTFD)
  time_to_full_display INT,
  -- `android_frames.frame_id` of frame for initial display
  ttid_frame_id INT,
  -- `android_frames.frame_id` of frame for full display
  ttfd_frame_id INT,
  -- `process.upid` of the startup
  upid INT
) AS
SELECT
  startup_id,
  ttid AS time_to_initial_display,
  ttfd AS time_to_full_display,
  _ttid.frame_id AS ttid_frame_id,
  _ttfd.frame_id AS ttfd_frame_id,
  _ttid.upid
FROM android_startups
LEFT JOIN _ttid USING (startup_id)
LEFT JOIN _ttfd USING (startup_id);

)_d3l1m1t3r_"
;

const char kAndroidWinscopeInputmethod[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Android inputmethod clients state dumps (from android.inputmethod data source).
CREATE PERFETTO VIEW android_inputmethod_clients(
  -- Dump id
  id INT,
  -- Timestamp when the dump was triggered
  ts INT,
  -- Extra args parsed from the proto message
  arg_set_id INT
) AS
SELECT
  id,
  ts,
  arg_set_id
FROM __intrinsic_inputmethod_clients;

-- Android inputmethod manager service state dumps (from android.inputmethod data source).
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO VIEW android_inputmethod_manager_service(
  -- Dump id
  id INT,
  -- Timestamp when the dump was triggered
  ts INT,
  -- Extra args parsed from the proto message
  arg_set_id INT
) AS
SELECT
  id,
  ts,
  arg_set_id
FROM __intrinsic_inputmethod_manager_service;

-- Android inputmethod service state dumps (from android.inputmethod data source).
CREATE PERFETTO VIEW android_inputmethod_service(
  -- Dump id
  id INT,
  -- Timestamp when the dump was triggered
  ts INT,
  -- Extra args parsed from the proto message
  arg_set_id INT
) AS
SELECT
  id,
  ts,
  arg_set_id
FROM __intrinsic_inputmethod_service;

)_d3l1m1t3r_"
;

const char kAndroidWinscopeViewcapture[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Android viewcapture (from android.viewcapture data source).
CREATE PERFETTO VIEW android_viewcapture(
  -- Snapshot id
  id INT,
  -- Timestamp when the snapshot was triggered
  ts INT,
  -- Extra args parsed from the proto message
  arg_set_id INT
) AS
SELECT
  id,
  ts,
  arg_set_id
FROM __intrinsic_viewcapture;

)_d3l1m1t3r_"
;

const char kAndroidAnrs[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- List of all ANRs that occurred in the trace (one row per ANR).
CREATE PERFETTO VIEW android_anrs(
  -- Name of the process that triggered the ANR.
  process_name STRING,
  -- PID of the process that triggered the ANR.
  pid INT,
  -- UPID of the process that triggered the ANR.
  upid INT,
  -- UUID of the ANR (generated on the platform).
  error_id STRING,
  -- Timestamp of the ANR.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ts INT,
  -- Subject line of the ANR.
  subject STRING
) AS
-- Process and PID that ANRed.
WITH anr AS (
  SELECT
    -- Counter formats:
    -- v1: "ErrorId:<process_name>#<UUID>"
    -- v2: "ErrorId:<process_name> <pid>#<UUID>"
    STR_SPLIT(SUBSTR(STR_SPLIT(process_counter_track.name, '#', 0), 9), ' ', 0) AS process_name,
    CAST(STR_SPLIT(SUBSTR(STR_SPLIT(process_counter_track.name, '#', 0), 9), ' ', 1) AS INT32) AS pid,
    STR_SPLIT(process_counter_track.name, '#', 1) AS error_id,
    counter.ts
  FROM process_counter_track
  JOIN process USING (upid)
  JOIN counter ON (counter.track_id = process_counter_track.id)
  WHERE process_counter_track.name GLOB 'ErrorId:*'
    AND process.name = 'system_server'
),
-- ANR subject line.
subject AS (
  --- Counter format:
  --- "Subject(for ErrorId <UUID>):<subject>"
  SELECT
    SUBSTR(STR_SPLIT(process_counter_track.name, ')', 0), 21) AS error_id,
    SUBSTR(process_counter_track.name, length(STR_SPLIT(process_counter_track.name, ')', 0)) + 3) AS subject
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  FROM process_counter_track
  JOIN process
  USING (upid)
  WHERE process_counter_track.name GLOB 'Subject(for ErrorId *'
  AND process.name = 'system_server'
)
SELECT
    anr.process_name,
    anr.pid,
    process.upid,
    anr.error_id,
    anr.ts,
    subject
FROM anr
LEFT JOIN subject USING (error_id)
LEFT JOIN process ON (process.pid = anr.pid);
)_d3l1m1t3r_"
;

const char kAndroidAppProcessStarts[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
INCLUDE PERFETTO MODULE slices.with_context;

-- All process starts.
CREATE PERFETTO VIEW _proc_start
AS
SELECT ts, dur, TRIM(SUBSTR(name, 12)) AS process_name
FROM thread_slice
WHERE name GLOB 'Start proc:*' AND process_name = 'system_server';

-- Broadcast, service and activity cold starts.
CREATE PERFETTO TABLE _cold_start
AS
WITH
  lifecycle_slice AS (
    SELECT
      id,
      ts AS intent_ts,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      dur AS intent_dur,
      track_id,
      name,
      upid,
      process_name,
      pid,
      utid,
      CASE
        WHEN name GLOB 'performCreate:*' THEN 'activity'
        WHEN name GLOB 'serviceCreate:*' THEN 'service'
        WHEN name GLOB 'broadcastReceiveComp:*' THEN 'broadcast'
      END AS reason,
            CASE
        WHEN name GLOB 'performCreate:*' THEN STR_SPLIT(name, 'performCreate:', 1)
        WHEN name GLOB 'serviceCreate:*' THEN STR_SPLIT(STR_SPLIT(name, '=', 2), ' ', 0)
        WHEN name GLOB 'broadcastReceive*' THEN STR_SPLIT(name, 'broadcastReceiveComp:', 1)
        END AS intent
    FROM thread_slice slice
    WHERE
      name GLOB 'bindApplication'
      OR name GLOB 'performCreate:*'
      OR name GLOB 'serviceCreate:*'
      OR name GLOB 'broadcastReceiveComp:*'
    ORDER BY ts
  ),
  cold_start AS (
    SELECT
      *,
      lag(name) OVER (PARTITION BY track_id ORDER BY intent_ts) AS bind_app_name,
      lag(intent_ts) OVER (PARTITION BY track_id ORDER BY intent_ts) AS bind_app_ts,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      lag(intent_dur) OVER (PARTITION BY track_id ORDER BY intent_ts) AS bind_app_dur,
      lag(id) OVER (PARTITION BY track_id ORDER BY intent_ts) AS bind_app_id
    FROM lifecycle_slice
  )
SELECT * FROM cold_start WHERE bind_app_name = 'bindApplication';

-- Join Broadcast, service and activity cold starts with process starts.
CREATE PERFETTO VIEW _cold_proc_start
AS
SELECT
  cold_start.*,
  MAX(proc_start.ts) AS proc_start_ts,
  proc_start.dur AS proc_start_dur,
  cold_start.intent_ts - MAX(proc_start.ts) + cold_start.intent_dur AS total_dur
FROM _cold_start cold_start
JOIN _proc_start proc_start
  ON proc_start.process_name = cold_start.process_name AND cold_start.intent_ts > proc_start.ts
GROUP BY cold_start.upid;

-- Provider cold starts.
CREATE PERFETTO TABLE _provider_start
AS
WITH
  provider_start AS (
    SELECT id AS bind_app_id FROM slice WHERE name = 'bindApplication'
    EXCEPT
    SELECT bind_app_id FROM _cold_start
  )
SELECT * FROM provider_start JOIN thread_slice ON id = bind_app_id;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Join Provider cold starts with process starts.
CREATE PERFETTO VIEW _provider_proc_start
AS
SELECT
  cold_start.*,
  MAX(proc_start.ts) AS proc_start_ts,
  proc_start.dur AS proc_start_dur,
  cold_start.ts - MAX(proc_start.ts) + cold_start.dur AS total_dur
FROM _provider_start cold_start
JOIN _proc_start proc_start
  ON proc_start.process_name = cold_start.process_name AND cold_start.ts > proc_start.ts
GROUP BY cold_start.upid;

-- All app cold starts with information about their cold start reason:
-- broadcast, service, activity or provider.
CREATE PERFETTO TABLE android_app_process_starts(
  -- Slice id of the bindApplication slice in the app. Uniquely identifies a process start.
  start_id INT,
  -- Slice id of intent received in the app.
  id INT,
  -- Track id of the intent received in the app.
  track_id INT,
  -- Name of the process receiving the intent.
  process_name STRING,
  -- Pid of the process receiving the intent.
  pid INT,
  -- Upid of the process receiving the intent.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  upid INT,
  -- Intent action or component responsible for the cold start.
  intent STRING,
  -- Process start reason: activity, broadcast, service or provider.
  reason STRING,
  -- Timestamp the process start was dispatched from system_server.
  proc_start_ts INT,
  -- Duration to dispatch the process start from system_server.
  proc_start_dur INT,
  -- Timestamp the bindApplication started in the app.
  bind_app_ts INT,
  -- Duration to complete bindApplication in the app.
  bind_app_dur INT,
  -- Timestamp the Intent was received in the app.
  intent_ts INT,
  -- Duration to handle intent in the app.
  intent_dur INT,
  -- Total duration from proc_start dispatched to intent completed.
  total_dur INT
) AS
SELECT
  bind_app_id AS start_id,
  id,
  track_id,
  process_name,
  pid,
  upid,
  intent,
  reason,
  proc_start_ts,
  proc_start_dur,
  bind_app_ts,
  bind_app_dur,
  intent_ts,
  intent_dur,
  total_dur
FROM _cold_proc_start
UNION ALL
SELECT
  bind_app_id AS start_id,
  NULL AS id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  NULL AS track_id,
  process_name,
  pid,
  upid,
  NULL AS intent,
  'provider' AS reason,
  proc_start_ts,
  proc_start_dur,
  ts AS bind_app_ts,
  dur AS bind_app_dur,
  NULL AS intent_ts,
  NULL AS intent_dur,
  total_dur
FROM _provider_proc_start;

)_d3l1m1t3r_"
;

const char kAndroidBattery[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Battery charge at timestamp.
CREATE PERFETTO VIEW android_battery_charge(
  -- Timestamp.
  ts INT,
  -- Current average micro ampers.
  current_avg_ua INT,
  -- Current capacity percentage.
  capacity_percent INT,
  -- Current charge in micro ampers.
  charge_uah INT,
  -- Current micro ampers.
  current_ua INT
)  AS
SELECT
  all_ts.ts,
  current_avg_ua,
  capacity_percent,
  charge_uah,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  current_ua
FROM (
  SELECT DISTINCT(ts) AS ts
  FROM counter c
  JOIN counter_track t ON c.track_id = t.id
  WHERE name GLOB 'batt.*'
) AS all_ts
LEFT JOIN (
  SELECT ts, value AS current_avg_ua
  FROM counter c
  JOIN counter_track t ON c.track_id = t.id
  WHERE name = 'batt.current.avg_ua'
) USING(ts)
LEFT JOIN (
  SELECT ts, value AS capacity_percent
  FROM counter c
  JOIN counter_track t ON c.track_id = t.id
  WHERE name = 'batt.capacity_pct'
) USING(ts)
LEFT JOIN (
  SELECT ts, value AS charge_uah
  FROM counter c
  JOIN counter_track t ON c.track_id = t.id
  WHERE name = 'batt.charge_uah'
) USING(ts)
LEFT JOIN (
  SELECT ts, value AS current_ua
  FROM counter c
  JOIN counter_track t ON c.track_id = t.id
  WHERE name = 'batt.current_ua'
) USING(ts)
ORDER BY ts;

)_d3l1m1t3r_"
;

const char kAndroidBatteryStats[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Converts a battery_stats counter value to human readable string.
CREATE PERFETTO FUNCTION android_battery_stats_counter_to_string(
  -- The counter track name (e.g. 'battery_stats.audio').
  track STRING,
  -- The counter value.
  value FLOAT)
-- The human-readable name for the counter value.
RETURNS STRING AS
SELECT
  CASE
    WHEN ($track = "battery_stats.wifi_scan" OR
          $track = "battery_stats.wifi_radio" OR
)_d3l1m1t3r_"
R"_d3l1m1t3r_(          $track = "battery_stats.mobile_radio" OR
          $track = "battery_stats.audio" OR
          $track = "battery_stats.video" OR
          $track = "battery_stats.camera" OR
          $track = "battery_stats.power_save" OR
          $track = "battery_stats.phone_in_call")
      THEN
        CASE $value
          WHEN 0 THEN "inactive"
          WHEN 1 THEN "active"
          ELSE "unknown"
        END
    WHEN $track = "battery_stats.wifi"
      THEN
        CASE $value
          WHEN 0 THEN "off"
          WHEN 1 THEN "on"
          ELSE "unknown"
        END
    WHEN $track = "battery_stats.phone_state"
      THEN
        CASE $value
          WHEN 0 THEN "in"
          WHEN 1 THEN "out"
          WHEN 2 THEN "emergency"
          WHEN 3 THEN "off"
          ELSE "unknown"
        END
    WHEN ($track = "battery_stats.phone_signal_strength" OR
          $track = "battery_stats.wifi_signal_strength")
      THEN
        CASE $value
          WHEN 0 THEN "0/4"
          WHEN 1 THEN "1/4"
)_d3l1m1t3r_"
R"_d3l1m1t3r_(          WHEN 2 THEN "2/4"
          WHEN 3 THEN "3/4"
          WHEN 4 THEN "4/4"
          ELSE "unknown"
        END
    WHEN $track = "battery_stats.wifi_suppl"
      THEN
        CASE $value
          WHEN 0 THEN "invalid"
          WHEN 1 THEN "disconnected"
          WHEN 2 THEN "disabled"
          WHEN 3 THEN "inactive"
          WHEN 4 THEN "scanning"
          WHEN 5 THEN "authenticating"
          WHEN 6 THEN "associating"
          WHEN 7 THEN "associated"
          WHEN 8 THEN "4-way-handshake"
          WHEN 9 THEN "group-handshake"
          WHEN 10 THEN "completed"
          WHEN 11 THEN "dormant"
          WHEN 12 THEN "uninitialized"
          ELSE "unknown"
        END
    WHEN $track = "battery_stats.data_conn"
      THEN
        CASE $value
          WHEN 0 THEN "Out of service"
          WHEN 1 THEN "2.5G (GPRS)"
          WHEN 2 THEN "2.7G (EDGE)"
          WHEN 3 THEN "3G (UMTS)"
          WHEN 4 THEN "3G (CDMA)"
          WHEN 5 THEN "3G (EVDO Rel 0)"
          WHEN 6 THEN "3G (EVDO Rev A)"
)_d3l1m1t3r_"
R"_d3l1m1t3r_(          WHEN 7 THEN "3G (LXRTT)"
          WHEN 8 THEN "3.5G (HSDPA)"
          WHEN 9 THEN "3.5G (HSUPA)"
          WHEN 10 THEN "3.5G (HSPA)"
          WHEN 11 THEN "2G (IDEN)"
          WHEN 12 THEN "3G (EVDO Rev B)"
          WHEN 13 THEN "4G (LTE)"
          WHEN 14 THEN "3.5G (eHRPD)"
          WHEN 15 THEN "3.7G (HSPA+)"
          WHEN 16 THEN "2G (GSM)"
          WHEN 17 THEN "3G (TD SCDMA)"
          WHEN 18 THEN "Wifi calling (IWLAN)"
          WHEN 19 THEN "4.5G (LTE CA)"
          WHEN 20 THEN "5G (NR)"
          WHEN 21 THEN "Emergency calls only"
          WHEN 22 THEN "Other"
          ELSE "unknown"
        END
    ELSE CAST($value AS text)
  END;

-- View of human readable battery stats counter-based states. These are recorded
-- by BatteryStats as a bitmap where each 'category' has a unique value at any
-- given time.
CREATE PERFETTO VIEW android_battery_stats_state(
  -- Timestamp in nanoseconds.
  ts INT,
  -- The duration the state was active, may be negative for incomplete slices.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  dur INT,
  -- The same as `dur`, but extends to trace end for incomplete slices.
  safe_dur INT,
  -- The name of the counter track.
  track_name STRING,
  -- The counter value as a number.
  value INT,
  -- The counter value as a human-readable string.
  value_name STRING
) AS
SELECT
  ts,
  IFNULL(LEAD(ts) OVER (PARTITION BY name ORDER BY ts) - ts, -1) AS dur,
  LEAD(ts, 1, TRACE_END()) OVER (PARTITION BY name ORDER BY ts) - ts AS safe_dur,
  name AS track_name,
  CAST(value AS INT64) AS value,
  android_battery_stats_counter_to_string(name, value) AS value_name
FROM counter
JOIN counter_track
  ON counter.track_id = counter_track.id
WHERE counter_track.name GLOB 'battery_stats.*';


-- View of slices derived from battery_stats events. Battery stats records all
-- events as instants, however some may indicate whether something started or
-- stopped with a '+' or '-' prefix. Events such as jobs, top apps, foreground
-- apps or long wakes include these details and allow drawing slices between
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- instant events found in a trace.
--
-- For example, we may see an event like the following on 'battery_stats.top':
--
--     -top=10215:"com.google.android.apps.nexuslauncher"
--
-- This view will find the associated start ('+top') with the matching suffix
-- (everything after the '=') to construct a slice. It computes the timestamp
-- and duration from the events and extract the details as follows:
--
--     track_name='battery_stats.top'
--     str_value='com.google.android.apps.nexuslauncher'
--     int_value=10215
CREATE PERFETTO VIEW android_battery_stats_event_slices(
  -- Timestamp in nanoseconds.
  ts INT,
  -- The duration the state was active, may be negative for incomplete slices.
  dur INT,
  -- The same as `dur`, but extends to trace end for incomplete slices.
  safe_dur INT,
  -- The name of the counter track.
  track_name STRING,
  -- String value.
  str_value STRING,
  -- Int value.
  int_value INT
) AS
WITH
  event_markers AS (
    SELECT
      ts,
      track.name AS track_name,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      str_split(slice.name, '=', 1) AS key,
      substr(slice.name, 1, 1) = '+' AS start
    FROM slice
    JOIN track
      ON slice.track_id = track.id
    WHERE
      track_name GLOB 'battery_stats.*'
      AND substr(slice.name, 1, 1) IN ('+', '-')
  ),
  with_neighbors AS (
    SELECT
      *,
      LAG(ts) OVER (PARTITION BY track_name, key ORDER BY ts) AS last_ts,
      LEAD(ts) OVER (PARTITION BY track_name, key ORDER BY ts) AS next_ts
    FROM event_markers
  ),
  -- Note: query performance depends on the ability to push down filters on
  -- the track_name. It would be more clear below to have two queries and union
  -- them, but doing so prevents push down through the above window functions.
  event_spans AS (
    SELECT
      track_name, key,
      IIF(start, ts, trace_start()) AS ts,
      IIF(start, next_ts, ts) AS end_ts
    FROM with_neighbors
    -- For the majority of events, we take the `start` event and compute the dur
    -- based on next_ts. In the off chance we get an end event with no prior
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    -- start (matched by the second half of this where), we can create an event
    -- starting from the beginning of the trace ending at the current event.
    WHERE (start OR last_ts IS NULL)
  )
SELECT
  ts,
  IFNULL(end_ts-ts, -1) AS dur,
  IFNULL(end_ts, TRACE_END()) - ts AS safe_dur,
  track_name,
  str_split(key, '"', 1) AS str_value,
  CAST(str_split(key, ':', 0) AS INT64) AS int_value
FROM event_spans;

)_d3l1m1t3r_"
;

const char kAndroidBinder[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE android.process_metadata;
INCLUDE PERFETTO MODULE android.suspend;

-- Count Binder transactions per process.
CREATE PERFETTO VIEW android_binder_metrics_by_process(
  -- Name of the process that started the binder transaction.
  process_name INT,
  -- PID of the process that started the binder transaction.
  pid INT,
  -- Name of the slice with binder transaction.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  slice_name STRING,
  -- Number of binder transactions in process in slice.
  event_count INT
) AS
SELECT
  process.name AS process_name,
  process.pid AS pid,
  slice.name AS slice_name,
  COUNT(*) AS event_count
FROM slice
JOIN thread_track ON slice.track_id = thread_track.id
JOIN thread ON thread.utid = thread_track.utid
JOIN process ON thread.upid = process.upid
WHERE
  slice.name GLOB 'binder*'
GROUP BY
  process_name,
  slice_name;

CREATE PERFETTO TABLE _binder_txn_merged AS
WITH maybe_broken_binder_txn AS (
  -- Fetch the broken binder txns first, i.e, the txns that have children slices
  -- They may be broken because synchronous txns are typically blocked sleeping while
  -- waiting for a response.
  -- These broken txns will be excluded below in the binder_txn CTE
    SELECT ancestor.id
    FROM slice
    JOIN slice ancestor
      ON ancestor.id = slice.parent_id
    WHERE ancestor.name = 'binder transaction'
    GROUP BY ancestor.id
), nested_binder_txn AS (
  -- Detect the non-broken cases which are just nested binder txns
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    SELECT slice_out AS id
    FROM maybe_broken_binder_txn
    JOIN following_flow(maybe_broken_binder_txn.id)
  ), broken_binder_txn AS (
  -- Exclude the nested txns from the 'maybe broken' set
    SELECT * FROM maybe_broken_binder_txn
    EXCEPT
    SELECT * FROM nested_binder_txn
  ),
  -- Adding MATERIALIZED here matters in cases where there are few/no binder
  -- transactions in the trace. Our cost estimation is not good enough to allow
  -- the query planner to see through to this fact. Instead, our cost estimation
  -- causes repeated queries on this table which is slow because it's an O(n)
  -- query.
  --
  -- We should fix this by doing some (ideally all) of the following:
  --  1) Add support for columnar tables in SQL which will allow for
  --     "subsetting" the slice table to only contain binder transactions.
  --  2) Make this query faster by adding improving string filtering.
  --  3) Add caching so that even if these queries happen many times, they are
  --     fast.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  --  4) Improve cost estimation algorithm to allow the joins to happen the
  --     right way around.
  binder_txn AS MATERIALIZED (
    SELECT
      slice.id AS binder_txn_id,
      process.name AS process_name,
      thread.name AS thread_name,
      thread.utid AS utid,
      thread.tid AS tid,
      process.pid AS pid,
      process.upid AS upid,
      slice.ts,
      slice.dur,
      thread.is_main_thread
    FROM slice
    JOIN thread_track ON slice.track_id = thread_track.id
    JOIN thread USING (utid)
    JOIN process USING (upid)
    LEFT JOIN broken_binder_txn ON broken_binder_txn.id = slice.id
    WHERE slice.name = 'binder transaction'
    AND broken_binder_txn.id IS NULL
  ),
  binder_reply AS (
    SELECT
      binder_txn.*,
      binder_reply.ts AS server_ts,
      binder_reply.dur AS server_dur,
      binder_reply.id AS binder_reply_id,
      reply_thread.name AS server_thread,
      reply_process.name AS server_process,
      reply_thread.utid AS server_utid,
      reply_thread.tid AS server_tid,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      reply_process.pid AS server_pid,
      reply_process.upid AS server_upid,
      aidl.name AS aidl_name,
      aidl.ts AS aidl_ts,
      aidl.dur AS aidl_dur
    FROM binder_txn
    JOIN flow binder_flow ON binder_txn.binder_txn_id = binder_flow.slice_out
    JOIN slice binder_reply ON binder_flow.slice_in = binder_reply.id
    JOIN thread_track reply_thread_track
      ON binder_reply.track_id = reply_thread_track.id
    JOIN thread reply_thread ON reply_thread.utid = reply_thread_track.utid
    JOIN process reply_process ON reply_process.upid = reply_thread.upid
    LEFT JOIN slice aidl ON aidl.parent_id = binder_reply.id
        AND (aidl.name GLOB 'AIDL::cpp*Server'
             OR aidl.name GLOB 'AIDL::java*server'
             OR aidl.name GLOB 'HIDL::*server')
  )
SELECT
  MIN(aidl_name) AS aidl_name,
  aidl_ts,
  aidl_dur,
  binder_txn_id,
  process_name AS client_process,
  thread_name AS client_thread,
  upid AS client_upid,
  utid AS client_utid,
  tid AS client_tid,
  pid AS client_pid,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  is_main_thread,
  ts AS client_ts,
  dur AS client_dur,
  binder_reply_id,
  server_process,
  server_thread,
  server_upid,
  server_utid,
  server_tid,
  server_pid,
  server_ts,
  server_dur
FROM binder_reply
WHERE client_dur != -1 AND server_dur != -1 AND client_dur >= server_dur
GROUP BY
  process_name,
  thread_name,
  binder_txn_id,
  binder_reply_id;

CREATE TABLE _oom_score AS
  SELECT
    process.upid,
    CAST(c.value AS INT) AS value,
    c.ts,
    IFNULL(LEAD(ts) OVER (PARTITION BY upid ORDER BY ts), trace_end()) AS end_ts
    FROM counter c
         JOIN process_counter_track t ON c.track_id = t.id
         JOIN process USING (upid)
   WHERE t.name = 'oom_score_adj';

CREATE INDEX _oom_score_idx ON _oom_score(upid, ts);

-- Breakdown synchronous binder transactions per txn.
-- It returns data about the client and server ends of every binder transaction.
CREATE PERFETTO VIEW _sync_binder_metrics_by_txn AS
SELECT binder.*, client_oom.value AS client_oom_score, server_oom.value AS server_oom_score
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM _binder_txn_merged binder
LEFT JOIN _oom_score client_oom
  ON
    binder.client_upid = client_oom.upid
    AND binder.client_ts BETWEEN client_oom.ts AND client_oom.end_ts
LEFT JOIN _oom_score server_oom
  ON
    binder.server_upid = server_oom.upid
    AND binder.server_ts BETWEEN server_oom.ts AND server_oom.end_ts;

CREATE PERFETTO VIEW _binder_txn
AS
SELECT client_ts AS ts, client_dur AS dur, client_utid AS utid, *
FROM _sync_binder_metrics_by_txn;

CREATE PERFETTO VIEW _binder_reply
AS
SELECT server_ts AS ts, server_dur AS dur, server_utid AS utid, *
FROM _sync_binder_metrics_by_txn;

CREATE VIRTUAL TABLE _sp_binder_txn_thread_state
USING
  SPAN_JOIN(_binder_txn PARTITIONED utid, thread_state PARTITIONED utid);

CREATE VIRTUAL TABLE _sp_binder_reply_thread_state
USING
  SPAN_JOIN(_binder_reply PARTITIONED utid, thread_state PARTITIONED utid);

-- Aggregated thread_states on the client and server side per binder txn
-- This builds on the data from |_sync_binder_metrics_by_txn| and
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- for each end (client and server) of the transaction, it returns
-- the aggregated sum of all the thread state durations.
-- The |thread_state_type| column represents whether a given 'aggregated thread_state'
-- row is on the client or server side. 'binder_txn' is client side and 'binder_reply'
-- is server side.
CREATE PERFETTO VIEW android_sync_binder_thread_state_by_txn(
  -- slice id of the binder txn
  binder_txn_id INT,
  -- Client timestamp
  client_ts INT,
  -- Client tid
  client_tid INT,
  -- slice id of the binder reply
  binder_reply_id INT,
  -- Server timestamp
  server_ts INT,
  -- Server tid
  server_tid INT,
  -- whether thread state is on the txn or reply side
  thread_state_type STRING,
  -- a thread_state that occurred in the txn
  thread_state STRING,
  -- aggregated dur of the |thread_state| in the txn
  thread_state_dur INT,
  -- aggregated count of the |thread_state| in the txn
  thread_state_count INT
) AS
SELECT
  binder_txn_id,
  client_ts,
  client_tid,
  binder_reply_id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  server_ts,
  server_tid,
  'binder_txn' AS thread_state_type,
  state AS thread_state,
  SUM(dur) AS thread_state_dur,
  COUNT(dur) AS thread_state_count
FROM _sp_binder_txn_thread_state
GROUP BY binder_txn_id, binder_reply_id, thread_state_type, thread_state
UNION ALL
SELECT
  binder_txn_id,
  client_ts,
  client_tid,
  binder_reply_id,
  server_ts,
  server_tid,
  'binder_reply' AS thread_state_type,
  state AS thread_state,
  SUM(dur) AS thread_state_dur,
  COUNT(dur) AS thread_state_count
FROM _sp_binder_reply_thread_state
GROUP BY binder_txn_id, binder_reply_id, thread_state_type, thread_state;

-- Aggregated blocked_functions on the client and server side per binder txn
-- This builds on the data from |_sync_binder_metrics_by_txn| and
-- for each end (client and server) of the transaction, it returns
-- the aggregated sum of all the kernel blocked function durations.
-- The |thread_state_type| column represents whether a given 'aggregated blocked_function'
-- row is on the client or server side. 'binder_txn' is client side and 'binder_reply'
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- is server side.
CREATE PERFETTO VIEW android_sync_binder_blocked_functions_by_txn(
  -- slice id of the binder txn
  binder_txn_id INT,
  -- Client ts
  client_ts INT,
  -- Client tid
  client_tid INT,
  -- slice id of the binder reply
  binder_reply_id INT,
  -- Server ts
  server_ts INT,
  -- Server tid
  server_tid INT,
  -- whether thread state is on the txn or reply side
  thread_state_type STRING,
  -- blocked kernel function in a thread state
  blocked_function STRING,
  -- aggregated dur of the |blocked_function| in the txn
  blocked_function_dur INT,
  -- aggregated count of the |blocked_function| in the txn
  blocked_function_count INT
) AS
SELECT
  binder_txn_id,
  client_ts,
  client_tid,
  binder_reply_id,
  server_ts,
  server_tid,
  'binder_txn' AS thread_state_type,
  blocked_function,
  SUM(dur) AS blocked_function_dur,
  COUNT(dur) AS blocked_function_count
FROM _sp_binder_txn_thread_state
WHERE blocked_function IS NOT NULL
GROUP BY binder_txn_id, binder_reply_id, blocked_function
)_d3l1m1t3r_"
R"_d3l1m1t3r_(UNION ALL
SELECT
  binder_txn_id,
  client_ts,
  client_tid,
  binder_reply_id,
  server_ts,
  server_tid,
  'binder_reply' AS thread_state_type,
  blocked_function,
  SUM(dur) AS blocked_function_dur,
  COUNT(dur) AS blocked_function_count
FROM _sp_binder_reply_thread_state
WHERE blocked_function IS NOT NULL
GROUP BY binder_txn_id, binder_reply_id, blocked_function;

CREATE PERFETTO TABLE _async_binder_reply AS
WITH async_reply AS MATERIALIZED (
  SELECT id, ts, dur, track_id, name
  FROM slice
  WHERE
    name GLOB 'AIDL::cpp*Server'
    OR name GLOB 'AIDL::java*server'
    OR name GLOB 'HIDL::*server'
    OR name = 'binder async rcv'
) SELECT *, LEAD(name) OVER (PARTITION BY track_id ORDER BY ts) AS next_name,
    LEAD(ts) OVER (PARTITION BY track_id ORDER BY ts) AS next_ts,
    LEAD(dur) OVER (PARTITION BY track_id ORDER BY ts) AS next_dur
    FROM async_reply;

CREATE PERFETTO TABLE _binder_async_txn_raw AS
SELECT
  slice.id AS binder_txn_id,
  process.name AS client_process,
  thread.name AS client_thread,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  process.upid AS client_upid,
  thread.utid AS client_utid,
  thread.tid AS client_tid,
  process.pid AS client_pid,
  thread.is_main_thread,
  slice.ts AS client_ts,
  slice.dur AS client_dur
FROM slice
JOIN thread_track
  ON slice.track_id = thread_track.id
JOIN thread
  USING (utid)
JOIN process
  USING (upid)
WHERE slice.name = 'binder transaction async';

CREATE PERFETTO TABLE _binder_async_txn AS
SELECT
  IIF(binder_reply.next_name = 'binder async rcv', NULL, binder_reply.next_name) AS aidl_name,
  IIF(binder_reply.next_name = 'binder async rcv', NULL, binder_reply.next_ts) AS aidl_ts,
  IIF(binder_reply.next_name = 'binder async rcv', NULL, binder_reply.next_dur) AS aidl_dur,
  binder_txn.*,
  binder_reply.id AS binder_reply_id,
  reply_process.name AS server_process,
  reply_thread.name AS server_thread,
  reply_process.upid AS server_upid,
  reply_thread.utid AS server_utid,
  reply_thread.tid AS server_tid,
  reply_process.pid AS server_pid,
  binder_reply.ts AS server_ts,
  binder_reply.dur AS server_dur
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM _binder_async_txn_raw binder_txn
JOIN flow binder_flow
  ON binder_txn.binder_txn_id = binder_flow.slice_out
JOIN _async_binder_reply binder_reply
  ON binder_flow.slice_in = binder_reply.id
JOIN thread_track reply_thread_track
  ON binder_reply.track_id = reply_thread_track.id
JOIN thread reply_thread
  ON reply_thread.utid = reply_thread_track.utid
JOIN process reply_process
  ON reply_process.upid = reply_thread.upid
WHERE binder_reply.name = 'binder async rcv';

-- Breakdown asynchronous binder transactions per txn.
-- It returns data about the client and server ends of every binder transaction async.
CREATE PERFETTO VIEW _async_binder_metrics_by_txn AS
SELECT binder.*, client_oom.value AS client_oom_score, server_oom.value AS server_oom_score
FROM _binder_async_txn binder
LEFT JOIN _oom_score client_oom
  ON
    binder.client_upid = client_oom.upid
    AND binder.client_ts BETWEEN client_oom.ts AND client_oom.end_ts
LEFT JOIN _oom_score server_oom
  ON
    binder.server_upid = server_oom.upid
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    AND binder.server_ts BETWEEN server_oom.ts AND server_oom.end_ts;

-- Breakdown binder transactions per txn.
-- It returns data about the client and server ends of every binder transaction async.
CREATE PERFETTO TABLE android_binder_txns(
  -- name of the binder interface if existing.
  aidl_name STRING,
  -- Timestamp the binder interface name was emitted. Proxy to 'ts' and 'dur' for async txns.
  aidl_ts INT,
  -- Duration of the binder interface name. Proxy to 'ts' and 'dur' for async txns.
  aidl_dur INT,
  -- slice id of the binder txn.
  binder_txn_id INT,
  -- name of the client process.
  client_process STRING,
  -- name of the client thread.
  client_thread STRING,
  -- Upid of the client process.
  client_upid INT,
  -- Utid of the client thread.
  client_utid INT,
  -- Tid of the client thread.
  client_tid INT,
  -- Pid of the client thread.
  client_pid INT,
  -- Whether the txn was initiated from the main thread of the client process.
  is_main_thread BOOL,
  -- timestamp of the client txn.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  client_ts INT,
  -- wall clock dur of the client txn.
  client_dur INT,
  -- slice id of the binder reply.
  binder_reply_id INT,
  -- name of the server process.
  server_process STRING,
  -- name of the server thread.
  server_thread STRING,
  -- Upid of the server process.
  server_upid INT,
  -- Utid of the server thread.
  server_utid INT,
  -- Tid of the server thread.
  server_tid INT,
  -- Pid of the server thread.
  server_pid INT,
  -- timestamp of the server txn.
  server_ts INT,
  -- wall clock dur of the server txn.
  server_dur INT,
  -- oom score of the client process at the start of the txn.
  client_oom_score INT,
  -- oom score of the server process at the start of the reply.
  server_oom_score INT,
  -- whether the txn is synchronous or async (oneway).
  is_sync BOOL,
  -- monotonic clock dur of the client txn.
  client_monotonic_dur INT,
  -- monotonic clock dur of the server txn.
  server_monotonic_dur INT,
  -- Client package version_code.
  client_package_version_code INT,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Server package version_code.
  server_package_version_code INT,
  -- Whether client package is debuggable.
  is_client_package_debuggable INT,
  -- Whether server package is debuggable.
  is_server_package_debuggable INT
) AS WITH all_binder AS (
  SELECT *, 1 AS is_sync FROM _sync_binder_metrics_by_txn
UNION ALL
SELECT *, 0 AS is_sync FROM _async_binder_metrics_by_txn
) SELECT
  all_binder.*,
  _extract_duration_without_suspend(client_ts, client_dur) AS client_monotonic_dur,
  _extract_duration_without_suspend(server_ts, server_dur) AS server_monotonic_dur,
  client_process_metadata.version_code AS client_package_version_code,
  server_process_metadata.version_code AS server_package_version_code,
  client_process_metadata.debuggable AS is_client_package_debuggable,
  server_process_metadata.debuggable AS is_server_package_debuggable
FROM all_binder
LEFT JOIN android_process_metadata client_process_metadata
  ON all_binder.client_upid = client_process_metadata.upid
LEFT JOIN android_process_metadata server_process_metadata
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ON all_binder.server_upid = server_process_metadata.upid;

-- Returns a DAG of all outgoing binder txns from a process.
-- The roots of the graph are the threads making the txns and the graph flows from:
-- thread -> server_process -> AIDL interface -> AIDL method.
-- The weights of each node represent the wall execution time in the server_process.
CREATE PERFETTO FUNCTION android_binder_outgoing_graph(
  -- Upid of process to generate an outgoing graph for.
  upid INT)
RETURNS TABLE(
  -- Pprof of outgoing binder txns.
  pprof BYTES) AS
WITH threads AS (
  SELECT binder_txn_id, CAT_STACKS(client_thread) AS stack
  FROM android_binder_txns
  WHERE ($upid IS NOT NULL AND client_upid = $upid) OR ($upid IS NULL)
), server_process AS (
  SELECT binder_txn_id, CAT_STACKS(stack, server_process) AS stack
  FROM android_binder_txns
  JOIN threads USING(binder_txn_id)
), end_points AS (
  SELECT binder_txn_id,
         CAT_STACKS(stack, STR_SPLIT(aidl_name, '::', IIF(aidl_name GLOB 'AIDL*', 2, 1))) AS stack
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  FROM android_binder_txns
  JOIN server_process USING(binder_txn_id)
), aidl_names AS (
  SELECT binder_txn_id, server_dur,
         CAT_STACKS(stack, STR_SPLIT(aidl_name, '::', IIF(aidl_name GLOB 'AIDL*', 3, 2))) AS stack
  FROM android_binder_txns
  JOIN end_points USING(binder_txn_id)
) SELECT EXPERIMENTAL_PROFILE(stack, 'duration', 'ns', server_dur) AS pprof
  FROM aidl_names;

-- Returns a DAG of all incoming binder txns from a process.
-- The roots of the graph are the clients making the txns and the graph flows from:
-- client_process -> AIDL interface -> AIDL method.
-- The weights of each node represent the wall execution time in the server_process.
CREATE PERFETTO FUNCTION android_binder_incoming_graph(
  -- Upid of process to generate an incoming graph for.
  upid INT)
RETURNS TABLE(
  -- Pprof of incoming binder txns.
  pprof BYTES) AS
WITH client_process AS (
  SELECT binder_txn_id, CAT_STACKS(client_process) AS stack
  FROM android_binder_txns
  WHERE ($upid IS NOT NULL AND server_upid = $upid) OR ($upid IS NULL)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(), end_points AS (
  SELECT binder_txn_id,
         CAT_STACKS(stack, STR_SPLIT(aidl_name, '::', IIF(aidl_name GLOB 'AIDL*', 2, 1))) AS stack
  FROM android_binder_txns
  JOIN client_process USING(binder_txn_id)
), aidl_names AS (
  SELECT binder_txn_id, server_dur,
         CAT_STACKS(stack, STR_SPLIT(aidl_name, '::', IIF(aidl_name GLOB 'AIDL*', 3, 2))) AS stack
  FROM android_binder_txns
  JOIN end_points USING(binder_txn_id)
) SELECT EXPERIMENTAL_PROFILE(stack, 'duration', 'ns', server_dur) AS pprof
  FROM aidl_names;

-- Returns a graph of all binder txns in a trace.
-- The nodes are client_process and server_process.
-- The weights of each node represent the wall execution time in the server_process.
CREATE PERFETTO FUNCTION android_binder_graph(
  -- Matches txns from client_processes greater than or equal to the OOM score.
  min_client_oom_score INT,
  -- Matches txns from client_processes less than or equal to the OOM score.
  max_client_oom_score INT,
  -- Matches txns to server_processes greater than or equal to the OOM score.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  min_server_oom_score INT,
  -- Matches txns to server_processes less than or equal to the OOM score.
  max_server_oom_score INT)
RETURNS TABLE(
  -- Pprof of binder txns.
  pprof BYTES) AS
WITH clients AS (
  SELECT binder_txn_id, CAT_STACKS(client_process) AS stack
   FROM android_binder_txns
   WHERE client_oom_score BETWEEN $min_client_oom_score AND $max_client_oom_score
), servers AS (
  SELECT binder_txn_id, server_dur, CAT_STACKS(stack, server_process) AS stack
  FROM android_binder_txns
  JOIN clients USING(binder_txn_id)
  WHERE server_oom_score BETWEEN $min_server_oom_score AND $max_server_oom_score
) SELECT EXPERIMENTAL_PROFILE(stack, 'duration', 'ns', server_dur) AS pprof
  FROM servers;

)_d3l1m1t3r_"
;

const char kAndroidBroadcasts[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE android.freezer;

CREATE PERFETTO FUNCTION _extract_broadcast_process_name(name STRING)
RETURNS INT
AS
WITH
  pid_and_name AS (
    SELECT STR_SPLIT(STR_SPLIT($name, '/', 0), ' ', 1) AS value
  ),
  start AS (
    SELECT CAST(INSTR(value, ':') AS INT) + 1 AS value FROM pid_and_name
  )
SELECT SUBSTR(pid_and_name.value, start.value) FROM pid_and_name, start;

)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- Provides a list of broadcast names and processes they were sent to by the
-- system_server process on U+ devices.
CREATE PERFETTO TABLE _android_broadcasts_minsdk_u(
  -- Intent action of the broadcast.
  intent_action STRING,
  -- Name of the process the broadcast was sent to.
  process_name STRING,
  -- Pid of the process the broadcast was sent to.
  pid STRING,
  -- Upid of the process the broadcast was sent to.
  upid STRING,
  -- Id of the broacast queue the broadcast was dispatched from.
  queue_id INT,
  -- Slice id of the broadcast dispatch.
  id INT,
  -- Timestamp the broadcast was dispatched.
  ts INT,
  -- Duration to dispatch the broadcast.
  dur INT,
  -- Track id the broadcast was dispatched from.
  track_id INT
) AS
WITH
  broadcast_queues AS (
    SELECT
      process_track.id,
      CAST(replace(str_split(process_track.name, '[', 1), ']', '') AS INT) AS queue_id
    FROM process_track
    JOIN process
      USING (upid)
    WHERE
      process_track.name GLOB 'BroadcastQueue.mRunning*'
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      AND process.name = 'system_server'
  ),
  broadcast_process_running AS (
    SELECT
      slice.id AS id,
      slice.ts,
      slice.dur,
      broadcast_queues.queue_id,
      _extract_broadcast_process_name(slice.name) AS process_name,
      CAST(str_split(str_split(str_split(slice.name, '/', 0), ' ', 1), ':', 0) AS INT) AS pid,
      queue_id
    FROM slice
    JOIN broadcast_queues
      ON broadcast_queues.id = slice.track_id
    WHERE slice.name GLOB '* running'
  ),
  broadcast_intent_action AS (
    SELECT
      str_split(str_split(slice.name, '/', 0), ' ', 1) AS intent_action,
      slice.parent_id,
      slice.id AS intent_id,
      slice.ts AS intent_ts,
      slice.track_id AS track_id,
      slice.dur AS intent_dur
    FROM slice
    WHERE slice.name GLOB '* scheduled'
  )
  SELECT
    broadcast_intent_action.intent_action,
    broadcast_process_running.process_name,
    broadcast_process_running.pid,
    _pid_to_upid(broadcast_process_running.pid, broadcast_intent_action.intent_ts) AS upid,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    broadcast_process_running.queue_id,
    broadcast_intent_action.intent_id AS id,
    broadcast_intent_action.intent_ts AS ts,
    broadcast_intent_action.intent_dur AS dur,
    broadcast_intent_action.track_id
  FROM broadcast_intent_action
  JOIN broadcast_process_running
    ON parent_id = id;

)_d3l1m1t3r_"
;

const char kAndroidCriticalBlockingCalls[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
INCLUDE PERFETTO MODULE android.slices;
INCLUDE PERFETTO MODULE android.binder;
INCLUDE PERFETTO MODULE slices.with_context;

CREATE PERFETTO FUNCTION _is_relevant_blocking_call(name STRING, depth INT)
RETURNS BOOL AS SELECT
  $name = 'measure'
  OR $name = 'layout'
  OR $name = 'configChanged'
  OR $name = 'animation'
  OR $name = 'input'
  OR $name = 'traversal'
  OR $name = 'Contending for pthread mutex'
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  OR $name = 'postAndWait'
  OR $name GLOB 'monitor contention with*'
  OR $name GLOB 'SuspendThreadByThreadId*'
  OR $name GLOB 'LoadApkAssetsFd*'
  OR $name GLOB '*binder transaction*'
  OR $name GLOB 'inflate*'
  OR $name GLOB 'Lock contention on*'
  OR $name GLOB 'android.os.Handler: kotlinx.coroutines*'
  OR $name GLOB 'relayoutWindow*'
  OR $name GLOB 'ImageDecoder#decode*'
  OR $name GLOB 'NotificationStackScrollLayout#onMeasure'
  OR $name GLOB 'ExpNotRow#*'
  OR $name GLOB 'GC: Wait For*'
  OR (
    -- Some top level handler slices
    $depth = 0
    AND $name NOT GLOB '*Choreographer*'
    AND $name NOT GLOB '*Input*'
    AND $name NOT GLOB '*input*'
    AND $name NOT GLOB 'android.os.Handler: #*'
    AND (
      -- Handler pattern heuristics
      $name GLOB '*Handler: *$*'
      OR $name GLOB '*.*.*: *$*'
      OR $name GLOB '*.*$*: #*'
    )
  );


--Extract all slice data on main thread for all processes.
CREATE PERFETTO TABLE _android_critical_blocking_calls AS
SELECT
  android_standardize_slice_name(s.name) AS name,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  s.ts,
  s.dur,
  s.id,
  s.process_name,
  thread.utid,
  s.upid
FROM thread_slice s JOIN
thread USING (utid)
WHERE
  thread.is_main_thread AND _is_relevant_blocking_call(s.name, s.depth)
UNION ALL
-- As binder names are not included in slice table, extract these directly from the
-- android_binder_txns table.
SELECT
  tx.aidl_name AS name,
  tx.client_ts AS ts,
  tx.client_dur AS dur,
  tx.binder_txn_id AS id,
  tx.client_process as process_name,
  tx.client_utid as utid,
  tx.client_upid as upid
FROM android_binder_txns AS tx
WHERE is_main_thread AND aidl_name IS NOT NULL AND is_sync = 1;

)_d3l1m1t3r_"
;

const char kAndroidDevice[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Extract name of the device based on metadata from the trace.
CREATE PERFETTO TABLE android_device_name(
  -- Device name.
  name STRING
)
AS
WITH
  -- Example str_value:
  -- Android/aosp_raven/raven:VanillaIceCream/UDC/11197703:userdebug/test-keys
  -- Gets substring after first slash;
  after_first_slash(str) AS (
    SELECT SUBSTR(str_value, INSTR(str_value, '/') + 1)
    FROM metadata
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    WHERE name = 'android_build_fingerprint'
  ),
  -- Gets substring after second slash
  after_second_slash(str) AS (
    SELECT SUBSTR(str, INSTR(str, '/') + 1)
    FROM after_first_slash
  ),
  -- Gets substring after second slash and before the colon
  before_colon(str) AS (
    SELECT SUBSTR(str, 0, INSTR(str, ':'))
    FROM after_second_slash
  )
SELECT str AS name FROM before_colon;


)_d3l1m1t3r_"
;

const char kAndroidDvfs[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Dvfs counter with duration.
CREATE PERFETTO VIEW android_dvfs_counters(
  -- Counter name.
  name STRING,
  -- Timestamp when counter value changed.
  ts INT,
  -- Counter value.
  value INT,
  -- Counter duration.
  dur INT
) AS
SELECT
  counter_track.name,
  counter.ts,
  counter.value,
  LEAD(counter.ts, 1, trace_end()) OVER (PARTITION BY counter_track.id ORDER BY counter.ts) - counter.ts AS dur
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM counter
JOIN counter_track
  ON counter.track_id = counter_track.id
WHERE
  counter_track.name IN (
    'domain@0 Frequency',
    'domain@1 Frequency',
    'domain@2 Frequency',
    '17000010.devfreq_mif Frequency',
    '17000020.devfreq_int Frequency',
    '17000090.devfreq_dsu Frequency',
    '170000a0.devfreq_bci Frequency',
    'dsu_throughput Frequency',
    'bus_throughput Frequency',
    'cpu0dsu Frequency',
    'cpu1dsu Frequency',
    'cpu2dsu Frequency',
    'cpu3dsu Frequency',
    'cpu4dsu Frequency',
    'cpu5dsu Frequency',
    'cpu6dsu Frequency',
    'cpu7dsu Frequency',
    'cpu8dsu Frequency',
    'gs_memlat_devfreq:devfreq_mif_cpu0_memlat@17000010 Frequency',
    'gs_memlat_devfreq:devfreq_mif_cpu1_memlat@17000010 Frequency',
    'gs_memlat_devfreq:devfreq_mif_cpu2_memlat@17000010 Frequency',
    'gs_memlat_devfreq:devfreq_mif_cpu3_memlat@17000010 Frequency',
    'gs_memlat_devfreq:devfreq_mif_cpu4_memlat@17000010 Frequency',
    'gs_memlat_devfreq:devfreq_mif_cpu5_memlat@17000010 Frequency',
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'gs_memlat_devfreq:devfreq_mif_cpu6_memlat@17000010 Frequency',
    'gs_memlat_devfreq:devfreq_mif_cpu7_memlat@17000010 Frequency',
    'gs_memlat_devfreq:devfreq_mif_cpu8_memlat@17000010 Frequency')
ORDER BY ts;

-- Aggregates dvfs counter slice for statistic.
CREATE PERFETTO TABLE android_dvfs_counter_stats(
  -- Counter name on which all the other values are aggregated on.
  name STRING,
  -- Max of all counter values for the counter name.
  max INT,
  -- Min of all counter values for the counter name.
  min INT,
  -- Duration between the first and last counter value for the counter name.
  dur INT,
  -- Weighted avergate of all the counter values for the counter name.
  wgt_avg FLOAT
) AS
SELECT
  name,
  MAX(value) AS max,
  MIN(value) AS min,
  (MAX(ts) - MIN(ts)) AS dur,
  (SUM(dur * value) / SUM(dur)) AS wgt_avg
FROM android_dvfs_counters
WHERE android_dvfs_counters.dur > 0
GROUP BY name;


-- Aggregates dvfs counter slice for residency
CREATE PERFETTO VIEW android_dvfs_counter_residency(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Counter name.
  name STRING,
  -- Counter value.
  value INT,
  -- Counter duration.
  dur INT,
  -- Counter duration as a percentage of total duration.
  pct FLOAT
) AS
WITH
total AS (
  SELECT
    name,
    SUM(dur) AS dur
  FROM android_dvfs_counters
  WHERE dur > 0
  GROUP BY name
)
SELECT
  android_dvfs_counters.name,
  android_dvfs_counters.value,
  SUM(android_dvfs_counters.dur) AS dur,
  (SUM(android_dvfs_counters.dur) * 100.0 / total.dur) AS pct
FROM android_dvfs_counters
JOIN total
  USING (name)
WHERE android_dvfs_counters.dur > 0
GROUP BY 1, 2;

)_d3l1m1t3r_"
;

const char kAndroidFreezer[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

CREATE PERFETTO FUNCTION _extract_freezer_pid(name STRING)
RETURNS INT
AS
SELECT CAST(reverse(str_split(reverse(str_split($name, ' ', 1)), ':', 0)) AS INT);

-- Converts a pid to a upid using the timestamp of occurence of an event from
-- |pid| to disambiguate duplicate pids.
--
-- This is still best effort because it relies on having information about
-- process start and end in the trace. In the edge case that we are missing this,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- it best effort returns the last upid.
CREATE PERFETTO FUNCTION _pid_to_upid(
  -- Pid to convert from.
  pid INT,
  -- Timestamp of an event from the |pid|.
  event_ts INT)
-- Returns the converted upid.
RETURNS INT
AS
WITH
  process_lifetime AS (
    SELECT
      pid,
      upid,
      COALESCE(start_ts, trace_start()) AS start_ts,
      COALESCE(end_ts, trace_end()) AS end_ts
    FROM process
  )
SELECT upid
FROM process_lifetime
WHERE pid = $pid AND $event_ts BETWEEN start_ts AND end_ts
ORDER BY upid DESC
LIMIT 1;

-- Translate unfreeze reason from INT to STRING.
-- See: frameworks/proto_logging/stats/atoms.proto
CREATE PERFETTO FUNCTION _translate_unfreeze_reason(reason INT)
RETURNS STRING
AS
SELECT
  CASE
    WHEN $reason = 0 THEN 'none'
    WHEN $reason = 1 THEN 'activity'
    WHEN $reason = 2 THEN 'finish_receiver'
    WHEN $reason = 3 THEN 'start_receiver'
    WHEN $reason = 4 THEN 'bind_service'
    WHEN $reason = 5 THEN 'unbind_service'
    WHEN $reason = 6 THEN 'start_service'
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    WHEN $reason = 7 THEN 'get_provider'
    WHEN $reason = 8 THEN 'remove_provider'
    WHEN $reason = 9 THEN 'ui_visibility'
    WHEN $reason = 10 THEN 'allowlist'
    WHEN $reason = 11 THEN 'process_begin'
    WHEN $reason = 12 THEN 'process_end'
    WHEN $reason = 13 THEN 'trim_memory'
    WHEN $reason = 15 THEN 'ping'
    WHEN $reason = 16 THEN 'file_locks'
    WHEN $reason = 17 THEN 'file_lock_check_failure'
    WHEN $reason = 18 THEN 'binder_txns'
    WHEN $reason = 19 THEN 'feature_flags'
    WHEN $reason = 20 THEN 'short_fgs_timeout'
    WHEN $reason = 21 THEN 'system_init'
    WHEN $reason = 22 THEN 'backup'
    WHEN $reason = 23 THEN 'shell'
    WHEN $reason = 24 THEN 'remove_task'
    WHEN $reason = 25 THEN 'uid_idle'
    WHEN $reason = 26 THEN 'stop_service'
    WHEN $reason = 27 THEN 'executing_service'
    WHEN $reason = 28 THEN 'restriction_change'
    WHEN $reason = 29 THEN 'component_disabled'
    ELSE NULL
  END;

-- All frozen processes and their frozen duration.
CREATE PERFETTO TABLE android_freezer_events (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Upid of frozen process
  upid INT,
  -- Pid of frozen process
  pid INT,
  -- Timestamp process was frozen.
  ts INT,
  -- Duration process was frozen for.
  dur INT,
  -- Unfreeze reason Integer.
  unfreeze_reason_int INT,
  -- Unfreeze reason String.
  unfreeze_reason_str INT
  )
AS
WITH
  freeze AS (
    SELECT ts, _extract_freezer_pid(name) AS pid,
    _pid_to_upid(_extract_freezer_pid(name), ts) AS upid, 'freeze' AS type,
    NULL AS unfreeze_reason
    FROM slice
    WHERE name GLOB 'Freeze *:*'
  ),
  unfreeze AS (
    SELECT ts, _extract_freezer_pid(name) AS pid,
    _pid_to_upid(_extract_freezer_pid(name), ts) AS upid, 'unfreeze' AS type,
    str_split(name, ' ', 2) AS unfreeze_reason
    FROM slice
    WHERE name GLOB 'Unfreeze *:*'
  ),
  merged AS (
    SELECT * FROM freeze
    UNION ALL
    SELECT * FROM unfreeze
  ),
  starts AS (
    SELECT
      type,
      upid,
      pid,
      ts,
      ifnull(lead(ts) OVER (PARTITION BY upid ORDER BY ts), trace_end()) - ts AS dur,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      CAST(lead(unfreeze_reason) OVER (PARTITION BY upid ORDER BY ts) AS INT) AS unfreeze_reason
    FROM merged
  )
SELECT
  upid,
  pid,
  ts,
  dur,
  unfreeze_reason AS unfreeze_reason_int,
  _translate_unfreeze_reason(unfreeze_reason) AS unfreeze_reason_str
FROM starts
WHERE starts.type = 'freeze' AND upid IS NOT NULL;

)_d3l1m1t3r_"
;

const char kAndroidGarbageCollection[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE slices.with_context;

-- Collect all GC slices. There's typically one enclosing slice but sometimes the
-- CompactionPhase is outside the nesting and we need to include that.
CREATE PERFETTO VIEW _gc_slice
AS
WITH concurrent AS (
SELECT
  id AS gc_id,
  name AS gc_name,
  LEAD(name) OVER (PARTITION BY track_id ORDER BY ts) AS compact_name,
  LEAD(dur) OVER (PARTITION BY track_id ORDER BY ts) AS compact_dur,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ts AS gc_ts,
  IIF(dur = -1, trace_end() - slice.ts, slice.dur) AS gc_dur,
  ts,
  dur,
  tid,
  utid,
  pid,
  upid,
  thread_name,
  process_name
FROM thread_slice slice
WHERE depth = 0
) SELECT
  gc_id,
  gc_name,
  ts AS gc_ts,
  ts,
  gc_dur + IIF(
    compact_name = 'CompactionPhase' OR compact_name = 'Background concurrent copying GC',
    compact_dur,
    0) AS gc_dur,
  gc_dur + IIF(
    compact_name = 'CompactionPhase' OR compact_name = 'Background concurrent copying GC',
    compact_dur,
    0) AS dur,
  utid,
  tid,
  upid,
  pid,
  thread_name,
  process_name
FROM concurrent WHERE gc_name GLOB '*concurrent*GC';

-- Extract the heap counter into <ts, dur, upid>
CREATE PERFETTO VIEW _gc_heap_counter
AS
SELECT
  c.ts,
  IFNULL(lead(c.ts) OVER (PARTITION BY track_id ORDER BY c.ts), trace_end()) - ts
    AS dur,
  process.upid,
  CAST(c.value AS INT) AS value
FROM counter c
JOIN process_counter_track t
  ON c.track_id = t.id
INNER JOIN process
  USING (upid)
WHERE
  t.name = 'Heap size (KB)';
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Find the last heap counter after the GC slice dur. This is the best effort to find the
-- final heap size after GC. The algorithm is like so:
-- 1. Merge end_ts of the GC events with the start_ts of the heap counters.
-- 2. Find the heap counter value right after each GC event.
CREATE PERFETTO VIEW _gc_slice_with_final_heap
AS
WITH
  slice_and_heap AS (
    SELECT upid, gc_id, gc_ts + gc_dur AS ts, NULL AS value FROM _gc_slice
    UNION ALL
    SELECT upid, NULL AS gc_id, ts, value FROM _gc_heap_counter
  ),
  next_heap AS (
    SELECT *, lead(value) OVER (PARTITION BY upid ORDER BY ts) AS last_value FROM slice_and_heap
  ),
  slice_with_last_heap AS (
    SELECT * FROM next_heap WHERE gc_id IS NOT NULL
  )
  SELECT _gc_slice.*, last_value FROM _gc_slice LEFT JOIN slice_with_last_heap USING (gc_id);

-- Span join with all the other heap counters to find the overall min and max heap size.
CREATE VIRTUAL TABLE _gc_slice_heap_sp
USING
  SPAN_JOIN(_gc_slice_with_final_heap PARTITIONED upid, _gc_heap_counter PARTITIONED upid);
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Aggregate the min and max heap across the GC event, taking into account the last heap size
-- derived earlier.
CREATE PERFETTO TABLE _gc_slice_heap
AS
SELECT
  *,
  CASE
    WHEN gc_name GLOB '*young*' THEN 'young'
    WHEN gc_name GLOB '*NativeAlloc*' THEN 'native_alloc'
    WHEN gc_name GLOB '*Alloc*' THEN 'alloc'
    WHEN gc_name GLOB '*CollectorTransition*' THEN 'collector_transition'
    WHEN gc_name GLOB '*Explicit*' THEN 'explicit'
    ELSE 'full'
    END AS gc_type,
  IIF(gc_name GLOB '*mark compact*', 1, 0) AS is_mark_compact,
  MAX(MAX(value, last_value))/1e3 AS max_heap_mb,
  MIN(MIN(value, last_value))/1e3 AS min_heap_mb
FROM _gc_slice_heap_sp
GROUP BY gc_id;

-- Span join GC events with thread states to breakdown the time spent.
CREATE VIRTUAL TABLE _gc_slice_heap_thread_state_sp
USING
  SPAN_JOIN(thread_state PARTITIONED utid, _gc_slice_heap PARTITIONED utid);

-- All Garbage collection events with a breakdown of the time spent and heap reclaimed.
CREATE PERFETTO TABLE android_garbage_collection_events (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Tid of thread running garbage collection.
  tid INT,
  -- Pid of process running garbage collection.
  pid INT,
  -- Utid of thread running garbage collection.
  utid INT,
  -- Upid of process running garbage collection.
  upid INT,
  -- Name of thread running garbage collection.
  thread_name INT,
  -- Name of process running garbage collection.
  process_name INT,
  -- Type of garbage collection.
  gc_type STRING,
  -- Whether gargage collection is mark compact or copying.
  is_mark_compact INT,
  -- MB reclaimed after garbage collection.
  reclaimed_mb INT,
  -- Minimum heap size in MB during garbage collection.
  min_heap_mb INT,
  -- Maximum heap size in MB during garbage collection.
  max_heap_mb INT,
  -- Garbage collection id.
  gc_id INT,
  -- Garbage collection timestamp.
  gc_ts INT,
  -- Garbage collection wall duration.
  gc_dur INT,
  -- Garbage collection duration spent executing on CPU.
  gc_running_dur INT,
  -- Garbage collection duration spent waiting for CPU.
  gc_runnable_dur INT,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Garbage collection duration spent waiting in the Linux kernel on IO.
  gc_unint_io_dur INT,
  -- Garbage collection duration spent waiting in the Linux kernel without IO.
  gc_unint_non_io_dur INT,
    -- Garbage collection duration spent waiting in interruptible sleep.
  gc_int_dur INT
  )
AS
WITH
  agg_events AS (
    SELECT
      tid,
      pid,
      utid,
      upid,
      thread_name,
      process_name,
      gc_type,
      is_mark_compact,
      gc_id,
      gc_ts,
      gc_dur,
      SUM(dur) AS dur,
      max_heap_mb - min_heap_mb AS reclaimed_mb,
      min_heap_mb,
      max_heap_mb,
      state,
      io_wait
    FROM _gc_slice_heap_thread_state_sp
    GROUP BY gc_id, state, io_wait
  )
SELECT
  tid,
  pid,
  utid,
  upid,
  thread_name,
  process_name,
  gc_type,
  is_mark_compact,
  reclaimed_mb,
  min_heap_mb,
  max_heap_mb,
  gc_id,
  gc_ts,
  gc_dur,
  SUM(IIF(state = 'Running', dur, 0)) AS gc_running_dur,
  SUM(IIF(state = 'R' OR state = 'R+', dur, 0)) AS gc_runnable_dur,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  SUM(IIF(state = 'D' AND io_wait = 1, dur, 0)) AS gc_unint_io_dur,
  SUM(IIF(state = 'D' AND io_wait != 1, dur, 0)) AS gc_unint_non_io_dur,
  SUM(IIF(state = 'S', dur, 0)) AS gc_int_dur
FROM agg_events
GROUP BY gc_id;

)_d3l1m1t3r_"
;

const char kAndroidInput[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

CREATE PERFETTO TABLE _input_message_sent
AS
SELECT
  STR_SPLIT(STR_SPLIT(slice.name, '=', 3), ')', 0) AS event_type,
  STR_SPLIT(STR_SPLIT(slice.name, '=', 2), ',', 0) AS event_seq,
  STR_SPLIT(STR_SPLIT(slice.name, '=', 1), ',', 0) AS event_channel,
  thread.tid,
  thread.name AS thread_name,
  process.pid,
  process.name AS process_name,
  slice.ts,
  slice.dur,
  slice.track_id
FROM slice
)_d3l1m1t3r_"
R"_d3l1m1t3r_(JOIN thread_track
  ON thread_track.id = slice.track_id
JOIN thread
  USING (utid)
JOIN process
  USING (upid)
WHERE slice.name GLOB 'sendMessage(*';

CREATE PERFETTO TABLE _input_message_received
AS
SELECT
  STR_SPLIT(STR_SPLIT(slice.name, '=', 3), ')', 0) AS event_type,
  STR_SPLIT(STR_SPLIT(slice.name, '=', 2), ',', 0) AS event_seq,
  STR_SPLIT(STR_SPLIT(slice.name, '=', 1), ',', 0) AS event_channel,
  thread.tid,
  thread.name AS thread_name,
  process.pid,
  process.name AS process_name,
  slice.ts,
  slice.dur,
  slice.track_id
FROM slice
JOIN thread_track
  ON thread_track.id = slice.track_id
JOIN thread
  USING (utid)
JOIN process
  USING (upid)
WHERE slice.name GLOB 'receiveMessage(*';

-- All input events with round trip latency breakdown. Input delivery is socket based and every
-- input event sent from the OS needs to be ACK'ed by the app. This gives us 4 subevents to measure
-- latencies between:
-- 1. Input dispatch event sent from OS.
-- 2. Input dispatch event received in app.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- 3. Input ACK event sent from app.
-- 4. Input ACk event received in OS.
CREATE PERFETTO TABLE android_input_events (
  -- Duration from input dispatch to input received.
  dispatch_latency_dur INT,
  -- Duration from input received to input ACK sent.
  handling_latency_dur INT,
  -- Duration from input ACK sent to input ACK recieved.
  ack_latency_dur INT,
  -- Duration from input dispatch to input event ACK received.
  total_latency_dur INT,
  -- Tid of thread receiving the input event.
  tid INT,
  -- Name of thread receiving the input event.
  thread_name INT,
  -- Pid of process receiving the input event.
  pid INT,
  -- Name of process receiving the input event.
  process_name INT,
  -- Input event type. See InputTransport.h: InputMessage#Type
  event_type INT,
  -- Input event sequence number, monotonically increasing for an event channel and pid.
  event_seq INT,
  -- Input event channel name.
  event_channel INT,
  -- Thread track id of input event dispatching thread.
  dispatch_track_id INT,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Timestamp input event was dispatched.
  dispatch_ts INT,
  -- Duration of input event dispatch.
  dispatch_dur INT,
  -- Thread track id of input event receiving thread.
  receive_track_id INT,
  -- Timestamp input event was received.
  receive_ts INT,
  -- Duration of input event receipt.
  receive_dur INT
  )
AS
SELECT
  receive.ts - dispatch.ts AS dispatch_latency_dur,
  finish.ts - receive.ts AS handling_latency_dur,
  finish_ack.ts - finish.ts AS ack_latency_dur,
  finish_ack.ts - dispatch.ts AS total_latency_dur,
  finish.tid AS tid,
  finish.thread_name AS thread_name,
  finish.pid AS pid,
  finish.process_name AS process_name,
  dispatch.event_type,
  dispatch.event_seq,
  dispatch.event_channel,
  dispatch.track_id AS dispatch_track_id,
  dispatch.ts AS dispatch_ts,
  dispatch.dur AS dispatch_dur,
  receive.ts AS receive_ts,
  receive.dur AS receive_dur,
  receive.track_id AS receive_track_id
FROM (SELECT * FROM _input_message_sent WHERE thread_name = 'InputDispatcher') dispatch
)_d3l1m1t3r_"
R"_d3l1m1t3r_(JOIN (SELECT * FROM _input_message_received WHERE event_type != '0x2') receive
  ON
    REPLACE(receive.event_channel, '(client)', '(server)') = dispatch.event_channel
    AND dispatch.event_seq = receive.event_seq
JOIN (SELECT * FROM _input_message_sent WHERE thread_name != 'InputDispatcher') finish
  ON
    REPLACE(finish.event_channel, '(client)', '(server)') = dispatch.event_channel
    AND dispatch.event_seq = finish.event_seq
JOIN (SELECT * FROM _input_message_received WHERE event_type = '0x2') finish_ack
  ON finish_ack.event_channel = dispatch.event_channel AND dispatch.event_seq = finish_ack.event_seq;

-- Key events processed by the Android framework (from android.input.inputevent data source).
CREATE PERFETTO VIEW android_key_events(
  -- ID of the trace entry
  id INT,
  -- The randomly-generated ID associated with each input event processed
  -- by Android Framework, used to track the event through the input pipeline
  event_id INT,
  -- The timestamp of when the input event was processed by the system
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ts INT,
  -- Details of the input event parsed from the proto message
  arg_set_id INT
) AS
SELECT
  id,
  event_id,
  ts,
  arg_set_id
FROM __intrinsic_android_key_events;

-- Motion events processed by the Android framework (from android.input.inputevent data source).
CREATE PERFETTO VIEW android_motion_events(
  -- ID of the trace entry
  id INT,
  -- The randomly-generated ID associated with each input event processed
  -- by Android Framework, used to track the event through the input pipeline
  event_id INT,
  -- The timestamp of when the input event was processed by the system
  ts INT,
  -- Details of the input event parsed from the proto message
  arg_set_id INT
) AS
SELECT
  id,
  event_id,
  ts,
  arg_set_id
FROM __intrinsic_android_motion_events;

-- Input event dispatching information in Android (from android.input.inputevent data source).
CREATE PERFETTO VIEW android_input_event_dispatch(
  -- ID of the trace entry
  id INT,
  -- Event ID of the input event that was dispatched
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  event_id INT,
  -- Extra args parsed from the proto message
  arg_set_id INT,
  -- Vsync ID that identifies the state of the windows during which the dispatch decision was made
  vsync_id INT,
  -- Window ID of the window receiving the event
  window_id INT
) AS
SELECT
  id,
  event_id,
  arg_set_id,
  vsync_id,
  window_id
FROM __intrinsic_android_input_event_dispatch;

)_d3l1m1t3r_"
;

const char kAndroidIo[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- TODO(b/329344794): Rewrite to fetch data from other tables than `raw`.

-- Aggregates f2fs IO and latency stats by counter name.
CREATE PERFETTO VIEW _android_io_f2fs_counter_stats(
  -- Counter name on which all the other values are aggregated on.
  name STRING,
  -- Sum of all counter values for the counter name.
  sum INT,
  -- Max of all counter values for the counter name.
  max INT,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Min of all counter values for the counter name.
  min INT,
  -- Duration between the first and last counter value for the counter name.
  dur INT,
  -- Count of all the counter values for the counter name.
  count INT,
  -- Avergate of all the counter values for the counter name.
  avg DOUBLE
) AS
SELECT
  STR_SPLIT(counter_track.name, '].', 1) AS name,
  SUM(counter.value) AS sum,
  MAX(counter.value) AS max,
  MIN(counter.value) AS min,
  MAX(ts) - MIN(ts) AS dur,
  COUNT(ts) AS count,
  AVG(counter.value) AS avg
FROM counter
JOIN counter_track
  ON counter_track.id = counter.track_id AND counter_track.name GLOB '*f2fs*'
GROUP BY name
ORDER BY sum DESC;

-- Aggregates f2fs_write stats by inode and thread.
CREATE PERFETTO VIEW _android_io_f2fs_write_stats(
  -- Utid of the thread.
  utid INT,
  -- Tid of the thread.
  tid INT,
  -- Name of the thread.
  thread_name STRING,
  -- Upid of the process.
  upid INT,
  -- Pid of the process.
  pid INT,
  -- Name of the thread.
  process_name STRING,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Inode number of the file being written.
  ino INT,
  -- Device node number of the file being written.
  dev INT,
  -- Total number of bytes written on this file by the |utid|.
  bytes BYTES,
  -- Total count of write requests for this file.
  write_count INT
) AS
WITH
  f2fs_write_end AS (
    SELECT
      *,
      EXTRACT_ARG(arg_set_id, 'len') AS len,
      EXTRACT_ARG(arg_set_id, 'dev') AS dev,
      EXTRACT_ARG(arg_set_id, 'ino') AS ino,
      EXTRACT_ARG(arg_set_id, 'copied') AS copied
    FROM raw
    WHERE name GLOB 'f2fs_write_end*'
  )
SELECT
  thread.utid,
  thread.tid,
  thread.name AS thread_name,
  process.upid,
  process.pid,
  process.name AS process_name,
  f.ino,
  f.dev,
  SUM(copied) AS bytes,
  COUNT(len) AS write_count
FROM f2fs_write_end f
JOIN thread
  USING (utid)
JOIN process
  USING (upid)
GROUP BY utid, ino, dev
ORDER BY bytes DESC;

-- Aggregates f2fs write stats. Counts distinct datapoints, total write operations,
-- and bytes written
CREATE PERFETTO VIEW _android_io_f2fs_aggregate_write_stats(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Total number of writes in the trace.
  total_write_count INT,
  -- Number of distinct processes.
  distinct_processes INT,
  -- Total number of bytes written.
  total_bytes_written INT,
  -- Count of distinct devices written to.
  distinct_device_count INT,
  -- Count of distinct inodes written to.
  distinct_inode_count INT,
  -- Count of distinct threads writing.
  distinct_thread_count INT
) AS
select SUM(write_count) as total_write_count,
      COUNT(DISTINCT pid) distinct_processes,
      SUM(bytes) as total_bytes_written,
      COUNT(DISTINCT dev) as distinct_device_count,
      COUNT(DISTINCT ino) distinct_inode_count,
      COUNT(DISTINCT tid) distinct_thread_count
from _android_io_f2fs_write_stats;
)_d3l1m1t3r_"
;

const char kAndroidJobScheduler[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- All scheduled jobs and their latencies.
CREATE PERFETTO TABLE android_job_scheduler_events (
  -- Id of the scheduled job assigned by the app developer.
  job_id INT,
  -- Uid of the process running the scheduled job.
  uid INT,
  -- Package name of the process running the scheduled job.
  package_name STRING,
  -- Service component name of the scheduled job.
  job_service_name STRING,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Thread track id of the job scheduler event slice.
  track_id INT,
  -- Slice id of the job scheduler event slice.
  id INT,
  -- Timestamp the job was scheduled.
  ts INT,
  -- Duration of the scheduled job.
  dur INT
  ) AS
SELECT
  CAST(STR_SPLIT(slice.name, '#', 1) AS INT) AS job_id,
  CAST(STR_SPLIT(STR_SPLIT(slice.name, '<', 1), '>', 0) AS INT) AS uid,
  STR_SPLIT(STR_SPLIT(slice.name, '>', 1), '/', 0) AS package_name,
  STR_SPLIT(STR_SPLIT(slice.name, '/', 1), '#', 0) AS job_service_name,
  track_id,
  slice.id,
  slice.ts,
  IIF(slice.dur = -1, trace_end() - slice.ts, slice.dur) AS dur
FROM
  slice
JOIN process_track
  ON slice.track_id = process_track.id
JOIN process
  ON process.upid = process_track.upid
WHERE
  process.name = 'system_server'
  AND slice.name GLOB '*job*'
  AND process_track.name = 'JobScheduler';

)_d3l1m1t3r_"
;

const char kAndroidMonitorContention[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE android.suspend;

-- Extracts the blocking thread from a slice name
CREATE PERFETTO FUNCTION android_extract_android_monitor_contention_blocking_thread(
  -- Name of slice
  slice_name STRING
)
-- Blocking thread
RETURNS STRING AS
SELECT STR_SPLIT(STR_SPLIT($slice_name, "with owner ", 1), " (", 0);

-- Extracts the blocking thread tid from a slice name
CREATE PERFETTO FUNCTION android_extract_android_monitor_contention_blocking_tid(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Name of slice
  slice_name STRING
)
-- Blocking thread tid
RETURNS INT AS
SELECT CAST(STR_SPLIT(STR_SPLIT($slice_name, " (", 1), ")", 0) AS INT);

-- Extracts the blocking method from a slice name
CREATE PERFETTO FUNCTION android_extract_android_monitor_contention_blocking_method(
  -- Name of slice
  slice_name STRING
)
-- Blocking thread
RETURNS STRING AS
SELECT STR_SPLIT(STR_SPLIT($slice_name, ") at ", 1), "(", 0)
    || "("
    || STR_SPLIT(STR_SPLIT($slice_name, ") at ", 1), "(", 1);

-- Extracts a shortened form of the blocking method name from a slice name.
-- The shortened form discards the parameter and return
-- types.
CREATE PERFETTO FUNCTION android_extract_android_monitor_contention_short_blocking_method(
  -- Name of slice
  slice_name STRING
)
-- Blocking thread
RETURNS STRING AS
SELECT
    STR_SPLIT(STR_SPLIT(android_extract_android_monitor_contention_blocking_method($slice_name), " ", 1), "(", 0);

-- Extracts the monitor contention blocked method from a slice name
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO FUNCTION android_extract_android_monitor_contention_blocked_method(
  -- Name of slice
  slice_name STRING
)
-- Blocking thread
RETURNS STRING AS
SELECT STR_SPLIT(STR_SPLIT($slice_name, "blocking from ", 1), "(", 0)
    || "("
    || STR_SPLIT(STR_SPLIT($slice_name, "blocking from ", 1), "(", 1);

-- Extracts a shortened form of the monitor contention blocked method name
-- from a slice name. The shortened form discards the parameter and return
-- types.
CREATE PERFETTO FUNCTION android_extract_android_monitor_contention_short_blocked_method(
  -- Name of slice
  slice_name STRING
)
-- Blocking thread
RETURNS STRING AS
SELECT
    STR_SPLIT(STR_SPLIT(android_extract_android_monitor_contention_blocked_method($slice_name), " ", 1), "(", 0);

-- Extracts the number of waiters on the monitor from a slice name
CREATE PERFETTO FUNCTION android_extract_android_monitor_contention_waiter_count(
  -- Name of slice
  slice_name STRING
)
-- Count of waiters on the lock
RETURNS INT AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT CAST(STR_SPLIT(STR_SPLIT($slice_name, "waiters=", 1), " ", 0) AS INT);

-- Extracts the monitor contention blocking source location from a slice name
CREATE PERFETTO FUNCTION android_extract_android_monitor_contention_blocking_src(
  -- Name of slice
  slice_name STRING
)
-- Blocking thread
RETURNS STRING AS
SELECT STR_SPLIT(STR_SPLIT($slice_name, ")(", 1), ")", 0);

-- Extracts the monitor contention blocked source location from a slice name
CREATE PERFETTO FUNCTION android_extract_android_monitor_contention_blocked_src(
  -- Name of slice
  slice_name STRING
)
-- Blocking thread
RETURNS STRING AS
SELECT STR_SPLIT(STR_SPLIT($slice_name, ")(", 2), ")", 0);

CREATE PERFETTO TABLE _valid_android_monitor_contention AS
SELECT slice.id AS id
FROM slice
LEFT JOIN slice child
  ON child.parent_id = slice.id
LEFT JOIN slice grand_child
  ON grand_child.parent_id = child.id
WHERE
  slice.name GLOB 'monitor contention*'
  AND (child.name GLOB 'Lock contention*' OR child.name IS NULL)
  AND (grand_child.name IS NULL)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(GROUP BY slice.id;

-- Contains parsed monitor contention slices.
--
-- @column blocking_method Name of the method holding the lock.
-- @column blocked_methhod Name of the method trying to acquire the lock.
-- @column short_blocking_method Blocking_method without arguments and return types.
-- @column short_blocked_method Blocked_method without arguments and return types.
-- @column blocking_src File location of blocking_method in form <filename:linenumber>.
-- @column blocked_src File location of blocked_method in form <filename:linenumber>.
-- @column waiter_count Zero indexed number of threads trying to acquire the lock.
-- @column blocking_utid Utid of thread holding the lock.
-- @column blocking_thread_name Thread name of thread holding the lock.
-- @column upid Upid of process experiencing lock contention.
-- @column process_name Process name of process experiencing lock contention.
-- @column id Slice id of lock contention.
-- @column ts Timestamp of lock contention start.
-- @column dur Wall clock duration of lock contention.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column monotonic_dur Monotonic clock duration of lock contention.
-- @column track_id Thread track id of blocked thread.
-- @column is_blocked_main_thread Whether the blocked thread is the main thread.
-- @column is_blocking_main_thread Whether the blocking thread is the main thread.
-- @column binder_reply_id Slice id of binder reply slice if lock contention was part of a binder txn.
-- @column binder_reply_ts Timestamp of binder reply slice if lock contention was part of a binder txn.
-- @column binder_reply_tid Tid of binder reply slice if lock contention was part of a binder txn.
CREATE TABLE android_monitor_contention AS
SELECT
  android_extract_android_monitor_contention_blocking_method(slice.name) AS blocking_method,
  android_extract_android_monitor_contention_blocked_method(slice.name)  AS blocked_method,
  android_extract_android_monitor_contention_short_blocking_method(slice.name) AS short_blocking_method,
  android_extract_android_monitor_contention_short_blocked_method(slice.name)  AS short_blocked_method,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  android_extract_android_monitor_contention_blocking_src(slice.name) AS blocking_src,
  android_extract_android_monitor_contention_blocked_src(slice.name) AS blocked_src,
  android_extract_android_monitor_contention_waiter_count(slice.name) AS waiter_count,
  thread.utid AS blocked_utid,
  thread.name AS blocked_thread_name,
  blocking_thread.utid AS blocking_utid,
  android_extract_android_monitor_contention_blocking_thread(slice.name) AS blocking_thread_name,
  android_extract_android_monitor_contention_blocking_tid(slice.name) AS blocking_tid,
  thread.upid AS upid,
  process.name AS process_name,
  slice.id,
  slice.ts,
  slice.dur,
  _extract_duration_without_suspend(slice.ts, slice.dur) AS monotonic_dur,
  slice.track_id,
  thread.is_main_thread AS is_blocked_thread_main,
  thread.tid AS blocked_thread_tid,
  blocking_thread.is_main_thread AS is_blocking_thread_main,
  blocking_thread.tid AS blocking_thread_tid,
  binder_reply.id AS binder_reply_id,
  binder_reply.ts AS binder_reply_ts,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  binder_reply_thread.tid AS binder_reply_tid,
  process.pid
FROM slice
JOIN thread_track
  ON thread_track.id = slice.track_id
LEFT JOIN thread
  USING (utid)
LEFT JOIN process
  USING (upid)
LEFT JOIN ANCESTOR_SLICE(slice.id) binder_reply ON binder_reply.name = 'binder reply'
LEFT JOIN thread_track binder_reply_thread_track ON binder_reply.track_id = binder_reply_thread_track.id
LEFT JOIN thread binder_reply_thread ON binder_reply_thread_track.utid = binder_reply_thread.utid
-- Before Android U, we didn't have blocking_thread tid (aosp/3000578). We do a LEFT JOIN instead
-- of JOIN so that on older devices we can at least capture the list of contentions without edges.
LEFT JOIN thread blocking_thread ON blocking_thread.tid = blocking_tid AND blocking_thread.upid = thread.upid
JOIN _valid_android_monitor_contention ON _valid_android_monitor_contention.id = slice.id
WHERE slice.name GLOB 'monitor contention*'
  AND slice.dur != -1
  AND short_blocking_method IS NOT NULL
  AND short_blocked_method IS NOT NULL
)_d3l1m1t3r_"
R"_d3l1m1t3r_(GROUP BY slice.id;

CREATE INDEX _android_monitor_contention_blocking_utid_idx
  ON android_monitor_contention (blocking_utid, ts);

CREATE INDEX _android_monitor_contention_id_idx
  ON android_monitor_contention (id);

-- Monitor contention slices that are blocked by another monitor contention slice.
-- They will have a |parent_id| field which is the id of the slice they are blocked by.
CREATE PERFETTO TABLE _children AS
SELECT parent.id AS parent_id, child.* FROM android_monitor_contention child
JOIN android_monitor_contention parent ON parent.blocked_utid = child.blocking_utid
AND child.ts BETWEEN parent.ts AND parent.ts + parent.dur;

-- Monitor contention slices that are blocking another monitor contention slice.
-- They will have a |child_id| field which is the id of the slice they are blocking.
CREATE PERFETTO TABLE _parents AS
SELECT parent.*, child.id AS child_id FROM android_monitor_contention parent
JOIN android_monitor_contention child ON parent.blocked_utid = child.blocking_utid
)_d3l1m1t3r_"
R"_d3l1m1t3r_(AND child.ts BETWEEN parent.ts AND parent.ts + parent.dur;

-- Monitor contention slices that are neither blocking nor blocked by another monitor contention
-- slice. They neither have |parent_id| nor |child_id| fields.
CREATE TABLE _isolated AS
WITH parents_and_children AS (
 SELECT id FROM _children
 UNION ALL
 SELECT id FROM _parents
), isolated AS (
    SELECT id FROM android_monitor_contention
    EXCEPT
    SELECT id FROM parents_and_children
  )
SELECT * FROM android_monitor_contention JOIN isolated USING (id);

-- Contains parsed monitor contention slices with the parent-child relationships.
--
-- @column parent_id Id of monitor contention slice blocking this contention.
-- @column blocking_method Name of the method holding the lock.
-- @column blocked_methhod Name of the method trying to acquire the lock.
-- @column short_blocking_method Blocking_method without arguments and return types.
-- @column short_blocked_method Blocked_method without arguments and return types.
-- @column blocking_src File location of blocking_method in form <filename:linenumber>.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column blocked_src File location of blocked_method in form <filename:linenumber>.
-- @column waiter_count Zero indexed number of threads trying to acquire the lock.
-- @column blocking_utid Utid of thread holding the lock.
-- @column blocking_thread_name Thread name of thread holding the lock.
-- @column upid Upid of process experiencing lock contention.
-- @column process_name Process name of process experiencing lock contention.
-- @column id Slice id of lock contention.
-- @column ts Timestamp of lock contention start.
-- @column dur Wall clock duration of lock contention.
-- @column monotonic_dur Monotonic clock duration of lock contention.
-- @column track_id Thread track id of blocked thread.
-- @column is_blocked_main_thread Whether the blocked thread is the main thread.
-- @column is_blocking_main_thread Whether the blocking thread is the main thread.
-- @column binder_reply_id Slice id of binder reply slice if lock contention was part of a binder txn.
-- @column binder_reply_ts Timestamp of binder reply slice if lock contention was part of a binder txn.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column binder_reply_tid Tid of binder reply slice if lock contention was part of a binder txn.
-- @column child_id Id of monitor contention slice blocked by this contention.
CREATE TABLE android_monitor_contention_chain AS
SELECT NULL AS parent_id, *, NULL AS child_id FROM _isolated
UNION ALL
SELECT c.*, p.child_id FROM _children c
LEFT JOIN _parents p USING(id)
UNION
SELECT c.parent_id, p.* FROM _parents p
LEFT JOIN _children c USING(id);

CREATE INDEX _android_monitor_contention_chain_idx
  ON android_monitor_contention_chain (blocking_method, blocking_utid, ts);

-- First blocked node on a lock, i.e nodes with |waiter_count| = 0. The |dur| here is adjusted
-- to only account for the time between the first thread waiting and the first thread to acquire
-- the lock. That way, the thread state span joins below only compute the thread states where
-- the blocking thread is actually holding the lock. This avoids counting the time when another
-- waiter acquired the lock before the first waiter.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO VIEW _first_blocked_contention
  AS
SELECT start.id, start.blocking_utid, start.ts, MIN(end.ts + end.dur) - start.ts AS dur
FROM android_monitor_contention_chain start
JOIN android_monitor_contention_chain end
  ON
    start.blocking_utid = end.blocking_utid
    AND start.blocking_method = end.blocking_method
    AND end.ts BETWEEN start.ts AND start.ts + start.dur
WHERE start.waiter_count = 0
GROUP BY start.id;

CREATE PERFETTO VIEW _blocking_thread_state
AS
SELECT utid AS blocking_utid, ts, dur, state, blocked_function
FROM thread_state;

-- Contains the span join of the first waiters in the |android_monitor_contention_chain| with their
-- blocking_thread thread state.

-- Note that we only span join the duration where the lock was actually held and contended.
-- This can be less than the duration the lock was 'waited on' when a different waiter acquired the
-- lock earlier than the first waiter.
--
-- @column parent_id Id of slice blocking the blocking_thread.
-- @column blocking_method Name of the method holding the lock.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column blocked_methhod Name of the method trying to acquire the lock.
-- @column short_blocking_method Blocking_method without arguments and return types.
-- @column short_blocked_method Blocked_method without arguments and return types.
-- @column blocking_src File location of blocking_method in form <filename:linenumber>.
-- @column blocked_src File location of blocked_method in form <filename:linenumber>.
-- @column waiter_count Zero indexed number of threads trying to acquire the lock.
-- @column blocking_utid Utid of thread holding the lock.
-- @column blocking_thread_name Thread name of thread holding the lock.
-- @column upid Upid of process experiencing lock contention.
-- @column process_name Process name of process experiencing lock contention.
-- @column id Slice id of lock contention.
-- @column ts Timestamp of lock contention start.
-- @column dur Wall clock duration of lock contention.
-- @column monotonic_dur Monotonic clock duration of lock contention.
-- @column track_id Thread track id of blocked thread.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column is_blocked_main_thread Whether the blocked thread is the main thread.
-- @column is_blocking_main_thread Whether the blocking thread is the main thread.
-- @column binder_reply_id Slice id of binder reply slice if lock contention was part of a binder txn.
-- @column binder_reply_ts Timestamp of binder reply slice if lock contention was part of a binder txn.
-- @column binder_reply_tid Tid of binder reply slice if lock contention was part of a binder txn.
-- @column blocking_utid Utid of the blocking |thread_state|.
-- @column ts Timestamp of the blocking |thread_state|.
-- @column state Thread state of the blocking thread.
-- @column blocked_function Blocked kernel function of the blocking thread.
CREATE VIRTUAL TABLE android_monitor_contention_chain_thread_state
USING
  SPAN_JOIN(_first_blocked_contention PARTITIONED blocking_utid,
            _blocking_thread_state PARTITIONED blocking_utid);

-- Aggregated thread_states on the 'blocking thread', the thread holding the lock.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- This builds on the data from |android_monitor_contention_chain| and
-- for each contention slice, it returns the aggregated sum of all the thread states on the
-- blocking thread.
--
-- Note that this data is only available for the first waiter on a lock.
--
CREATE PERFETTO VIEW android_monitor_contention_chain_thread_state_by_txn(
  -- Slice id of the monitor contention.
  id INT,
  -- A |thread_state| that occurred in the blocking thread during the contention.
  thread_state STRING,
  -- Total time the blocking thread spent in the |thread_state| during contention.
  thread_state_dur INT,
  -- Count of all times the blocking thread entered |thread_state| during the contention.
  thread_state_count INT
) AS
SELECT
  id,
  state AS thread_state,
  SUM(dur) AS thread_state_dur,
  COUNT(dur) AS thread_state_count
FROM android_monitor_contention_chain_thread_state
GROUP BY id, thread_state;

-- Aggregated blocked_functions on the 'blocking thread', the thread holding the lock.
-- This builds on the data from |android_monitor_contention_chain| and
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- for each contention, it returns the aggregated sum of all the kernel
-- blocked function durations on the blocking thread.
--
-- Note that this data is only available for the first waiter on a lock.
CREATE PERFETTO VIEW android_monitor_contention_chain_blocked_functions_by_txn(
  -- Slice id of the monitor contention.
  id INT,
  -- Blocked kernel function in a thread state in the blocking thread during the contention.
  blocked_function STRING,
  -- Total time the blocking thread spent in the |blocked_function| during the contention.
  blocked_function_dur INT,
  -- Count of all times the blocking thread executed the |blocked_function| during the contention.
  blocked_function_count INT
) AS
SELECT
  id,
  blocked_function,
  SUM(dur) AS blocked_function_dur,
  COUNT(dur) AS blocked_function_count
FROM android_monitor_contention_chain_thread_state
WHERE blocked_function IS NOT NULL
GROUP BY id, blocked_function;

-- Returns a DAG of all Java lock contentions in a process.
-- Each node in the graph is a <thread:Java method> pair.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- Each edge connects from a node waiting on a lock to a node holding a lock.
-- The weights of each node represent the cumulative wall time the node blocked
-- other nodes connected to it.
CREATE PERFETTO FUNCTION android_monitor_contention_graph(
  -- Upid of process to generate a lock graph for.
  upid INT)
RETURNS TABLE(
  -- Pprof of lock graph.
  pprof BYTES) AS
WITH contention_chain AS (
SELECT *,
       IIF(blocked_thread_name GLOB 'binder:*', 'binder', blocked_thread_name)
        AS blocked_thread_name_norm,
       IIF(blocking_thread_name GLOB 'binder:*', 'binder', blocking_thread_name)
        AS blocking_thread_name_norm
FROM android_monitor_contention_chain WHERE upid = $upid
GROUP BY id, parent_id
), graph AS (
SELECT
  id,
  dur,
  CAT_STACKS(blocked_thread_name_norm || ':' || short_blocked_method,
    blocking_thread_name_norm || ':' || short_blocking_method) AS stack
FROM contention_chain
WHERE parent_id IS NULL
UNION ALL
SELECT
c.id,
c.dur AS dur,
  CAT_STACKS(blocked_thread_name_norm || ':' || short_blocked_method,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(             blocking_thread_name_norm || ':' || short_blocking_method, stack) AS stack
FROM contention_chain c, graph AS p
WHERE p.id = c.parent_id
) SELECT EXPERIMENTAL_PROFILE(stack, 'duration', 'ns', dur) AS pprof
  FROM graph;

)_d3l1m1t3r_"
;

const char kAndroidNetworkPackets[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Android network packet events (from android.network_packets data source).
CREATE PERFETTO VIEW android_network_packets(
  -- Timestamp in nanoseconds.
  ts INT,
  -- Duration (non-zero only in aggregate events)
  dur INT,
  -- The track name (interface and direction)
  track_name STRING,
  -- Traffic package source (or uid=$X if not found)
  package_name STRING,
  -- Traffic interface name (linux interface name)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  iface STRING,
  -- Traffic direction ('Transmitted' or 'Received')
  direction STRING,
  -- Number of packets in this event
  packet_count INT,
  -- Number of bytes in this event (wire size)
  packet_length INT,
  -- Transport used for traffic in this event
  packet_transport STRING,
  -- TCP flags used by tcp frames in this event
  packet_tcp_flags INT,
  -- The Android traffic tag of the network socket
  socket_tag STRING,
  -- The Linux user id of the network socket
  socket_uid INT,
  -- The local port number (for udp or tcp only)
  local_port INT,
  -- The remote port number (for udp or tcp only)
  remote_port INT,
  -- 1-byte ICMP type identifier.
  packet_icmp_type INT,
  -- 1-byte ICMP code identifier.
  packet_icmp_code INT,
  -- Packet's tcp flags bitmask (e.g. FIN=0x1, SYN=0x2).
  packet_tcp_flags_int INT,
  -- Packet's socket tag as an integer.
  socket_tag_int INT
) AS
SELECT
  ts,
  dur,
  category AS track_name,
  name AS package_name,
  iface,
  direction,
  packet_count,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  packet_length,
  packet_transport,
  -- For backwards compatibility, the _str suffixed flags (which the ui shows)
  -- are exposed without suffix, and the integer fields get suffix instead.
  packet_tcp_flags_str AS packet_tcp_flags,
  packet_tcp_flags AS packet_tcp_flags_int,
  socket_tag_str AS socket_tag,
  socket_tag AS socket_tag_int,
  socket_uid,
  local_port,
  remote_port,
  packet_icmp_type,
  packet_icmp_code
FROM __intrinsic_android_network_packets;

)_d3l1m1t3r_"
;

const char kAndroidOomAdjuster[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE slices.with_context;
INCLUDE PERFETTO MODULE counters.intervals;

-- Converts an oom_adj score Integer to String sample name.
-- One of: cached, background, job, foreground_service, bfgs, foreground and
-- system.
CREATE PERFETTO FUNCTION android_oom_adj_score_to_bucket_name(
  -- `oom_score` value
  oom_score INT
)
-- Returns the sample bucket based on the oom score.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(RETURNS STRING
AS
SELECT
  CASE
    WHEN $oom_score >= 900 THEN 'cached'
    WHEN $oom_score BETWEEN 250 AND 900 THEN 'background'
    WHEN $oom_score BETWEEN 201 AND 250 THEN 'job'
    WHEN $oom_score = 200 THEN 'foreground_service'
    WHEN $oom_score BETWEEN 100 AND 200 THEN 'bfgs'
    WHEN $oom_score BETWEEN 0 AND 100 THEN 'foreground'
    WHEN $oom_score < 0 THEN 'system'
END;

-- Converts an oom_adj score Integer to String bucket name.
-- Deprecated: use `android_oom_adj_score_to_bucket_name` instead.
CREATE PERFETTO FUNCTION android_oom_adj_score_to_detailed_bucket_name(
  -- oom_adj score.
  value INT,
  -- android_app id of the process.
  android_appid INT)
-- Returns the oom_adj bucket.
RETURNS STRING
AS
SELECT
  CASE
    WHEN $value = -1000 THEN 'native'
    WHEN $value = -900 THEN 'system'
    WHEN $value = -800 THEN 'persistent_proc'
    WHEN $value = -700 THEN 'persistent_service'
    WHEN $value = -600 THEN 'logcat'
    WHEN $value = 0 THEN 'foreground_app'
    WHEN $value = 50 THEN 'perceptible_foreground_app'
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    WHEN $value BETWEEN 100 AND 199 THEN 'visible_app'
    WHEN $value BETWEEN 200 AND 224 THEN 'perceptible_app'
    WHEN $value BETWEEN 225 AND 249 THEN 'perceptible_medium_app'
    WHEN $value BETWEEN 250 AND 299 THEN 'perceptible_low_app'
    WHEN $value BETWEEN 300 AND 399 THEN 'backup'
    WHEN $value BETWEEN 400 AND 499 THEN 'heavy_weight_app'
    WHEN $value BETWEEN 500 AND 599 THEN 'service'
    WHEN $value BETWEEN 600 AND 699 THEN 'home_app'
    WHEN $value BETWEEN 700 AND 799 THEN 'previous_app'
    WHEN $value BETWEEN 800 AND 899 THEN 'service_b'
    WHEN $value BETWEEN 900 AND 949 THEN 'cached_app'
    WHEN $value >= 950 THEN 'cached_app_lmk_first'
    WHEN $android_appid IS NULL THEN 'unknown'
    WHEN $android_appid < 10000 THEN 'unknown_native'
    ELSE 'unknown_app'
  END;

CREATE PERFETTO TABLE _oom_adjuster_intervals AS
WITH reason AS (
  SELECT
    thread_slice.id AS oom_adj_id,
    thread_slice.ts AS oom_adj_ts,
    thread_slice.dur AS oom_adj_dur,
    thread_slice.track_id AS oom_adj_track_id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    utid AS oom_adj_utid,
    thread_name AS oom_adj_thread_name,
    str_split(thread_slice.name, '_', 1) AS oom_adj_reason,
    slice.name AS oom_adj_trigger,
    LEAD(thread_slice.ts) OVER (ORDER BY thread_slice.ts) AS oom_adj_next_ts
  FROM thread_slice
  LEFT JOIN slice ON slice.id = thread_slice.parent_id AND slice.dur != -1
  WHERE thread_slice.name GLOB 'updateOomAdj_*' AND process_name = 'system_server'
)
SELECT
  ts,
  dur,
  cast_int!(value) AS score,
  process.upid,
  process.name AS process_name,
  reason.oom_adj_id,
  reason.oom_adj_ts,
  reason.oom_adj_dur,
  reason.oom_adj_track_id,
  reason.oom_adj_thread_name,
  reason.oom_adj_utid,
  reason.oom_adj_reason,
  reason.oom_adj_trigger,
  android_appid
FROM
  counter_leading_intervals
    !(
      (
        SELECT counter.*
        FROM counter
        JOIN counter_track track
          ON track.id = counter.track_id AND track.name = 'oom_score_adj'
      ))
      counter
JOIN process_counter_track track
  ON counter.track_id = track.id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(JOIN process
  USING (upid)
LEFT JOIN reason
  ON counter.ts BETWEEN oom_adj_ts AND COALESCE(oom_adj_next_ts, trace_end())
WHERE track.name = 'oom_score_adj';


-- All oom adj state intervals across all processes along with the reason for the state update.
CREATE PERFETTO VIEW android_oom_adj_intervals (
  -- Timestamp the oom_adj score of the process changed
  ts INT,
  -- Duration until the next oom_adj score change of the process.
  dur INT,
  -- oom_adj score of the process.
  score INT,
  -- oom_adj bucket of the process.
  bucket STRING,
  -- Upid of the process having an oom_adj update.
  upid INT,
  -- Name of the process having an oom_adj update.
  process_name STRING,
  -- Slice id of the latest oom_adj update in the system_server.
  oom_adj_id INT,
  -- Timestamp of the latest oom_adj update in the system_server.
  oom_adj_ts INT,
  -- Duration of the latest oom_adj update in the system_server.
  oom_adj_dur INT,
  -- Track id of the latest oom_adj update in the system_server
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  oom_adj_track_id INT,
  -- Thread name of the latest oom_adj update in the system_server.
  oom_adj_thread_name STRING,
  -- Reason for the latest oom_adj update in the system_server.
  oom_adj_reason STRING,
  -- Trigger for the latest oom_adj update in the system_server.
  oom_adj_trigger STRING
  ) AS
SELECT
  ts,
  dur,
  score,
  android_oom_adj_score_to_bucket_name(score) AS bucket,
  upid,
  process_name,
  oom_adj_id,
  oom_adj_ts,
  oom_adj_dur,
  oom_adj_track_id,
  oom_adj_thread_name,
  oom_adj_reason,
  oom_adj_trigger
FROM _oom_adjuster_intervals;

)_d3l1m1t3r_"
;

const char kAndroidPowerRails[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE counters.intervals;
INCLUDE PERFETTO MODULE time.conversion;

-- Android power rails counters data.
-- For details see: https://perfetto.dev/docs/data-sources/battery-counters#odpm
-- NOTE: Requires dedicated hardware - table is only populated on Pixels.
CREATE PERFETTO TABLE android_power_rails_counters (
    -- `counter.id`
    id INT,
    -- Timestamp of the energy measurement.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    ts INT,
    -- Time until the next energy measurement.
    dur INT,
    -- Power rail name. Alias of `counter_track.name`.
    power_rail_name STRING,
    -- Raw power rail name.
    raw_power_rail_name STRING,
    -- Energy accumulated by this rail since boot in microwatt-seconds
    -- (uWs) (AKA micro-joules). Alias of `counter.value`.
    energy_since_boot INT,
    -- Energy accumulated by this rail at next energy measurement in
    -- microwatt-seconds (uWs) (AKA micro-joules). Alias of `counter.value` of
    -- the next meaningful (with value change) counter value.
    energy_since_boot_at_end INT,
    -- Average power in mW (milliwatts) over between ts and the next energy
    -- measurement.
    average_power DOUBLE,
    -- The change of energy accumulated by this rails since the last
    -- measurement in microwatt-seconds (uWs) (AKA micro-joules).
    energy_delta DOUBLE,
    -- Power rail track id. Alias of `counter_track.id`.
    track_id INT,
    -- DEPRECATED. Use `energy_since_boot` instead.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    value DOUBLE
) AS
WITH counter_table AS (
SELECT
    c.*
FROM counter c
JOIN counter_track t ON c.track_id = t.id
WHERE name GLOB 'power.*'
)
SELECT
    c.id,
    c.ts,
    c.dur,
    t.name AS power_rail_name,
    EXTRACT_ARG(source_arg_set_id, 'raw_name') AS raw_power_rail_name,
    c.value AS energy_since_boot,
    c.next_value AS energy_since_boot_at_end,
    1e3*(c.delta_value/(time_to_s(c.dur))) AS average_power,
    c.delta_value AS energy_delta,
    c.track_id,
    c.value
FROM counter_leading_intervals!(counter_table) c
JOIN counter_track t ON c.track_id = t.id;

)_d3l1m1t3r_"
;

const char kAndroidProcessMetadata[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- Count packages by package UID.
CREATE PERFETTO TABLE _uid_package_count AS
SELECT uid, COUNT(1) AS cnt
FROM package_list
GROUP BY 1;

CREATE PERFETTO FUNCTION _android_package_for_process(
  uid INT,
  uid_count INT,
  process_name STRING
)
RETURNS TABLE(
  package_name STRING,
  version_code INT,
  debuggable BOOL
)
AS
WITH min_distance AS (
  SELECT
    -- SQLite allows omitting the group-by for the MIN: the other columns
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    -- will match the row with the minimum value.
    MIN(LENGTH($process_name) - LENGTH(package_name)),
    package_name,
    version_code,
    debuggable
  FROM package_list
  WHERE (
    (
      $uid = uid
      AND (
        -- unique match
        $uid_count = 1
        -- or process name is a prefix the package name
        OR $process_name GLOB package_name || '*'
      )
    )
    OR
    (
      -- isolated processes can only be matched based on the name
      $uid >= 90000 AND $uid < 100000
      AND STR_SPLIT($process_name, ':', 0) GLOB package_name || '*'
    )
  )
)
SELECT package_name, version_code, debuggable
FROM min_distance;

-- Data about packages running on the process.
CREATE PERFETTO TABLE android_process_metadata(
  -- Process upid.
  upid INT,
  -- Process name.
  process_name STRING,
  -- Android app UID.
  uid INT,
  -- Whether the UID is shared by multiple packages.
  shared_uid BOOL,
  -- Name of the packages running in this process.
  package_name STRING,
  -- Package version code.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  version_code INT,
  -- Whether package is debuggable.
  debuggable INT
) AS
SELECT
  process.upid,
  -- workaround for b/169226092: the bug has been fixed it Android T, but
  -- we support ingesting traces from older Android versions.
  CASE
    -- cmdline gets rewritten after fork, if these are still there we must
    -- have seen a racy capture.
    WHEN length(process.name) = 15 AND (
      process.cmdline IN ('zygote', 'zygote64', '<pre-initialized>')
      OR process.cmdline GLOB '*' || process.name)
      THEN process.cmdline
    ELSE process.name
  END AS process_name,
  process.android_appid AS uid,
  CASE WHEN _uid_package_count.cnt > 1 THEN TRUE ELSE NULL END AS shared_uid,
  plist.package_name,
  plist.version_code,
  plist.debuggable
FROM process
LEFT JOIN _uid_package_count ON process.android_appid = _uid_package_count.uid
LEFT JOIN _android_package_for_process(
  process.android_appid, _uid_package_count.cnt, process.name
) AS plist;

)_d3l1m1t3r_"
;

const char kAndroidScreenshots[] = R"_d3l1m1t3r_(-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Screenshot slices, used in perfetto UI.
CREATE PERFETTO TABLE android_screenshots(
  -- Slice id.
  id INT,
  -- Slice timestamp.
  ts INT,
  -- Slice duration, should be typically 0 since screeenshot slices are of instant
  -- type.
  dur INT,
  -- Slice name.
  name STRING
) AS
SELECT
  slice.id as id,
  slice.ts as ts,
  slice.dur as dur,
  slice.name as name
FROM slice
JOIN args USING(arg_set_id)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(WHERE slice.name = "Screenshot"
  AND slice.category = "android_screenshot"
  AND args.key = "screenshot.jpg_image";

)_d3l1m1t3r_"
;

const char kAndroidServices[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE slices.with_context;
INCLUDE PERFETTO MODULE android.binder;
INCLUDE PERFETTO MODULE graphs.search;

-- Details of all Service#onBind dispatched events.
CREATE PERFETTO TABLE _bind_dispatch
AS
WITH
  next_sibling AS MATERIALIZED (
    SELECT *
    FROM
      graph_next_sibling!(
          (
            SELECT id AS node_id, parent_id AS node_parent_id, ts AS sort_key
)_d3l1m1t3r_"
R"_d3l1m1t3r_(            FROM slice
            WHERE dur = 0
          )
      )
  ),
  service AS (
    SELECT
      next_slice.id,
      next_slice.ts,
      next_slice.dur,
      next_slice.name,
      slice.utid,
      slice.name AS bind_seq_name
    FROM next_sibling
    JOIN thread_slice slice
      ON slice.id = next_sibling.node_id
    JOIN slice next_slice
      ON next_slice.id = next_sibling.next_node_id
  )
  SELECT
  id,
  ts,
  dur,
  utid,
  CAST(STR_SPLIT(STR_SPLIT(bind_seq_name, 'bindSeq=', 1), ' ', 0) AS INT) AS bind_seq
FROM service
WHERE bind_seq_name GLOB 'requestServiceBinding*' AND name = 'binder transaction async';

-- Details of all Service#onBind received events.
CREATE PERFETTO TABLE _bind_receive
AS
SELECT
  id,
  ts,
  dur,
  track_id,
  REPLACE(STR_SPLIT(STR_SPLIT(name, 'token=', 1), ' ', 0), 'ServiceRecord{', '') AS token,
  STR_SPLIT(STR_SPLIT(name, 'act=', 1), ' ', 0) AS act,
  STR_SPLIT(STR_SPLIT(name, 'cmp=', 1), ' ', 0) AS cmp,
  STR_SPLIT(STR_SPLIT(name, 'flg=', 1), ' ', 0) AS flg,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  CAST(STR_SPLIT(STR_SPLIT(name, 'bindSeq=', 1), '}', 0) AS INT) AS bind_seq
FROM slice
WHERE name GLOB 'serviceBind:*';

-- All service bindings from client app to server app.
CREATE PERFETTO TABLE android_service_bindings(
  -- OOM score of client process making the binding.
  client_oom_score INT,
  -- Name of client process making the binding.
  client_process STRING,
  -- Name of client thread making the binding.
  client_thread STRING,
  -- Pid of client process making the binding.
  client_pid INT,
  -- Tid of client process making the binding.
  client_tid INT,
  -- Upid of client process making the binding.
  client_upid INT,
  -- Utid of client thread making the binding.
  client_utid INT,
  -- Timestamp the client process made the request.
  client_ts INT,
  -- Duration of the client binding request.
  client_dur INT,
  -- OOM score of server process getting bound to.
  server_oom_score INT,
  -- Name of server process getting bound to
  server_process STRING,
  -- Name of server thread getting bound to.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  server_thread STRING,
  -- Pid of server process getting bound to.
  server_pid INT,
  -- Tid of server process getting bound to.
  server_tid INT,
  -- Upid of server process getting bound to.
  server_upid INT,
  -- Utid of server process getting bound to.
  server_utid INT,
  -- Timestamp the server process got bound to.
  server_ts INT,
  -- Duration of the server process handling the binding.
  server_dur INT,
  -- Unique binder identifier for the Service binding.
  token STRING,
  -- Intent action name for the service binding.
  act STRING,
  -- Intent component name for the service binding.
  cmp STRING,
  -- Intent flag for the service binding.
  flg STRING,
  -- Monotonically increasing id for the service binding.
  bind_seq INT)
AS
SELECT
  COALESCE(client_binder.client_oom_score, server_binder.client_oom_score) AS client_oom_score,
  COALESCE(client_binder.client_process, server_binder.client_process) AS client_process,
  COALESCE(client_binder.client_thread, server_binder.client_thread) AS client_thread,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  COALESCE(client_binder.client_pid, server_binder.client_pid) AS client_pid,
  COALESCE(client_binder.client_tid, server_binder.client_tid) AS client_tid,
  COALESCE(client_binder.client_upid, server_binder.client_upid) AS client_upid,
  COALESCE(client_binder.client_utid, server_binder.client_utid) AS client_utid,
  COALESCE(client_binder.client_ts, server_binder.client_ts) AS client_ts,
  COALESCE(client_binder.client_dur, server_binder.client_dur) AS client_dur,
  server_binder.server_oom_score,
  server_binder.server_process,
  server_binder.server_thread,
  server_binder.server_pid,
  server_binder.server_tid,
  server_binder.server_upid,
  server_binder.server_utid,
  receive.ts AS server_ts,
  receive.dur AS server_dur,
  receive.token,
  receive.act,
  receive.cmp,
  receive.flg,
  receive.bind_seq
FROM _bind_dispatch dispatch
JOIN _bind_receive receive
  ON dispatch.bind_seq = receive.bind_seq
LEFT JOIN android_binder_txns server_binder
  ON server_binder.binder_txn_id = dispatch.id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(LEFT JOIN ancestor_slice(dispatch.id) anc ON anc.depth = 0
LEFT JOIN android_binder_txns client_binder
  ON client_binder.server_ts = anc.ts AND dispatch.utid = client_binder.server_utid;

)_d3l1m1t3r_"
;

const char kAndroidSlices[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.


CREATE PERFETTO FUNCTION _remove_lambda_name(
-- Raw slice name containing at least one "$"
  name STRING)
-- Removes everything after the first "$"
RETURNS STRING AS
SELECT
    substr($name, 0, instr($name, "$"))
END;

-- Some slice names have params in them. This functions removes them to make it
-- possible to aggregate by name.
-- Some examples are:
--  - Lock/monitor contention slices. The name includes where the lock
)_d3l1m1t3r_"
R"_d3l1m1t3r_(--    contention is in the code. That part is removed.
--  - DrawFrames/ooFrame. The name also includes the frame number.
--  - Apk/oat/dex loading: The name of the apk is removed
CREATE PERFETTO FUNCTION android_standardize_slice_name(
  -- The raw slice name.
  name STRING)
-- Simplified name.
RETURNS STRING AS
SELECT
  CASE
    WHEN $name GLOB "monitor contention with*" THEN "monitor contention with <...>"
    WHEN $name GLOB "SuspendThreadByThreadId*" THEN "SuspendThreadByThreadId <...>"
    WHEN $name GLOB "LoadApkAssetsFd*" THEN "LoadApkAssetsFd <...>"
    WHEN $name GLOB "relayoutWindow*" THEN "relayoutWindow <...>"
    WHEN $name GLOB "android.os.Handler: kotlinx.coroutines*" THEN "CoroutineContinuation"
    WHEN $name GLOB "Choreographer#doFrame*" THEN "Choreographer#doFrame"
    WHEN $name GLOB "DrawFrames*" THEN "DrawFrames"
    WHEN $name GLOB "/data/app*.apk" THEN "APK load"
    WHEN $name GLOB "OpenDexFilesFromOat*" THEN "OpenDexFilesFromOat"
    WHEN $name GLOB "Open oat file*" THEN "Open oat file"
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    WHEN $name GLOB "GC: Wait For*" THEN "Garbage Collector"
    -- E.g. Lock contention on thread list lock (owner tid: 1665)
    -- To: Lock contention on thread list lock <...>
    WHEN $name GLOB "Lock contention on* (*" THEN substr($name, 0, instr($name, "(")) || "<...>"
    -- Top level handlers slices heuristics:
        -- E.g. android.os.Handler: com.android.systemui.qs.external.TileServiceManager$1
        -- To: Handler: com.android.systemui.qs.external.TileServiceManager
    WHEN $name GLOB "*Handler: *$*" THEN _remove_lambda_name(substr($name, instr($name, "Handler:")))
        -- E.g. : android.view.ViewRootImpl$ViewRootHandler: com.android.systemui.someClass$enableMarquee$1
        -- To: Handler: android.view.ViewRootImpl
    WHEN $name GLOB "*.*.*: *$*" THEN "Handler: " || _remove_lambda_name(substr($name, ": "))
        -- E.g.: android.os.AsyncTask$InternalHandler: #1
        -- To: Handler: android.os.AsyncTask
    WHEN $name GLOB "*.*$*: #*" THEN "Handler: " || _remove_lambda_name($name)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    ELSE $name
  END;

)_d3l1m1t3r_"
;

const char kAndroidStatsd[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- Statsd atoms.
--
-- A subset of the slice table containing statsd atom instant events.
CREATE PERFETTO VIEW android_statsd_atoms(
  -- Unique identifier for this slice.
  id INT,
  -- The name of the "most-specific" child table containing this row.
  type STRING,
  -- The timestamp at the start of the slice (in nanoseconds).
  ts INT,
  -- The duration of the slice (in nanoseconds).
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  dur INT,
  -- The id of the argument set associated with this slice.
  arg_set_id INT,
  -- The value of the CPU instruction counter at the start of the slice. This column will only be populated if thread instruction collection is enabled with track_event.
  thread_instruction_count INT,
  -- The change in value of the CPU instruction counter between the start and end of the slice. This column will only be populated if thread instruction collection is enabled with track_event.
  thread_instruction_delta INT,
  -- The id of the track this slice is located on.
  track_id INT,
  -- The "category" of the slice. If this slice originated with track_event, this column contains the category emitted. Otherwise, it is likely to be null (with limited exceptions).
  category STRING,
  -- The name of the slice. The name describes what was happening during the slice.
  name STRING,
  -- The depth of the slice in the current stack of slices.
  depth INT,
  -- A unique identifier obtained from the names of all slices in this stack. This is rarely useful and kept around only for legacy reasons.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  stack_id INT,
  -- The stack_id for the parent of this slice. Rarely useful.
  parent_stack_id INT,
  -- The id of the parent (i.e. immediate ancestor) slice for this slice.
  parent_id INT,
  -- The thread timestamp at the start of the slice. This column will only be populated if thread timestamp collection is enabled with track_event.
  thread_ts INT,
  -- The thread time used by this slice. This column will only be populated if thread timestamp collection is enabled with track_event.
  thread_dur INT
) AS
SELECT
  slice.id AS id,
  slice.type AS type,
  slice.ts AS ts,
  slice.dur AS dur,
  slice.arg_set_id AS arg_set_id,
  slice.thread_instruction_count AS thread_instruction_count,
  slice.thread_instruction_delta AS thread_instruction_delta,
  slice.track_id AS track_id,
  slice.category AS category,
  slice.name AS name,
  slice.depth AS depth,
  slice.stack_id AS stack_id,
  slice.parent_stack_id AS parent_stack_id,
  slice.parent_id AS parent_id,
  slice.thread_ts AS thread_ts,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  slice.thread_dur AS thread_dur
FROM slice
JOIN track ON slice.track_id = track.id
WHERE
  track.name = 'Statsd Atoms';

-- Information about Perfetto triggers, extracted from statsd atoms, which
-- happened during the trace.
--
-- This requires the `android.statsd` data-source to be enabled and the
-- `ATOM_PERFETTO_TRIGGER` push atom to be configured.
CREATE PERFETTO TABLE _android_statsd_perfetto_triggers(
  -- Timestamp of the trigger.
  ts INT,
  -- The name of the trigger.
  trigger_name STRING
)
AS
SELECT
  ts,
  extract_arg(arg_set_id, 'perfetto_trigger.trigger_name') AS trigger_name
FROM android_statsd_atoms
WHERE name = 'perfetto_trigger';

)_d3l1m1t3r_"
;

const char kAndroidSuspend[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- Table of suspended and awake slices.
--
-- Selects either the minimal or full ftrace source depending on what's
-- available, marks suspended periods, and complements them to give awake
-- periods.
CREATE PERFETTO TABLE android_suspend_state(
  -- Timestamp
  ts INT,
  -- Duration
  dur INT,
  -- 'awake' or 'suspended'
  power_state STRING) AS
WITH suspend_slice_from_minimal AS (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  SELECT ts, dur
  FROM track t JOIN slice s ON s.track_id = t.id
  WHERE t.name = 'Suspend/Resume Minimal'
),
suspend_slice as (
  SELECT ts, dur FROM suspend_slice_from_minimal
  UNION ALL
  SELECT
    ts,
    dur
  FROM
    slice
  JOIN
    track
    ON slice.track_id = track.id
  WHERE
    track.name = 'Suspend/Resume Latency'
    AND (slice.name = 'syscore_resume(0)' OR slice.name = 'timekeeping_freeze(0)')
    AND dur != -1
    AND NOT EXISTS(SELECT * FROM suspend_slice_from_minimal)
),
awake_slice AS (
  -- If we don't have any rows, use the trace bounds.
  SELECT
    trace_start() AS ts,
    trace_dur() AS dur
  WHERE (SELECT COUNT(*) FROM suspend_slice) = 0
  UNION ALL
  -- If we do have rows, create one slice from the trace start to the first suspend.
  SELECT
    trace_start() AS ts,
    (SELECT min(ts) FROM suspend_slice) - trace_start() AS dur
  WHERE (SELECT COUNT(*) FROM suspend_slice) != 0
  UNION ALL
  -- And then one slice for each suspend, from the end of the suspend to the
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- start of the next one (or the end of the trace if there is no next one).
  SELECT
    ts + dur AS ts,
    ifnull(lead(ts) OVER (ORDER BY ts), trace_end()) - ts - dur
      AS dur
  FROM suspend_slice
)
SELECT ts, dur, 'awake' AS power_state
FROM awake_slice
UNION ALL
SELECT ts, dur, 'suspended' AS power_state
FROM suspend_slice
ORDER BY ts; -- Order by will cause Perfetto table to index by ts.


-- Extracts the duration without counting CPU suspended time from an event.
-- This is the same as converting an event duration from wall clock to monotonic clock.
-- If there was no CPU suspend, the result is same as |dur|.
CREATE PERFETTO FUNCTION _extract_duration_without_suspend(
  -- Timestamp of event.
  ts INT,
  -- Duration of event.
  dur INT)
RETURNS INT
AS
SELECT to_monotonic($ts + $dur) - to_monotonic($ts);

)_d3l1m1t3r_"
;

const char kAndroidThread[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

CREATE PERFETTO FUNCTION _thread_prefix(thread_name STRING)
RETURNS STRING AS
SELECT STR_SPLIT(STR_SPLIT(STR_SPLIT(STR_SPLIT($thread_name, "-", 0), "[", 0), ":", 0), " ", 0);

-- Per process stats of threads created in a process
CREATE PERFETTO FUNCTION _android_thread_creation_spam(
  -- Minimum duration between creating and destroying a thread before their the
  -- thread creation event is considered. If NULL, considers all thread creations.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  min_thread_dur FLOAT,
  -- Sliding window duration for counting the thread creations. Each window
  -- starts at the first thread creation per <process, thread_name_prefix>.
  sliding_window_dur FLOAT)
RETURNS TABLE(
  -- Process name creating threads.
  process_name STRING,
  -- Process pid creating threads.
  pid INT,
  -- String prefix of thread names created.
  thread_name_prefix STRING,
  -- Max number of threads created within a time window.
  max_count_per_sec INT
) AS
WITH
x AS (
  SELECT
    pid,
    upid,
    _THREAD_PREFIX(thread.name) AS thread_name_prefix,
    process.name AS process_name,
    COUNT(thread.start_ts)
      OVER (
        PARTITION BY upid, thread.name
        ORDER BY thread.start_ts
        RANGE BETWEEN CURRENT ROW AND CAST($sliding_window_dur AS INT64) FOLLOWING
      ) AS count
  FROM thread
  JOIN process
    USING (upid)
  WHERE
    ($min_thread_dur AND (thread.end_ts - thread.start_ts) <= $min_thread_dur)
    OR $min_thread_dur IS NULL
)
SELECT process_name, pid, thread_name_prefix, MAX(count) AS max_count_per_sec
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM x
GROUP BY upid, thread_name_prefix
HAVING max_count_per_sec > 0
ORDER BY count DESC;

)_d3l1m1t3r_"
;

const char kChromeChromeScrolls[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

INCLUDE PERFETTO MODULE chrome.scroll_jank.utils;

-- Defines slices for all of the individual scrolls in a trace based on the
-- LatencyInfo-based scroll definition.
--
-- NOTE: this view of top level scrolls is based on the LatencyInfo definition
-- of a scroll, which differs subtly from the definition based on
-- EventLatencies.
-- TODO(b/278684408): add support for tracking scrolls across multiple Chrome/
-- WebView instances. Currently gesture_scroll_id unique within an instance, but
-- is not unique across multiple instances. Switching to an EventLatency based
-- definition of scrolls should resolve this.
CREATE PERFETTO TABLE chrome_scrolls(
  -- The unique identifier of the scroll.
  id INT,
  -- The start timestamp of the scroll.
  ts INT,
  -- The duration of the scroll.
  dur INT,
  -- The earliest timestamp of the EventLatency slice of the GESTURE_SCROLL_BEGIN type for the
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- corresponding scroll id.
  gesture_scroll_begin_ts INT,
  -- The earliest timestamp of the EventLatency slice of the GESTURE_SCROLL_END type /
  -- the latest timestamp of the EventLatency slice of the GESTURE_SCROLL_UPDATE type for the
  -- corresponding scroll id.
  gesture_scroll_end_ts INT
) AS
WITH all_scrolls AS (
  SELECT
    args.string_value AS name,
    S.ts AS ts,
    S.dur AS dur,
    chrome_get_most_recent_scroll_begin_id(S.ts) AS scroll_id
  FROM slice AS S JOIN args USING(arg_set_id)
  WHERE name="EventLatency"
  AND args.string_value GLOB "*GESTURE_SCROLL*"
),
scroll_starts AS (
  SELECT
    scroll_id,
    MIN(ts) AS gesture_scroll_begin_ts
  FROM all_scrolls
  WHERE name = "GESTURE_SCROLL_BEGIN"
  GROUP BY scroll_id
),
scroll_ends AS (
  SELECT
    scroll_id,
    MAX(ts) AS gesture_scroll_end_ts
  FROM all_scrolls
  WHERE name GLOB "*GESTURE_SCROLL_UPDATE"
    OR name = "GESTURE_SCROLL_END"
  GROUP BY scroll_id
)
SELECT
  sa.scroll_id AS id,
  MIN(ts) AS ts,
  CAST(MAX(ts + dur) - MIN(ts) AS INT) AS dur,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ss.gesture_scroll_begin_ts AS gesture_scroll_begin_ts,
  se.gesture_scroll_end_ts AS gesture_scroll_end_ts
FROM all_scrolls sa
  LEFT JOIN scroll_starts ss ON
    sa.scroll_id = ss.scroll_id
  LEFT JOIN scroll_ends se ON
    sa.scroll_id = se.scroll_id
GROUP BY sa.scroll_id;

-- Defines slices for all of scrolls intervals in a trace based on the scroll
-- definition in chrome_scrolls. Note that scrolls may overlap (particularly in
-- cases of jank/broken traces, etc); so scrolling intervals are not exactly the
-- same as individual scrolls.
CREATE PERFETTO VIEW chrome_scrolling_intervals(
  -- The unique identifier of the scroll interval. This may span multiple scrolls if they overlap.
  id INT,
  -- Comma-separated list of scroll ids that are included in this interval.
  scroll_ids STRING,
  -- The start timestamp of the scroll interval.
  ts INT,
  -- The duration of the scroll interval.
  dur INT
) AS
WITH all_scrolls AS (
  SELECT
    id AS scroll_id,
    s.ts AS start_ts,
    s.ts + s.dur AS end_ts
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  FROM chrome_scrolls s),
ordered_end_ts AS (
  SELECT
    *,
    MAX(end_ts) OVER (ORDER BY start_ts) AS max_end_ts_so_far
  FROM all_scrolls),
range_starts AS (
  SELECT
    *,
    CASE
      WHEN start_ts <= 1 + LAG(max_end_ts_so_far) OVER (ORDER BY start_ts) THEN 0
      ELSE 1
    END AS range_start
  FROM ordered_end_ts),
range_groups AS (
  SELECT
    *,
    SUM(range_start) OVER (ORDER BY start_ts) AS range_group
  FROM range_starts)
SELECT
  range_group AS id,
  GROUP_CONCAT(scroll_id) AS scroll_ids,
  MIN(start_ts) AS ts,
  MAX(end_ts) - MIN(start_ts) AS dur
FROM range_groups
GROUP BY range_group;

)_d3l1m1t3r_"
;

const char kChromeCpuPowerups[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- Find causes for CPUs powering up.
--
-- The scripts below analyse traces with the following tracing options
-- enabled:
--
--  - Linux kernel:
---    "power/*", "sched/*", "task/*",
--  - Chromium:
--      "toplevel", "toplevel.flow".

-- Noteworthy tables:
--
--   chrome_cpu_power_first_toplevel_slice_after_powerup :: The top-level
--      slices that ran after a CPU power-up.

-- The CPU power transitions in the trace.
-- Power states are encoded as non-negative integers, with zero representing
-- full-power operation and positive values representing increasingly deep
-- sleep states.
--
-- On ARM systems, power state 1 represents the WFI (Wait For Interrupt) sleep
-- state that the CPU enters while idle.
CREATE PERFETTO VIEW chrome_cpu_power_slice(
  -- The timestamp at the start of the slice.
  ts INT,
  -- The duration of the slice.
  dur INT,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- The CPU on which the transition occurred
  cpu INT,
  -- The power state that the CPU was in at time 'ts' for duration 'dur'.
  power_state INT,
  -- The power state that the CPU was previously in.
  previous_power_state INT,
  -- A unique ID for the CPU power-up.
  powerup_id INT
) AS
  WITH cpu_power_states AS (
    SELECT
      c.id AS id,
      cct.cpu AS cpu,
      c.ts,
      -- Encode the 'value' field as a power state.
      CAST((CASE c.value WHEN 4294967295 THEN 0 ELSE c.value + 1 END)
        AS INT) AS power_state
    FROM counter AS c
    JOIN cpu_counter_track AS cct
      ON c.track_id = cct.id
    WHERE cct.name = 'cpuidle'
  )
  SELECT *
  FROM (
    SELECT
      ts,
      LEAD(ts) OVER (PARTITION BY cpu ORDER BY ts ASC) - ts
        AS dur,
      cpu,
      power_state,
      LAG(power_state) OVER (PARTITION BY cpu ORDER BY ts ASC)
        AS previous_power_state,
      id AS powerup_id
    FROM cpu_power_states
  )
  WHERE dur IS NOT NULL
    AND previous_power_state IS NOT NULL
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    AND power_state = 0                      -- Track full-power states.
    AND power_state != previous_power_state  -- Skip missing spans.
    ORDER BY ts ASC;

-- We do not want scheduler slices with utid = 0 (the 'swapper' kernel thread).
CREATE PERFETTO VIEW _cpu_power_valid_sched_slice AS
  SELECT *
  FROM sched_slice
  WHERE utid != 0;

-- Join scheduler slices with the spans with CPU power slices.
--
-- There multiple scheduler slices could fall into one CPU power slice.
--
---  CPU Power:
--   |----------------------------|....................|---------|
--   A       <cpu active>         B     <cpu idling>   C         D

--   Scheduler slices on that CPU:
--     |-----T1-----| |....T2....|                      |---T3--|
--     E            F G          H                      I       J
--
-- Here threads T1 and T2 executed in CPU power slice [A,B].  The
-- time between F and G represents time between threads in the kernel.
CREATE VIRTUAL TABLE _cpu_power_and_sched_slice
USING
  SPAN_JOIN(chrome_cpu_power_slice PARTITIONED cpu,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(            _cpu_power_valid_sched_slice PARTITIONED cpu);

-- The Linux scheduler slices that executed immediately after a
-- CPU power up.
CREATE PERFETTO TABLE chrome_cpu_power_first_sched_slice_after_powerup(
  -- The timestamp at the start of the slice.
  ts INT,
  -- The duration of the slice.
  dur INT,
  -- The cpu on which the slice executed.
  cpu INT,
  -- Id for the sched_slice table.
  sched_id INT,
  -- Unique id for the thread that ran within the slice.
  utid INT,
  -- The CPU's power state before this slice.
  previous_power_state INT,
  -- A unique ID for the CPU power-up.
  powerup_id INT
) AS
SELECT
  ts,
  dur,
  cpu,
  id AS sched_id,
  utid,
  previous_power_state,
  powerup_id
FROM _cpu_power_and_sched_slice
WHERE power_state = 0     -- Power-ups only.
GROUP BY cpu, powerup_id
HAVING ts = MIN(ts)       -- There will only be one MIN sched slice
                          -- per CPU power up.
ORDER BY ts ASC;

-- A view joining thread tracks and top-level slices.
--
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- This view is intended to be intersected by time with the scheduler
-- slices scheduled after a CPU power up.
--
--   utid      Thread unique id.
--   slice_id  The slice_id for the top-level slice.
--   ts        Starting timestamp for the slice.
--   dur       The duration for the slice.
CREATE PERFETTO VIEW _cpu_power_thread_and_toplevel_slice AS
  SELECT
    t.utid AS utid,
    s.id AS slice_id,
    s.ts,
    s.dur
  FROM slice AS s
  JOIN thread_track AS t
    ON s.track_id = t.id
  WHERE s.depth = 0   -- Top-level slices only.
  ORDER BY ts ASC;

-- A table holding the slices that executed within the scheduler
-- slice that ran on a CPU immediately after power-up.
--
-- @column  ts        Timestamp of the resulting slice
-- @column dur        Duration of the slice.
-- @column cpu        The CPU the sched slice ran on.
-- @column utid       Unique thread id for the slice.
-- @column sched_id   'id' field from the sched_slice table.
-- @column type       From the sched_slice table, always 'sched_slice'.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column end_state  The ending state for the sched_slice
-- @column priority   The kernel thread priority
-- @column slice_id   Id of the top-level slice for this (sched) slice.
CREATE VIRTUAL TABLE chrome_cpu_power_post_powerup_slice
USING
  SPAN_JOIN(chrome_cpu_power_first_sched_slice_after_powerup PARTITIONED utid,
            _cpu_power_thread_and_toplevel_slice PARTITIONED utid);

-- The first top-level slice that ran after a CPU power-up.
CREATE PERFETTO VIEW chrome_cpu_power_first_toplevel_slice_after_powerup(
  -- ID of the slice in the slice table.
  slice_id INT,
  -- The power state of the CPU prior to power-up.
  previous_power_state INT
) AS
  SELECT slice_id, previous_power_state
  FROM chrome_cpu_power_post_powerup_slice
  GROUP BY cpu, powerup_id
  HAVING ts = MIN(ts)
  ORDER BY ts ASC;

)_d3l1m1t3r_"
;

const char kChromeEventLatencyDescription[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- Source of truth of the descriptions of EventLatency stages.
CREATE PERFETTO TABLE chrome_event_latency_stage_descriptions (
    -- The name of the EventLatency stage.
    name STRING,
    -- A description of the EventLatency stage.
    description STRING
) AS
WITH event_latency_descriptions(
  name,
  description)
AS (
VALUES
  ('TouchRendererHandlingToBrowserMain',
    'Interval between when the website handled blocking touch move to when ' ||
    'the browser UI thread started processing the input. Blocking touch ' ||
    'move happens when a touch event has to be handled by the website ' ||
    'before being converted to a scroll.'),
  ('GenerationToBrowserMain',
    'Interval between OS-provided hardware input timestamp to when the ' ||
    'browser UI thread began processing the input.'),
  ('GenerationToRendererCompositor',
    'Interval between OS-provided hardware input timestamp to when the ' ||
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'renderer compositor thread starts handling the artificial TOUCH_PRESS ' ||
    'browser injects in the kTouchScrollStarted event. See ' ||
    'PrependTouchScrollNotification for more info.'),
  ('BrowserMainToRendererCompositor',
    'Interval between when Browser UI thread starts to process the input to ' ||
    'renderer compositor thread starting to process it. This stage includes ' ||
    'browser UI thread processing, and task queueing times on the IO and ' ||
    'renderer compositor threads.'),
  ('RendererCompositorQueueingDelay',
    'Interval between when the input event is queued in the renderer ' ||
    'compositor and start of the BeginImplFrame producing a frame ' ||
    'containing this input.'),
  ('RendererCompositorToMain',
    'Interval between when the Renderer Compositor finishes processing the ' ||
    'event and when the Renderer Main (CrRendererMain) starts processing ' ||
    'the event, only seen when the compositor thread cannot handle the ' ||
    'scroll event by itself (known as "slow path"), usually caused by the ' ||
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'presence of blocking JS event listeners or complex page layout.'),
  ('RendererCompositorProcessing',
    'Interval corresponding to the Renderer Compositor thread processing ' ||
    'the frame updates.'),
  ('RendererMainProcessing',
    'Interval corresponding to the Renderer Main thread processing the ' ||
    'frame updates.'),
  ('EndActivateToSubmitCompositorFrame',
    'Interval that the Renderer Compositor waits for the GPU to flush a ' ||
    'frame to submit a new one.'),
  ('SubmitCompositorFrameToPresentationCompositorFrame',
    'Interval between the first Renderer Frame received to when the system ' ||
    'presented the fully composited frame on the screen. Note that on some ' ||
    'systems/apps this is incomplete/inaccurate due to lack of feedback ' ||
    'timestamps from the platform (Mac, iOS, Android Webview, etc).'),
  ('ArrivedInRendererCompositorToTermination',
    'Interval between when Renderer Compositor received the frame to when ' ||
    'this input was decided to either be ignored or merged into another ' ||
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'frame being produced. This could be a dropped frame, or just a normal ' ||
    'coalescing.'),
  ('RendererCompositorStartedToTermination',
    'Interval between when Renderer Compositor started processing the frame ' ||
    'to when this input was decided to either be ignored or merged into ' ||
    'another frame being produced. This could be a dropped frame, or just a ' ||
    'normal coalescing.'),
  ('RendererMainFinishedToTermination',
    'Interval between when Renderer Main finished processing the frame ' ||
    'to when this input was decided to either be ignored or merged into ' ||
    'another frame being produced. This could be a dropped frame, or just a ' ||
    'normal coalescing.'),
  ('RendererCompositorFinishedToTermination',
    'Interval between when Renderer Compositor finished processing the ' ||
    'frame to when this input was decided to either be ignored or merged ' ||
    'into another frame being produced. This could be just a normal ' ||
    'coalescing.'),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ('RendererMainStartedToTermination',
    'Interval between when Renderer Main started processing the frame ' ||
    'to when this input was decided to either be ignored or merged into ' ||
    'another frame being produced. This could be a dropped frame, or just a ' ||
    'normal coalescing.'),
  ('RendererCompositorFinishedToBeginImplFrame',
    'Interval when Renderer Compositor has finished processing a vsync ' ||
    '(with input), but did not end up producing a CompositorFrame due to ' ||
    'reasons such as waiting on main thread, and is now waiting for the ' ||
    'next BeginFrame from the GPU VizCompositor.'),
  ('RendererCompositorFinishedToCommit',
    'Interval between when the Renderer Compositor has finished its work ' ||
    'and the current tree state will be committed from the Renderer Main ' ||
    '(CrRendererMain) thread.'),
  ('RendererCompositorFinishedToEndCommit',
    'Interval between when the Renderer Compositor finishing processing to ' ||
    'the Renderer Main (CrRendererMain) both starting and finishing the ' ||
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'commit.'),
  ('RendererCompositorFinishedToActivation',
    'Interval of activation without a previous commit (not as a stage with ' ||
    'ToEndCommit). Activation occurs on the Renderer Compositor Thread ' ||
    'after it has been notified of a fully committed RendererMain tree.'),
  ('RendererCompositorFinishedToEndActivate',
    'Interval when the Renderer Compositor has finished processing and ' ||
    'activating the Tree.'),
  ('RendererCompositorFinishedToSubmitCompositorFrame',
    'Interval when processing does not need to wait for a commit (can do an ' ||
    'early out) for activation and can go straight to providing the frame ' ||
    'to the GPU VizCompositor. The Renderer Compositor is waiting for the ' ||
    'GPU to flush a frame so that it can then submit a new frame.'),
  ('RendererMainFinishedToBeginImplFrame',
    'Interval when the input was sent first to the RendererMain thread and ' ||
    'now requires the Renderer Compositor to react, aka it is is waiting ' ||
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'for a BeginFrame signal.'),
  ('RendererMainFinishedToSendBeginMainFrame',
    'Interval during which the Renderer Main (CrRendererMain) thread is ' ||
    'waiting for BeginMainFrame.'),
  ('RendererMainFinishedToCommit',
    'Interval when the Renderer Main (CrRendererMain) is ready to commit ' ||
    'its work to the Renderer Compositor.'),
  ('BeginImplFrameToSendBeginMainFrame',
    'Interval during which the Renderer Compositor has received the ' ||
    'BeginFrame signal from the GPU VizCompositor, and now needs to send it ' ||
    'to the Renderer Main thread (CrRendererMain).'),
  ('RendererCompositorFinishedToSendBeginMainFrame',
    'Interval during which the Renderer Compositor is waiting for a ' ||
    'BeginFrame from the GPU VizCompositor, and it expects to have to do ' ||
    'work on the Renderer Main thread (CrRendererMain), so we are waiting ' ||
    'for a BeginMainFrame'),
  ('SendBeginMainFrameToCommit',
    'Interval when updates (such as HandleInputEvents, Animate, StyleUpdate ' ||
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'and LayoutUpdate) are updatedon the Renderer Main thread ' ||
    '(CrRendererMain).'),
  ('Commit',
    'Interval during which the Renderer Main thread (CrRendererMain) ' ||
    'commits updates back to Renderer Compositor for activation. ' ||
    'Specifically, the main thread copies its own version of layer tree ' ||
    'onto the pending tree on the compositor thread. The main thread is ' ||
    'blocked during the copying process.'),
  ('EndCommitToActivation',
    'Interval when the commit is ready and waiting for activation.'),
  ('Activation',
    'Interval when the layer trees and properties are on the pending tree ' ||
    'is pused to the active tree on the Renderer Compositor.'),
  ('SubmitToReceiveCompositorFrame',
    'Interval of the delay b/w Renderer Compositor thread sending ' ||
    'CompositorFrame and then GPU VizCompositorThread receiving the ' ||
    'CompositorFrame.'),
  ('ReceiveCompositorFrameToStartDraw',
    'Interval between the first frame received to when all frames (or ' ||
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'timeouts have occurred) and we start drawing. It can be blocked by ' ||
    'other processes (e.g to draw a toolbar it waiting for information from ' ||
    'the Browser) as it waits for timeouts or frames to be provided. This ' ||
    'is the tree of dependencies that the GPU VizCompositor is waiting for ' ||
    'things to arrive. That is creating a single frame for multiple ' ||
    'compositor frames. '),
  ('StartDrawToSwapStart',
    'Interval when all compositing sources are done, or compositing ' ||
    'deadline passes - the viz thread takes all the latest composited ' ||
    'surfaces and issues the software draw instructions to layer the ' ||
    'composited tiles, this substage ends when the swap starts on Gpu ' ||
    'CompositorGpuThread.'),
  ('SwapStartToBufferAvailable',
    'Interval that is a substage of stage "Swap" when the framebuffer ' ||
    'is prepared by the system and the fence Chrome waits on before ' ||
    'writing is signalled, and Chrome can start transferring the new frame.'),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ('BufferAvailableToBufferReady',
    'Interval that is a Ssubstage of stage "Swap" when Chrome is ' ||
    'transferring a new frame to when it has finished completely sending a ' ||
    'frame to the framebuffer.'),
  ('BufferReadyToLatch',
    'Interval that is a substage of stage "Swap", when the system latches ' ||
    'and is ready to use the frame, and then it can get to work producing ' ||
    'the final frame.'),
  ('LatchToSwapEnd',
    'Intereval that is a substage of stage "Swap", when the latch has ' ||
    'finished until the frame is fully swapped and in the queue of frames ' ||
    'to be presented.'),
  ('SwapEndToPresentationCompositorFrame',
    'Interval that the frame is presented on the screen (and pixels became ' ||
    'visible).'))
SELECT
  name,
  description
FROM event_latency_descriptions;

)_d3l1m1t3r_"
;

const char kChromeHistograms[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

DROP VIEW IF EXISTS chrome_histograms;

-- A helper view on top of the histogram events emitted by Chrome.
-- Requires "disabled-by-default-histogram_samples" Chrome category.
CREATE PERFETTO TABLE chrome_histograms(
  -- The name of the histogram.
  name STRING,
  -- The value of the histogram sample.
  value INT,
  -- Alias of |slice.ts|.
  ts INT,
  -- Thread name.
  thread_name STRING,
  -- Utid of the thread.
  utid INT,
  -- Tid of the thread.
  tid INT,
  -- Process name.
  process_name STRING,
  -- Upid of the process.
  upid INT,
  -- Pid of the process.
  pid INT
) AS
SELECT
  extract_arg(slice.arg_set_id, "chrome_histogram_sample.name") as name,
  extract_arg(slice.arg_set_id, "chrome_histogram_sample.sample") as value,
  ts,
  thread.name as thread_name,
  thread.utid as utid,
  thread.tid as tid,
  process.name as process_name,
  process.upid as upid,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  process.pid as pid
FROM slice
JOIN thread_track ON thread_track.id = slice.track_id
JOIN thread USING (utid)
JOIN process USING (upid)
WHERE
  slice.name = "HistogramSample"
  AND category = "disabled-by-default-histogram_samples";
)_d3l1m1t3r_"
;

const char kChromeInteractions[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- This file specifies common metrics/tables for critical user interactions. It
-- is expected to be in flux as metrics are added across different CUI types.
-- Currently we only track Chrome page loads and their associated metrics.

INCLUDE PERFETTO MODULE chrome.page_loads;
INCLUDE PERFETTO MODULE chrome.startups;
INCLUDE PERFETTO MODULE chrome.web_content_interactions;

-- All critical user interaction events, including type and table with
-- associated metrics.
CREATE PERFETTO TABLE chrome_interactions(
  -- Identifier of the interaction; this is not guaranteed to be unique to the table -
  -- rather, it is unique within an individual interaction type. Combine with type to get
  -- a unique identifier in this table.
  scoped_id INT,
  -- Type of this interaction, which together with scoped_id uniquely identifies this
  -- interaction. Also corresponds to a SQL table name containing more details specific
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- to this type of interaction.
  type STRING,
  -- Interaction name - e.g. 'PageLoad', 'Tap', etc. Interactions will have unique metrics
  -- stored in other tables.
  name STRING,
  -- Timestamp of the CUI event.
  ts INT,
  -- Duration of the CUI event.
  dur INT
) AS
SELECT
  id AS scoped_id,
  'chrome_page_loads' AS type,
  'PageLoad' AS name,
  navigation_start_ts AS ts,
  IFNULL(lcp, fcp) AS dur
FROM chrome_page_loads
UNION ALL
SELECT
  id AS scoped_id,
  'chrome_startups' AS type,
  name,
  startup_begin_ts AS ts,
  CASE
    WHEN first_visible_content_ts IS NOT NULL
      THEN first_visible_content_ts - startup_begin_ts
    ELSE 0
  END AS dur
FROM chrome_startups
UNION ALL
SELECT
  id AS scoped_id,
  'chrome_web_content_interactions' AS type,
  'InteractionToFirstPaint' AS name,
  ts,
  dur
FROM chrome_web_content_interactions;

)_d3l1m1t3r_"
;

const char kChromeMetadata[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- Returns hardware class of the device, often use to find device brand
-- and model.
CREATE PERFETTO FUNCTION chrome_hardware_class()
-- Hardware class name.
RETURNS STRING AS
SELECT
  str_value
  FROM metadata
WHERE name = "cr-hardware-class";
)_d3l1m1t3r_"
;

const char kChromePageLoads[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- TODO(b/306300843): The recorded navigation ids are not guaranteed to be
-- unique within a trace; they are only guaranteed to be unique within a single
-- chrome instance. Chrome instance id needs to be recorded, and used here in
-- combination with navigation id to uniquely identify page load metrics.

INCLUDE PERFETTO MODULE slices.with_context;

CREATE PERFETTO VIEW _fcp_metrics AS
SELECT
  ts,
  dur,
  EXTRACT_ARG(arg_set_id, 'page_load.navigation_id') AS navigation_id,
  EXTRACT_ARG(arg_set_id, 'page_load.url') AS url,
  upid AS browser_upid
FROM process_slice
WHERE name = 'PageLoadMetrics.NavigationToFirstContentfulPaint';

CREATE PERFETTO FUNCTION _page_load_metrics(event_name STRING)
RETURNS TABLE(
  ts LONG,
  dur LONG,
  navigation_id INT,
  browser_upid INT
) AS
SELECT
  ts,
  dur,
  EXTRACT_ARG(arg_set_id, 'page_load.navigation_id')
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    AS navigation_id,
  upid AS browser_upid
FROM process_slice
WHERE name = $event_name;

-- Chrome page loads, including associated high-level metrics and properties.
CREATE PERFETTO TABLE chrome_page_loads(
  -- ID of the navigation and Chrome browser process; this combination is
  -- unique to every individual navigation.
  id INT,
  -- ID of the navigation associated with the page load (i.e. the cross-document
  -- navigation in primary main frame which created this page's main document).
  -- Also note that navigation_id is specific to a given Chrome browser process,
  -- and not globally unique.
  navigation_id INT,
  -- Timestamp of the start of navigation.
  navigation_start_ts INT,
  -- Duration between the navigation start and the first contentful paint event
  -- (web.dev/fcp).
  fcp INT,
  -- Timestamp of the first contentful paint.
  fcp_ts INT,
  -- Duration between the navigation start and the largest contentful paint event
  -- (web.dev/lcp).
  lcp INT,
  -- Timestamp of the largest contentful paint.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  lcp_ts INT,
  -- Timestamp of the DomContentLoaded event:
  -- https://developer.mozilla.org/en-US/docs/Web/API/Document/DOMContentLoaded_event
  dom_content_loaded_event_ts INT,
  -- Timestamp of the window load event:
  -- https://developer.mozilla.org/en-US/docs/Web/API/Window/load_event
  load_event_ts INT,
  -- Timestamp of the page self-reporting as fully loaded through the
  -- performance.mark('mark_fully_loaded') API.
  mark_fully_loaded_ts INT,
  -- Timestamp of the page self-reporting as fully visible through the
  -- performance.mark('mark_fully_visible') API.
  mark_fully_visible_ts INT,
  -- Timestamp of the page self-reporting as fully interactive through the
  -- performance.mark('mark_interactive') API.
  mark_interactive_ts INT,
  -- URL at the page load event.
  url STRING,
  -- The unique process id (upid) of the browser process where the page load occurred.
  browser_upid INT
) AS
SELECT
  ROW_NUMBER() OVER(ORDER BY fcp.ts) AS id,
  fcp.navigation_id,
  fcp.ts AS navigation_start_ts,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  fcp.dur AS fcp,
  fcp.ts + fcp.dur AS fcp_ts,
  lcp.dur AS lcp,
  lcp.dur + lcp.ts AS lcp_ts,
  load_fired.ts AS dom_content_loaded_event_ts,
  start_load.ts AS load_event_ts,
  timing_loaded.ts AS mark_fully_loaded_ts,
  timing_visible.ts AS mark_fully_visible_ts,
  timing_interactive.ts AS mark_interactive_ts,
  fcp.url,
  fcp.browser_upid
FROM _fcp_metrics fcp
LEFT JOIN
  _page_load_metrics('PageLoadMetrics.NavigationToLargestContentfulPaint') lcp
    USING (navigation_id, browser_upid)
LEFT JOIN
  _page_load_metrics('PageLoadMetrics.NavigationToDOMContentLoadedEventFired') load_fired
    USING (navigation_id, browser_upid)
LEFT JOIN
  _page_load_metrics('PageLoadMetrics.NavigationToMainFrameOnLoad') start_load
    USING (navigation_id, browser_upid)
LEFT JOIN
  _page_load_metrics('PageLoadMetrics.UserTimingMarkFullyLoaded') timing_loaded
    USING (navigation_id, browser_upid)
LEFT JOIN
  _page_load_metrics('PageLoadMetrics.UserTimingMarkFullyVisible') timing_visible
    USING (navigation_id, browser_upid)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(LEFT JOIN
  _page_load_metrics('PageLoadMetrics.UserTimingMarkInteractive') timing_interactive
    USING (navigation_id, browser_upid);

)_d3l1m1t3r_"
;

const char kChromeSpeedometer[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

INCLUDE PERFETTO MODULE chrome.speedometer_2_1;
INCLUDE PERFETTO MODULE chrome.speedometer_3;

CREATE PERFETTO FUNCTION _chrome_speedometer_version()
RETURNS STRING
AS
WITH
  num_measures AS (
    SELECT '2.1' AS version, COUNT(*) AS num_measures
    FROM chrome_speedometer_2_1_measure
    UNION ALL
    SELECT '3' AS version, COUNT(*) AS num_measures
    FROM chrome_speedometer_3_measure
  )
SELECT version
FROM num_measures
ORDER BY num_measures DESC
LIMIT 1;

-- Augmented slices for Speedometer measurements.
-- These are the intervals of time Speedometer uses to compute the final score.
-- There are two intervals that are measured for every test: sync and async
CREATE PERFETTO TABLE chrome_speedometer_measure(
  -- Start timestamp of the measure slice
  ts INT,
  -- Duration of the measure slice
  dur INT,
  -- Full measure name
  name STRING,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Speedometer iteration the slice belongs to.
  iteration INT,
  -- Suite name
  suite_name STRING,
  -- Test name
  test_name STRING,
  -- Type of the measure (sync or async)
  measure_type STRING)
AS
WITH
  all_versions AS (
    SELECT '2.1' AS version, * FROM chrome_speedometer_2_1_measure
    UNION ALL
    SELECT '3' AS version, * FROM chrome_speedometer_3_measure
  )
SELECT ts, dur, name, iteration, suite_name, test_name, measure_type
FROM all_versions
WHERE version = _chrome_speedometer_version();

-- Slice that covers one Speedometer iteration.
-- Depending on the Speedometer version these slices might need to be estimated
-- as older versions of Speedometer to not emit marks for this interval. The
-- metrics associated are the same ones Speedometer would output, but note we
-- use ns precision (Speedometer uses ~100us) so the actual values might differ
-- a bit.
CREATE PERFETTO TABLE chrome_speedometer_iteration(
  -- Start timestamp of the iteration
  ts INT,
  -- Duration of the iteration
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  dur INT,
  -- Iteration name
  name STRING,
  -- Iteration number
  iteration INT,
  -- Geometric mean of the suite durations for this iteration.
  geomean DOUBLE,
  -- Speedometer score for this iteration (The total score for a run in the
  -- average of all iteration scores).
  score DOUBLE)
AS
WITH
  all_versions AS (
    SELECT '2.1' AS version, * FROM chrome_speedometer_2_1_iteration
    UNION ALL
    SELECT '3' AS version, * FROM chrome_speedometer_3_iteration
  )
SELECT ts, dur, name, iteration, geomean, score
FROM all_versions
WHERE version = _chrome_speedometer_version();

-- Returns the Speedometer score for all iterations in the trace
CREATE PERFETTO FUNCTION chrome_speedometer_score()
-- Speedometer score
RETURNS DOUBLE
AS
SELECT
  IIF(
    _chrome_speedometer_version() = '3',
    chrome_speedometer_3_score(),
    chrome_speedometer_2_1_score());

)_d3l1m1t3r_"
;

const char kChromeSpeedometer21[] = R"_d3l1m1t3r_(-- Copyright 2024 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- List Speedometer 2.1 tests.
CREATE PERFETTO VIEW _chrome_speedometer_2_1_test_name(
  -- Suite name
  suite_name STRING,
  -- Test name
  test_name STRING)
AS
WITH
  data(suite_name, test_name) AS (
    VALUES('Angular2-TypeScript-TodoMVC', 'Adding100Items'),
    ('Angular2-TypeScript-TodoMVC', 'CompletingAllItems'),
    ('Angular2-TypeScript-TodoMVC', 'DeletingItems'),
    ('AngularJS-TodoMVC', 'Adding100Items'),
    ('AngularJS-TodoMVC', 'CompletingAllItems'),
    ('AngularJS-TodoMVC', 'DeletingAllItems'),
    ('BackboneJS-TodoMVC', 'Adding100Items'),
    ('BackboneJS-TodoMVC', 'CompletingAllItems'),
    ('BackboneJS-TodoMVC', 'DeletingAllItems'),
    ('Elm-TodoMVC', 'Adding100Items'),
    ('Elm-TodoMVC', 'CompletingAllItems'),
    ('Elm-TodoMVC', 'DeletingItems'),
    ('EmberJS-Debug-TodoMVC', 'Adding100Items'),
    ('EmberJS-Debug-TodoMVC', 'CompletingAllItems'),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    ('EmberJS-Debug-TodoMVC', 'DeletingItems'),
    ('EmberJS-TodoMVC', 'Adding100Items'),
    ('EmberJS-TodoMVC', 'CompletingAllItems'),
    ('EmberJS-TodoMVC', 'DeletingItems'),
    ('Flight-TodoMVC', 'Adding100Items'),
    ('Flight-TodoMVC', 'CompletingAllItems'),
    ('Flight-TodoMVC', 'DeletingItems'),
    ('Inferno-TodoMVC', 'Adding100Items'),
    ('Inferno-TodoMVC', 'CompletingAllItems'),
    ('Inferno-TodoMVC', 'DeletingItems'),
    ('Preact-TodoMVC', 'Adding100Items'),
    ('Preact-TodoMVC', 'CompletingAllItems'),
    ('Preact-TodoMVC', 'DeletingItems'),
    ('React-Redux-TodoMVC', 'Adding100Items'),
    ('React-Redux-TodoMVC', 'CompletingAllItems'),
    ('React-Redux-TodoMVC', 'DeletingItems'),
    ('React-TodoMVC', 'Adding100Items'),
    ('React-TodoMVC', 'CompletingAllItems'),
    ('React-TodoMVC', 'DeletingAllItems'),
    ('Vanilla-ES2015-Babel-Webpack-TodoMVC', 'Adding100Items'),
    ('Vanilla-ES2015-Babel-Webpack-TodoMVC', 'CompletingAllItems'),
    ('Vanilla-ES2015-Babel-Webpack-TodoMVC', 'DeletingItems'),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    ('Vanilla-ES2015-TodoMVC', 'Adding100Items'),
    ('Vanilla-ES2015-TodoMVC', 'CompletingAllItems'),
    ('Vanilla-ES2015-TodoMVC', 'DeletingItems'),
    ('VanillaJS-TodoMVC', 'Adding100Items'),
    ('VanillaJS-TodoMVC', 'CompletingAllItems'),
    ('VanillaJS-TodoMVC', 'DeletingAllItems'),
    ('VueJS-TodoMVC', 'Adding100Items'),
    ('VueJS-TodoMVC', 'CompletingAllItems'),
    ('VueJS-TodoMVC', 'DeletingAllItems'),
    ('jQuery-TodoMVC', 'Adding100Items'),
    ('jQuery-TodoMVC', 'CompletingAllItems'),
    ('jQuery-TodoMVC', 'DeletingAllItems')
  )
SELECT suite_name, test_name FROM data;

-- Augmented slices for Speedometer measurements.
-- These are the intervals of time Speedometer uses to compute the final score.
-- There are two intervals that are measured for every test: sync and async
-- sync is the time between the start and sync-end marks, async is the time
-- between the sync-end and async-end marks.
CREATE PERFETTO TABLE chrome_speedometer_2_1_measure(
  -- Start timestamp of the measure slice
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ts INT,
  -- Duration of the measure slice
  dur INT,
  -- Full measure name
  name STRING,
  -- Speedometer iteration the slice belongs to.
  iteration INT,
  -- Suite name
  suite_name STRING,
  -- Test name
  test_name STRING,
  -- Type of the measure (sync or async)
  measure_type STRING)
AS
WITH
  mark_type(mark_type) AS (
    VALUES('start'),
    ('sync-end'),
    ('async-end')
  ),
  -- Make sure we only look at slices with names we expect.
  mark_name AS (
    SELECT
      suite_name || '.' || test_name || '-' || mark_type AS name,
      suite_name,
      test_name,
      mark_type
    FROM
      _chrome_speedometer_2_1_test_name,
      mark_type
  ),
  mark AS (
    SELECT
      s.id AS slice_id,
      RANK() OVER (PARTITION BY name ORDER BY ts ASC) AS iteration,
      m.suite_name,
      m.test_name,
      m.mark_type
    FROM slice AS s
    JOIN mark_name AS m
      USING (name)
    WHERE category = 'blink.user_timing'
  ),
  -- Get the 3 test timestamps (start, sync-end, async-end) in one row. Using a
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- the LAG window function and partitioning by test. 2 out of the 3 rows
  -- generated per test will have some NULL ts values.
  augmented AS (
    SELECT
      iteration,
      suite_name,
      test_name,
      ts AS async_end_ts,
      LAG(ts, 1)
        OVER (PARTITION BY iteration, suite_name, test_name ORDER BY ts ASC)
        AS sync_end_ts,
      LAG(ts, 2)
        OVER (PARTITION BY iteration, suite_name, test_name ORDER BY ts ASC)
        AS start_ts,
      COUNT()
        OVER (PARTITION BY iteration, suite_name, test_name ORDER BY ts ASC)
        AS mark_count
    FROM mark
    JOIN slice
      USING (slice_id)
  ),
  filtered AS (
    SELECT *
    FROM augmented
    -- This server 2 purposes: make sure we have all the marks (think truncated
    -- trace), and remove the NULL ts values due to the LAG window function.
    WHERE mark_count = 3
  ),
  base AS (
    SELECT
      sync_end_ts AS ts,
      async_end_ts - sync_end_ts AS dur,
      iteration,
      suite_name,
      test_name,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      'async' AS measure_type
    FROM filtered
    UNION ALL
    SELECT
      start_ts AS ts,
      sync_end_ts - start_ts AS dur,
      iteration,
      suite_name,
      test_name,
      'sync' AS measure_type
    FROM filtered
  )
SELECT
  ts,
  dur,
  suite_name || '.' || test_name || '-' || measure_type AS name,
  iteration,
  suite_name,
  test_name,
  measure_type
FROM base;

-- Slice that covers one Speedometer iteration.
-- This slice is actually estimated as a default Speedometer run will not emit
-- marks to cover this interval. The metrics associated are the same ones
-- Speedometer would output, but note we use ns precision (Speedometer uses
-- ~100us) so the actual values might differ a bit. Also note Speedometer
-- returns the values in ms these here and in ns.
CREATE PERFETTO TABLE chrome_speedometer_2_1_iteration(
  -- Start timestamp of the iteration
  ts INT,
  -- Duration of the iteration
  dur INT,
  -- Iteration name
  name STRING,
  -- Iteration number
  iteration INT,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Geometric mean of the suite durations for this iteration.
  geomean DOUBLE,
  -- Speedometer score for this iteration (The total score for a run in the
  -- average of all iteration scores).
  score DOUBLE)
AS
SELECT
  MIN(start) AS ts,
  MAX(END) - MIN(start) AS dur,
  'iteration-' || iteration AS name,
  iteration,
  -- Compute geometric mean using LN instead of multiplication to prevent
  -- overflows
  EXP(AVG(LN(suite_total))) AS geomean,
  1000 / EXP(AVG(LN(suite_total))) * 60 / 3 AS score
FROM
  (
    SELECT
      iteration,
      SUM(dur / (1000.0 * 1000.0)) AS suite_total,
      MIN(ts) AS start,
      MAX(ts + dur) AS END
    FROM chrome_speedometer_2_1_measure
    GROUP BY suite_name, iteration
  )
GROUP BY iteration;

-- Returns the Speedometer 2.1 score for all iterations in the trace
CREATE PERFETTO FUNCTION chrome_speedometer_2_1_score()
-- Speedometer 2.1 score
RETURNS DOUBLE
AS
SELECT AVG(score) FROM chrome_speedometer_2_1_iteration;

)_d3l1m1t3r_"
;

const char kChromeSpeedometer3[] = R"_d3l1m1t3r_(-- Copyright 2024 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- List Speedometer 3 tests.
CREATE PERFETTO VIEW _chrome_speedometer_3_test_name(
  -- Suite name
  suite_name STRING,
  -- Test name
  test_name STRING)
AS
WITH
  data(suite_name, test_name) AS (
    VALUES('TodoMVC-JavaScript-ES5', 'Adding100Items'),
    ('TodoMVC-JavaScript-ES5', 'CompletingAllItems'),
    ('TodoMVC-JavaScript-ES5', 'DeletingAllItems'),
    ('TodoMVC-JavaScript-ES6-Webpack-Complex-DOM', 'Adding100Items'),
    ('TodoMVC-JavaScript-ES6-Webpack-Complex-DOM', 'CompletingAllItems'),
    ('TodoMVC-JavaScript-ES6-Webpack-Complex-DOM', 'DeletingAllItems'),
    ('TodoMVC-WebComponents', 'Adding100Items'),
    ('TodoMVC-WebComponents', 'CompletingAllItems'),
    ('TodoMVC-WebComponents', 'DeletingAllItems'),
    ('TodoMVC-React-Complex-DOM', 'Adding100Items'),
    ('TodoMVC-React-Complex-DOM', 'CompletingAllItems'),
    ('TodoMVC-React-Complex-DOM', 'DeletingAllItems'),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    ('TodoMVC-React-Redux', 'Adding100Items'),
    ('TodoMVC-React-Redux', 'CompletingAllItems'),
    ('TodoMVC-React-Redux', 'DeletingAllItems'),
    ('TodoMVC-Backbone', 'Adding100Items'),
    ('TodoMVC-Backbone', 'CompletingAllItems'),
    ('TodoMVC-Backbone', 'DeletingAllItems'),
    ('TodoMVC-Angular-Complex-DOM', 'Adding100Items'),
    ('TodoMVC-Angular-Complex-DOM', 'CompletingAllItems'),
    ('TodoMVC-Angular-Complex-DOM', 'DeletingAllItems'),
    ('TodoMVC-Vue', 'Adding100Items'),
    ('TodoMVC-Vue', 'CompletingAllItems'),
    ('TodoMVC-Vue', 'DeletingAllItems'),
    ('TodoMVC-jQuery', 'Adding100Items'),
    ('TodoMVC-jQuery', 'CompletingAllItems'),
    ('TodoMVC-jQuery', 'DeletingAllItems'),
    ('TodoMVC-Preact-Complex-DOM', 'Adding100Items'),
    ('TodoMVC-Preact-Complex-DOM', 'CompletingAllItems'),
    ('TodoMVC-Preact-Complex-DOM', 'DeletingAllItems'),
    ('TodoMVC-Svelte-Complex-DOM', 'Adding100Items'),
    ('TodoMVC-Svelte-Complex-DOM', 'CompletingAllItems'),
    ('TodoMVC-Svelte-Complex-DOM', 'DeletingAllItems'),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    ('TodoMVC-Lit-Complex-DOM', 'Adding100Items'),
    ('TodoMVC-Lit-Complex-DOM', 'CompletingAllItems'),
    ('TodoMVC-Lit-Complex-DOM', 'DeletingAllItems'),
    ('NewsSite-Next', 'NavigateToUS'),
    ('NewsSite-Next', 'NavigateToWorld'),
    ('NewsSite-Next', 'NavigateToPolitics'),
    ('NewsSite-Nuxt', 'NavigateToUS'),
    ('NewsSite-Nuxt', 'NavigateToWorld'),
    ('NewsSite-Nuxt', 'NavigateToPolitics'),
    ('Editor-CodeMirror', 'Long'),
    ('Editor-CodeMirror', 'Highlight'),
    ('Editor-TipTap', 'Long'),
    ('Editor-TipTap', 'Highlight'),
    ('Charts-observable-plot', 'Stacked by 6'),
    ('Charts-observable-plot', 'Stacked by 20'),
    ('Charts-observable-plot', 'Dotted'),
    ('Charts-chartjs', 'Draw scatter'),
    ('Charts-chartjs', 'Show tooltip'),
    ('Charts-chartjs', 'Draw opaque scatter'),
    ('React-Stockcharts-SVG', 'Render'),
    ('React-Stockcharts-SVG', 'PanTheChart'),
    ('React-Stockcharts-SVG', 'ZoomTheChart'),
    ('Perf-Dashboard', 'Render'),
    ('Perf-Dashboard', 'SelectingPoints'),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    ('Perf-Dashboard', 'SelectingRange')
  )
SELECT suite_name, test_name FROM data;

CREATE
  PERFETTO MACRO _chrome_speedometer_iteration_slice()
RETURNS TableOrSubquery
AS (
  SELECT
    *,
    substr(name, 1 + length('iteration-')) AS iteration
  FROM
    slice
  WHERE
    category = 'blink.user_timing'
    AND name GLOB 'iteration-*'
    AND iteration = CAST(iteration AS INTEGER)
);

-- Augmented slices for Speedometer measurements.
-- These are the intervals of time Speedometer uses to compute the final score.
-- There are two intervals that are measured for every test: sync and async.
CREATE PERFETTO TABLE chrome_speedometer_3_measure(
  -- Start timestamp of the measure slice
  ts INT,
  -- Duration of the measure slice
  dur INT,
  -- Full measure name
  name STRING,
  -- Speedometer iteration the slice belongs to.
  iteration INT,
  -- Suite name
  suite_name STRING,
  -- Test name
  test_name STRING,
  -- Type of the measure (sync or async)
  measure_type STRING)
AS
WITH
  measure_type(measure_type) AS (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    VALUES('sync'),
    ('async')
  ),
  measure_name AS (
    SELECT
      suite_name || '.' || test_name || '-' || measure_type AS name,
      suite_name,
      test_name,
      measure_type
    FROM
      _chrome_speedometer_3_test_name,
      measure_type
  ),
  measure_slice AS (
    SELECT
      s.ts,
      s.dur,
      s.name,
      m.suite_name,
      m.test_name,
      m.measure_type
    FROM
      slice s,
      measure_name AS m
    USING (name)
    WHERE
      s.category = 'blink.user_timing'
  )
SELECT
  s.ts,
  s.dur,
  s.name,
  i.iteration,
  s.suite_name,
  s.test_name,
  s.measure_type
FROM
  measure_slice AS s,
  _chrome_speedometer_iteration_slice !() AS i
ON (s.ts >= i.ts AND s.ts < i.ts + i.dur)
ORDER BY s.ts ASC;

-- Slice that covers one Speedometer iteration.
-- The metrics associated are the same ones
-- Speedometer would output, but note we use ns precision (Speedometer uses
-- ~100us) so the actual values might differ a bit.
CREATE PERFETTO TABLE chrome_speedometer_3_iteration(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Start timestamp of the iteration
  ts INT,
  -- Duration of the iteration
  dur INT,
  -- Iteration name
  name STRING,
  -- Iteration number
  iteration INT,
  -- Geometric mean of the suite durations for this iteration.
  geomean DOUBLE,
  -- Speedometer score for this iteration (The total score for a run in the
  -- average of all iteration scores).
  score DOUBLE)
AS
WITH
  suite AS (
    SELECT
      iteration, suite_name, SUM(dur / (1000.0 * 1000.0)) AS suite_total
    FROM chrome_speedometer_3_measure
    GROUP BY iteration, suite_name
  ),
  iteration AS (
    SELECT
      iteration,
      -- Compute geometric mean using LN instead of multiplication to prevent
      -- overflows
      EXP(AVG(LN(suite_total))) AS geomean
    FROM suite
    GROUP BY iteration
  )
SELECT
  s.ts,
  s.dur,
  s.name,
  i.iteration,
  i.geomean,
  1000.0 / i.geomean AS score
FROM iteration AS i, _chrome_speedometer_iteration_slice !() AS s
USING (iteration);

-- Returns the Speedometer 3 score for all iterations in the trace
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO FUNCTION chrome_speedometer_3_score()
-- Speedometer 3 score
RETURNS DOUBLE
AS
SELECT AVG(score) FROM chrome_speedometer_3_iteration;

)_d3l1m1t3r_"
;

const char kChromeStartups[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

INCLUDE PERFETTO MODULE slices.with_context;

-- Access all startups, including those that don't lead to any visible content.
-- If TimeToFirstVisibleContent is available, then this event will be the
-- main event of the startup. Otherwise, the event for the start timestamp will
-- be used.
CREATE PERFETTO VIEW _startup_start_events AS
WITH
starts AS (
  SELECT
    name,
    EXTRACT_ARG(arg_set_id, 'startup.activity_id') AS activity_id,
    ts,
    dur,
    upid AS browser_upid
  FROM thread_slice
  WHERE name = 'Startup.ActivityStart'
),
times_to_first_visible_content AS (
  SELECT
    name,
    EXTRACT_ARG(arg_set_id, 'startup.activity_id') AS activity_id,
    ts,
    dur,
    upid AS browser_upid
  FROM process_slice
  WHERE name = 'Startup.TimeToFirstVisibleContent2'
),
all_activity_ids AS (
  SELECT
    DISTINCT activity_id,
    browser_upid
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  FROM starts
  UNION ALL
  SELECT
    DISTINCT activity_id,
    browser_upid
  FROM times_to_first_visible_content
),
activity_ids AS (
  SELECT
    DISTINCT activity_id,
    browser_upid
  FROM all_activity_ids
)
SELECT
  activity_ids.activity_id,
  'Startup' AS name,
  IFNULL(times_to_first_visible_content.ts, starts.ts) AS startup_begin_ts,
  times_to_first_visible_content.ts +
    times_to_first_visible_content.dur AS first_visible_content_ts,
  activity_ids.browser_upid
FROM activity_ids
  LEFT JOIN times_to_first_visible_content using(activity_id, browser_upid)
  LEFT JOIN starts using(activity_id, browser_upid);

-- Chrome launch causes, not recorded at start time; use the activity id to
-- join with the actual startup events.
CREATE PERFETTO VIEW _launch_causes AS
SELECT
  EXTRACT_ARG(arg_set_id, 'startup.activity_id') AS activity_id,
  EXTRACT_ARG(arg_set_id, 'startup.launch_cause') AS launch_cause,
  upid AS browser_upid
FROM thread_slice
WHERE name = 'Startup.LaunchCause';

)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- Chrome startups, including launch cause.
CREATE PERFETTO TABLE chrome_startups(
  -- Unique ID
  id INT,
  -- Chrome Activity event id of the launch.
  activity_id INT,
  -- Name of the launch start event.
  name STRING,
  -- Timestamp that the startup occurred.
  startup_begin_ts INT,
  -- Timestamp to the first visible content.
  first_visible_content_ts INT,
  -- Launch cause. See Startup.LaunchCauseType in chrome_track_event.proto.
  launch_cause STRING,
  -- Process ID of the Browser where the startup occurred.
  browser_upid INT
) AS
SELECT
  ROW_NUMBER() OVER (ORDER BY start_events.startup_begin_ts) AS id,
  start_events.activity_id,
  start_events.name,
  start_events.startup_begin_ts,
  start_events.first_visible_content_ts,
  launches.launch_cause,
  start_events.browser_upid
FROM _startup_start_events start_events
  LEFT JOIN _launch_causes launches
  USING(activity_id, browser_upid);

)_d3l1m1t3r_"
;

const char kChromeTasks[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- Checks if slice has an ancestor with provided name.
CREATE PERFETTO FUNCTION _has_parent_slice_with_name(
  -- Id of the slice to check parents of.
  id INT,
  -- Name of potential ancestor slice.
  parent_name STRING)
-- Whether `parent_name` is a name of an ancestor slice.
RETURNS BOOL AS
SELECT EXISTS(
  SELECT 1
  FROM ancestor_slice($id)
  WHERE name = $parent_name
  LIMIT 1
);

-- Returns the mojo ipc hash for a given task, looking it up from the
-- argument of descendant ScopedSetIpcHash slice.
-- This is relevant only for the older Chrome traces, where mojo IPC
-- hash was reported in a separate ScopedSetIpcHash slice.
CREATE PERFETTO FUNCTION _extract_mojo_ipc_hash(slice_id INT)
RETURNS INT AS
SELECT EXTRACT_ARG(arg_set_id, "chrome_mojo_event_info.ipc_hash")
FROM descendant_slice($slice_id)
WHERE name="ScopedSetIpcHash"
ORDER BY id
LIMIT 1;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Returns the frame type (main frame vs subframe) for key navigation tasks
-- which capture the associated RenderFrameHost in an argument.
CREATE PERFETTO FUNCTION _extract_frame_type(slice_id INT)
RETURNS INT AS
SELECT EXTRACT_ARG(arg_set_id, "render_frame_host.frame_type")
FROM descendant_slice($slice_id)
WHERE name IN (
  "RenderFrameHostImpl::BeginNavigation",
  "RenderFrameHostImpl::DidCommitProvisionalLoad",
  "RenderFrameHostImpl::DidCommitSameDocumentNavigation",
  "RenderFrameHostImpl::DidStopLoading"
)
LIMIT 1;

-- Human-readable aliases for a few key navigation tasks.
CREATE PERFETTO FUNCTION _human_readable_navigation_task_name(
  task_name STRING)
RETURNS STRING AS
SELECT
  CASE
    WHEN $task_name = "content.mojom.FrameHost message (hash=2168461044)"
      THEN "FrameHost::BeginNavigation"
    WHEN $task_name = "content.mojom.FrameHost message (hash=3561497419)"
      THEN "FrameHost::DidCommitProvisionalLoad"
    WHEN $task_name = "content.mojom.FrameHost message (hash=1421450774)"
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      THEN "FrameHost::DidCommitSameDocumentNavigation"
    WHEN $task_name = "content.mojom.FrameHost message (hash=368650583)"
      THEN "FrameHost::DidStopLoading"
  END;

-- Takes a task name and formats it correctly for scheduler tasks.
CREATE PERFETTO FUNCTION _format_scheduler_task_name(task_name STRING)
RETURNS STRING AS
SELECT printf("RunTask(posted_from=%s)", $task_name);

-- Takes the category and determines whether it is "Java" only, as opposed to
-- "toplevel,Java".
CREATE PERFETTO FUNCTION _java_not_top_level_category(category STRING)
RETURNS BOOL AS
SELECT $category GLOB "*Java*" AND $category not GLOB "*toplevel*";

-- Takes the category and determines whether is any valid
-- toplevel category or combination of categories.
CREATE PERFETTO FUNCTION _any_top_level_category(category STRING)
RETURNS BOOL AS
SELECT $category IN ("toplevel", "toplevel,viz", "toplevel,Java");

-- TODO(altimin): the situations with kinds in this file is a bit of a mess.
-- The idea is that it should work as `type` in the `slice` table, pointing to
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- a "child" table with more information about the task (e.g. posted_from for
-- scheduler tasks). Currently this is not the case and needs a cleanup.
-- Also we should align this with how table inheritance should work for
-- `CREATE PERFETTO TABLE`.

-- Get task type for a given task kind.
CREATE PERFETTO FUNCTION _get_java_views_task_type(kind STRING)
RETURNS STRING AS
SELECT
  CASE $kind
    WHEN "Choreographer" THEN "choreographer"
    WHEN "SingleThreadProxy::BeginMainFrame" THEN "ui_thread_begin_main_frame"
  END;

-- All slices corresponding to receiving mojo messages.
-- On the newer Chrome versions, it's just "Receive mojo message" and
-- "Receive mojo reply" slices (or "Receive {mojo_message_name}" if
-- built with `extended_tracing_enabled`. On legacy Chrome versions,
-- other appropriate messages (like "Connector::DispatchMessage") are used.
--
-- @column STRING interface_name    Name of the IPC interface.
-- @column INT ipc_hash             Hash of a message name.
-- @column STRING message_type      Either 'message' or 'reply'.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column INT id                   Slice id.
--
-- Note: this might include messages received within a sync mojo call.
-- TODO(altimin): This should use EXTEND_TABLE when it becomes available.
CREATE TABLE _chrome_mojo_slices AS
WITH
-- Select all new-style (post crrev.com/c/3270337) mojo slices and
-- generate |task_name| for them.
-- If extended tracing is enabled, the slice name will have the full method
-- name (i.e. "Receive content::mojom::FrameHost::DidStopLoading") and we
-- should use it as a full name.
-- If extended tracing is not enabled, we should include the interface name
-- and method hash into the full name.
new_mojo_slices AS (
  SELECT
    EXTRACT_ARG(arg_set_id, "chrome_mojo_event_info.mojo_interface_tag") AS interface_name,
    EXTRACT_ARG(arg_set_id, "chrome_mojo_event_info.ipc_hash") AS ipc_hash,
    CASE name
      WHEN "Receive mojo message" THEN "message"
      WHEN "Receive mojo reply" THEN "reply"
    END AS message_type,
    id
  FROM slice
  WHERE
    category GLOB '*toplevel*'
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    AND name GLOB 'Receive *'
),
-- Select old-style slices for channel-associated mojo events.
old_associated_mojo_slices AS (
  SELECT
    name AS interface_name,
    _extract_mojo_ipc_hash(id) AS ipc_hash,
    "message" AS message_type,
    id
  FROM slice
  WHERE
    category GLOB "*mojom*"
    AND name GLOB '*.mojom.*'
),
-- Select old-style slices for non-(channel-associated) mojo events.
old_non_associated_mojo_slices AS (
  SELECT
    COALESCE(
      EXTRACT_ARG(arg_set_id, "chrome_mojo_event_info.watcher_notify_interface_tag"),
      EXTRACT_ARG(arg_set_id, "chrome_mojo_event_info.mojo_interface_tag")
    ) AS interface_name,
    _extract_mojo_ipc_hash(id) AS ipc_hash,
    "message" AS message_type,
    id
  FROM slice
  WHERE
    category GLOB "*toplevel*" AND name = "Connector::DispatchMessage"
)
-- Merge all mojo slices.
SELECT * FROM new_mojo_slices
UNION ALL
SELECT * FROM old_associated_mojo_slices
UNION ALL
SELECT * FROM old_non_associated_mojo_slices;

-- As we lookup by ID on |_chrome_mojo_slices| table, add an index on
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- id to make lookups fast.
CREATE INDEX _chrome_mojo_slices_idx ON _chrome_mojo_slices(id);

-- This table contains a list of slices corresponding to the _representative_
-- Chrome Java view operations.
-- These are the outermost Java view slices after filtering out generic framework views
-- (like FitWindowsLinearLayout) and selecting the outermost slices from the remaining ones.
--
-- @column id INT                       Slice id.
-- @column ts INT                       Timestamp.
-- @column dur INT                      Duration.
-- @column name STRING                  Name of the view.
-- @column is_software_screenshot BOOL  Whether this slice is a part of non-accelerated
--                                      capture toolbar screenshot.
-- @column is_hardware_screenshot BOOL  Whether this slice is a part of accelerated
--                                      capture toolbar screenshot.
CREATE TABLE _chrome_java_views AS
WITH
-- .draw, .onLayout and .onMeasure parts of the java view names don't add much, strip them.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(java_slices_with_trimmed_names AS (
  SELECT
    id,
    REPLACE(
      REPLACE(
        REPLACE(
          REPLACE(
            REPLACE(
              s1.name,
              ".draw", ""),
            ".onLayout", ""),
          ".onMeasure", ""),
        ".Layout", ""),
      ".Measure", "") AS name,
      ts,
      dur
    FROM
      slice s1
    -- Ensure that toplevel Java slices are not included, as they may be logged
    -- with either category = "toplevel" or category = "toplevel,Java".
    -- Also filter out the zero duration slices as an attempt to reduce noise as
    -- "Java" category contains misc events (as it's hard to add new categories).
    WHERE _java_not_top_level_category(category) AND dur > 0
  ),
  -- We filter out generic slices from various UI frameworks which don't tell us much about
  -- what exactly this view is doing.
  interesting_java_slices AS (
    SELECT
      id, name, ts, dur
    FROM java_slices_with_trimmed_names
    WHERE NOT name IN (
      -- AndroidX.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      "FitWindowsFrameLayout",
      "FitWindowsLinearLayout",
      "ContentFrameLayout",
      "CoordinatorLayout",
      -- Other non-Chrome UI libraries.
      "ComponentHost",
      -- Generic Chrome frameworks.
      "CompositorView:finalizeLayers",
      "CompositorViewHolder",
      "CompositorViewHolder:layout",
      "CompositorViewHolder:updateContentViewChildrenDimension",
      "CoordinatorLayoutForPointer",
      "OptimizedFrameLayout",
      "ViewResourceAdapter:getBitmap",
      "ViewResourceFrameLayout",
      -- Non-specific Chrome slices.
      "AppCompatImageButton",
      "ScrollingBottomViewResourceFrameLayout",
      -- Screenshots get their custom annotations below.
      "ViewResourceAdapter:captureWithHardwareDraw",
      "ViewResourceAdapter:captureWithSoftwareDraw",
      -- Non-bytecode generated slices.
      "LayoutDriver:onUpdate"
    )
)
SELECT
  s1.*,
  -- While the parent slices are too generic to be used by themselves,
  -- they can provide some useful metadata.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  _has_parent_slice_with_name(
    s1.id,
    "ViewResourceAdapter:captureWithSoftwareDraw"
  ) AS is_software_screenshot,
  _has_parent_slice_with_name(
    s1.id,
    "ViewResourceAdapter:captureWithHardwareDraw"
  ) AS is_hardware_screenshot
FROM interesting_java_slices s1
-- We select "outermost" interesting slices: interesting slices which
-- do not another interesting slice in their parent chain.
WHERE (SELECT count()
  FROM ancestor_slice(s1.id) s2
  JOIN interesting_java_slices s3 ON s2.id = s3.id) = 0;

-- A list of slices corresponding to operations on interesting (non-generic)
-- Chrome Java views. The view is considered interested if it's not a system
-- (ContentFrameLayout) or generic library (CompositorViewHolder) views.
--
-- TODO(altimin): Add "columns_from slice" annotation.
-- TODO(altimin): convert this to EXTEND_TABLE when it becomes available.
CREATE PERFETTO VIEW chrome_java_views(
  -- Name of the view.
  filtered_name STRING,
  -- Whether this slice is a part of non-accelerated capture toolbar screenshot.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  is_software_screenshot BOOL,
  -- Whether this slice is a part of accelerated capture toolbar screenshot.
  is_hardware_screenshot BOOL,
  -- Slice id.
  slice_id INT
) AS
SELECT
  java_view.name AS filtered_name,
  java_view.is_software_screenshot,
  java_view.is_hardware_screenshot,
  slice.id as slice_id
FROM _chrome_java_views java_view
JOIN slice USING (id);

-- A list of Choreographer tasks (Android frame generation) in Chrome.
CREATE PERFETTO VIEW _chrome_choreographer_tasks
AS
SELECT
  id,
  "Choreographer" AS kind,
  ts,
  dur,
  name
FROM slice
WHERE name GLOB "Looper.dispatch: android.view.Choreographer$FrameHandler*";

-- Extract task's posted_from information from task's arguments.
CREATE PERFETTO FUNCTION _get_posted_from(arg_set_id INT)
RETURNS STRING AS
WITH posted_from as (
  SELECT
    EXTRACT_ARG($arg_set_id, "task.posted_from.file_name") AS file_name,
    EXTRACT_ARG($arg_set_id, "task.posted_from.function_name") AS function_name
)
SELECT file_name || ":" || function_name as posted_from
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM posted_from;

-- Selects the BeginMainFrame slices (which as posted from ScheduledActionSendBeginMainFrame),
-- used for root-level processing. In top-level/Java based slices, these will correspond to the
-- ancestor of descendant slices; in long-task tracking, these tasks will be
-- on a custom track and will need to be associated with children by timestamp
-- and duration. Corresponds with the Choreographer root slices in
-- chrome_choreographer_tasks below.
--
-- Schema:
-- @column is            The slice id.
-- @column kind          The type of Java slice.
-- @column ts            The timestamp of the slice.
-- @column name          The name of the slice.
CREATE PERFETTO FUNCTION _select_begin_main_frame_java_slices(
  name STRING)
RETURNS TABLE(id INT, kind STRING, ts LONG, dur LONG, name STRING) AS
SELECT
  id,
  "SingleThreadProxy::BeginMainFrame" AS kind,
  ts,
  dur,
  name
FROM slice
WHERE
  (name = $name
    AND _get_posted_from(arg_set_id) =
        "cc/trees/single_thread_proxy.cc:ScheduledActionSendBeginMainFrame");
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- A list of Chrome tasks which were performing operations with Java views,
-- together with the names of these views.
-- @column id INT            Slice id.
-- @column kind STRING       Type of the task.
-- @column java_views STRING Concatenated names of Java views used by the task.
CREATE PERFETTO VIEW _chrome_slices_with_java_views AS
WITH
  -- Select UI thread BeginMainFrames (which are Chrome scheduler tasks) and
  -- Choreographer frames (which are looper tasks).
  root_slices AS (
    SELECT id, kind
    FROM _SELECT_BEGIN_MAIN_FRAME_JAVA_SLICES('ThreadControllerImpl::RunTask')
    UNION ALL
    SELECT id, kind FROM _chrome_choreographer_tasks
  ),
  -- Intermediate step to allow us to sort java view names.
  root_slice_and_java_view_not_grouped AS (
    SELECT
      root.id, root.kind, java_view.name AS java_view_name
    FROM root_slices root
    JOIN descendant_slice(root.id) child
    JOIN _chrome_java_views java_view ON java_view.id = child.id
  )
SELECT
  root.id,
  root.kind,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  GROUP_CONCAT(DISTINCT java_view.java_view_name) AS java_views
FROM root_slices root
LEFT JOIN root_slice_and_java_view_not_grouped java_view USING (id)
GROUP BY root.id;

-- A list of tasks executed by Chrome scheduler.
CREATE TABLE _chrome_scheduler_tasks AS
SELECT
  id
FROM slice
WHERE
  category GLOB "*toplevel*"
  AND (name = "ThreadControllerImpl::RunTask" OR name = "ThreadPool_RunTask")
ORDER BY id;

-- A list of tasks executed by Chrome scheduler.
CREATE PERFETTO VIEW chrome_scheduler_tasks(
  -- Slice id.
  id INT,
  -- Type.
  type STRING,
  -- Name of the task.
  name STRING,
  -- Timestamp.
  ts INT,
  -- Duration.
  dur INT,
  -- Utid of the thread this task run on.
  utid INT,
  -- Name of the thread this task run on.
  thread_name STRING,
  -- Upid of the process of this task.
  upid INT,
  -- Name of the process of this task.
  process_name STRING,
  -- Same as slice.track_id.
  track_id INT,
  -- Same as slice.category.
  category STRING,
  -- Same as slice.depth.
  depth INT,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Same as slice.parent_id.
  parent_id INT,
  -- Same as slice.arg_set_id.
  arg_set_id INT,
  -- Same as slice.thread_ts.
  thread_ts INT,
  -- Same as slice.thread_dur.
  thread_dur INT,
  -- Source location where the PostTask was called.
  posted_from STRING
) AS
SELECT
  task.id,
  "chrome_scheduler_tasks" as type,
  _format_scheduler_task_name(
    _get_posted_from(slice.arg_set_id)) as name,
  slice.ts,
  slice.dur,
  thread.utid,
  thread.name as thread_name,
  process.upid,
  process.name as process_name,
  slice.track_id,
  slice.category,
  slice.depth,
  slice.parent_id,
  slice.arg_set_id,
  slice.thread_ts,
  slice.thread_dur,
  _get_posted_from(slice.arg_set_id) as posted_from
FROM _chrome_scheduler_tasks task
JOIN slice using (id)
JOIN thread_track ON slice.track_id = thread_track.id
JOIN thread using (utid)
JOIN process using (upid)
ORDER BY task.id;

-- Select the slice that might be the descendant mojo slice for the given task
-- slice if it exists.
CREATE PERFETTO FUNCTION _get_descendant_mojo_slice_candidate(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  slice_id INT
)
RETURNS INT AS
SELECT
  id
FROM descendant_slice($slice_id)
WHERE
  -- The tricky case here is dealing with sync mojo IPCs: we do not want to
  -- pick up sync IPCs when we are in a non-IPC task.
  -- So we look at all toplevel events and pick up the first one:
  -- for sync mojo messages, it will be "Send mojo message", which then
  -- will fail.
  -- Some events are excluded as they can legimately appear under "RunTask"
  -- before "Receive mojo message".
  category GLOB "*toplevel*" AND
  name NOT IN (
    "SimpleWatcher::OnHandleReady",
    "MessagePipe peer closed")
ORDER by depth, ts
LIMIT 1;

CREATE PERFETTO FUNCTION _descendant_mojo_slice(slice_id INT)
RETURNS TABLE(task_name STRING) AS
SELECT
  printf("%s %s (hash=%d)",
    mojo.interface_name, mojo.message_type, mojo.ipc_hash) AS task_name
FROM slice task
JOIN _chrome_mojo_slices mojo
  ON mojo.id = _get_descendant_mojo_slice_candidate($slice_id)
WHERE task.id = $slice_id;

-- A list of "Chrome tasks": top-level execution units (e.g. scheduler tasks /
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- IPCs / system callbacks) run by Chrome. For a given thread, the tasks
-- will not intersect.
--
-- @column task_name STRING  Name for the given task.
-- @column task_type STRING  Type of the task (e.g. "scheduler").
-- @column scheduling_delay INT
CREATE TABLE _chrome_tasks AS
WITH
-- Select slices from "toplevel" category which do not have another
-- "toplevel" slice as ancestor. The possible cases include sync mojo messages
-- and tasks in nested runloops. Toplevel events may also be logged as with
-- the Java category.
non_embedded_toplevel_slices AS (
  SELECT * FROM slice
  WHERE
    _any_top_level_category(category)
    AND (SELECT count() FROM ancestor_slice(slice.id) anc
      WHERE anc.category GLOB "*toplevel*" or anc.category GLOB "*toplevel.viz*") = 0
),
-- Select slices from "Java" category which do not have another "Java" or
-- "toplevel" slice as parent. In the longer term they should probably belong
-- to "toplevel" category as well, but for now this will have to do. Ensure
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- that "Java" slices do not include "toplevel" slices as those would be
-- handled elsewhere.
non_embedded_java_slices AS (
  SELECT
    id,
    name AS task_name,
    "java" as task_type
  FROM slice s
  WHERE
    _java_not_top_level_category(category)
    AND (SELECT count()
      FROM ancestor_slice(s.id) s2
      WHERE s2.category GLOB "*toplevel*" OR s2.category GLOB "*Java*") = 0
),
-- Generate full names for tasks with java views.
java_views_tasks AS (
  SELECT
    id,
    printf('%s(java_views=%s)', kind, java_views) AS task_name,
    _get_java_views_task_type(kind) AS task_type
  FROM _chrome_slices_with_java_views
),
scheduler_tasks AS (
  SELECT
    id,
    name as task_name,
    "scheduler" as task_type
  FROM chrome_scheduler_tasks
),
-- Select scheduler tasks which are used to run mojo messages and use the mojo names
-- as full names for these slices.
-- We restrict this to specific scheduler tasks which are expected to run mojo
-- tasks due to sync mojo events, which also emit similar events.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(scheduler_tasks_with_mojo AS (
  SELECT
    -- We use the "RunTask" as the task, and pick up the name from its child
    -- "Receive mojo message" event.
    task.id,
    receive_message.task_name,
    "mojo" AS task_type
  FROM
    chrome_scheduler_tasks task
  JOIN _DESCENDANT_MOJO_SLICE(task.id) receive_message
  WHERE
    task.posted_from IN (
      "mojo/public/cpp/system/simple_watcher.cc:Notify",
      "mojo/public/cpp/system/simple_watcher.cc:ArmOrNotify",
      "mojo/public/cpp/bindings/lib/connector.cc:PostDispatchNextMessageFromPipe",
      "ipc/ipc_mojo_bootstrap.cc:Accept")
),
navigation_tasks AS (
  WITH tasks_with_readable_names AS (
    SELECT
      id,
      _human_readable_navigation_task_name(task_name) as readable_name,
      IFNULL(_extract_frame_type(id), 'unknown frame type') as frame_type
    FROM
      scheduler_tasks_with_mojo
  )
  SELECT
    id,
    printf("%s (%s)", readable_name, frame_type) as task_name,
    'navigation_task' AS task_type
  FROM tasks_with_readable_names
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  WHERE readable_name IS NOT NULL
),
-- Add scheduler and mojo full names to non-embedded slices from
-- the "toplevel" category, with mojo ones taking precedence.
non_embedded_toplevel_slices_with_task_name AS (
  SELECT
    task.id AS id,
    COALESCE(
        navigation.task_name,
        java_views.task_name,
        mojo.task_name,
        scheduler.task_name,
        task.name
    ) AS name,
    COALESCE(
        navigation.task_type,
        java_views.task_type,
        mojo.task_type,
        scheduler.task_type,
        "other"
    ) AS task_type
  FROM non_embedded_toplevel_slices task
  LEFT JOIN scheduler_tasks_with_mojo mojo ON mojo.id = task.id
  LEFT JOIN scheduler_tasks scheduler ON scheduler.id = task.id
  LEFT JOIN java_views_tasks java_views ON java_views.id = task.id
  LEFT JOIN navigation_tasks navigation ON navigation.id = task.id
)
-- Merge slices from toplevel and Java categories.
SELECT * FROM non_embedded_toplevel_slices_with_task_name
UNION ALL
SELECT * FROM non_embedded_java_slices
)_d3l1m1t3r_"
R"_d3l1m1t3r_(ORDER BY id;

-- A list of "Chrome tasks": top-level execution units (e.g. scheduler tasks /
-- IPCs / system callbacks) run by Chrome. For a given thread, the slices
-- corresponding to these tasks will not intersect.
CREATE PERFETTO VIEW chrome_tasks(
  -- Id for the given task, also the id of the slice this task corresponds to.
  id INT,
  -- Name for the given task.
  name STRING,
  -- Type of the task (e.g. "scheduler").
  task_type STRING,
  -- Thread name.
  thread_name STRING,
  -- Utid.
  utid INT,
  -- Process name.
  process_name STRING,
  -- Upid.
  upid INT,
  -- Alias of |slice.ts|.
  ts INT,
  -- Alias of |slice.dur|.
  dur INT,
  -- Alias of |slice.track_id|.
  track_id INT,
  -- Alias of |slice.category|.
  category INT,
  -- Alias of |slice.arg_set_id|.
  arg_set_id INT,
  -- Alias of |slice.thread_ts|.
  thread_ts INT,
  -- Alias of |slice.thread_dur|.
  thread_dur INT,
  -- STRING    Legacy alias for |name|.
  full_name STRING
) AS
SELECT
  cti.id,
  cti.name,
  task_type,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  thread.name AS thread_name,
  thread.utid,
  process.name AS process_name,
  thread.upid,
  s.ts,
  s.dur,
  s.track_id,
  s.category,
  s.arg_set_id,
  s.thread_ts,
  s.thread_dur,
  cti.name as full_name
FROM _chrome_tasks cti
JOIN slice s ON cti.id = s.id
JOIN thread_track tt ON s.track_id = tt.id
JOIN thread USING (utid)
JOIN process USING (upid);

)_d3l1m1t3r_"
;

const char kChromeVsyncIntervals[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- A simple table that checks the time between VSync (this can be used to
-- determine if we're refreshing at 90 FPS or 60 FPS).
--
-- Note: In traces without the "Java" category there will be no VSync
--       TraceEvents and this table will be empty.
CREATE PERFETTO TABLE chrome_vsync_intervals(
  -- Slice id of the vsync slice.
  slice_id INT,
  -- Timestamp of the vsync slice.
  ts INT,
  -- Duration of the vsync slice.
  dur INT,
  -- Track id of the vsync slice.
  track_id INT,
  -- Duration until next vsync arrives.
  time_to_next_vsync INT
) AS
SELECT
  slice_id,
  ts,
  dur,
  track_id,
  LEAD(ts) OVER(PARTITION BY track_id ORDER BY ts) - ts AS time_to_next_vsync
FROM slice
WHERE name = "VSync"
ORDER BY track_id, ts;

-- Function: compute the average Vysnc interval of the
-- gesture (hopefully this would be either 60 FPS for the whole gesture or 90
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- FPS but that isnt always the case) on the given time segment.
-- If the trace doesnt contain the VSync TraceEvent we just fall back on
-- assuming its 60 FPS (this is the 1.6e+7 in the COALESCE which
-- corresponds to 16 ms or 60 FPS).
CREATE PERFETTO FUNCTION chrome_calculate_avg_vsync_interval(
  -- Interval start time.
  begin_ts LONG,
  -- Interval end time.
  end_ts LONG
)
-- The average vsync interval on this time segment
-- or 1.6e+7, if trace doesn't contain the VSync TraceEvent.
RETURNS FLOAT AS
SELECT
  COALESCE((
    SELECT
      CAST(AVG(time_to_next_vsync) AS FLOAT)
    FROM chrome_vsync_intervals in_query
    WHERE
      time_to_next_vsync IS NOT NULL AND
      in_query.ts > $begin_ts AND
      in_query.ts < $end_ts
  ), 1e+9 / 60);

)_d3l1m1t3r_"
;

const char kChromeWebContentInteractions[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

INCLUDE PERFETTO MODULE slices.with_context;

-- Chrome web content interactions (InteractionToFirstPaint), including
-- associated high-level metrics and properties.
--
-- Multiple events may occur for the same interaction; each row in this table
-- represents the primary (longest) event for the interaction.
--
-- Web content interactions are discrete, as opposed to sustained (e.g.
-- scrolling); and only occur with the web content itself, as opposed to other
-- parts of Chrome (e.g. omnibox). Interaction events include taps, clicks,
-- keyboard input (typing), and drags.
CREATE PERFETTO TABLE chrome_web_content_interactions(
  -- Unique id for this interaction.
  id INT,
  -- Start timestamp of the event. Because multiple events may occur for the
  -- same interaction, this is the start timestamp of the longest event.
  ts INT,
  -- Duration of the event. Because multiple events may occur for the same
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- interaction, this is the duration of the longest event.
  dur INT,
  -- The interaction type.
  interaction_type STRING,
  -- The total duration of all events that occurred for the same interaction.
  total_duration_ms INT,
  -- The process id this event occurred on.
  renderer_upid INT
) AS
SELECT
  id,
  ts,
  dur,
  EXTRACT_ARG(arg_set_id, 'web_content_interaction.type') AS interaction_type,
  EXTRACT_ARG(
    arg_set_id,
    'web_content_interaction.total_duration_ms'
  ) AS total_duration_ms,
  upid AS renderer_upid
FROM process_slice
WHERE name = 'Web Interaction';

)_d3l1m1t3r_"
;

const char kChromeScrollJankScrollJankCauseMap[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

INCLUDE PERFETTO MODULE chrome.event_latency_description;

-- Source of truth of the descriptions of EventLatency-based scroll jank causes.
CREATE PERFETTO TABLE chrome_scroll_jank_cause_descriptions (
  -- The name of the EventLatency stage.
  event_latency_stage STRING,
  -- The process where the cause of scroll jank occurred.
  cause_process STRING,
  -- The thread where the cause of scroll jank occurred.
  cause_thread STRING,
  -- A description of the cause of scroll jank.
  cause_description STRING
) AS
WITH cause_descriptions(
  event_latency_stage,
  cause_process,
  cause_thread,
  cause_description)
AS (
VALUES
  ('GenerationToBrowserMain', 'Browser', 'CrBrowserMain',
    'This also corresponds to a matching InputLatency::TouchMove. Key ' ||
    'things to look for: Browser Main thread (CrBrowserMain) is busy, often ' ||
    'running tasks. The true cause can be confirmed by checking which tasks ' ||
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'are being run on CrBrowserMain, or checking any ScopedBlockingCall ' ||
    'slices during this stage from a ThreadPoolForegroundWorker, or ' ||
    'checking if the NetworkService is busy. Common causes may include page' ||
    'navigations (same document and new pages), slow BeginMainFrames, and ' ||
    'Java Choreographer slowdowns.'),
  ('RendererCompositorQueueingDelay', 'Renderer', 'Compositor',
    'The renderer needs to decide to produce a frame in response to a ' ||
    'BeginFrame signal. Sometimes it can not because it is waiting on the ' ||
    'RendererMain thread to do touch targeting or javascript handling or ' ||
    'other such things causing a long queuing delay after it has already ' ||
    'started the scroll (so the TouchStart has been processed).'),
  ('RendererCompositorQueueingDelay', 'GPU', 'VizCompositorThread',
    'Waiting for a BeginFrame to be sent. Key things to look for: check if ' ||
    'a fling occurred before or during the scroll; flings produce a single ' ||
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'input and result in multiple inputs coalescing into a single frame.'),
  ('ReceiveCompositorFrameToStartDraw', 'GPU', 'VizCompositorThread',
    'A delay when the VizCompositor is waiting for the frame, but may be ' ||
    'connected to other processes and threads. Key things to look for: ' ||
    'check the BeginFrame task that finished during this EventLatency. The ' ||
    'VizCompositor holds onto the frame/does not send it on. Alternately ' ||
    'the system may be holding on to the buffer.'),
  ('ReceiveCompositorFrameToStartDraw', 'GPU', 'CrGpuMain',
    'Key things to look for: if the GPU Main thread is busy, and does not ' ||
    'release the buffer; specific causes will be on the GPU Main thread. If ' ||
    'this thread is not busy, the buffer may be held by the system instead.'),
  ('ReceiveCompositorFrameToStartDraw', 'Browser', 'CrBrowserMain',
    'Key things to look for: the toolbar on the Browser may be blocked by ' ||
    'other tasks.'),
  ('BufferReadyToLatch', 'GPU', 'VizCompositorThread',
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'Often a scheduling issue. The frame was submitted, but missed the ' ||
    'latch in the system that was received from the previous frame. The ' ||
    'system only latches a buffer once per frame; when the latch deadline ' ||
    'is missed, the system is forced to wait for another vsync interval to ' ||
    'latch again. Key things to look for: whether the event duration before ' ||
    'BufferReadyToLatch stage of the previous EventLatency is longer or ' ||
    'shorter than the event duration before BufferReadyToLatch in the ' ||
    'current EventLatency. If this duration is longer, then this is a ' ||
    'System problem. If this duration is shorter, then it is a Chrome ' ||
    'problem. The previous frame may have been drawn too quickly, or the ' ||
    'GPU may be delayed.'),
  ('SwapEndToPresentationCompositorFrame', 'GPU', 'VizCompositorThread',
    'May be attributed to a scheduling issue as with BufferReadyToLatch. ' ||
    'The frame was submitted, but missed the latch in the system that was ' ||
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'received from the previous frame. The system only latches a buffer ' ||
    'once per frame; when the latch deadline is missed, the system is ' ||
    'forced to wait for another vsync interval to latch again. Key things ' ||
    'to look for: whether the event duration before BufferReadyToLatch ' ||
    'stage of the previous EventLatency is longer or shorter than the event ' ||
    'duration before BufferReadyToLatch in the current EventLatency. If ' ||
    'this duration is longer, then this is a System problem. If this ' ||
    'duration is shorter, then it is a Chrome problem. The previous frame ' ||
    'may have been drawn too quickly, or the GPU may be delayed.'),
  ('SwapEndToPresentationCompositorFrame', 'GPU', 'CrGpuMain',
    'Key things to look for: whether StartDrawToBufferAvailable is also ' ||
    'present during this EventLatency. If so, then the GPU main thread may ' ||
    'be descheduled or busy. If surfaceflinger is available, check there as ' ||
    'well.'),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ('SwapEndToPresentationCompositorFrame', 'GPU', 'surfaceflinger',
    'Key things to look for: whether StartDrawToBufferAvailable is also ' ||
    'present during this EventLatency. If so, then the VizCompositor has ' ||
    'not received a signal from surfaceflinger to start writing into the ' ||
    'buffer.'))
SELECT
  event_latency_stage,
  cause_process,
  cause_thread,
  cause_description
FROM cause_descriptions;

-- Combined description of scroll jank cause and associated event latency stage.
CREATE PERFETTO VIEW chrome_scroll_jank_causes_with_event_latencies(
  -- The name of the EventLatency stage.
  name STRING,
  -- Description of the EventLatency stage.
  description STRING,
  -- The process name that may cause scroll jank.
  cause_process STRING,
  -- The thread name that may cause scroll jank. The thread will be on the
  -- cause_process.
  cause_thread STRING,
  -- Description of the cause of scroll jank on this process and thread.
  cause_description STRING
) AS
SELECT
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  stages.name,
  stages.description,
  causes.cause_process,
  causes.cause_thread,
  causes.cause_description
FROM chrome_event_latency_stage_descriptions stages
LEFT JOIN chrome_scroll_jank_cause_descriptions causes
    ON causes.event_latency_stage = stages.name;

)_d3l1m1t3r_"
;

const char kChromeScrollJankScrollJankCauseUtils[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

INCLUDE PERFETTO MODULE slices.with_context;

-- Function to retrieve the upid for a surfaceflinger, as these are attributed
-- to the GPU but are recorded on a different data source (and track group).
CREATE PERFETTO FUNCTION _get_process_id_for_surfaceflinger()
-- The process id for surfaceflinger.
RETURNS INT AS
SELECT
 upid
FROM process
WHERE name GLOB '*surfaceflinger*'
LIMIT 1;

-- Map a generic process type to a specific name or substring of a name that
-- can be found in the trace process table.
CREATE PERFETTO TABLE _process_type_to_name (
  -- The process type: one of 'Browser' or 'GPU'.
  process_type STRING,
  -- The process name for Chrome traces.
  process_name STRING,
  -- Substring identifying the process for system traces.
  process_glob STRING
) AS
WITH process_names (
  process_type,
  process_name,
  process_glob
  )
AS (
VALUES
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ('Browser', 'Browser', '*.chrome'),
  ('GPU', 'Gpu', '*.chrome*:privileged_process*'))
SELECT
  process_type,
  process_name,
  process_glob
FROM process_names;

CREATE PERFETTO FUNCTION _get_process_name(
  -- The process type: one of 'Browser' or 'GPU'.
  type STRING
)
-- The process name
RETURNS STRING AS
SELECT
    process_name
FROM _process_type_to_name
WHERE process_type = $type
LIMIT 1;

CREATE PERFETTO FUNCTION _get_process_glob(
  -- The process type: one of 'Browser' or 'GPU'.
  type STRING
)
-- A substring of the process name that can be used in GLOB calculations.
RETURNS STRING AS
SELECT
    process_glob
FROM _process_type_to_name
WHERE process_type = $type
LIMIT 1;

-- TODO(b/309937901): Add chrome instance id for multiple chromes/webviews in a
-- trace, as this may result in  multiple browser and GPU processes.
-- Function to retrieve the chrome process ID for a specific process type. Does
-- not retrieve the Renderer process, as this is determined when the
-- EventLatency is known. See function
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- _get_renderer_upid_for_event_latency below.
CREATE PERFETTO FUNCTION _get_process_id_by_type(
  -- The process type: one of 'Browser' or 'GPU'.
  type STRING
)
RETURNS TABLE (
    -- The process id for the process type.
    upid INT
) AS
SELECT
  upid
FROM process
WHERE name = _get_process_name($type)
  OR name GLOB _get_process_glob($type);

-- Function to retrieve the chrome process ID that a given EventLatency slice
-- occurred on. This is the Renderer process.
CREATE PERFETTO FUNCTION _get_renderer_upid_for_event_latency(
  -- The slice id for an EventLatency slice.
  id INT
)
-- The process id for an EventLatency slice. This is the Renderer process.
RETURNS INT AS
SELECT
  upid
FROM process_slice
WHERE id = $id;

-- Helper function to retrieve all of the upids for a given process, thread,
-- or EventLatency.
CREATE PERFETTO FUNCTION _processes_by_type_for_event_latency(
  -- The process type that the thread is on: one of 'Browser', 'Renderer' or
  -- 'GPU'.
  type STRING,
  -- The name of the thread.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  thread STRING,
  -- The slice id of an EventLatency slice.
  event_latency_id INT)
RETURNS TABLE (
    upid INT
) AS
WITH all_upids AS (
  -- Renderer process upids
  SELECT
    $type AS process,
    $thread AS thread,
    $event_latency_id AS event_latency_id,
    _get_renderer_upid_for_event_latency($event_latency_id) AS upid
  WHERE $type = 'Renderer'
  UNION ALL
  -- surfaceflinger upids
  SELECT
    $type AS process,
    $thread AS thread,
    $event_latency_id AS event_latency_id,
    _get_process_id_for_surfaceflinger() AS upid
  WHERE $type = 'GPU' AND $thread = 'surfaceflinger'
  UNION ALL
  -- Generic Browser and GPU process upids
  SELECT
    $type AS process,
    $thread AS thread,
    $event_latency_id AS event_latency_id,
    upid
  FROM _get_process_id_by_type($type)
  WHERE $type = 'Browser'
    OR ($type = 'GPU' AND $thread != 'surfaceflinger')
)
SELECT
  upid
FROM all_upids;

-- Function to retrieve the thread id of the thread on a particular process if
-- there are any slices during a particular EventLatency slice duration; this
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- upid/thread combination refers to a cause of Scroll Jank.
CREATE PERFETTO FUNCTION chrome_select_scroll_jank_cause_thread(
  -- The slice id of an EventLatency slice.
  event_latency_id INT,
  -- The process type that the thread is on: one of 'Browser', 'Renderer' or
  -- 'GPU'.
  process_type STRING,
  -- The name of the thread.
  thread_name STRING)
RETURNS TABLE (
  -- The utid associated with |thread| on the process with |upid|.
  utid INT
) AS
WITH threads AS (
  SELECT
    utid
  FROM thread
  WHERE upid IN
    (
      SELECT DISTINCT
        upid
      FROM _processes_by_type_for_event_latency(
        $process_type,
        $thread_name,
        $event_latency_id)
    )
    AND name = $thread_name
)
SELECT
 DISTINCT utid
FROM thread_slice
WHERE utid IN
  (
    SELECT
      utid
    FROM threads
  )
  AND ts >= (SELECT ts FROM slice WHERE id = $event_latency_id LIMIT 1)
  AND ts <= (SELECT ts + dur FROM slice WHERE id = $event_latency_id LIMIT 1);

)_d3l1m1t3r_"
;

const char kChromeScrollJankScrollJankIntervals[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

INCLUDE PERFETTO MODULE chrome.chrome_scrolls;
INCLUDE PERFETTO MODULE chrome.scroll_jank.scroll_jank_v3;

-- Selects EventLatency slices that correspond with janks in a scroll. This is
-- based on the V3 version of scroll jank metrics.
CREATE PERFETTO TABLE chrome_janky_event_latencies_v3(
  -- The slice id.
  id INT,
  -- The start timestamp of the slice.
  ts INT,
  -- The duration of the slice.
  dur INT,
  -- The track_id for the slice.
  track_id INT,
  -- The name of the slice (EventLatency).
  name STRING,
  -- The stage of EventLatency that the caused the jank.
  cause_of_jank STRING,
  -- The stage of cause_of_jank that caused the jank.
  sub_cause_of_jank STRING,
  -- How many vsyncs this frame missed its deadline by.
  delayed_frame_count INT,
  -- The start timestamp where frame presentation was delayed.
  frame_jank_ts INT,
  -- The duration in ms of the delay in frame presentation.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  frame_jank_dur INT
) AS
SELECT
  s.id,
  s.ts,
  s.dur,
  s.track_id,
  s.name,
  e.cause_of_jank,
  e.sub_cause_of_jank,
  CAST((e.delay_since_last_frame/e.vsync_interval) - 1 AS INT) AS delayed_frame_count,
  CAST(s.ts + s.dur - ((e.delay_since_last_frame - e.vsync_interval) * 1e6) AS INT) AS frame_jank_ts,
  CAST((e.delay_since_last_frame - e.vsync_interval) * 1e6 AS INT) AS frame_jank_dur
FROM slice s
JOIN chrome_janky_frames e
  ON s.id = e. event_latency_id;

-- Frame presentation interval is the delta between when the frame was supposed
-- to be presented and when it was actually presented.
CREATE PERFETTO VIEW chrome_janky_frame_presentation_intervals(
  -- Unique id.
  id INT,
  -- The start timestamp of the slice.
  ts INT,
  -- The duration of the slice.
  dur INT,
  -- How many vsyncs this frame missed its deadline by.
  delayed_frame_count INT,
  -- The stage of EventLatency that the caused the jank.
  cause_of_jank INT,
  -- The stage of cause_of_jank that caused the jank.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  sub_cause_of_jank INT,
  -- The id of the associated event latency in the slice table.
  event_latency_id INT
) AS
SELECT
  ROW_NUMBER() OVER(ORDER BY frame_jank_ts) AS id,
  frame_jank_ts AS ts,
  frame_jank_dur AS dur,
  delayed_frame_count,
  cause_of_jank,
  sub_cause_of_jank,
  id AS event_latency_id
FROM chrome_janky_event_latencies_v3;

-- Scroll jank frame presentation stats for individual scrolls.
CREATE PERFETTO VIEW chrome_scroll_stats(
  -- Id of the individual scroll.
  scroll_id INT,
  -- The number of frames in the scroll.
  frame_count INT,
  -- The number of missed vsyncs in the scroll.
  missed_vsyncs INT,
  -- The number presented frames in the scroll.
  presented_frame_count INT,
  -- The number of janky frames in the scroll.
  janky_frame_count INT,
  -- The % of frames that janked in the scroll.
  janky_frame_percent FLOAT
) AS
WITH vsyncs AS (
  SELECT
    COUNT() AS presented_vsync_count,
    scroll.id AS scroll_id
  FROM chrome_unique_frame_presentation_ts frame
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  JOIN chrome_scrolls scroll
    ON frame.presentation_timestamp >= scroll.ts
    AND frame.presentation_timestamp <= scroll.ts + scroll.dur
  GROUP BY scroll_id),
missed_vsyncs AS (
  SELECT
    CAST(SUM((delay_since_last_frame / vsync_interval) - 1) AS INT)  AS total_missed_vsyncs,
    scroll_id
  FROM chrome_janky_frames
  GROUP BY scroll_id),
frame_stats AS (
  SELECT
    scroll_id,
    num_frames AS presented_frame_count,
    IFNULL(num_janky_frames, 0) AS janky_frame_count,
    ROUND(IFNULL(scroll_jank_percentage, 0), 2) AS janky_frame_percent
  FROM chrome_frames_per_scroll
)
SELECT
  vsyncs.scroll_id,
  presented_vsync_count + IFNULL(total_missed_vsyncs, 0) AS frame_count,
  total_missed_vsyncs AS missed_vsyncs,
  presented_frame_count,
  janky_frame_count,
  janky_frame_percent
FROM vsyncs
LEFT JOIN missed_vsyncs
  USING (scroll_id)
LEFT JOIN frame_stats
  USING (scroll_id);

-- Defines slices for all of janky scrolling intervals in a trace.
CREATE PERFETTO TABLE chrome_scroll_jank_intervals_v3(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- The unique identifier of the janky interval.
  id INT,
  -- The start timestamp of the janky interval.
  ts INT,
  -- The duration of the janky interval.
  dur INT
) AS
-- Sub-table to retrieve all janky slice timestamps. Ordering calculations are
-- based on timestamps rather than durations.
WITH janky_latencies AS (
  SELECT
    s.frame_jank_ts AS start_ts,
    s.frame_jank_ts + s.frame_jank_dur AS end_ts
  FROM chrome_janky_event_latencies_v3 s),
-- Determine the local maximum timestamp for janks thus far; this will allow
-- us to coalesce all earlier events up to the maximum.
ordered_jank_end_ts AS (
  SELECT
    *,
    MAX(end_ts) OVER (
      ORDER BY start_ts ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
      AS max_end_ts_so_far
  FROM janky_latencies),
-- Determine the local minimum timestamp for janks thus far; this will allow
-- us to coalesce all later events up to the nearest local maximum.
range_starts AS (
  SELECT
    *,
    CASE
      -- This is a two-pass calculation to calculate the first event in the
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      -- group. An event is considered the first event in a group if all events
      -- which started before it also finished the current one started.
      WHEN start_ts <= 1 + LAG(max_end_ts_so_far) OVER (ORDER BY start_ts) THEN 0
      ELSE 1
    END AS range_start
  FROM ordered_jank_end_ts),
-- Assign an id to allow coalescing of individual slices.
range_groups AS (
  SELECT
    *,
    SUM(range_start) OVER (ORDER BY start_ts) AS range_group
  FROM range_starts)
-- Coalesce all slices within an interval.
SELECT
  range_group AS id,
  MIN(start_ts) AS ts,
  MAX(end_ts) - MIN(start_ts) AS dur
FROM range_groups
GROUP BY range_group;

)_d3l1m1t3r_"
;

const char kChromeScrollJankScrollJankV3Cause[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- Finds all slices with a direct parent with the given parent_id.
CREATE PERFETTO FUNCTION _direct_children_slice(
  -- Id of the parent slice.
  parent_id LONG)
RETURNS TABLE(
  -- Alias for `slice.id`.
  id LONG,
  -- Alias for `slice.type`.
  type STRING,
  -- Alias for `slice.ts`.
  ts LONG,
  -- Alias for `slice.dur`.
  dur LONG,
  -- Alias for `slice.category`.
  category LONG,
  -- Alias for `slice.name`.
  name STRING,
  -- Alias for `slice.track_id`.
  track_id LONG,
  -- Alias for `slice.depth`.
  depth LONG,
  -- Alias for `slice.parent_id`.
  parent_id LONG,
  -- Alias for `slice.arg_set_id`.
  arg_set_id LONG,
  -- Alias for `slice.thread_ts`.
  thread_ts LONG,
  -- Alias for `slice.thread_dur`.
  thread_dur LONG
) AS
SELECT
  slice.id,
  slice.type,
  slice.ts,
  slice.dur,
  slice.category,
  slice.name,
  slice.track_id,
  slice.depth,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  slice.parent_id,
  slice.arg_set_id,
  slice.thread_ts,
  slice.thread_dur
FROM slice
WHERE parent_id = $parent_id;

-- Given two slice Ids A and B, find the maximum difference
-- between the durations of it's direct children with matching names
-- for example if slice A has children named (X, Y, Z) with durations of (10, 10, 5)
-- and slice B has children named (X, Y) with durations of (9, 9), the function will return
-- the slice id of the slice named Z that is A's child, as no matching slice named Z was found
-- under B, making 5 - 0 = 5 the maximum delta between both slice's direct children
CREATE PERFETTO FUNCTION chrome_get_v3_jank_cause_id(
  -- The slice id of the parent slice that we want to cause among it's children.
  janky_slice_id LONG,
  -- The slice id of the parent slice that's the reference in comparison to
  -- |janky_slice_id|.
  prev_slice_id LONG
)
-- The slice id of the breakdown that has the maximum duration delta.
RETURNS LONG AS
WITH
  current_breakdowns AS (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    SELECT
      *
    FROM _direct_children_slice($janky_slice_id)
  ),
  prev_breakdowns AS (
    SELECT
      *
    FROM _direct_children_slice($prev_slice_id)
  ),
  joint_breakdowns AS (
    SELECT
      cur.id AS breakdown_id,
      (cur.dur - COALESCE(prev.dur, 0)) AS breakdown_delta
    FROM current_breakdowns cur
    LEFT JOIN prev_breakdowns prev ON
      cur.name = prev.name
  ),
  max_breakdown AS (
    SELECT
      MAX(breakdown_delta) AS breakdown_delta,
      breakdown_id
    FROM joint_breakdowns
  )
  SELECT
    breakdown_id
  FROM max_breakdown;

)_d3l1m1t3r_"
;

const char kChromeScrollJankScrollJankV3[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

INCLUDE PERFETTO MODULE deprecated.v42.common.slices;

-- Hardware info is useful when using sql metrics for analysis
-- in BTP.
INCLUDE PERFETTO MODULE chrome.metadata;
INCLUDE PERFETTO MODULE chrome.scroll_jank.scroll_jank_v3_cause;
INCLUDE PERFETTO MODULE chrome.scroll_jank.utils;

-- Finds the end timestamp for a given slice's descendant with a given name.
-- If there are multiple descendants with a given name, the function will return the
-- first one, so it's most useful when working with a timeline broken down into phases,
-- where each subphase can happen only once.
CREATE PERFETTO FUNCTION _descendant_slice_end(
  -- Id of the parent slice.
  parent_id INT,
  -- Name of the child with the desired end TS.
  child_name STRING
)
-- End timestamp of the child or NULL if it doesn't exist.
RETURNS INT AS
SELECT
  CASE WHEN s.dur
    IS NOT -1 THEN s.ts + s.dur
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    ELSE NULL
  END
FROM descendant_slice($parent_id) s
WHERE s.name = $child_name
LIMIT 1;

-- Given a slice id, returns the name of the slice.
CREATE PERFETTO FUNCTION _slice_name_from_id(
  -- The slice id which we need the name for.
  id LONG
)
-- The name of slice with the given id.
RETURNS STRING AS
SELECT
  name
FROM slice
WHERE $id = id;

-- Grabs all gesture updates with respective scroll ids and start/end
-- timestamps, regardless of being presented.
CREATE PERFETTO TABLE chrome_gesture_scroll_updates(
  -- The start timestamp of the scroll.
  ts INT,
  -- The duration of the scroll.
  dur INT,
  -- Slice id for the scroll.
  id INT,
  -- The id of the scroll update event.
  scroll_update_id INT,
  -- The id of the scroll.
  scroll_id INT,
  -- Whether this input event was presented.
  is_presented BOOL,
  -- Frame presentation timestamp aka the timestamp of the
  -- SwapEndToPresentationCompositorFrame substage.
  -- TODO(b/341047059): temporarily use LatchToSwapEnd as a workaround if
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- SwapEndToPresentationCompositorFrame is missing due to b/247542163.
  presentation_timestamp INT,
  -- EventLatency event type.
  event_type INT
) AS
SELECT
  slice.ts,
  slice.dur,
  slice.id,
  EXTRACT_arg(arg_set_id, 'event_latency.event_latency_id') AS scroll_update_id,
  chrome_get_most_recent_scroll_begin_id(slice.ts) AS scroll_id,
  has_descendant_slice_with_name(slice.id, 'SubmitCompositorFrameToPresentationCompositorFrame')
  AS is_presented,
  CASE WHEN has_descendant_slice_with_name(slice.id, "SwapEndToPresentationCompositorFrame")
    THEN _descendant_slice_end(slice.id, "SwapEndToPresentationCompositorFrame")
    ELSE _descendant_slice_end(slice.id, "LatchToSwapEnd")
  END
  AS presentation_timestamp,
  EXTRACT_ARG(arg_set_id, 'event_latency.event_type') AS event_type
FROM slice JOIN args USING(arg_set_id)
WHERE name = "EventLatency"
AND (
  args.string_value GLOB '*GESTURE_SCROLL_UPDATE'
  -- Pinches are only relevant if the frame was presented.
  OR (args.string_value GLOB '*GESTURE_PINCH_UPDATE'
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    AND has_descendant_slice_with_name(
      slice.id,
      'SubmitCompositorFrameToPresentationCompositorFrame')
  )
);

CREATE PERFETTO TABLE _presented_gesture_scrolls AS
SELECT
  id,
  ts,
  dur,
  scroll_update_id,
  scroll_id,
  presentation_timestamp,
  event_type
FROM chrome_gesture_scroll_updates
WHERE is_presented = true
ORDER BY ts ASC;

-- Scroll updates, corresponding to all input events that were converted to a
-- presented scroll update.
CREATE PERFETTO TABLE chrome_presented_gesture_scrolls(
  -- Minimum slice id for input presented in this frame, the non-presented input.
  id INT,
  -- The start timestamp for producing the frame.
  ts INT,
  -- The duration between producing and presenting the frame.
  dur INT,
  -- The timestamp of the last input that arrived and got presented in the frame.
  last_presented_input_ts INT,
  -- The id of the scroll update event, a unique identifier to the gesture.
  scroll_update_id INT,
  -- The id of the ongoing scroll.
  scroll_id INT,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Frame presentation timestamp.
  presentation_timestamp INT,
  -- EventLatency event type.
  event_type INT
) AS
WITH
scroll_updates_with_presentation_info as MATERIALIZED (
  SELECT
    id,
    ts,
    -- For each scroll update, find the latest presented update which
    -- started before it.
    (
      SELECT id
      FROM _presented_gesture_scrolls _presented
      WHERE _presented.ts <= scroll_update.ts
      ORDER BY ts DESC
      LIMIT 1
     ) as presented_to_scroll_update_slice_id
  FROM chrome_gesture_scroll_updates scroll_update
  ORDER BY presented_to_scroll_update_slice_id, ts
)
SELECT
  id,
  ts,
  dur,
  -- Find the latest input that was presented in this scroll update.
  (
    SELECT presentation_info.ts
    FROM scroll_updates_with_presentation_info presentation_info
    WHERE
      presentation_info.presented_to_scroll_update_slice_id =
        _presented_gesture_scrolls.id
    ORDER BY ts DESC
    LIMIT 1
  ) as last_presented_input_ts,
  scroll_update_id,
  scroll_id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  presentation_timestamp,
  event_type
FROM _presented_gesture_scrolls;

-- Associate every trace_id with it's perceived delta_y on the screen after
-- prediction.
CREATE PERFETTO TABLE chrome_scroll_updates_with_deltas(
  -- The id of the scroll update event.
  scroll_update_id INT,
  -- The perceived delta_y on the screen post prediction.
  delta_y INT
) AS
SELECT
  EXTRACT_ARG(arg_set_id, 'scroll_deltas.trace_id') AS scroll_update_id,
  EXTRACT_ARG(arg_set_id, 'scroll_deltas.provided_to_compositor_delta_y') AS delta_y
FROM slice
WHERE name = "InputHandlerProxy::HandleGestureScrollUpdate_Result";

-- Obtain the subset of input events that were fully presented.
CREATE PERFETTO TABLE chrome_full_frame_view(
  -- ID of the frame.
  id INT,
  -- Start timestamp of the frame.
  ts INT,
  -- The timestamp of the last presented input.
  last_presented_input_ts INT,
  -- ID of the associated scroll.
  scroll_id INT,
  -- ID of the associated scroll update.
  scroll_update_id INT,
  -- ID of the associated EventLatency.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  event_latency_id INT,
  -- Duration of the associated EventLatency.
  dur INT,
  -- Frame presentation timestamp.
  presentation_timestamp INT
) AS
SELECT
  frames.id,
  frames.ts,
  frames.last_presented_input_ts,
  frames.scroll_id,
  frames.scroll_update_id,
  frames.id AS event_latency_id,
  frames.dur,
  frames.presentation_timestamp
FROM chrome_presented_gesture_scrolls frames
WHERE frames.event_type in (
          'GESTURE_SCROLL_UPDATE',
          'FIRST_GESTURE_SCROLL_UPDATE',
          'INERTIAL_GESTURE_SCROLL_UPDATE',
          'GESTURE_PINCH_UPDATE')
AND frames.presentation_timestamp IS NOT NULL;

-- Join deltas with EventLatency data.
CREATE PERFETTO TABLE chrome_full_frame_delta_view(
  -- ID of the frame.
  id INT,
  -- Start timestamp of the frame.
  ts INT,
  -- ID of the associated scroll.
  scroll_id INT,
  -- ID of the associated scroll update.
  scroll_update_id INT,
  -- The timestamp of the last presented input.
  last_presented_input_ts INT,
  -- The perceived delta_y on the screen post prediction.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  delta_y INT,
  -- ID of the associated EventLatency.
  event_latency_id INT,
  -- Duration of the associated EventLatency.
  dur INT,
  -- Frame presentation timestamp.
  presentation_timestamp INT
) AS
SELECT
  frames.id,
  frames.ts,
  frames.scroll_id,
  frames.scroll_update_id,
  frames.last_presented_input_ts,
  deltas.delta_y,
  frames.event_latency_id,
  frames.dur,
  frames.presentation_timestamp
FROM chrome_full_frame_view frames
LEFT JOIN chrome_scroll_updates_with_deltas deltas
  ON deltas.scroll_update_id = frames.scroll_update_id;

-- Group all gestures presented at the same timestamp together in
-- a single row.
CREATE PERFETTO VIEW chrome_merged_frame_view(
  -- ID of the frame.
  id INT,
  -- The timestamp of the last presented input.
  max_start_ts INT,
  -- The earliest frame start timestamp.
  min_start_ts INT,
  -- ID of the associated scroll.
  scroll_id INT,
  -- ID of the associated scroll update.
  scroll_update_id INT,
  -- All scroll updates associated with the frame presentation timestamp.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  encapsulated_scroll_ids INT,
  -- Sum of all perceived delta_y values at the frame presentation timestamp.
  total_delta INT,
  -- Lists all of the perceived delta_y values at the frame presentation timestamp.
  segregated_delta_y INT,
  -- ID of the associated EventLatency.
  event_latency_id INT,
  -- Maximum duration of the associated EventLatency.
  dur INT,
  -- Frame presentation timestamp.
  presentation_timestamp INT
) AS
SELECT
  id,
  MAX(last_presented_input_ts) AS max_start_ts,
  MIN(ts) AS min_start_ts,
  scroll_id,
  scroll_update_id,
  GROUP_CONCAT(scroll_update_id,',') AS encapsulated_scroll_ids,
  SUM(delta_y) AS total_delta,
  GROUP_CONCAT(delta_y, ',') AS segregated_delta_y,
  event_latency_id,
  MAX(dur) AS dur,
  presentation_timestamp
FROM chrome_full_frame_delta_view
GROUP BY presentation_timestamp
ORDER BY presentation_timestamp;

-- View contains all chrome presented frames during gesture updates
-- while calculating delay since last presented which usually should
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- equal to |VSYNC_INTERVAL| if no jank is present.
CREATE PERFETTO VIEW chrome_frame_info_with_delay(
  -- gesture scroll slice id.
  id INT,
  -- OS timestamp of the last touch move arrival within a frame.
  max_start_ts INT,
  -- OS timestamp of the first touch move arrival within a frame.
  min_start_ts INT,
  -- The scroll which the touch belongs to.
  scroll_id INT,
  -- ID of the associated scroll update.
  scroll_update_id INT,
  -- Trace ids of all frames presented in at this vsync.
  encapsulated_scroll_ids INT,
  -- Summation of all delta_y of all gesture scrolls in this frame.
  total_delta INT,
  -- All delta y of all gesture scrolls comma separated, summing those gives |total_delta|.
  segregated_delta_y INT,
  -- Event latency id of the presented frame.
  event_latency_id INT,
  -- Duration of the EventLatency.
  dur INT,
  -- Timestamp at which the frame was shown on the screen.
  presentation_timestamp INT,
  -- Time elapsed since the previous frame was presented, usually equals |VSYNC|
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- if no frame drops happened.
  delay_since_last_frame INT,
  -- Difference in OS timestamps of inputs in the current and the previous frame.
  delay_since_last_input INT,
  -- The event latency id that will be used as a reference to determine the
  -- jank cause.
  prev_event_latency_id INT
) AS
SELECT
  *,
  (presentation_timestamp -
  LAG(presentation_timestamp, 1, presentation_timestamp)
  OVER (PARTITION BY scroll_id ORDER BY presentation_timestamp)) / 1e6 AS delay_since_last_frame,
  (min_start_ts -
  LAG(max_start_ts, 1, min_start_ts)
  OVER (PARTITION BY scroll_id ORDER BY min_start_ts)) / 1e6 AS delay_since_last_input,
  LAG(event_latency_id, 1, -1) OVER (PARTITION BY scroll_id ORDER BY min_start_ts) AS prev_event_latency_id
FROM chrome_merged_frame_view;

-- Calculate |VSYNC_INTERVAL| as the lowest vsync seen in the trace or the
-- minimum delay between frames larger than zero.
--
-- TODO(~M130): Remove the lowest vsync since we should always have vsync_interval_ms.
CREATE PERFETTO VIEW chrome_vsyncs(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- The lowest delay between frames larger than zero.
  vsync_interval INT
) AS
WITH
  trace_vsyncs AS (
    SELECT EXTRACT_ARG(slice.arg_set_id, 'event_latency.vsync_interval_ms') AS vsync_interval_ms
    FROM
      slice JOIN chrome_frame_info_with_delay
        ON chrome_frame_info_with_delay.event_latency_id = slice.id
    WHERE EXTRACT_ARG(slice.arg_set_id, 'event_latency.vsync_interval_ms') > 0
  )
SELECT
  COALESCE(
    (SELECT MIN(vsync_interval_ms) FROM trace_vsyncs),
    MIN(delay_since_last_frame)) AS vsync_interval
FROM chrome_frame_info_with_delay
WHERE delay_since_last_frame > 0;

-- Filter the frame view only to frames that had missed vsyncs.
CREATE PERFETTO VIEW chrome_janky_frames_no_cause(
  -- Time elapsed since the previous frame was presented, will be more than |VSYNC| in this view.
  delay_since_last_frame INT,
  -- Event latency id of the presented frame.
  event_latency_id INT,
  -- Vsync interval at the time of recording the trace.
  vsync_interval INT,
  -- Device brand and model.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  hardware_class STRING,
  -- The scroll corresponding to this frame.
  scroll_id INT,
  -- The event latency id that will be used as a reference to determine the jank cause.
  prev_event_latency_id INT
) AS
SELECT
  delay_since_last_frame,
  event_latency_id,
  (SELECT vsync_interval FROM chrome_vsyncs) AS vsync_interval,
  chrome_hardware_class() AS hardware_class,
  scroll_id,
  prev_event_latency_id
FROM chrome_frame_info_with_delay
WHERE delay_since_last_frame > (select vsync_interval + vsync_interval / 2 from chrome_vsyncs)
      AND delay_since_last_input < (select vsync_interval + vsync_interval / 2 from chrome_vsyncs);

-- Janky frame information including the jank cause.
CREATE PERFETTO VIEW chrome_janky_frames_no_subcause(
  -- Time elapsed since the previous frame was presented, will be more than |VSYNC| in this view.
  delay_since_last_frame INT,
  -- Event latency id of the presented frame.
  event_latency_id INT,
  -- Vsync interval at the time of recording the trace.
  vsync_interval INT,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Device brand and model.
  hardware_class STRING,
  -- The scroll corresponding to this frame.
  scroll_id INT,
  -- The event latency id that will be used as a reference to determine the jank cause.
  prev_event_latency_id INT,
  -- Id of the slice corresponding to the offending stage.
  cause_id INT
) AS
SELECT
  *,
  chrome_get_v3_jank_cause_id(event_latency_id, prev_event_latency_id) AS cause_id
FROM chrome_janky_frames_no_cause;

-- Finds all causes of jank for all janky frames, and a cause of sub jank
-- if the cause of jank was GPU related.
CREATE PERFETTO VIEW chrome_janky_frames(
  -- The reason the Vsync was missed.
  cause_of_jank INT,
  -- Further breakdown if the root cause was GPU related.
  sub_cause_of_jank INT,
  -- Time elapsed since the previous frame was presented, will be more than |VSYNC| in this view.
  delay_since_last_frame INT,
  -- Event latency id of the presented frame.
  event_latency_id INT,
  -- Vsync interval at the time of recording the trace.
  vsync_interval INT,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Device brand and model.
  hardware_class STRING,
  -- The scroll corresponding to this frame.
  scroll_id INT
) AS
SELECT
  _slice_name_from_id(cause_id) AS cause_of_jank,
  _slice_name_from_id(
    -- Getting sub-cause
    chrome_get_v3_jank_cause_id(
      -- Here the cause itself is the parent.
      cause_id,
      -- Get the previous cause id as a child to the previous |EventLatency|.
     (SELECT
      id
      FROM slice
      WHERE name = _slice_name_from_id(cause_id)
        AND parent_id = prev_event_latency_id)
    )) AS sub_cause_of_jank,
  delay_since_last_frame,
  event_latency_id,
  vsync_interval,
  hardware_class,
  scroll_id
FROM chrome_janky_frames_no_subcause;

-- Counting all unique frame presentation timestamps.
CREATE PERFETTO VIEW chrome_unique_frame_presentation_ts(
  -- The unique frame presentation timestamp.
  presentation_timestamp INT
) AS
SELECT DISTINCT
presentation_timestamp
FROM chrome_presented_gesture_scrolls;

-- Dividing missed frames over total frames to get janky frame percentage.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- This represents the v3 scroll jank metrics.
-- Reflects Event.Jank.DelayedFramesPercentage UMA metric.
CREATE PERFETTO VIEW chrome_janky_frames_percentage(
  -- The percent of missed frames relative to total frames - aka the percent of janky frames.
  delayed_frame_percentage FLOAT
) AS
SELECT
(SELECT
  COUNT()
 FROM chrome_janky_frames) * 1.0
/ (SELECT
    COUNT()
  FROM chrome_unique_frame_presentation_ts) * 100 AS delayed_frame_percentage;

-- Number of frames and janky frames per scroll.
CREATE PERFETTO VIEW chrome_frames_per_scroll(
  -- The ID of the scroll.
  scroll_id INT,
  -- The number of frames in the scroll.
  num_frames INT,
  -- The number of delayed/janky frames.
  num_janky_frames INT,
  -- The percentage of janky frames relative to total frames.
  scroll_jank_percentage INT
) AS
WITH
  frames AS (
    SELECT scroll_id, COUNT(*) AS num_frames
    FROM
      chrome_frame_info_with_delay
    GROUP BY scroll_id
  ),
  janky_frames AS (
    SELECT scroll_id, COUNT(*) AS num_janky_frames
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    FROM
      chrome_janky_frames
    GROUP BY scroll_id
  )
SELECT
  frames.scroll_id AS scroll_id,
  frames.num_frames AS num_frames,
  janky_frames.num_janky_frames AS num_janky_frames,
  100.0 * janky_frames.num_janky_frames / frames.num_frames
    AS scroll_jank_percentage
FROM frames
LEFT JOIN janky_frames
  ON frames.scroll_id = janky_frames.scroll_id;

-- Scroll jank causes per scroll.
CREATE PERFETTO VIEW chrome_causes_per_scroll(
  -- The ID of the scroll.
  scroll_id INT,
  -- The maximum time a frame was delayed after the presentation of the previous
  -- frame.
  max_delay_since_last_frame INT,
  -- The expected vsync interval.
  vsync_interval INT,
  -- A proto amalgamation of each scroll jank cause including cause name, sub
  -- cause and the duration of the delay since the previous frame was presented.
  scroll_jank_causes BYTES
) AS
SELECT
  scroll_id,
  MAX(1.0 * delay_since_last_frame / vsync_interval)
    AS max_delay_since_last_frame,
  -- MAX does not matter, since `vsync_interval` is the computed as the
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- same value for a single trace.
  MAX(vsync_interval) AS vsync_interval,
  RepeatedField(
    ChromeScrollJankV3_Scroll_ScrollJankCause(
      'cause',
      cause_of_jank,
      'sub_cause',
      sub_cause_of_jank,
      'delay_since_last_frame',
      1.0 * delay_since_last_frame / vsync_interval))
    AS scroll_jank_causes
FROM
  chrome_janky_frames
GROUP BY scroll_id;
)_d3l1m1t3r_"
;

const char kChromeScrollJankScrollOffsets[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- This file creates two public views:
--     - chrome_scroll_input_offsets and
--     - chrome_presented_scroll_offsets
--
-- These views store the pixel deltas and offsets for (respectively) all chrome
-- scroll inputs (coalesced and not coalesced), and for chrome presented frames
-- (not coalesced), along with the associated timestamp, and id.
--
-- Raw deltas are recorded as changes in pixel positions along the y-axis of a
-- screen, and are scaled to the viewport size. The corresponding trace event
-- for this is TranslateAndScaleWebInputEvent. These are the deltas for all
-- chrome scroll inputs.
--
-- For presented frames, the delta is calculated from the visual offset,
-- recorded once the input has been processed, in the
-- InputHandlerProxy::HandleGestureScrollUpdate_Result event. These values are
-- also scaled to the screen size.
--
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- Offsets are calculated by summing all of the deltas, ordered by timestamp.
-- For a given input/frame, the offset is the sum of its corresponding delta and
-- all previous deltas.
--
--
-- All values required for calculating deltas and offsets are recorded at
-- various stages of input processing, and are unified by a single
-- scroll_update_id value, recorded as scroll_deltas.trace_id in each event.

INCLUDE PERFETTO MODULE chrome.chrome_scrolls;
INCLUDE PERFETTO MODULE chrome.scroll_jank.scroll_jank_v3;

-- All (coalesced and non-coalesced) vertical scrolling deltas and their
-- associated scroll ids. Delta values are recorded after being scaled to the
-- device's screen size in the TranslateAndScaleWebInputEvent trace event. In
-- this trace event, the deltas recorded represent the true (read "original")
-- values that the Browser receives from Android, and the only processing is
-- scaling and translation.
CREATE PERFETTO TABLE _translate_and_scale_scroll_deltas AS
SELECT
  EXTRACT_ARG(arg_set_id, 'scroll_deltas.trace_id') AS scroll_update_id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  EXTRACT_ARG(arg_set_id, 'scroll_deltas.original_delta_y') AS delta_y
FROM slice
WHERE slice.name = 'TranslateAndScaleWebInputEvent';

-- Associate the gesture scroll update OS timestamp with the delta.
CREATE PERFETTO TABLE _scroll_deltas_with_timestamp AS
SELECT
  slice.ts AS input_ts,
  data.scroll_update_id,
  data.delta_y
FROM _translate_and_scale_scroll_deltas data
  JOIN slice ON slice.name = 'EventLatency'
    AND data.scroll_update_id = EXTRACT_ARG(arg_set_id,
        'event_latency.event_latency_id');

-- Associate the scroll update/delta with the correct scroll.
CREATE PERFETTO TABLE _scroll_deltas_with_scroll_id AS
SELECT
  scrolls.id AS scroll_id,
  deltas.input_ts,
  deltas.scroll_update_id,
  deltas.delta_y
FROM _scroll_deltas_with_timestamp deltas
  LEFT JOIN chrome_scrolls scrolls
    ON deltas.input_ts >= scrolls.ts
      AND deltas.input_ts <= scrolls.ts + scrolls.dur;

-- Associate the presentation timestamp/deltas with the user deltas.
CREATE PERFETTO TABLE _scroll_deltas_with_delays AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  deltas.scroll_id,
  delay.total_delta,
  delay.scroll_update_id,
  delay.presentation_timestamp AS presentation_timestamp,
  deltas.input_ts,
  deltas.delta_y
FROM _scroll_deltas_with_scroll_id AS deltas
  LEFT JOIN chrome_frame_info_with_delay AS delay USING(scroll_update_id);

-- The raw coordinates and pixel offsets for all input events which were part of
-- a scroll.
CREATE PERFETTO TABLE chrome_scroll_input_offsets(
  -- Trace id associated with the scroll.
  scroll_id INT,
  -- Trace id associated with the scroll.
  scroll_update_id INT,
  -- Timestamp the of the scroll input event.
  ts INT,
  -- The delta in raw coordinates between this scroll update event and the
  -- previous.
  delta_y INT,
  -- The pixel offset of this scroll update event compared to the initial one.
  relative_offset_y INT
) AS
SELECT
  scroll_id,
  scroll_update_id,
  input_ts AS ts,
  delta_y,
  SUM(IFNULL(delta_y, 0)) OVER ( PARTITION BY scroll_id
    ORDER BY scroll_update_id, input_ts
    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS relative_offset_y
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM _scroll_deltas_with_delays;

-- The scrolling offsets for the actual (applied) scroll events. These are not
-- necessarily inclusive of all user scroll events, rather those scroll events
-- that are actually processed.
CREATE PERFETTO TABLE chrome_presented_scroll_offsets(
  -- Trace id associated with the scroll.
  scroll_id INT,
  -- Trace id associated with the scroll update event.
  scroll_update_id INT,
  -- Presentation timestamp.
  ts INT,
  -- The delta in raw coordinates between this scroll update event and the
  -- previous.
  delta_y INT,
  -- The pixel offset of this scroll update event compared to the initial one.
  relative_offset_y INT
) AS
SELECT
  scroll_id,
  scroll_update_id,
  presentation_timestamp AS ts,
  total_delta AS delta_y,
  SUM(IFNULL(total_delta, 0)) OVER ( PARTITION BY scroll_id
    ORDER BY scroll_update_id, presentation_timestamp
    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS relative_offset_y
FROM _scroll_deltas_with_delays;
)_d3l1m1t3r_"
;

const char kChromeScrollJankUtils[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.
--
-- Those are helper functions used in computing jank metrics

-- This function takes timestamps of two consecutive frames and determines if
-- its janky by a delay of more than 0.5 of a frame  in order to make sure that
-- the comparison does not filter out ratios that are precisely 0.5, which can
-- fall a little above or below exact value due to inherent inaccuracy of operations with
-- floating-point numbers. Value 1e-9 have been chosen as follows: the ratio has
-- nanoseconds in numerator and VSync interval in denominator. Assuming refresh
-- rate more than 1 FPS (and therefore VSync interval less than a second), this
-- ratio should increase with increments more than minimal value in numerator
-- (1ns) divided by maximum value in denominator, giving 1e-9.

-- Function : function takes scroll ids of frames to verify it's from
-- the same scroll, and makes sure the frame ts occurred within the scroll
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- timestamp of the neighbour and computes whether the frame was janky or not.
CREATE PERFETTO FUNCTION _is_janky_frame(cur_gesture_id LONG,
                                      neighbour_gesture_id LONG,
                                      neighbour_ts LONG,
                                      cur_gesture_begin_ts LONG,
                                      cur_gesture_end_ts LONG,
                                      cur_frame_exact FLOAT,
                                      neighbour_frame_exact FLOAT)
-- Returns true if the frame was janky, false otherwise
RETURNS BOOL AS
SELECT
    CASE WHEN
      $cur_gesture_id != $neighbour_gesture_id OR
      $neighbour_ts IS NULL OR
      $neighbour_ts < $cur_gesture_begin_ts OR
      $neighbour_ts > $cur_gesture_end_ts THEN
        FALSE ELSE
        $cur_frame_exact > $neighbour_frame_exact + 0.5 + 1e-9
    END;

-- Function : function takes the cur_frame_exact, prev_frame_exact and
-- next_frame_exact and returns the value of the jank budget of the current
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- frame.
--
-- jank_budget is the minimum amount of frames/time we need to reduce the frame
-- duration by for it to be no longer considered janky.
--
-- Returns the jank budget in percentage (i.e. 0.75) of vsync interval
-- percentage.
CREATE PERFETTO FUNCTION _jank_budget(
  cur_frame_exact FLOAT,
  prev_frame_exact FLOAT,
  next_frame_exact FLOAT
)
RETURNS FLOAT AS
-- We determine the difference between the frame count of the current frame
-- and its consecutive frames by subtracting with the frame_exact values. We
-- null check for cases when the neighbor frame count can be null for the
-- first and last frames.
--
-- Since a frame is considered janky, if the difference in the frame count
-- with its adjacent frame is greater than 0.5 (half a vsync) which means we
-- need to reduce the frame count by a value less than 0.5 of maximum
-- difference in frame count for it to be no longer janky. We subtract 1e-9 as
-- we want to output minimum amount required.
SELECT
  COALESCE(
    -- Could be null if next or previous is null.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    MAX(
      ($cur_frame_exact - $prev_frame_exact),
      ($cur_frame_exact - $next_frame_exact)
    ),
    -- If one of them is null output the first non-null.
    ($cur_frame_exact - $prev_frame_exact),
    ($cur_frame_exact - $next_frame_exact)
    -- Otherwise return null
  ) - 0.5 - 1e-9;

-- Extract mojo information for the long-task-tracking scenario for specific
-- names. For example, LongTaskTracker slices may have associated IPC
-- metadata, or InterestingTask slices for input may have associated IPC to
-- determine whether the task is fling/etc.
CREATE PERFETTO FUNCTION chrome_select_long_task_slices(
  -- The name of slice.
  name STRING)
RETURNS TABLE(
  -- Name of the interface of the IPC call.
  interface_name STRING,
  -- Hash of the IPC call.
  ipc_hash INT,
  -- Message type (e.g. reply).
  message_type STRING,
  -- The slice id.
  id INT
) AS
SELECT
  EXTRACT_ARG(s.arg_set_id, "chrome_mojo_event_info.mojo_interface_tag") AS interface_name,
  EXTRACT_ARG(arg_set_id, "chrome_mojo_event_info.ipc_hash") AS ipc_hash,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  CASE
    WHEN EXTRACT_ARG(arg_set_id, "chrome_mojo_event_info.is_reply") THEN "reply"
    ELSE "message"
  END AS message_type,
  s.id
FROM slice s
WHERE
  category GLOB "*scheduler.long_tasks*"
  AND name = $name;

-- Extracts scroll id for the EventLatency slice at `ts`.
CREATE PERFETTO FUNCTION chrome_get_most_recent_scroll_begin_id(
  -- Timestamp of the EventLatency slice to get the scroll id for.
  ts INT)
-- The event_latency_id of the EventLatency slice with the type
-- GESTURE_SCROLL_BEGIN that is the closest to `ts`.
RETURNS INT AS
SELECT EXTRACT_ARG(arg_set_id, "event_latency.event_latency_id")
FROM slice
WHERE name="EventLatency"
AND EXTRACT_ARG(arg_set_id, "event_latency.event_type") = "GESTURE_SCROLL_BEGIN"
AND ts<=$ts
ORDER BY ts DESC
LIMIT 1;

)_d3l1m1t3r_"
;

const char kCommonArgs[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- No new changes allowed. Will be removed after v45 of Perfetto.
--
-- We decided to move away from the generalised `common` module and migrate the
-- most useful functionality into specialised modules.
INCLUDE PERFETTO MODULE deprecated.v42.common.args;
)_d3l1m1t3r_"
;

const char kCommonCounters[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- No new changes allowed. Will be removed after v45 of Perfetto.
--
-- We decided to move away from the generalised `common` module and migrate the
-- most useful functionality into specialised modules.
INCLUDE PERFETTO MODULE deprecated.v42.common.args;
INCLUDE PERFETTO MODULE deprecated.v42.common.counters;
)_d3l1m1t3r_"
;

const char kCommonCpus[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- No new changes allowed. Will be removed after v45 of Perfetto.
--
-- We decided to move away from the generalised `common` module and migrate the
-- most useful functionality into specialised modules.
INCLUDE PERFETTO MODULE deprecated.v42.common.args;
INCLUDE PERFETTO MODULE deprecated.v42.common.cpus;
)_d3l1m1t3r_"
;

const char kCommonMetadata[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- No new changes allowed. Will be removed after v45 of Perfetto.
--
-- We decided to move away from the generalised `common` module and migrate the
-- most useful functionality into specialised modules.
INCLUDE PERFETTO MODULE deprecated.v42.common.args;
INCLUDE PERFETTO MODULE deprecated.v42.common.metadata;
)_d3l1m1t3r_"
;

const char kCommonPercentiles[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- No new changes allowed. Will be removed after v45 of Perfetto.
--
-- We decided to move away from the generalised `common` module and migrate the
-- most useful functionality into specialised modules.
INCLUDE PERFETTO MODULE deprecated.v42.common.args;
INCLUDE PERFETTO MODULE deprecated.v42.common.percentiles;
)_d3l1m1t3r_"
;

const char kCommonSlices[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- No new changes allowed. Will be removed after v45 of Perfetto.
--
-- We decided to move away from the generalised `common` module and migrate the
-- most useful functionality into specialised modules.
INCLUDE PERFETTO MODULE deprecated.v42.common.args;
INCLUDE PERFETTO MODULE deprecated.v42.common.slices;
)_d3l1m1t3r_"
;

const char kCommonThreadStates[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- No new changes allowed. Will be removed after v45 of Perfetto.
--
-- We decided to move away from the generalised `common` module and migrate the
-- most useful functionality into specialised modules.
INCLUDE PERFETTO MODULE deprecated.v42.common.args;
INCLUDE PERFETTO MODULE deprecated.v42.common.thread_states;
)_d3l1m1t3r_"
;

const char kCommonTimestamps[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- No new changes allowed. Will be removed after v45 of Perfetto.
--
-- We decided to move away from the generalised `common` module and migrate the
-- most useful functionality into specialised modules.
INCLUDE PERFETTO MODULE deprecated.v42.common.args;
INCLUDE PERFETTO MODULE deprecated.v42.common.timestamps;
)_d3l1m1t3r_"
;

const char kCountersIntervals[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- For a given counter timeline (e.g. a single counter track), returns
-- intervals of time where the counter has the same value.
--
-- Intervals are computed in a "forward-looking" way. That is, if a counter
-- changes value at some timestamp, it's assumed it *just* reached that
-- value and it should continue to have that value until the next
-- value change. The final value is assumed to hold until the very end of
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- the trace.
--
-- For example, suppose we have the following data:
-- ```
-- ts=0, value=10, track_id=1
-- ts=0, value=10, track_id=2
-- ts=10, value=10, track_id=1
-- ts=10, value=20, track_id=2
-- ts=20, value=30, track_id=1
-- [end of trace at ts = 40]
-- ```
--
-- Then this macro will generate the following intervals:
-- ```
-- ts=0, dur=20, value=10, track_id=1
-- ts=20, dur=10, value=30, track_id=1
-- ts=0, dur=10, value=10, track_id=2
-- ts=10, dur=30, value=20, track_id=2
-- ```
CREATE PERFETTO MACRO counter_leading_intervals(
  -- A table/view/subquery corresponding to a "counter-like" table.
  -- This table must have the columns "id" and "ts" and "track_id" and "value" corresponding
  -- to an id, timestamp, counter track_id and associated counter value.
  counter_table TableOrSubquery)
-- Table with the schema (id UINT32, ts UINT64, dur UINT64, track_id UINT64,
-- value DOUBLE, next_value DOUBLE, delta_value DOUBLE).
RETURNS TableOrSubquery AS
(
  WITH base AS (
    SELECT
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      id,
      ts,
      track_id,
      value,
      LAG(value) OVER (PARTITION BY track_id ORDER BY ts) AS lag_value
    FROM $counter_table
  )
  SELECT
    id,
    ts,
    LEAD(ts, 1, trace_end()) OVER(PARTITION BY track_id ORDER BY ts) - ts AS dur,
    track_id,
    value,
    LEAD(value) OVER(PARTITION BY track_id ORDER BY ts) AS next_value,
    value - lag_value AS delta_value
  FROM base
  WHERE value != lag_value OR lag_value IS NULL
);
)_d3l1m1t3r_"
;

const char kCpuUtilizationGeneral[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE cpu.freq;

-- Returns the timestamp of the start of the partition that contains the |ts|.
CREATE PERFETTO FUNCTION _partition_start(ts INT, size INT) RETURNS INT AS
-- Division of two ints would result in floor(ts/size).
SELECT ($ts/$size)*$size;

-- Returns the number of partitions required to cover all of the trace
-- timestamps.
CREATE PERFETTO FUNCTION _partition_count(size INT) RETURNS INT AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
    (_partition_start(TRACE_END(), $size) -
    _partition_start(TRACE_START(), $size))/$size + 1;

-- Returns a table of partitions with first partition containing the
-- TRACE_START() and last one containing TRACE_END().
CREATE PERFETTO FUNCTION _partitions(size INT)
RETURNS TABLE (ts INT, ts_end INT) AS
WITH no_ends AS (
SELECT
    _partition_start(TRACE_START(), $size) + (id * $size) AS ts
-- We are using the sched table for source of ids. If the table is too small
-- for specified size, the results would be invalid none the less.
FROM sched
LIMIT _partition_count($size))
SELECT ts, ts + $size AS ts_end FROM no_ends;

-- Partitions any |intervals| table with partitions defined in the |partitions|
-- table.
CREATE PERFETTO MACRO _interval_partitions(
  -- Requires |ts| and |ts_end| columns.
  partitions TableOrSubquery,
  -- Requires |ts| and |ts_end| column.
  intervals TableOrSubquery
) RETURNS TableOrSubquery AS (
SELECT
  p.ts AS partition_ts,
  IIF(i.ts_end < p.ts_end, i.ts_end, p.ts_end) AS ts_end,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  IIF(i.ts < p.ts, p.ts, i.ts) AS ts
FROM $intervals i
JOIN $partitions p
ON (p.ts <= i.ts AND i.ts < p.ts_end));

-- Returns a table of utilization per given period.
-- Utilization is calculated as sum of average utilization of each CPU in each
-- period, which is defined as a multiply of |interval|. For this reason
-- first and last period might have lower then real utilization.
CREATE PERFETTO MACRO _cpu_avg_utilization_per_period(
  -- Length of the period on which utilization should be averaged.
  interval Expr,
  -- Either sched table or its filtered down version.
  sched_table TableOrSubquery
)
-- The returned table has the schema (ts UINT32, utilization DOUBLE,
-- unnormalized_utilization DOUBLE).
RETURNS TableOrSubquery AS (
SELECT
  partition_ts AS ts,
  SUM(ts_end - ts)/(cast_double!($interval) * (SELECT MAX(cpu) + 1 FROM sched)) AS utilization,
  SUM(ts_end - ts)/cast_double!($interval) AS unnormalized_utilization
FROM _interval_partitions!(_partitions($interval), $sched_table)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(GROUP BY 1);

CREATE PERFETTO VIEW _cpu_freq_for_metrics AS
SELECT
    id,
    ts,
    dur,
    cpu,
    freq
FROM cpu_freq_counters;

CREATE PERFETTO VIEW _sched_without_id AS
SELECT ts, dur, utid, cpu
FROM sched
WHERE utid != 0 AND dur != -1;

CREATE VIRTUAL TABLE _cpu_freq_per_thread_span_join
USING SPAN_LEFT_JOIN(
    _sched_without_id PARTITIONED cpu,
    _cpu_freq_for_metrics PARTITIONED cpu);

CREATE PERFETTO TABLE _cpu_freq_per_thread
AS SELECT * FROM _cpu_freq_per_thread_span_join;


)_d3l1m1t3r_"
;

const char kCpuUtilizationProcess[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE cpu.utilization.general;
INCLUDE PERFETTO MODULE time.conversion;

-- Returns a table of process utilization per given period.
-- Utilization is calculated as sum of average utilization of each CPU in each
-- period, which is defined as a multiply of |interval|. For this reason
-- first and last period might have lower then real utilization.
CREATE PERFETTO FUNCTION cpu_process_utilization_per_period(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    -- Length of the period on which utilization should be averaged.
    interval INT,
    -- Upid of the process.
    upid INT
)
RETURNS TABLE(
  -- Timestamp of start of a second.
  ts INT,
  -- Sum of average utilization over period.
  -- Note: as the data is normalized, the values will be in the
  -- [0, 1] range.
  utilization DOUBLE,
  -- Sum of average utilization over all CPUs over period.
  -- Note: as the data is unnormalized, the values will be in the
  -- [0, cpu_count] range.
  unnormalized_utilization DOUBLE
) AS
WITH sched_for_upid AS (
  SELECT
    ts,
    ts_end,
    utid
  FROM sched
  JOIN thread USING (utid)
  JOIN process USING (upid)
  WHERE upid = $upid AND utid != 0)
SELECT * FROM _cpu_avg_utilization_per_period!($interval, sched_for_upid);

-- Returns a table of process utilization per second.
-- Utilization is calculated as sum of average utilization of each CPU in each
-- period, which is defined as a multiply of |interval|. For this reason
-- first and last period might have lower then real utilization.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO FUNCTION cpu_process_utilization_per_second(
  -- Upid of the process.
  upid INT
)
RETURNS TABLE (
  -- Timestamp of start of a second.
  ts INT,
  -- Sum of average utilization over period.
  -- Note: as the data is normalized, the values will be in the
  -- [0, 1] range.
  utilization DOUBLE,
  -- Sum of average utilization over all CPUs over period.
  -- Note: as the data is unnormalized, the values will be in the
  -- [0, cpu_count] range.
  unnormalized_utilization DOUBLE
) AS
SELECT * FROM cpu_process_utilization_per_period(time_from_s(1), $upid);

-- Aggregated CPU statistics for each process.
CREATE PERFETTO TABLE cpu_cycles_per_process(
  -- Unique process id
  upid INT,
  -- Sum of CPU millicycles
  millicycles INT,
  -- Sum of CPU megacycles
  megacycles INT,
  -- Total runtime duration
  runtime INT,
  -- Minimum CPU frequency in kHz
  min_freq INT,
  -- Maximum CPU frequency in kHz
  max_freq INT,
  -- Average CPU frequency in kHz
  avg_freq INT
) AS
WITH threads AS (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  SELECT upid, utid FROM thread
)
SELECT
  upid,
  cast_int!(SUM(dur * freq) / 1000) AS millicycles,
  cast_int!(SUM(dur * freq) / 1000 / 1e9) AS megacycles,
  SUM(dur) AS runtime,
  MIN(freq) AS min_freq,
  MAX(freq) AS max_freq,
  cast_int!(SUM((dur * freq) / 1000) / SUM(dur / 1000)) AS avg_freq
FROM _cpu_freq_per_thread
JOIN threads USING (utid)
GROUP BY upid;
)_d3l1m1t3r_"
;

const char kCpuUtilizationSystem[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE cpu.utilization.general;
INCLUDE PERFETTO MODULE cpu.size;

INCLUDE PERFETTO MODULE time.conversion;

-- The purpose of this module is to provide high level aggregates of system
-- utilization, akin to /proc/stat results.

-- Returns a table of system utilization per given period.
-- Utilization is calculated as sum of average utilization of each CPU in each
-- period, which is defined as a multiply of |interval|. For this reason
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- first and last period might have lower then real utilization.
CREATE PERFETTO FUNCTION cpu_utilization_per_period(
  -- Length of the period on which utilization should be averaged.
  interval INT)
RETURNS TABLE (
  -- Timestamp of start of a second.
  ts INT,
  -- Sum of average utilization over period.
  -- Note: as the data is normalized, the values will be in the
  -- [0, 1] range.
  utilization DOUBLE,
  -- Sum of average utilization over all CPUs over period.
  -- Note: as the data is unnormalized, the values will be in the
  -- [0, cpu_count] range.
  unnormalized_utilization DOUBLE
) AS
SELECT *
FROM _cpu_avg_utilization_per_period!(
  $interval,
  (SELECT * FROM sched WHERE utid != 0)
);

-- Table with system utilization per second.
-- Utilization is calculated by sum of average utilization of each CPU every
-- second. For this reason first and last second might have lower then real
-- utilization.
CREATE PERFETTO TABLE cpu_utilization_per_second(
  -- Timestamp of start of a second.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ts INT,
  -- Sum of average utilization over period.
  -- Note: as the data is normalized, the values will be in the
  -- [0, 1] range.
  utilization DOUBLE,
  -- Sum of average utilization over all CPUs over period.
  -- Note: as the data is unnormalized, the values will be in the
  -- [0, cpu_count] range.
  unnormalized_utilization DOUBLE
) AS
SELECT
  ts,
  utilization,
  unnormalized_utilization
FROM cpu_utilization_per_period(time_from_s(1));

-- Aggregated CPU statistics for runtime of each thread on a CPU.
CREATE PERFETTO TABLE _cpu_cycles_raw(
  -- The id of CPU
  cpu INT,
  -- Unique thread id
  utid INT,
  -- Sum of CPU millicycles
  millicycles INT,
  -- Sum of CPU megacycles
  megacycles INT,
  -- Total runtime duration
  runtime INT,
  -- Minimum CPU frequency in kHz
  min_freq INT,
  -- Maximum CPU frequency in kHz
  max_freq INT,
  -- Average CPU frequency in kHz
  avg_freq INT
) AS
SELECT
  cpu,
  utid,
  -- We divide by 1e3 here as dur is in ns and freq in khz. In total
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- this means we need to divide the duration by 1e9 and multiply the
  -- frequency by 1e3 then multiply again by 1e3 to get millicycles
  -- i.e. divide by 1e3 in total.
  -- We use millicycles as we want to preserve this level of precision
  -- for future calculations.
  cast_int!(SUM(dur * freq) / 1000) AS millicycles,
  cast_int!(SUM(dur * freq) / 1000 / 1e9) AS megacycles,
  SUM(dur) AS runtime,
  MIN(freq) AS min_freq,
  MAX(freq) AS max_freq,
  -- We choose to work in micros space in both the numerator and
  -- denominator as this gives us good enough precision without risking
  -- overflows.
  cast_int!(SUM((dur * freq) / 1000) / SUM(dur / 1000)) AS avg_freq
FROM _cpu_freq_per_thread
GROUP BY utid, cpu;

-- Aggregated CPU statistics for each CPU.
CREATE PERFETTO TABLE cpu_cycles_per_cpu(
  -- The id of CPU
  cpu INT,
  -- CPU type
  cpu_type STRING,
  -- Sum of CPU millicycles
  millicycles INT,
  -- Sum of CPU megacycles
  megacycles INT,
  -- Total runtime of all threads running on CPU
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  runtime INT,
  -- Minimum CPU frequency in kHz
  min_freq INT,
  -- Maximum CPU frequency in kHz
  max_freq INT,
  -- Average CPU frequency in kHz
  avg_freq INT
) AS
SELECT
  cpu,
  cpu_guess_core_type(cpu) AS cpu_type,
  cast_int!(SUM(dur * freq) / 1000) AS millicycles,
  cast_int!(SUM(dur * freq) / 1000 / 1e9) AS megacycles,
  SUM(dur) AS runtime,
  MIN(freq) AS min_freq,
  MAX(freq) AS max_freq,
  cast_int!(SUM((dur * freq) / 1000) / SUM(dur / 1000)) AS avg_freq
FROM _cpu_freq_per_thread
GROUP BY cpu;
)_d3l1m1t3r_"
;

const char kCpuUtilizationThread[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE cpu.utilization.general;
INCLUDE PERFETTO MODULE time.conversion;

-- Returns a table of thread utilization per given period.
-- Utilization is calculated as sum of average utilization of each CPU in each
-- period, which is defined as a multiply of |interval|. For this reason
-- first and last period might have lower then real utilization.
CREATE PERFETTO FUNCTION cpu_thread_utilization_per_period(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    -- Length of the period on which utilization should be averaged.
    interval INT,
    -- Utid of the thread.
    utid INT
)
RETURNS TABLE(
  -- Timestamp of start of a second.
  ts INT,
  -- Sum of average utilization over period.
  -- Note: as the data is normalized, the values will be in the
  -- [0, 1] range.
  utilization DOUBLE,
  -- Sum of average utilization over all CPUs over period.
  -- Note: as the data is unnormalized, the values will be in the
  -- [0, cpu_count] range.
  unnormalized_utilization DOUBLE
) AS
WITH sched_for_utid AS (
  SELECT
    ts,
    ts_end,
    utid
  FROM sched
  WHERE utid = $utid
) SELECT * FROM _cpu_avg_utilization_per_period!($interval, sched_for_utid);

-- Returns a table of thread utilization per second.
-- Utilization is calculated as sum of average utilization of each CPU in each
-- period, which is defined as a multiply of |interval|. For this reason
-- first and last period might have lower then real utilization.
CREATE PERFETTO FUNCTION cpu_thread_utilization_per_second(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Utid of the thread.
  utid INT
)
RETURNS TABLE (
  -- Timestamp of start of a second.
  ts INT,
  -- Sum of average utilization over period.
  -- Note: as the data is normalized, the values will be in the
  -- [0, 1] range.
  utilization DOUBLE,
  -- Sum of average utilization over all CPUs over period.
  -- Note: as the data is unnormalized, the values will be in the
  -- [0, cpu_count] range.
  unnormalized_utilization DOUBLE
) AS
SELECT * FROM cpu_thread_utilization_per_period(time_from_s(1), $utid);

-- Aggregated CPU statistics for each thread.
CREATE PERFETTO TABLE cpu_cycles_per_thread(
  -- Unique thread id
  utid INT,
  -- Sum of CPU millicycles
  millicycles INT,
  -- Sum of CPU megacycles
  megacycles INT,
  -- Total runtime duration
  runtime INT,
  -- Minimum CPU frequency in kHz
  min_freq INT,
  -- Maximum CPU frequency in kHz
  max_freq INT,
  -- Average CPU frequency in kHz
  avg_freq INT
) AS
SELECT
  utid,
  cast_int!(SUM(dur * freq) / 1000) AS millicycles,
  cast_int!(SUM(dur * freq) / 1000 / 1e9) AS megacycles,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  SUM(dur) AS runtime,
  MIN(freq) AS min_freq,
  MAX(freq) AS max_freq,
  cast_int!(SUM((dur * freq) / 1000) / SUM(dur / 1000)) AS avg_freq
FROM _cpu_freq_per_thread
GROUP BY utid;
)_d3l1m1t3r_"
;

const char kCpuCpus[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE cpu.size;

-- All of the CPUs with their core type as a descriptive size ('little', 'mid', 'big', etc).
CREATE PERFETTO TABLE cpu_core_types(
  -- Index of the CPU.
  cpu_index INT,
  -- A descriptive size ('little', 'mid', 'big', etc) or NULL if we have insufficient information.
  size STRING
) AS
SELECT
  cpu as cpu_index,
  cpu_guess_core_type(cpu) AS size
FROM _ranked_cpus;
)_d3l1m1t3r_"
R"_d3l1m1t3r_()_d3l1m1t3r_"
;

const char kCpuFreq[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE counters.intervals;

-- Counter information for each frequency change for each CPU. Finds each time
-- region where a CPU frequency is constant.
CREATE PERFETTO TABLE cpu_freq_counters(
  -- Counter id.
  id INT,
  -- Joinable with 'counter_track.id'.
  track_id INT,
  -- Starting timestamp of the counter
  ts LONG,
  -- Duration in which counter is constant and frequency doesn't change.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  dur INT,
  -- Frequency in kHz of the CPU that corresponds to this counter. NULL if not
  -- found or undefined.
  freq INT,
  -- CPU that corresponds to this counter.
  cpu INT
) AS
SELECT
  count_w_dur.id,
  count_w_dur.track_id,
  count_w_dur.ts,
  count_w_dur.dur,
  cast_int!(count_w_dur.value) as freq,
  cct.cpu
FROM
counter_leading_intervals!((
  SELECT c.*
  FROM counter c
  JOIN cpu_counter_track cct
  ON cct.id = c.track_id AND cct.name = 'cpufreq'
)) count_w_dur
JOIN cpu_counter_track cct
ON track_id = cct.id;


)_d3l1m1t3r_"
;

const char kCpuIdle[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE counters.intervals;

-- Counter information for each idle state change for each CPU. Finds each time
-- region where a CPU idle state is constant.
CREATE PERFETTO TABLE cpu_idle_counters(
  -- Counter id.
  id INT,
  -- Joinable with 'counter_track.id'.
  track_id INT,
  -- Starting timestamp of the counter.
  ts LONG,
  -- Duration in which the counter is contant and idle state doesn't change.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  dur INT,
  -- Idle state of the CPU that corresponds to this counter. An idle state of -1
  -- is defined to be active state for the CPU, and the larger the integer, the
  -- deeper the idle state of the CPU. NULL if not found or undefined.
  idle INT,
  -- CPU that corresponds to this counter.
  cpu INT
)
AS
SELECT
  count_w_dur.id,
  count_w_dur.track_id,
  count_w_dur.ts,
  count_w_dur.dur,
  cast_int!(IIF(count_w_dur.value = 4294967295, -1, count_w_dur.value)) AS idle,
  cct.cpu
FROM
counter_leading_intervals!((
  SELECT c.*
  FROM counter c
  JOIN cpu_counter_track cct
  ON cct.id = c.track_id and cct.name = 'cpuidle'
)) count_w_dur
JOIN cpu_counter_track cct
ON track_id = cct.id;


)_d3l1m1t3r_"
;

const char kCpuSize[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

CREATE PERFETTO TABLE _cpu_sizes AS
SELECT 0 AS n, 'little' AS size
UNION
SELECT 1 AS n, 'mid' AS size
UNION
SELECT 2 AS n, 'big' AS size;

CREATE PERFETTO TABLE _ranked_cpus AS
SELECT
 (DENSE_RANK() OVER win) - 1 AS n,
 cpu
FROM (
  SELECT
    track.cpu AS cpu,
    MAX(counter.value) AS maxfreq
  FROM counter
  JOIN cpu_counter_track AS track
  ON (counter.track_id = track.id)
  WHERE track.name = "cpufreq"
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  GROUP BY track.cpu
)
WINDOW win AS (ORDER BY maxfreq);

-- Guess size of CPU.
-- On some multicore devices the cores are heterogeneous and divided
-- into two or more 'sizes'. In a typical case a device might have 8
-- cores of which 4 are 'little' (low power & low performance) and 4
-- are 'big' (high power & high performance). This functions attempts
-- to map a given CPU index onto the relevant descriptor. For
-- homogeneous systems this returns NULL.
CREATE PERFETTO FUNCTION cpu_guess_core_type(
  -- Index of the CPU whose size we will guess.
  cpu_index INT)
-- A descriptive size ('little', 'mid', 'big', etc) or NULL if we have insufficient information.
RETURNS STRING AS
SELECT
  IIF((SELECT COUNT(DISTINCT n) FROM _ranked_cpus) >= 2, size, null) as size
FROM _ranked_cpus
LEFT JOIN _cpu_sizes USING(n)
WHERE cpu = $cpu_index;
)_d3l1m1t3r_"
;

const char kDeprecatedV42CommonArgs[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Returns the formatted value of a given argument.
-- Similar to EXTRACT_ARG, but instead of returning the raw value, it returns
-- the value formatted according to the 'value_type' column (e.g. for booleans,
-- EXTRACT_ARG will return 0 or 1, while FORMATTED_ARG will return 'true' or
-- 'false').
CREATE PERFETTO FUNCTION formatted_arg(
  -- Id of the arg set.
  arg_set_id INT,
  -- Key of the argument.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  arg_key STRING
)
-- Formatted value of the argument.
RETURNS STRING AS
SELECT display_value
FROM args
WHERE arg_set_id = $arg_set_id AND key = $arg_key;
)_d3l1m1t3r_"
;

const char kDeprecatedV42CommonCounters[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE deprecated.v42.common.timestamps;

-- Timestamp of first counter value in a counter.
CREATE PERFETTO FUNCTION earliest_timestamp_for_counter_track(
  -- Id of a counter track with a counter.
  counter_track_id INT)
-- Timestamp of first counter value. Null if doesn't exist.
RETURNS LONG AS
SELECT MIN(ts) FROM counter WHERE counter.track_id = $counter_track_id;

)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- Counter values with details of counter track with calculated duration of each counter value.
-- Duration is calculated as time from counter to the next counter.
CREATE PERFETTO FUNCTION counter_with_dur_for_track(
  -- Id of track counter track.
  counter_track_id INT)
RETURNS TABLE(
    -- Timestamp of the counter value.
    ts LONG,
    -- Duration of the counter value.
    dur LONG,
    -- Counter value.
    value DOUBLE,
    -- Id of the counter track.
    track_id INT,
    -- Name of the counter track.
    track_name STRING,
    -- Counter track set id.
    track_arg_set_id INT,
    -- Counter arg set id.
    arg_set_id INT
) AS
SELECT
  ts,
  LEAD(ts, 1, trace_end()) OVER(ORDER BY ts) - ts AS dur,
  value,
  track.id AS track_id,
  track.name AS track_name,
  track.source_arg_set_id AS track_arg_set_id,
  counter.arg_set_id AS arg_set_id
FROM counter
JOIN counter_track track ON track.id = counter.track_id
WHERE track.id = $counter_track_id;

-- COUNTER_WITH_DUR_FOR_TRACK but in a specified time.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- Does calculation over the table ends - creates an artificial counter value at
-- the start if needed and chops the duration of the last timestamps in range.
CREATE PERFETTO FUNCTION counter_for_time_range(
  -- Id of track counter track.
  counter_track_id INT,
  -- Timestamp of the timerange start.
  -- Can be earlier than the first counter value.
  start_ts LONG,
  -- Timestamp of the timerange end.
  end_ts LONG)
RETURNS TABLE(
  -- Timestamp of the counter value.
  ts LONG,
  -- Duration of the counter value.
  dur LONG,
  -- Counter value.
  value DOUBLE,
  -- If of the counter track.
  track_id INT,
  -- Name of the counter track.
  track_name STRING,
  -- Counter track set id.
  track_arg_set_id INT,
  -- Counter arg set id.
  arg_set_id INT
) AS
SELECT
  IIF(ts < $start_ts, $start_ts, ts) AS ts,
  IIF(
    ts < $start_ts,
    dur - ($start_ts - ts),
    IIF(ts + dur > $end_ts, $end_ts - ts, dur)) AS dur,
  value,
  track_id,
  track_name,
  track_arg_set_id,
  arg_set_id
FROM counter_with_dur_for_track($counter_track_id)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(WHERE TRUE
  AND ts + dur >= $start_ts
  AND ts < $end_ts
ORDER BY ts ASC;

)_d3l1m1t3r_"
;

const char kDeprecatedV42CommonCpus[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE cpu.size;
INCLUDE PERFETTO MODULE cpu.cpus;

CREATE PERFETTO TABLE cpus(cpu_index INT, size STRING)
AS
SELECT * FROM cpu_core_types;


CREATE PERFETTO FUNCTION guess_cpu_size(cpu_index INT)
RETURNS STRING AS
SELECT cpu_guess_core_type($cpu_index);
)_d3l1m1t3r_"
;

const char kDeprecatedV42CommonMetadata[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Extracts an int value with the given name from the metadata table.
CREATE PERFETTO FUNCTION extract_int_metadata(
  -- The name of the metadata entry.
  name STRING)
-- int_value for the given name. NULL if there's no such entry.
RETURNS LONG AS
SELECT int_value FROM metadata WHERE name = ($name);
)_d3l1m1t3r_"
;

const char kDeprecatedV42CommonPercentiles[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE deprecated.v42.common.counters;
INCLUDE PERFETTO MODULE deprecated.v42.common.timestamps;

CREATE PERFETTO FUNCTION _number_generator(upper_limit INT)
RETURNS TABLE(num INT) AS
WITH nums AS
    (SELECT 1 num UNION SELECT num + 1
    from NUMS
    WHERE num < $upper_limit)
SELECT num FROM nums;

CREATE PERFETTO FUNCTION _earliest_timestamp_for_counter_track(
  -- Id of a counter track with a counter.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  counter_track_id INT)
-- Timestamp of first counter value. Null if doesn't exist.
RETURNS LONG AS
SELECT MIN(ts) FROM counter WHERE counter.track_id = $counter_track_id;

-- COUNTER_WITH_DUR_FOR_TRACK but in a specified time.
-- Does calculation over the table ends - creates an artificial counter value at
-- the start if needed and chops the duration of the last timestamps in range.
CREATE PERFETTO FUNCTION _counter_for_time_range(
  -- Id of track counter track.
  counter_track_id INT,
  -- Timestamp of the timerange start.
  -- Can be earlier than the first counter value.
  start_ts LONG,
  -- Timestamp of the timerange end.
  end_ts LONG)
RETURNS TABLE(
  -- Timestamp of the counter value.
  ts LONG,
  -- Duration of the counter value.
  dur LONG,
  -- Counter value.
  value DOUBLE,
  -- If of the counter track.
  track_id INT,
  -- Name of the counter track.
  track_name STRING,
  -- Counter track set id.
  track_arg_set_id INT,
  -- Counter arg set id.
  arg_set_id INT
) AS
SELECT
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  IIF(ts < $start_ts, $start_ts, ts) AS ts,
  IIF(
    ts < $start_ts,
    dur - ($start_ts - ts),
    IIF(ts + dur > $end_ts, $end_ts - ts, dur)) AS dur,
  value,
  track_id,
  track_name,
  track_arg_set_id,
  arg_set_id
FROM counter_with_dur_for_track($counter_track_id)
WHERE TRUE
  AND ts + dur >= $start_ts
  AND ts < $end_ts
ORDER BY ts ASC;

--
-- Get durations for percentile
--

-- All percentiles (range 1-100) for counter track ID in a given time range.
--
-- Percentiles are calculated by:
-- 1. Dividing the sum of duration in time range for each value in the counter
-- by duration of the counter in range. This gives us `percentile_for)value` (DOUBLE).
-- 2. Fetching each percentile by taking floor of each `percentile_for_value`, grouping by
-- resulting `percentile` and MIN from value for each grouping. As we are rounding down,
-- taking MIN assures most reliable data.
-- 3. Filling the possible gaps in percentiles by getting the minimal value from higher
-- percentiles for each gap.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO FUNCTION counter_percentiles_for_time_range(
  -- Id of the counter track.
  counter_track_id INT,
  -- Timestamp of start of time range.
  start_ts LONG,
  -- Timestamp of end of time range.
  end_ts LONG)
RETURNS TABLE(
  -- All of the numbers from 1 to 100.
  percentile INT,
  -- Value for the percentile.
  value DOUBLE
) AS
WITH percentiles_for_value AS (
    SELECT
        value,
        (CAST(SUM(dur) OVER(ORDER BY value ASC) AS DOUBLE) /
            ($end_ts - MAX($start_ts, _earliest_timestamp_for_counter_track($counter_track_id)))) * 100
        AS percentile_for_value
    FROM _COUNTER_FOR_TIME_RANGE($counter_track_id, $start_ts, $end_ts)
    ORDER BY value ASC
),
with_gaps AS (
    SELECT
        CAST(percentile_for_value AS INT) AS percentile,
        MIN(value) AS value
    FROM percentiles_for_value
    GROUP BY percentile
    ORDER BY percentile ASC)
SELECT
    num AS percentile,
    IFNULL(value, MIN(value) OVER (ORDER BY percentile DESC)) AS value
FROM _NUMBER_GENERATOR(100) AS nums
)_d3l1m1t3r_"
R"_d3l1m1t3r_(LEFT JOIN with_gaps ON with_gaps.percentile = nums.num
ORDER BY percentile DESC;

-- All percentiles (range 1-100) for counter track ID.
CREATE PERFETTO FUNCTION counter_percentiles_for_track(
  -- Id of the counter track.
  counter_track_id INT)
RETURNS TABLE(
  -- All of the numbers from 1 to 100.
  percentile INT,
  -- Value for the percentile.
  value DOUBLE
) AS
SELECT *
FROM counter_percentiles_for_time_range(
  $counter_track_id, trace_start(), trace_end());

-- Value for specific percentile (range 1-100) for counter track ID in time range.
CREATE PERFETTO FUNCTION counter_track_percentile_for_time(
  -- Id of the counter track.
  counter_track_id INT,
  -- Any of the numbers from 1 to 100.
  percentile INT,
  -- Timestamp of start of time range.
  start_ts LONG,
  -- Timestamp of end of time range.
  end_ts LONG)
-- Value for the percentile.
RETURNS DOUBLE AS
SELECT value
FROM counter_percentiles_for_time_range($counter_track_id, $start_ts, $end_ts)
WHERE percentile = $percentile;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Value for specific percentile (range 1-100) for counter track ID.
CREATE PERFETTO FUNCTION counter_track_percentile(
  -- Id of the counter track.
  counter_track_id INT,
  -- Any of the numbers from 1 to 100.
  percentile INT)
-- Value for the percentile.
RETURNS DOUBLE AS
SELECT counter_track_percentile_for_time($counter_track_id,
                                         $percentile,
                                         trace_start(),
                                         trace_end());

)_d3l1m1t3r_"
;

const char kDeprecatedV42CommonSlices[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE slices.with_context;

-- Checks if slice has an ancestor with provided name.
CREATE PERFETTO FUNCTION has_parent_slice_with_name(
  -- Id of the slice to check parents of.
  id INT,
  -- Name of potential ancestor slice.
  parent_name STRING)
-- Whether `parent_name` is a name of an ancestor slice.
RETURNS BOOL AS
SELECT EXISTS(
  SELECT 1
  FROM ancestor_slice($id)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  WHERE name = $parent_name
  LIMIT 1
);

-- Checks if slice has a descendant with provided name.
CREATE PERFETTO FUNCTION has_descendant_slice_with_name(
  -- Id of the slice to check descendants of.
  id INT,
  -- Name of potential descendant slice.
  descendant_name STRING
)
-- Whether `descendant_name` is a name of an descendant slice.
RETURNS BOOL AS
SELECT EXISTS(
  SELECT 1
  FROM descendant_slice($id)
  WHERE name = $descendant_name
  LIMIT 1
);

-- Finds the end timestamp for a given slice's descendant with a given name.
-- If there are multiple descendants with a given name, the function will return the
-- first one, so it's most useful when working with a timeline broken down into phases,
-- where each subphase can happen only once.
CREATE PERFETTO FUNCTION descendant_slice_end(
  -- Id of the parent slice.
  parent_id INT,
  -- Name of the child with the desired end TS.
  child_name STRING
)
-- End timestamp of the child or NULL if it doesn't exist.
RETURNS INT AS
SELECT
  CASE WHEN s.dur
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    IS NOT -1 THEN s.ts + s.dur
    ELSE NULL
  END
FROM descendant_slice($parent_id) s
WHERE s.name = $child_name
LIMIT 1;

-- Finds all slices with a direct parent with the given parent_id.
CREATE PERFETTO FUNCTION direct_children_slice(
  -- Id of the parent slice.
  parent_id LONG)
RETURNS TABLE(
  -- Alias for `slice.id`.
  id LONG,
  -- Alias for `slice.type`.
  type STRING,
  -- Alias for `slice.ts`.
  ts LONG,
  -- Alias for `slice.dur`.
  dur LONG,
  -- Alias for `slice.category`.
  category LONG,
  -- Alias for `slice.name`.
  name STRING,
  -- Alias for `slice.track_id`.
  track_id LONG,
  -- Alias for `slice.depth`.
  depth LONG,
  -- Alias for `slice.parent_id`.
  parent_id LONG,
  -- Alias for `slice.arg_set_id`.
  arg_set_id LONG,
  -- Alias for `slice.thread_ts`.
  thread_ts LONG,
  -- Alias for `slice.thread_dur`.
  thread_dur LONG
) AS
SELECT
  slice.id,
  slice.type,
  slice.ts,
  slice.dur,
  slice.category,
  slice.name,
  slice.track_id,
  slice.depth,
  slice.parent_id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  slice.arg_set_id,
  slice.thread_ts,
  slice.thread_dur
FROM slice
WHERE parent_id = $parent_id;

-- Given a slice id, returns the name of the slice.
CREATE PERFETTO FUNCTION slice_name_from_id(
  -- The slice id which we need the name for.
  id LONG
)
-- The name of slice with the given id.
RETURNS STRING AS
SELECT
  name
FROM slice
WHERE $id = id;

CREATE PERFETTO FUNCTION slice_count(
  -- Name of the slices to counted.
  slice_glob STRING)
-- Number of slices with the name.
RETURNS INT AS
SELECT COUNT(1) FROM slice WHERE name GLOB $slice_glob;

)_d3l1m1t3r_"
;

const char kDeprecatedV42CommonThreadStates[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE deprecated.v42.common.timestamps;
INCLUDE PERFETTO MODULE sched.time_in_state;
INCLUDE PERFETTO MODULE sched.states;
INCLUDE PERFETTO MODULE cpu.size;

CREATE PERFETTO FUNCTION _translate_thread_state_name(name STRING)
RETURNS STRING AS
SELECT sched_state_to_human_readable_string($name);


-- Returns a human-readable name for a thread state.
CREATE PERFETTO FUNCTION human_readable_thread_state_name(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Thread state id.
  id INT)
-- Human-readable name for the thread state.
RETURNS STRING AS
SELECT sched_state_io_to_human_readable_string(state, io_wait)
FROM thread_state
WHERE id = $id;

-- Returns an aggregation of thread states (by state and cpu) for a given
-- interval of time for a given thread.
CREATE PERFETTO FUNCTION thread_state_summary_for_interval(
  -- The start of the interval.
  ts INT,
  -- The duration of the interval.
  dur INT,
  -- The utid of the thread.
  utid INT)
RETURNS TABLE(
  -- Human-readable thread state name.
  state STRING,
  -- Raw thread state name, alias of `thread_state.state`.
  raw_state STRING,
  -- The type of CPU if available (e.g. "big" / "mid" / "little").
  cpu_type STRING,
  -- The CPU index.
  cpu INT,
  -- The name of the kernel function execution is blocked in.
  blocked_function STRING,
  -- The total duration.
  dur INT
) AS
SELECT
  sched_state_io_to_human_readable_string(state, io_wait) as state,
  state AS raw_state,
  cpu_guess_core_type(cpu) as cpu_type,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  cpu,
  blocked_function,
  dur
FROM sched_time_in_state_and_cpu_for_thread_in_interval($ts, $dur, $utid);
)_d3l1m1t3r_"
;

const char kDeprecatedV42CommonTimestamps[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE time.conversion;

CREATE PERFETTO FUNCTION is_spans_overlapping(
  ts1 LONG,
  ts_end1 LONG,
  ts2 LONG,
  ts_end2 LONG)
RETURNS BOOL AS
SELECT (IIF($ts1 < $ts2, $ts2, $ts1)
      < IIF($ts_end1 < $ts_end2, $ts_end1, $ts_end2));

CREATE PERFETTO FUNCTION spans_overlapping_dur(
  ts1 LONG,
  dur1 LONG,
  ts2 LONG,
  dur2 LONG
)
RETURNS INT AS
SELECT
  CASE
    WHEN $dur1 = -1 OR $dur2 = -1 THEN 0
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    WHEN $ts1 + $dur1 < $ts2 OR $ts2 + $dur2 < $ts1 THEN 0
    WHEN ($ts1 >= $ts2) AND ($ts1 + $dur1 <= $ts2 + $dur2) THEN $dur1
    WHEN ($ts1 < $ts2) AND ($ts1 + $dur1 < $ts2 + $dur2) THEN $ts1 + $dur1 - $ts2
    WHEN ($ts1 > $ts2) AND ($ts1 + $dur1 > $ts2 + $dur2) THEN $ts2 + $dur2 - $ts1
    ELSE $dur2
  END;

-- Renames

CREATE PERFETTO FUNCTION ns(nanos INT)
RETURNS INT AS
SELECT time_from_ns($nanos);

CREATE PERFETTO FUNCTION us(micros INT)
RETURNS INT AS
SELECT time_from_us($micros);

CREATE PERFETTO FUNCTION ms(millis INT)
RETURNS INT AS
SELECT time_from_ms($millis);

CREATE PERFETTO FUNCTION seconds(seconds INT)
RETURNS INT AS
SELECT time_from_s($seconds);

CREATE PERFETTO FUNCTION minutes(minutes INT)
RETURNS INT AS
SELECT time_from_min($minutes);

CREATE PERFETTO FUNCTION hours(hours INT)
RETURNS INT AS
SELECT time_from_hours($hours);

CREATE PERFETTO FUNCTION days(days INT)
RETURNS INT AS
SELECT time_from_days($days);

)_d3l1m1t3r_"
;

const char kGpuFrequency[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE counters.intervals;

-- GPU frequency counter per GPU.
CREATE PERFETTO TABLE gpu_frequency(
  -- Timestamp
  ts INT,
  -- Duration
  dur INT,
  -- GPU id. Joinable with `gpu_counter_track.gpu_id`.
  gpu_id INT,
  -- GPU frequency
  gpu_freq INT
) AS
SELECT
  ts,
  dur,
  gpu_id,
  cast_int!(value) AS gpu_freq
FROM counter_leading_intervals!((
    SELECT c.*
    FROM counter c
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    JOIN gpu_counter_track t
    ON t.id = c.track_id AND t.name = 'gpufreq'
    WHERE gpu_id IS NOT NULL
))
JOIN gpu_counter_track t ON t.id = track_id;
)_d3l1m1t3r_"
;

const char kGraphsDominatorTree[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Given a table containing a directed flow-graph and an entry node, computes
-- the "dominator tree" for the graph. See [1] for an explanation of what a
-- dominator tree is.
--
-- [1] https://en.wikipedia.org/wiki/Dominator_(graph_theory)
--
-- Example usage on traces containing heap graphs:
-- ```
-- CREATE PERFETTO VIEW dominator_compatible_heap_graph AS
-- -- Extract the edges from the heap graph which correspond to references
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- -- between objects.
-- SELECT
--   owner_id AS source_node_id,
--   owned_id as dest_node_id
-- FROM heap_graph_reference
-- JOIN heap_graph_object owner on heap_graph_reference.owner_id = owner.id
-- WHERE owned_id IS NOT NULL AND owner.reachable
-- UNION ALL
-- -- Since a Java heap graph is a "forest" structure, we need to add a dummy
-- -- "root" node which connects all the roots of the forest into a single
-- -- connected component.
-- SELECT
--   (SELECT max(id) + 1 FROM heap_graph_object) as source_node_id,
--   id
-- FROM heap_graph_object
-- WHERE root_type IS NOT NULL;
--
-- SELECT *
-- FROM graph_dominator_tree!(
--   dominator_compatible_heap_graph,
--   (SELECT max(id) + 1 FROM heap_graph_object)
-- );
-- ```
CREATE PERFETTO MACRO graph_dominator_tree(
  -- A table/view/subquery corresponding to a directed flow-graph on which the
  -- dominator tree should be computed. This table must have the columns
  -- "source_node_id" and "dest_node_id" corresponding to the two nodes on
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- either end of the edges in the graph.
  --
  -- Note: the columns must contain uint32 similar to ids in trace processor
  -- tables (i.e. the values should be relatively dense and close to zero). The
  -- implementation makes assumptions on this for performance reasons and, if
  -- this criteria is not, can lead to enormous amounts of memory being
  -- allocated.
  --
  -- Note: this means that the graph *must* be a single fully connected
  -- component with |root_node_id| (see below) being the "entry node" for this
  -- component. Specifically, all nodes *must* be reachable by following paths
  -- from the root node. Failing to adhere to this property will result in
  -- undefined behaviour.
  --
  -- If working with a "forest"-like structure, a dummy node should be added which
  -- links all the roots of the forest together into a single component; an example
  -- of this can be found in the heap graph example query above.
  graph_table TableOrSubquery,
  -- The entry node to |graph_table| which will be the root of the dominator
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- tree.
  root_node_id Expr
)
-- The returned table has the schema (node_id UINT32, dominator_node_id UINT32).
-- |node_id| is the id of the node from the input graph and |dominator_node_id|
-- is the id of the node in the input flow-graph which is the "dominator" of
-- |node_id|.
RETURNS TableOrSubquery AS
(
  -- Rename the generic columns of __intrinsic_table_ptr to the actual columns.
  SELECT c0 AS node_id, c1 AS dominator_node_id
  FROM __intrinsic_table_ptr((
    -- Aggregate function to perform a DFS on the nodes on the input graph.
    SELECT __intrinsic_dominator_tree(g.source_node_id, g.dest_node_id, $root_node_id)
    FROM $graph_table g
  ))
  -- Bind the dynamic columns in the |__intrinsic_table_ptr| to the columns of
  -- the dominator tree table.
  WHERE __intrinsic_table_ptr_bind(c0, 'node_id')
    AND __intrinsic_table_ptr_bind(c1, 'dominator_node_id')
);

)_d3l1m1t3r_"
;

const char kGraphsPartition[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Partitions a tree into a forest of trees based on a given grouping key
-- in a structure-preserving way.
--
-- Specifically, for each tree in the output forest, all the nodes in that tree
-- have the same ancestors and descendants as in the original tree *iff* that
-- ancestor/descendent belonged to the same group.
--
-- Example:
-- Input
--
--   id | parent_id | group_key
--   ---|-----------|----------
)_d3l1m1t3r_"
R"_d3l1m1t3r_(--   1  | NULL      | 1
--   2  | 1         | 1
--   3  | NULL      | 2
--   4  | NULL      | 2
--   5  | 2         | 1
--   6  | NULL      | 3
--   7  | 4         | 2
--   8  | 4         | 1
--
-- Or as a graph:
-- ```
--         1 (1)
--        /
--       2 (1)
--      /  \
--     3 (2) 4 (2)
--           /   \
--         5 (1) 8 (1)
--        /  \
--     6 (3) 7 (2)
-- ```
-- Possible output (order of rows is implementation-defined)
--
--   id | parent_id | group_key
--   ---|-----------|-------
--   1  | NULL      | 1
--   2  | 1         | 1
--   3  | NULL      | 2
--   4  | NULL      | 2
--   5  | 2         | 1
--   6  | NULL      | 3
--   7  | 4         | 2
--   8  | 2         | 1
--
-- Or as a forest:
-- ```
--     1 (1)       3 (2)      4 (2)        6 (3)
--      |                      |
--     2 (1)                  7 (2)
--     /   \
--   5 (1) 8 (1)
-- ```
CREATE PERFETTO MACRO tree_structural_partition_by_group(
  -- A table/view/subquery corresponding to a tree which should be partitioned.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- This table must have the columns "id", "parent_id" and "group_key".
  --
  -- Note: the columns must contain uint32 similar to ids in trace processor
  -- tables (i.e. the values should be relatively dense and close to zero). The
  -- implementation makes assumptions on this for performance reasons and, if
  -- this criteria is not, can lead to enormous amounts of memory being
  -- allocated.
  tree_table TableOrSubquery
)
-- The returned table has the schema
-- (id UINT32, parent_id UINT32, group_key UINT32).
RETURNS TableOrSubquery AS
(
  -- Rename the generic columns of __intrinsic_table_ptr to the actual columns.
  SELECT c0 AS id, c1 AS parent_id, c2 AS group_key
  FROM __intrinsic_table_ptr((
    -- Aggregate function to perform the partitioning algorithm.
    SELECT __intrinsic_structural_tree_partition(g.id, g.parent_id, g.group_key)
    FROM $tree_table g
  ))
  -- Bind the dynamic columns in the |__intrinsic_table_ptr| to the columns of
  -- the partitioning table.
  WHERE __intrinsic_table_ptr_bind(c0, 'node_id')
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    AND __intrinsic_table_ptr_bind(c1, 'parent_node_id')
    AND __intrinsic_table_ptr_bind(c2, 'group_key')
);

)_d3l1m1t3r_"
;

const char kGraphsSearch[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Computes the "reachable" set of nodes in a directed graph from a given set
-- of starting nodes by performing a depth-first search on the graph. The
-- returned nodes are structured as a tree with parent-child relationships
-- corresponding to the order in which nodes were encountered by the DFS.
--
-- While this macro can be used directly by end users (hence being public),
-- it is primarily intended as a lower-level building block upon which higher
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- level functions/macros in the standard library can be built.
--
-- Example usage on traces containing heap graphs:
-- ```
-- -- Compute the reachable nodes from the first heap root.
-- SELECT *
-- FROM graph_reachable_dfs!(
--   (
--     SELECT
--       owner_id AS source_node_id,
--       owned_id as dest_node_id
--     FROM heap_graph_reference
--     WHERE owned_id IS NOT NULL
--   ),
--   (SELECT id FROM heap_graph_object WHERE root_type IS NOT NULL)
-- );
-- ```
CREATE PERFETTO MACRO graph_reachable_dfs(
  -- A table/view/subquery corresponding to a directed graph on which the
  -- reachability search should be performed. This table must have the columns
  -- "source_node_id" and "dest_node_id" corresponding to the two nodes on
  -- either end of the edges in the graph.
  --
  -- Note: the columns must contain uint32 similar to ids in trace processor
  -- tables (i.e. the values should be relatively dense and close to zero). The
  -- implementation makes assumptions on this for performance reasons and, if
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- this criteria is not, can lead to enormous amounts of memory being
  -- allocated.
  graph_table TableOrSubquery,
  -- A table/view/subquery corresponding to the list of start nodes for
  -- the BFS. This table must have a single column "node_id".
  start_nodes TableOrSubquery
)
-- The returned table has the schema (node_id UINT32, parent_node_id UINT32).
-- |node_id| is the id of the node from the input graph and |parent_node_id|
-- is the id of the node which was the first encountered predecessor in a DFS
-- search of the graph.
RETURNS TableOrSubquery AS
(
  -- Rename the generic columns of __intrinsic_table_ptr to the actual columns.
  SELECT c0 AS node_id, c1 AS parent_node_id
  FROM __intrinsic_table_ptr(__intrinsic_dfs(
    (SELECT __intrinsic_graph_agg(g.source_node_id, g.dest_node_id) FROM $graph_table g),
    (SELECT __intrinsic_array_agg(t.node_id) arr FROM $start_nodes t)
  ))
  -- Bind the dynamic columns in the |__intrinsic_table_ptr| to the columns of
  -- the DFS table.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  WHERE __intrinsic_table_ptr_bind(c0, 'node_id')
    AND __intrinsic_table_ptr_bind(c1, 'parent_node_id')
);

-- Computes the "reachable" set of nodes in a directed graph from a given
-- starting node by performing a breadth-first search on the graph. The returned
-- nodes are structured as a tree with parent-child relationships corresponding
-- to the order in which nodes were encountered by the BFS.
--
-- While this macro can be used directly by end users (hence being public),
-- it is primarily intended as a lower-level building block upon which higher
-- level functions/macros in the standard library can be built.
--
-- Example usage on traces containing heap graphs:
-- ```
-- -- Compute the reachable nodes from all heap roots.
-- SELECT *
-- FROM graph_reachable_bfs!(
--   (
--     SELECT
--       owner_id AS source_node_id,
--       owned_id as dest_node_id
--     FROM heap_graph_reference
--     WHERE owned_id IS NOT NULL
--   ),
--   (SELECT id FROM heap_graph_object WHERE root_type IS NOT NULL)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- );
-- ```
CREATE PERFETTO MACRO graph_reachable_bfs(
  -- A table/view/subquery corresponding to a directed graph on which the
  -- reachability search should be performed. This table must have the columns
  -- "source_node_id" and "dest_node_id" corresponding to the two nodes on
  -- either end of the edges in the graph.
  --
  -- Note: the columns must contain uint32 similar to ids in trace processor
  -- tables (i.e. the values should be relatively dense and close to zero). The
  -- implementation makes assumptions on this for performance reasons and, if
  -- this criteria is not, can lead to enormous amounts of memory being
  -- allocated.
  graph_table TableOrSubquery,
  -- A table/view/subquery corresponding to the list of start nodes for
  -- the BFS. This table must have a single column "node_id".
  start_nodes TableOrSubquery
)
-- The returned table has the schema (node_id UINT32, parent_node_id UINT32).
-- |node_id| is the id of the node from the input graph and |parent_node_id|
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- is the id of the node which was the first encountered predecessor in a BFS
-- search of the graph.
RETURNS TableOrSubquery AS
(
  -- Rename the generic columns of __intrinsic_table_ptr to the actual columns.
  SELECT c0 AS node_id, c1 AS parent_node_id
  FROM __intrinsic_table_ptr(__intrinsic_bfs(
    (SELECT __intrinsic_graph_agg(g.source_node_id, g.dest_node_id) FROM $graph_table g),
    (SELECT __intrinsic_array_agg(t.node_id) arr FROM $start_nodes t)
  ))
  -- Bind the dynamic columns in the |__intrinsic_table_ptr| to the columns of
  -- the DFS table.
  WHERE __intrinsic_table_ptr_bind(c0, 'node_id')
    AND __intrinsic_table_ptr_bind(c1, 'parent_node_id')
);

-- Computes the next sibling node in a directed graph. The next node under a parent node
-- is determined by on the |sort_key|, which should be unique for every node under a parent.
-- The order of the next sibling is undefined if the |sort_key| is not unique.
--
-- Example usage:
-- ```
-- -- Compute the next sibling:
-- SELECT *
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- FROM graph_next_sibling!(
--   (
--     SELECT
--       id AS node_id,
--       parent_id AS node_parent_id,
--       ts AS sort_key
--     FROM slice
--   )
-- );
-- ```
CREATE PERFETTO MACRO graph_next_sibling(
  -- A table/view/subquery corresponding to a directed graph for which to find the next sibling.
  -- This table must have the columns "node_id", "node_parent_id" and "sort_key".
  graph_table TableOrSubquery
)
-- The returned table has the schema (node_id UINT32, next_node_id UINT32).
-- |node_id| is the id of the node from the input graph and |next_node_id|
-- is the id of the node which is its next sibling.
RETURNS TableOrSubquery AS
(
  SELECT node_id, lead(node_id) OVER (PARTITION BY node_parent_id ORDER BY sort_key) AS next_node_id
    FROM $graph_table
);

-- Computes the "reachable" set of nodes in a directed graph from a set of
-- starting (root) nodes by performing a depth-first search from each root node on the graph.
-- The search is bounded by the sum of edge weights on the path and the root node specifies the
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- max weight (inclusive) allowed before stopping the search.
-- The returned nodes are structured as a tree with parent-child relationships corresponding
-- to the order in which nodes were encountered by the DFS. Each row also has the root node from
-- which where the edge was encountered.
--
-- While this macro can be used directly by end users (hence being public),
-- it is primarily intended as a lower-level building block upon which higher
-- level functions/macros in the standard library can be built.
--
-- Example usage on traces with sched info:
-- ```
-- -- Compute the reachable nodes from a sched wakeup chain
-- INCLUDE PERFETTO MODULE sched.thread_executing_spans;
--
-- SELECT *
-- FROM
--   graph_reachable_dfs_bounded
--    !(
--      (
--        SELECT
--          id AS source_node_id,
--          COALESCE(parent_id, id) AS dest_node_id,
--          id - COALESCE(parent_id, id) AS edge_weight
--        FROM _wakeup_chain
--      ),
--      (
--        SELECT
--          id AS root_node_id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(--          id - COALESCE(prev_id, id) AS root_target_weight
--        FROM _wakeup_chain
--      ));
-- ```
CREATE PERFETTO MACRO graph_reachable_weight_bounded_dfs(
  -- A table/view/subquery corresponding to a directed graph on which the
  -- reachability search should be performed. This table must have the columns
  -- "source_node_id" and "dest_node_id" corresponding to the two nodes on
  -- either end of the edges in the graph and an "edge_weight" corresponding to the
  -- weight of the edge between the node.
  --
  -- Note: the columns must contain uint32 similar to ids in trace processor
  -- tables (i.e. the values should be relatively dense and close to zero). The
  -- implementation makes assumptions on this for performance reasons and, if
  -- this criteria is not, can lead to enormous amounts of memory being
  -- allocated.
  graph_table TableOrSubquery,
  -- A table/view/subquery corresponding to start nodes to |graph_table| which will be the
  -- roots of the reachability trees. This table must have the columns
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- "root_node_id" and "root_target_weight" corresponding to the starting node id and the max
  -- weight allowed on the tree.
  --
  -- Note: the columns must contain uint32 similar to ids in trace processor
  -- tables (i.e. the values should be relatively dense and close to zero). The
  -- implementation makes assumptions on this for performance reasons and, if
  -- this criteria is not, can lead to enormous amounts of memory being
  -- allocated.
  root_table TableOrSubquery,
  -- Whether the target_weight is a floor weight or ceiling weight.
  -- If it's floor, the search stops right after we exceed the target weight, and we
  -- include the node that pushed just passed the target. If ceiling, the search stops
  -- right before the target weight and the node that would have pushed us passed the
  -- target is not included.
  is_target_weight_floor Expr

)
-- The returned table has the schema (root_node_id, node_id UINT32, parent_node_id UINT32).
-- |root_node_id| is the id of the starting node under which this edge was encountered.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- |node_id| is the id of the node from the input graph and |parent_node_id|
-- is the id of the node which was the first encountered predecessor in a DFS
-- search of the graph.
RETURNS TableOrSubquery AS
(
  WITH __temp_graph_table AS (SELECT * FROM $graph_table),
  __temp_root_table AS (SELECT * FROM $root_table)
  SELECT dt.root_node_id, dt.node_id, dt.parent_node_id
  FROM __intrinsic_dfs_weight_bounded(
    (SELECT RepeatedField(source_node_id) FROM __temp_graph_table),
    (SELECT RepeatedField(dest_node_id) FROM __temp_graph_table),
    (SELECT RepeatedField(edge_weight) FROM __temp_graph_table),
    (SELECT RepeatedField(root_node_id) FROM __temp_root_table),
    (SELECT RepeatedField(root_target_weight) FROM __temp_root_table),
    $is_target_weight_floor
  ) dt
);

)_d3l1m1t3r_"
;

const char kIntervalsIntersect[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

CREATE PERFETTO MACRO _interval_intersect(
  left_table TableOrSubquery,
  right_table TableOrSubquery
)
RETURNS TableOrSubquery AS
(
  WITH
    __temp_left_table AS (SELECT * FROM $left_table ORDER BY ts),
    __temp_right_table AS (SELECT * FROM $right_table ORDER BY ts)
  SELECT ii.ts, ii.dur, ii.left_id, ii.right_id
  FROM __intrinsic_interval_intersect(
    (SELECT RepeatedField(id) FROM __temp_left_table),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    (SELECT RepeatedField(ts) FROM __temp_left_table),
    (SELECT RepeatedField(dur) FROM __temp_left_table),
    (SELECT RepeatedField(id) FROM __temp_right_table),
    (SELECT RepeatedField(ts) FROM __temp_right_table),
    (SELECT RepeatedField(dur) FROM __temp_right_table)
  ) ii
);

CREATE PERFETTO MACRO _interval_intersect_single(
  ts Expr,
  dur Expr,
  intervals_table TableOrSubquery
) RETURNS TableOrSubquery AS (
  SELECT
    left_id AS id,
    ts,
    dur
  FROM _interval_intersect!(
    $intervals_table,
    (SELECT
        0 AS id,
        $ts AS ts,
        $dur AS dur
    )
  )
)

)_d3l1m1t3r_"
;

const char kIntervalsOverlap[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Compute the distribution of the overlap of the given intervals over time.
--
-- Each interval is a (ts, dur) pair and the overlap represented as a (ts, value)
-- counter, with the value corresponding to the number of intervals that overlap
-- the given timestamp and interval until the next timestamp.
CREATE PERFETTO MACRO intervals_overlap_count(
    -- Table or subquery containing interval data.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    segments TableOrSubquery,
    -- Column containing interval starts (usually `ts`).
    ts_column ColumnName,
    -- Column containing interval durations (usually `dur`).
    dur_column ColumnName)
-- The returned table has the schema (ts INT64, value UINT32).
-- |ts| is the timestamp when the number of open segments changed. |value| is
-- the number of open segments.
RETURNS TableOrSubquery AS
(
-- Algorithm: for each segment, emit a +1 at the start and a -1 at the end.
-- Then, merge events with the same timestamp and compute a cumulative sum.
WITH
_starts AS (
  SELECT
    1 AS delta,
    $ts_column AS ts
  FROM $segments
),
_ends AS (
  SELECT
    -1 AS delta,
    $ts_column + $dur_column AS ts
  FROM $segments
  WHERE $dur_column != -1
),
_events AS (
  SELECT * FROM _starts
  UNION ALL
  SELECT * FROM _ends
),
-- Merge events with the same timestamp to avoid artifacts in the data.
_merged_events AS (
  SELECT ts, sum(delta) as delta
  FROM _events
  GROUP BY ts
)
SELECT
  ts,
  sum(delta) OVER (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    ORDER BY ts
    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
  ) as value
FROM _merged_events
ORDER BY ts
);

-- Returns whether |intervals| contains any overlapping intervals. Useful for
-- checking if provided table/subquery can be used for intervals_intersect
-- macro.
CREATE PERFETTO MACRO _intervals_overlap_in_table(
  -- Table/subquery of intervals with |ts| and |dur| columns.
  intervals TableOrSubquery)
-- Returns 1 if table contains overlapping intervals. Otherwise returns 0.
RETURNS Expr AS (
WITH ts_with_next AS (
  SELECT
    ts + dur AS ts_end,
    -- The last slice will have |next_ts == NULL|, but it's not an issue as if
    -- it's the last slice we know that it will not overlap with the next one.
    LEAD(ts) OVER (ORDER BY ts) AS next_ts
  FROM $intervals
  WHERE dur != -1
), filtered AS (
  SELECT * FROM ts_with_next
  WHERE ts_end > next_ts
  LIMIT 1
)
SELECT count() AS has_overlaps
FROM filtered
);

-- Merges a |roots_table| and |children_table| into one table. See _intervals_flatten
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- that accepts the output of this macro to flatten intervals.
CREATE PERFETTO MACRO _intervals_merge_root_and_children(
  -- Table or subquery containing all the root intervals: (id, ts, dur).
  -- Note that parent_id is not necessary in this table as it will be NULL anyways.
  roots_table TableOrSubquery,
  -- Table or subquery containing all the child intervals:
  -- (root_id, id, parent_id, ts, dur)
  children_table TableOrSubquery)
-- The returned table has the schema (root_id UINT32, root_ts INT64, root_dur, INT64,
-- id UINT32, parent_id UINT32, ts INT64, dur INT64).
RETURNS TableOrSubquery
AS (
  WITH
    _roots AS (
      SELECT id AS root_id, ts AS root_ts, dur AS root_dur FROM ($roots_table) WHERE dur > 0
    ),
    _children AS (
      SELECT * FROM ($children_table) WHERE dur > 0
    ),
    _roots_without_children AS (
      SELECT root_id FROM _roots
      EXCEPT
      SELECT DISTINCT parent_id AS root_id FROM _children
    )
    SELECT
      _roots.root_id,
      _roots.root_ts,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      _roots.root_dur,
      _children.id,
      _children.parent_id,
      _children.ts,
      _children.dur
    FROM _children
    JOIN _roots USING(root_id)
    UNION ALL
    -- Handle singleton roots
    SELECT
      root_id,
      root_ts,
      root_dur,
      NULL AS id,
      NULL AS parent_id,
      NULL AS ts,
      NULL AS dur
    FROM _roots_without_children
    JOIN _roots USING(root_id)
);

-- Partition and flatten a hierarchy of intervals into non-overlapping intervals where
-- each resulting interval is the leaf in the hierarchy at any given time. The result also
-- denotes the 'self-time' of each interval.
--
-- Each interval is a (root_id, root_ts, root_dur, id, parent_id, ts, dur) and the overlap is
-- represented as a (root_id, id, parent_id, ts, dur).
-- Note that, children intervals must not be longer than any ancestor interval.
-- See _intervals_merge_root_and_children that can be used to generate input to this macro
-- from two different root and children tables.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO MACRO _intervals_flatten(children_with_roots_table TableOrSubquery)
-- The returned table has the schema (root_id UINT32, id UINT32, ts INT64, dur INT64).
RETURNS TableOrSubquery
AS (
  -- Algorithm: Sort all the start and end timestamps of the children within a root.
  -- The interval duration between one timestamp and the next is one result.
  -- If the timestamp is a start, the id is the id of the interval, if it's an end,
  -- it's the parent_id.
  -- Special case the edges of the roots and roots without children.
  WITH
    _children_with_roots AS (
      SELECT * FROM ($children_with_roots_table) WHERE root_dur > 0 AND (dur IS NULL OR dur > 0)
    ),
    _ends AS (
      SELECT
        root_id,
        root_ts,
        root_dur,
        IFNULL(parent_id, root_id) AS id,
        ts + dur AS ts
      FROM _children_with_roots WHERE id IS NOT NULL
    ),
    _events AS (
      SELECT root_id, root_ts, root_dur, id, ts, 1 AS priority
      FROM _children_with_roots
      UNION ALL
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      SELECT root_id, root_ts, root_dur, id, ts, 0 AS priority FROM _ends
    ),
    _events_deduped AS (
      SELECT root_id, root_ts, root_dur, id, ts
      FROM _events
      GROUP BY root_id, ts
      HAVING priority = MAX(priority)
    ),
    _intervals AS (
      SELECT
        root_id,
        root_ts,
        root_dur,
        id,
        ts,
        LEAD(ts)
          OVER (PARTITION BY root_id ORDER BY ts) - ts AS dur
      FROM _events_deduped
    ),
    _only_middle AS (
      SELECT * FROM _intervals WHERE dur > 0
    ),
    _only_start AS (
      SELECT
        root_id,
        root_id AS id,
        root_ts AS ts,
        MIN(ts) - root_ts AS dur
      FROM _only_middle
      GROUP BY root_id
      HAVING dur > 0
    ),
    _only_end AS (
      SELECT
        root_id,
        root_id AS id,
        MAX(ts + dur) AS ts,
        root_ts + root_dur - MAX(ts + dur) AS dur
      FROM _only_middle
      GROUP BY root_id
      HAVING dur > 0
    ),
    _only_singleton AS (
      SELECT root_id, root_id AS id, root_ts AS ts, root_dur AS dur
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      FROM _children_with_roots WHERE id IS NULL
      GROUP BY root_id
    )
  SELECT root_id, id, ts, dur FROM _only_middle
  UNION ALL
  SELECT root_id, id, ts, dur FROM _only_start
  UNION ALL
  SELECT root_id, id, ts, dur FROM _only_end
  UNION ALL
  SELECT root_id, id, ts, dur FROM _only_singleton
);

)_d3l1m1t3r_"
;

const char kLinuxCpuIdle[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- CPU frequency counter per core.
CREATE PERFETTO VIEW _cpu_freq_counters
AS
SELECT
  ts,
  dur,
  value AS freq_value,
  cct.cpu
FROM experimental_counter_dur ecd
LEFT JOIN cpu_counter_track cct
  ON ecd.track_id = cct.id
WHERE cct.name = 'cpufreq';

-- CPU idle counter per core.
CREATE PERFETTO VIEW _cpu_idle_counters
AS
SELECT
  ts,
  dur,
  -- Correct 4294967295 to -1 (both of them means an exit from the current state).
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  iif(value = 4294967295, -1, CAST(value AS int)) AS idle_value,
  cct.cpu
FROM experimental_counter_dur ecd
LEFT JOIN cpu_counter_track cct
  ON ecd.track_id = cct.id
WHERE cct.name = 'cpuidle';

-- Combined cpu freq & idle counter
CREATE VIRTUAL TABLE _freq_idle_counters
USING
  span_join(_cpu_freq_counters PARTITIONED cpu, _cpu_idle_counters PARTITIONED cpu);

-- Aggregates cpu idle statistics per core.
CREATE PERFETTO TABLE linux_cpu_idle_stats(
  -- CPU core number.
  cpu INT,
  -- CPU idle state (C-states).
  state INT,
  -- The count of entering idle state.
  count INT,
  -- Total CPU core idle state duration in nanoseconds.
  dur INT,
  -- Average CPU core idle state duration in nanoseconds.
  avg_dur INT,
  -- Idle state percentage of non suspend time (C-states + P-states).
  idle_percent FLOAT
)
AS
WITH
total AS (
  SELECT
    cpu,
    sum(dur) AS dur
  FROM _freq_idle_counters
  GROUP BY cpu
)
SELECT
  cpu,
  (idle_value + 1) AS state,
  COUNT(idle_value) AS count,
  SUM(dur) AS dur,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  SUM(dur) / COUNT(idle_value) AS avg_dur,
  SUM(dur) * 100.0 / (SELECT dur FROM total t WHERE t.cpu = ific.cpu) AS idle_percent
FROM _freq_idle_counters ific
WHERE idle_value >=0
GROUP BY cpu, idle_value;

)_d3l1m1t3r_"
;

const char kMemoryAndroidGpu[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE memory.linux.general;

-- Counter for GPU memory per process with duration.
CREATE PERFETTO TABLE memory_gpu_per_process(
    -- Timestamp
    ts INT,
    -- Duration
    dur INT,
    -- Upid of the process
    upid INT,
    -- GPU memory
    gpu_memory INT
) AS
SELECT
  ts,
  dur,
  upid,
  cast_int!(value) AS gpu_memory
FROM _all_counters_per_process
WHERE name = 'GPU Memory';
)_d3l1m1t3r_"
R"_d3l1m1t3r_()_d3l1m1t3r_"
;

const char kMemoryLinuxGeneral[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the 'License');
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an 'AS IS' BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

CREATE PERFETTO VIEW _all_counters_per_process AS
SELECT
  ts,
  LEAD(
    ts, 1,
    (SELECT COALESCE(end_ts, trace_end())
    FROM process p WHERE p.upid = t.upid) + 1)
    OVER (PARTITION BY track_id ORDER BY ts) - ts AS dur,
  upid,
  value,
  track_id,
  name
FROM counter c JOIN process_counter_track t
ON t.id = c.track_id
WHERE upid IS NOT NULL;
)_d3l1m1t3r_"
;

const char kMemoryLinuxHighWatermark[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the 'License');
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an 'AS IS' BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE memory.linux.process;
INCLUDE PERFETTO MODULE counters.intervals;

CREATE PERFETTO TABLE _memory_rss_high_watermark_per_process_table AS
WITH with_rss AS (
    SELECT
        ts,
        dur,
        upid,
        COALESCE(file_rss, 0) + COALESCE(anon_rss, 0) + COALESCE(shmem_rss, 0) AS rss
    FROM _memory_rss_and_swap_per_process_table
),
high_watermark_as_counter AS (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
    ts,
    MAX(rss) OVER (PARTITION BY upid ORDER BY ts) AS value,
    -- `id` and `track_id` are hacks to use this table in
    -- `counter_leading_intervals` macro. As `track_id` is using for looking
    -- for duplicates, we are aliasing `upid` with it. `Id` is ignored by the macro.
    upid AS track_id,
    0 AS id
FROM with_rss
)
SELECT ts, dur, track_id AS upid, cast_int!(value) AS rss_high_watermark
FROM counter_leading_intervals!(high_watermark_as_counter);

-- For each process fetches the memory high watermark until or during
-- timestamp.
CREATE PERFETTO VIEW memory_rss_high_watermark_per_process
(
    -- Timestamp
    ts INT,
    -- Duration
    dur INT,
    -- Upid of the process
    upid INT,
    -- Pid of the process
    pid INT,
    -- Name of the process
    process_name STRING,
    -- Maximum `rss` value until now
    rss_high_watermark INT
) AS
SELECT
    ts,
    dur,
    upid,
    pid,
    name AS process_name,
    rss_high_watermark
FROM _memory_rss_high_watermark_per_process_table
)_d3l1m1t3r_"
R"_d3l1m1t3r_(JOIN process USING (upid);
)_d3l1m1t3r_"
;

const char kMemoryLinuxProcess[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the 'License');
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an 'AS IS' BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE android.oom_adjuster;
INCLUDE PERFETTO MODULE memory.linux.general;

-- All memory counters tables.

CREATE PERFETTO VIEW _anon_rss AS
SELECT
  ts,
  dur,
  upid,
  value AS anon_rss_val
FROM _all_counters_per_process
WHERE name = 'mem.rss.anon';

CREATE PERFETTO VIEW _file_rss AS
SELECT
  ts,
  dur,
  upid,
  value AS file_rss_val
FROM _all_counters_per_process
)_d3l1m1t3r_"
R"_d3l1m1t3r_(WHERE name = 'mem.rss.file';

CREATE PERFETTO VIEW _shmem_rss AS
SELECT
  ts,
  dur,
  upid,
  value AS shmem_rss_val
FROM _all_counters_per_process
WHERE name = 'mem.rss.shmem';

CREATE PERFETTO VIEW _swap AS
SELECT
  ts,
  dur,
  upid,
  value AS swap_val
FROM _all_counters_per_process
WHERE name = 'mem.swap';

-- Span joins

CREATE VIRTUAL TABLE _anon_swap_sj
USING SPAN_OUTER_JOIN(
  _anon_rss PARTITIONED upid,
  _swap PARTITIONED upid);

CREATE VIRTUAL TABLE _anon_swap_file_sj
USING SPAN_OUTER_JOIN(
  _anon_swap_sj PARTITIONED upid,
  _file_rss PARTITIONED upid
);

CREATE VIRTUAL TABLE _rss_swap_sj
USING SPAN_OUTER_JOIN(
  _anon_swap_file_sj PARTITIONED upid,
  _shmem_rss PARTITIONED upid
);

CREATE PERFETTO TABLE _memory_rss_and_swap_per_process_table AS
SELECT
  ts, dur, upid,
  cast_int!(anon_rss_val) AS anon_rss,
  cast_int!(file_rss_val) AS file_rss,
  cast_int!(shmem_rss_val) AS shmem_rss,
  cast_int!(swap_val) AS swap
FROM _rss_swap_sj;


-- Memory metrics timeline for each process.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO VIEW memory_rss_and_swap_per_process(
  -- Timestamp
  ts INT,
  -- Duration
  dur INT,
  -- Upid of the process
  upid INT,
  -- Pid of the process
  pid INT,
  -- Name of the process
  process_name STRING,
  -- Anon RSS counter value
  anon_rss INT,
  -- File RSS counter value
  file_rss INT,
  -- Shared memory RSS counter value
  shmem_rss INT,
  -- Total RSS value. Sum of `anon_rss`, `file_rss` and `shmem_rss`. Returns
  -- value even if one of the values is NULL.
  rss INT,
  -- Swap counter value
  swap INT,
  -- Sum or `anon_rss` and `swap`. Returns value even if one of the values is
  -- NULL.
  anon_rss_and_swap INT,
  -- Sum or `rss` and `swap`. Returns value even if one of the values is NULL.
  rss_and_swap INT
) AS
SELECT
  ts,
  dur,
  upid,
  pid,
  name AS process_name,
  anon_rss,
  file_rss,
  shmem_rss,
  -- We do COALESCE only on `shmem_rss` and `swap`, as it can be expected all
  -- process start to emit anon rss and file rss events (you'll need to at
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- least read code and have some memory to work with) - so the NULLs are real
  --  values. But it is possible that you will never swap or never use shmem,
  -- so those values are expected to often be NULLs, which shouldn't propagate
  -- into the values like `anon_and_swap` or `rss`.
  file_rss + anon_rss + COALESCE(shmem_rss, 0) AS rss,
  swap,
  anon_rss + COALESCE(swap, 0) AS anon_rss_and_swap,
  anon_rss + file_rss  + COALESCE(shmem_rss, 0) + COALESCE(swap, 0) AS rss_and_swap
FROM _memory_rss_and_swap_per_process_table
JOIN process USING (upid);

-- OOM score tables

CREATE VIRTUAL TABLE _mem_ooms_sj
USING SPAN_OUTER_JOIN(
  android_oom_adj_intervals PARTITIONED upid,
  _memory_rss_and_swap_per_process_table PARTITIONED upid);

-- Process memory and it's OOM adjuster scores. Detects transitions, each new
-- interval means that either the memory or OOM adjuster score of the process changed.
CREATE PERFETTO TABLE memory_oom_score_with_rss_and_swap_per_process(
  -- Timestamp the oom_adj score or memory of the process changed
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ts INT,
  -- Duration until the next oom_adj score or memory change of the process.
  dur INT,
  -- oom adjuster score of the process.
  score INT,
  -- oom adjuster bucket of the process.
  bucket STRING,
  -- Upid of the process having an oom_adj update.
  upid INT,
  -- Name of the process having an oom_adj update.
  process_name STRING,
  -- Pid of the process having an oom_adj update.
  pid INT,
  -- Slice of the latest oom_adj update in the system_server. Alias of
  -- `slice.id`.
  oom_adj_id INT,
  -- Timestamp of the latest oom_adj update in the system_server.
  oom_adj_ts INT,
  -- Duration of the latest oom_adj update in the system_server.
  oom_adj_dur INT,
  -- Track of the latest oom_adj update in the system_server. Alias of
  -- `track.id`.
  oom_adj_track_id INT,
  -- Thread name of the latest oom_adj update in the system_server.
  oom_adj_thread_name STRING,
  -- Reason for the latest oom_adj update in the system_server.
  oom_adj_reason STRING,
  -- Trigger for the latest oom_adj update in the system_server.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  oom_adj_trigger STRING,
  -- Anon RSS counter value
  anon_rss INT,
  -- File RSS counter value
  file_rss INT,
  -- Shared memory RSS counter value
  shmem_rss INT,
  -- Total RSS value. Sum of `anon_rss`, `file_rss` and `shmem_rss`. Returns
  -- value even if one of the values is NULL.
  rss INT,
  -- Swap counter value
  swap INT,
  -- Sum or `anon_rss` and `swap`. Returns value even if one of the values is
  -- NULL.
  anon_rss_and_swap INT,
  -- Sum or `rss` and `swap`. Returns value even if one of the values is NULL.
  rss_and_swap INT
) AS
SELECT
  ts,
  dur,
  score,
  bucket,
  upid,
  process_name,
  pid,
  oom_adj_id,
  oom_adj_ts,
  oom_adj_dur,
  oom_adj_track_id,
  oom_adj_thread_name,
  oom_adj_reason,
  oom_adj_trigger,
  anon_rss,
  file_rss,
  shmem_rss,
  file_rss + anon_rss + COALESCE(shmem_rss, 0) AS rss,
  swap,
  anon_rss + COALESCE(swap, 0) AS anon_rss_and_swap,
  anon_rss + file_rss  + COALESCE(shmem_rss, 0) + COALESCE(swap, 0) AS rss_and_swap
FROM _mem_ooms_sj
)_d3l1m1t3r_"
R"_d3l1m1t3r_(JOIN process USING (upid);

)_d3l1m1t3r_"
;

const char kMemoryHeapGraphDominatorTree[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE graphs.dominator_tree;

-- Excluding following types from the graph as they share objects' ownership
-- with their real (more interesting) owners and will mask their idom to be the
-- "super root".
CREATE PERFETTO TABLE _ref_type_ids AS
SELECT id AS type_id FROM heap_graph_class
WHERE kind IN (
  'KIND_FINALIZER_REFERENCE',
  'KIND_PHANTOM_REFERENCE',
  'KIND_SOFT_REFERENCE',
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  'KIND_WEAK_REFERENCE');

CREATE PERFETTO TABLE _excluded_refs AS
SELECT ref.id
  FROM _ref_type_ids
  JOIN heap_graph_object robj USING (type_id)
  JOIN heap_graph_reference ref USING (reference_set_id)
WHERE ref.field_name = 'java.lang.ref.Reference.referent'
ORDER BY ref.id;

-- The assigned id of the "super root".
-- Since a Java heap graph is a "forest" structure, we need to add a imaginary
-- "super root" node which connects all the roots of the forest into a single
-- connected component, so that the dominator tree algorithm can be performed.
CREATE PERFETTO FUNCTION memory_heap_graph_super_root_fn()
-- The assigned id of the "super root".
RETURNS INT AS
SELECT max(id) + 1 FROM heap_graph_object;

CREATE PERFETTO VIEW _dominator_compatible_heap_graph AS
SELECT
  ref.owner_id AS source_node_id,
  ref.owned_id AS dest_node_id
FROM heap_graph_reference ref
JOIN heap_graph_object source_node ON ref.owner_id = source_node.id
WHERE source_node.reachable
  AND ref.id NOT IN _excluded_refs
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  AND ref.owned_id IS NOT NULL
UNION ALL
SELECT
  (SELECT memory_heap_graph_super_root_fn()) as source_node_id,
  id AS dest_node_id
FROM heap_graph_object
WHERE root_type IS NOT NULL;

CREATE PERFETTO TABLE _heap_graph_dominator_tree AS
SELECT
  node_id AS id,
  dominator_node_id AS idom_id
FROM graph_dominator_tree!(
  _dominator_compatible_heap_graph,
  (SELECT memory_heap_graph_super_root_fn())
)
-- Excluding the imaginary root.
WHERE dominator_node_id IS NOT NULL
-- Ordering by idom_id so queries below are faster when joining on idom_id.
-- TODO(lalitm): support create index for Perfetto tables.
ORDER BY idom_id;

CREATE PERFETTO TABLE _heap_graph_dominator_tree_depth AS
WITH RECURSIVE _tree_visitor(id, depth) AS (
  -- Let the super root have depth 0.
  SELECT id, 1 AS depth
  FROM _heap_graph_dominator_tree
  WHERE idom_id IN (SELECT memory_heap_graph_super_root_fn())
  UNION ALL
  SELECT child.id, parent.depth + 1
  FROM _heap_graph_dominator_tree child
  JOIN _tree_visitor parent ON child.idom_id = parent.id
)_d3l1m1t3r_"
R"_d3l1m1t3r_()
SELECT * FROM _tree_visitor
ORDER BY id;

-- A performance note: we need 3 memoize functions because EXPERIMENTAL_MEMOIZE
-- limits the function to return only 1 int.
-- This means the exact same "memoized dfs pass" on the tree is done 3 times, so
-- it takes 3x the time taken by only doing 1 pass. Doing only 1 pass would be
-- possible if EXPERIMENTAL_MEMOIZE could return more than 1 int.

CREATE PERFETTO FUNCTION _subtree_obj_count(id INT)
RETURNS INT AS
SELECT 1 + IFNULL((
  SELECT
    SUM(_subtree_obj_count(child.id))
  FROM _heap_graph_dominator_tree child
  WHERE child.idom_id = $id
), 0);
SELECT EXPERIMENTAL_MEMOIZE('_subtree_obj_count');

CREATE PERFETTO FUNCTION _subtree_size_bytes(id INT)
RETURNS INT AS
SELECT (
  SELECT self_size
  FROM heap_graph_object
  WHERE heap_graph_object.id = $id
) +
IFNULL((
  SELECT
    SUM(_subtree_size_bytes(child.id))
  FROM _heap_graph_dominator_tree child
  WHERE child.idom_id = $id
), 0);
SELECT EXPERIMENTAL_MEMOIZE('_subtree_size_bytes');
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
CREATE PERFETTO FUNCTION _subtree_native_size_bytes(id INT)
RETURNS INT AS
SELECT (
  SELECT native_size
  FROM heap_graph_object
  WHERE heap_graph_object.id = $id
) +
IFNULL((
  SELECT
    SUM(_subtree_native_size_bytes(child.id))
  FROM _heap_graph_dominator_tree child
  WHERE child.idom_id = $id
), 0);
SELECT EXPERIMENTAL_MEMOIZE('_subtree_native_size_bytes');

-- All reachable heap graph objects, their immediate dominators and summary of
-- their dominated sets.
-- The heap graph dominator tree is calculated by stdlib graphs.dominator_tree.
-- Each reachable object is a node in the dominator tree, their immediate
-- dominator is their parent node in the tree, and their dominated set is all
-- their descendants in the tree. All size information come from the
-- heap_graph_object prelude table.
CREATE PERFETTO TABLE memory_heap_graph_dominator_tree (
  -- Heap graph object id.
  id INT,
  -- Immediate dominator object id of the object.
  idom_id INT,
  -- Count of all objects dominated by this object, self inclusive.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  dominated_obj_count INT,
  -- Total self_size of all objects dominated by this object, self inclusive.
  dominated_size_bytes INT,
  -- Total native_size of all objects dominated by this object, self inclusive.
  dominated_native_size_bytes INT,
  -- Depth of the object in the dominator tree. Depth of root objects are 1.
  depth INT
) AS
SELECT
  t.id,
  t.idom_id,
  _subtree_obj_count(t.id) AS dominated_obj_count,
  _subtree_size_bytes(t.id) AS dominated_size_bytes,
  _subtree_native_size_bytes(t.id) AS dominated_native_size_bytes,
  d.depth
FROM _heap_graph_dominator_tree t
JOIN _heap_graph_dominator_tree_depth d USING(id)
ORDER BY id;

)_d3l1m1t3r_"
;

const char kPkvmHypervisor[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- Events when CPU entered hypervisor.
CREATE PERFETTO VIEW pkvm_hypervisor_events(
  -- Id of the corresponding slice in slices table.
  slice_id INT,
  -- CPU that entered hypervisor.
  cpu INT,
  -- Timestamp when CPU entered hypervisor (in nanoseconds).
  ts INT,
  -- How much time CPU spent in hypervisor (in nanoseconds).
  dur INT,
  -- Reason for entering hypervisor (e.g. host_hcall, host_mem_abort), or NULL if unknown.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  reason STRING
) AS
SELECT
  slices.id as slice_id,
  cpu_track.cpu as cpu,
  slices.ts as ts,
  slices.dur as dur,
  EXTRACT_ARG(slices.arg_set_id, 'hyp_enter_reason') as reason
FROM slices
JOIN cpu_track ON cpu_track.id = slices.track_id
WHERE
  slices.category = 'pkvm_hyp'

)_d3l1m1t3r_"
;

const char kPreludeCasts[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Casts |value| to INT.
CREATE PERFETTO MACRO cast_int(
    -- Query or subquery that will be cast.
    value Expr
) RETURNS Expr AS
CAST($value AS INT);

-- Casts |value| to DOUBLE.
CREATE PERFETTO MACRO cast_double(
    -- Query or subquery that will be cast.
    value Expr
) RETURNS Expr AS
CAST($value AS REAL);

-- Casts |value| to STRING.
CREATE PERFETTO MACRO cast_string(
    -- Query or subquery that will be cast.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    value Expr
) RETURNS Expr AS
CAST($value AS TEXT);
)_d3l1m1t3r_"
;

const char kPreludeSlices[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Given two slice ids, returns whether the first is an ancestor of the second.
CREATE PERFETTO FUNCTION slice_is_ancestor(
  -- Id of the potential ancestor slice.
  ancestor_id LONG,
  -- Id of the potential descendant slice.
  descendant_id LONG
)
-- Whether `ancestor_id` slice is an ancestor of `descendant_id`.
RETURNS BOOL AS
SELECT
  ancestor.track_id = descendant.track_id AND
  ancestor.ts <= descendant.ts AND
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  (ancestor.dur == -1 OR ancestor.ts + ancestor.dur >= descendant.ts + descendant.dur)
FROM slice ancestor
JOIN slice descendant
WHERE ancestor.id = $ancestor_id
  AND descendant.id = $descendant_id;
)_d3l1m1t3r_"
;

const char kPreludeTablesViews[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
-- Contains information of CPUs seen during the trace.
CREATE PERFETTO VIEW cpu (
  -- Unique identifier for this CPU. Identical to |ucpu|, prefer using |ucpu|
  -- instead.
  id UINT,
  -- Unique identifier for this CPU. Isn't equal to |cpu| for remote machines
  -- and is equal to |cpu| for the host machine.
  ucpu UINT,
  -- The 0-based CPU core identifier.
  cpu UINT,
  -- The name of the "most-specific" child table containing this row.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  type STRING,
  -- The cluster id is shared by CPUs in the same cluster.
  cluster_id UINT,
  -- A string describing this core.
  processor STRING,
  -- Machine identifier, non-null for CPUs on a remote machine.
  machine_id UINT
) AS
SELECT
  id,
  id AS ucpu,
  cpu,
  type AS type,
  cluster_id,
  processor,
  machine_id
FROM
  __intrinsic_cpu
WHERE
  cpu IS NOT NULL;

-- Contains information of available frequencies of CPUs.
CREATE PERFETTO VIEW cpu_frequencies (
  -- Unique identifier for this cpu frequency.
  id UINT,
  -- The CPU for this frequency, meaningful only in single machine traces.
  -- For multi-machine, join with the `cpu` table on `ucpu` to get the CPU
  -- identifier of each machine.
  cpu UINT,
  -- CPU frequency in KHz.
  freq UINT,
  -- The CPU that the slice executed on (meaningful only in single machine
  -- traces). For multi-machine, join with the `cpu` table on `ucpu` to get the
  -- CPU identifier of each machine.
  ucpu UINT
) AS
SELECT id, ucpu AS cpu, freq, ucpu
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM __intrinsic_cpu_freq;

-- This table holds slices with kernel thread scheduling information. These
-- slices are collected when the Linux "ftrace" data source is used with the
-- "sched/switch" and "sched/wakeup*" events enabled.
--
-- The rows in this table will always have a matching row in the |thread_state|
-- table with |thread_state.state| = 'Running'
CREATE PERFETTO VIEW sched_slice (
  --  Unique identifier for this scheduling slice.
  id UINT,
  -- The name of the "most-specific" child table containing this row.
  type STRING,
  -- The timestamp at the start of the slice (in nanoseconds).
  ts LONG,
  -- The duration of the slice (in nanoseconds).
  dur LONG,
  -- The CPU that the slice executed on (meaningful only in single machine
  -- traces). For multi-machine, join with the `cpu` table on `ucpu` to get the
  -- CPU identifier of each machine.
  cpu UINT,
  -- The thread's unique id in the trace.
  utid UINT,
  -- A string representing the scheduling state of the kernel
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- thread at the end of the slice.  The individual characters in
  -- the string mean the following: R (runnable), S (awaiting a
  -- wakeup), D (in an uninterruptible sleep), T (suspended),
  -- t (being traced), X (exiting), P (parked), W (waking),
  -- I (idle), N (not contributing to the load average),
  -- K (wakeable on fatal signals) and Z (zombie, awaiting
  -- cleanup).
  end_state STRING,
  -- The kernel priority that the thread ran at.
  priority INT,
  -- The unique CPU identifier that the slice executed on.
  ucpu UINT
) AS
SELECT
  id,
  type,
  ts,
  dur,
  ucpu AS cpu,
  utid,
  end_state,
  priority,
  ucpu
FROM
  __intrinsic_sched_slice;

-- This table contains the scheduling state of every thread on the system during
-- the trace.
--
-- The rows in this table which have |state| = 'Running', will have a
-- corresponding row in the |sched_slice| table.
CREATE PERFETTO VIEW thread_state (
  -- Unique identifier for this thread state.
  id UINT,
  -- The name of the "most-specific" child table containing this row.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  type STRING,
  -- The timestamp at the start of the slice (in nanoseconds).
  ts LONG,
  -- The duration of the slice (in nanoseconds).
  dur LONG,
  -- The CPU that the thread executed on (meaningful only in single machine
  -- traces). For multi-machine, join with the `cpu` table on `ucpu` to get the
  -- CPU identifier of each machine.
  cpu UINT,
  -- The thread's unique id in the trace.
  utid UINT,
  -- The scheduling state of the thread. Can be "Running" or any of the states
  -- described in |sched_slice.end_state|.
  state STRING,
  -- Indicates whether this thread was blocked on IO.
  io_wait UINT,
  -- The function in the kernel this thread was blocked on.
  blocked_function STRING,
  -- The unique thread id of the thread which caused a wakeup of this thread.
  waker_utid UINT,
  -- The unique thread state id which caused a wakeup of this thread.
  waker_id UINT,
  -- Whether the wakeup was from interrupt context or process context.
  irq_context UINT,
  -- The unique CPU identifier that the thread executed on.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ucpu UINT
) AS
SELECT
  id,
  type,
  ts,
  dur,
  ucpu AS cpu,
  utid,
  state,
  io_wait,
  blocked_function,
  waker_utid,
  waker_id,
  irq_context,
  ucpu
FROM
  __intrinsic_thread_state;

-- Contains 'raw' events from the trace for some types of events. This table
-- only exists for debugging purposes and should not be relied on in production
-- usecases (i.e. metrics, standard library etc.)
CREATE PERFETTO VIEW raw (
  -- Unique identifier for this raw event.
  id UINT,
  -- The name of the "most-specific" child table containing this row.
  type STRING,
  -- The timestamp of this event.
  ts LONG,
  -- The name of the event. For ftrace events, this will be the ftrace event
  -- name.
  name STRING,
  -- The CPU this event was emitted on (meaningful only in single machine
  -- traces). For multi-machine, join with the `cpu` table on `ucpu` to get the
  -- CPU identifier of each machine.
  cpu UINT,
  -- The thread this event was emitted on.
  utid UINT,
  -- The set of key/value pairs associated with this event.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  arg_set_id UINT,
  -- Ftrace event flags for this event. Currently only emitted for sched_waking
  -- events.
  common_flags UINT,
  -- The unique CPU identifier that this event was emitted on.
  ucpu UINT
) AS
SELECT
  id,
  type,
  ts,
  name,
  ucpu AS cpu,
  utid,
  arg_set_id,
  common_flags,
  ucpu
FROM
  __intrinsic_raw;

-- Contains all the ftrace events in the trace. This table exists only for
-- debugging purposes and should not be relied on in production usecases (i.e.
-- metrics, standard library etc). Note also that this table might be empty if
-- raw ftrace parsing has been disabled.
CREATE PERFETTO VIEW ftrace_event (
  -- Unique identifier for this ftrace event.
  id UINT,
  -- The name of the "most-specific" child table containing this row.
  type STRING,
  -- The timestamp of this event.
  ts LONG,
  -- The ftrace event name.
  name STRING,
  -- The CPU this event was emitted on (meaningful only in single machine
  -- traces). For multi-machine, join with the `cpu` table on `ucpu` to get the
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- CPU identifier of each machine.
  cpu UINT,
  -- The thread this event was emitted on.
  utid UINT,
  -- The set of key/value pairs associated with this event.
  arg_set_id UINT,
  -- Ftrace event flags for this event. Currently only emitted for
  -- sched_waking events.
  common_flags UINT,
  -- The unique CPU identifier that this event was emitted on.
  ucpu UINT
) AS
SELECT
  id,
  type,
  ts,
  name,
  ucpu AS cpu,
  utid,
  arg_set_id,
  common_flags,
  ucpu
FROM
  __intrinsic_ftrace_event;

-- The sched_slice table with the upid column.
CREATE PERFETTO VIEW experimental_sched_upid (
  --  Unique identifier for this scheduling slice.
  id UINT,
  -- The name of the "most-specific" child table containing this row.
  type STRING,
  -- The timestamp at the start of the slice (in nanoseconds).
  ts LONG,
  -- The duration of the slice (in nanoseconds).
  dur LONG,
  -- The CPU that the slice executed on (meaningful only in single machine
  -- traces). For multi-machine, join with the `cpu` table on `ucpu` to get the
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- CPU identifier of each machine.
  cpu UINT,
  -- The thread's unique id in the trace.
  utid UINT,
  -- A string representing the scheduling state of the kernel thread at the end
  -- of the slice. The individual characters in the string mean the following: R
  -- (runnable), S (awaiting a wakeup), D (in an uninterruptible sleep), T
  -- (suspended), t (being traced), X (exiting), P (parked), W (waking), I
  -- (idle), N (not contributing to the load average), K (wakeable on fatal
  -- signals) and Z (zombie, awaiting cleanup).
  end_state STRING,
  -- The kernel priority that the thread ran at.
  priority INT,
  -- The unique CPU identifier that the slice executed on.
  ucpu UINT,
  -- The process's unique id in the trace.
  upid UINT
) AS
SELECT
  id,
  type,
  ts,
  dur,
  ucpu AS cpu,
  utid,
  end_state,
  priority,
  ucpu,
  upid
FROM
  __intrinsic_sched_upid;
)_d3l1m1t3r_"
;

const char kPreludeTraceBounds[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Definition of `trace_bounds` table. The values are being filled by Trace
-- Processor when parsing the trace. Can't be a Perfetto table because it has
-- to be mutable. 
-- It is recommended to depend on the `trace_start()` and `trace_end()`
-- functions rather than directly on `trace_bounds`.
CREATE TABLE trace_bounds AS
SELECT 0 AS start_ts, 0 AS end_ts;

-- Fetch start of the trace.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO FUNCTION trace_start()
-- Start of the trace in nanoseconds.
RETURNS LONG AS
SELECT start_ts FROM trace_bounds;

-- Fetch end of the trace.
CREATE PERFETTO FUNCTION trace_end()
-- End of the trace in nanoseconds.
RETURNS LONG AS
SELECT end_ts FROM trace_bounds;

-- Fetch duration of the trace.
CREATE PERFETTO FUNCTION trace_dur()
-- Duration of the trace in nanoseconds.
RETURNS LONG AS
SELECT trace_end() - trace_start();
)_d3l1m1t3r_"
;

const char kSchedRunnable[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- Previous runnable slice on the same thread.
-- For each "Running" thread state finds:
-- - previous "Runnable" (or runnable preempted) state.
-- - previous uninterrupted "Runnable" state with a valid waker thread.
CREATE PERFETTO TABLE sched_previous_runnable_on_thread(
    -- `thread_state.id` id.
    id INT,
    -- Previous runnable `thread_state.id`.
    prev_runnable_id INT,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    -- Previous runnable `thread_state.id` with valid waker
    -- thread.
    prev_wakeup_runnable_id INT
) AS
WITH running_and_runnable AS (
  SELECT
        id,
        state,
        MAX(id)
          FILTER (WHERE state != 'Running')
          OVER utid_part AS prev_runnable_id,
        MAX(id)
          FILTER (WHERE
            waker_utid IS NOT NULL
            AND (irq_context IS NULL OR irq_context != 1))
          OVER utid_part AS prev_wakeup_runnable_id
    FROM thread_state
    -- Optimal operation for state IN (R, R+, Running)
    WHERE state GLOB 'R*' AND dur != -1
    WINDOW utid_part AS (PARTITION BY utid ORDER BY id)
)
SELECT
  id,
  prev_runnable_id,
  prev_wakeup_runnable_id
FROM running_and_runnable
WHERE state = 'Running'
ORDER BY id;
)_d3l1m1t3r_"
;

const char kSchedStates[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- TODO(altimin): `sched_humanly_readable_name` doesn't handle some corner
-- cases which thread_state.ts handles (as complex strings manipulations in
-- SQL are pretty painful), but they are pretty niche.

-- Translates a single-letter scheduling state to a human-readable string.
CREATE PERFETTO FUNCTION sched_state_to_human_readable_string(
  -- An individual character string representing the scheduling state of the
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- kernel thread at the end of the slice.
  short_name STRING
)
-- Humanly readable string representing the scheduling state of the kernel
-- thread. The individual characters in the string mean the following: R
-- (runnable), S (awaiting a wakeup), D (in an uninterruptible sleep), T
-- (suspended), t (being traced), X (exiting), P (parked), W (waking), I
-- (idle), N (not contributing to the load average), K (wakeable on fatal
-- signals) and Z (zombie, awaiting cleanup).
RETURNS STRING AS
SELECT CASE $short_name
WHEN 'Running' THEN 'Running'
WHEN 'R' THEN 'Runnable'
WHEN 'R+' THEN 'Runnable (Preempted)'
WHEN 'S' THEN 'Sleeping'
WHEN 'D' THEN 'Uninterruptible Sleep'
WHEN 'T' THEN 'Stopped'
WHEN 't' THEN 'Traced'
WHEN 'X' THEN 'Exit (Dead)'
WHEN 'Z' THEN 'Exit (Zombie)'
WHEN 'x' THEN 'Task Dead'
WHEN 'I' THEN 'Idle'
WHEN 'K' THEN 'Wakekill'
WHEN 'W' THEN 'Waking'
WHEN 'P' THEN 'Parked'
WHEN 'N' THEN 'No Load'
-- ETW SPECIFIC STATES
WHEN 'Stand By' THEN 'Stand By'
WHEN 'Initialized' THEN 'Initialized'
)_d3l1m1t3r_"
R"_d3l1m1t3r_(WHEN 'Waiting' THEN 'Waiting'
WHEN 'Transition' THEN 'Transition'
WHEN 'Deferred Ready' THEN 'Deferred Ready'
ELSE $short_name
END;

-- Translates a single-letter scheduling state and IO wait information to
-- a human-readable string.
CREATE PERFETTO FUNCTION sched_state_io_to_human_readable_string(
  -- An individual character string representing the scheduling state of the
  -- kernel thread at the end of the slice.
  sched_state STRING,
  -- A (posssibly NULL) boolean indicating, if the device was in uninterruptible
  -- sleep, if it was an IO sleep.
  io_wait BOOL
)
-- A human readable string with information about the scheduling state and IO wait.
RETURNS STRING AS
SELECT printf(
  '%s%s',
  sched_state_to_human_readable_string($sched_state),
  CASE $io_wait
    WHEN 1 THEN ' (IO)'
    WHEN 0 THEN ' (non-IO)'
    ELSE ''
  END
);

)_d3l1m1t3r_"
;

const char kSchedThreadExecutingSpan[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE graphs.search;

-- A 'thread_executing_span' is thread_state span starting with a runnable slice
-- until the next runnable slice that's woken up by a process (as opposed
-- to an interrupt). Note that within a 'thread_executing_span' we can have sleep
-- spans blocked on an interrupt.
-- We consider the id of this span to be the id of the first thread_state in the span.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
--
-- Finds all runnable states that are woken up by a process.
--
-- We achieve this by checking that the |thread_state.irq_context|
-- value is NOT 1. In otherwords, it is either 0 or NULL. The NULL check
-- is important to support older Android versions.
--
-- On older versions of Android (<U). We don't have IRQ context information,
-- so this table might contain wakeups from interrupt context, consequently, the
-- wakeup graph generated might not be accurate.
--
CREATE PERFETTO TABLE _runnable_state
AS
SELECT
  thread_state.id,
  thread_state.ts,
  thread_state.dur,
  thread_state.state,
  thread_state.utid,
  thread_state.waker_id,
  thread_state.waker_utid
FROM thread_state
WHERE
  thread_state.dur != -1
  AND thread_state.waker_utid IS NOT NULL
  AND (thread_state.irq_context = 0 OR thread_state.irq_context IS NULL);

-- Similar to |_runnable_state| but finds the first runnable state at thread.
CREATE PERFETTO TABLE _first_runnable_state
AS
WITH
  first_state AS (
    SELECT
      MIN(thread_state.id) AS id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    FROM thread_state
    GROUP BY utid
  )
SELECT
  thread_state.id,
  thread_state.ts,
  thread_state.dur,
  thread_state.state,
  thread_state.utid,
  thread_state.waker_id,
  thread_state.waker_utid
FROM thread_state
JOIN first_state
  USING (id)
WHERE
  thread_state.dur != -1
  AND thread_state.state = 'R'
  AND (thread_state.irq_context = 0 OR thread_state.irq_context IS NULL);

--
-- Finds all sleep states including interruptible (S) and uninterruptible (D).
CREATE PERFETTO TABLE _sleep_state
AS
SELECT
  thread_state.id,
  thread_state.ts,
  thread_state.dur,
  thread_state.state,
  thread_state.blocked_function,
  thread_state.utid
FROM thread_state
WHERE dur != -1 AND (state = 'S' OR state = 'D' OR state = 'I');

--
-- Finds the last execution for every thread to end executing_spans without a Sleep.
--
CREATE PERFETTO TABLE _thread_end_ts
AS
SELECT
  MAX(ts) + dur AS end_ts,
  utid
FROM thread_state
WHERE dur != -1
GROUP BY utid;

-- Similar to |_sleep_state| but finds the first sleep state in a thread.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO TABLE _first_sleep_state
AS
SELECT
  MIN(s.id) AS id,
  s.ts,
  s.dur,
  s.state,
  s.blocked_function,
  s.utid
FROM _sleep_state s
JOIN _runnable_state r
  ON s.utid = r.utid AND (s.ts + s.dur = r.ts)
GROUP BY s.utid;

--
-- Finds all neighbouring ('Sleeping', 'Runnable') thread_states pairs from the same thread.
-- More succintly, pairs of S[n-1]-R[n] where R is woken by a process context and S is an
-- interruptible or uninterruptible sleep state.
--
-- This is achieved by joining the |_runnable_state|.ts with the
-- |_sleep_state|.|ts + dur|.
--
-- With the S-R pairs of a thread, we can re-align to [R-S) intervals with LEADS and LAGS.
--
-- Given the following thread_states on a thread:
-- S0__|R0__Running0___|S1__|R1__Running1___|S2__|R2__Running2__S2|.
--
-- We have 3 thread_executing_spans: [R0, S0), [R1, S1), [R2, S2).
--
-- We define the following markers in this table:
--
-- prev_id          = R0_id.
--
-- prev_end_ts      = S0_ts.
-- state            = 'S' or 'D'.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- blocked_function = <kernel blocking function>
--
-- id               = R1_id.
-- ts               = R1_ts.
--
-- end_ts           = S1_ts.
CREATE PERFETTO TABLE _wakeup
AS
WITH
  all_wakeups AS (
    SELECT
      s.state,
      s.blocked_function,
      r.id,
      r.ts AS ts,
      r.utid AS utid,
      r.waker_id,
      r.waker_utid,
      s.ts AS prev_end_ts
    FROM _runnable_state r
    JOIN _sleep_state s
      ON s.utid = r.utid AND (s.ts + s.dur = r.ts)
    UNION ALL
    SELECT
      NULL AS state,
      NULL AS blocked_function,
      r.id,
      r.ts,
      r.utid AS utid,
      r.waker_id,
      r.waker_utid,
      NULL AS prev_end_ts
    FROM _first_runnable_state r
    LEFT JOIN _first_sleep_state s
      ON s.utid = r.utid
  )
SELECT
  all_wakeups.*,
  LAG(id) OVER (PARTITION BY utid ORDER BY ts) AS prev_id,
  IFNULL(LEAD(prev_end_ts) OVER (PARTITION BY utid ORDER BY ts), thread_end.end_ts) AS end_ts
FROM all_wakeups
LEFT JOIN _thread_end_ts thread_end
  USING (utid);

)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- Mapping from running thread state to runnable
-- TODO(zezeozue): Switch to use `sched_previous_runnable_on_thread`.
CREATE PERFETTO TABLE _wakeup_map
AS
WITH x AS (
SELECT id, waker_id, utid, state FROM thread_state WHERE state = 'Running' AND dur != -1
UNION ALL
SELECT id, waker_id, utid, state FROM _first_runnable_state
UNION ALL
SELECT id, waker_id, utid, state FROM _runnable_state
), y AS (
    SELECT
      id AS waker_id,
      state,
      MAX(id)
        filter(WHERE state = 'R')
          OVER (PARTITION BY utid ORDER BY id) AS id
    FROM x
  )
SELECT id, waker_id FROM y WHERE state = 'Running' ORDER BY waker_id;

--
-- Builds the parent-child chain from all thread_executing_spans. The parent is the waker and
-- child is the wakee.
--
-- Note that this doesn't include the roots. We'll compute the roots below.
-- This two step process improves performance because it's more efficient to scan
-- parent and find a child between than to scan child and find the parent it lies between.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO TABLE _wakeup_graph
AS
SELECT
  _wakeup_map.id AS waker_id,
  prev_id,
  prev_end_ts,
  _wakeup.id AS id,
  _wakeup.ts AS ts,
  _wakeup.end_ts,
  IIF(_wakeup.state IS NULL OR _wakeup.state = 'S', 0, 1) AS is_kernel,
  _wakeup.utid,
  _wakeup.state,
  _wakeup.blocked_function
FROM _wakeup
JOIN _wakeup_map USING(waker_id)
ORDER BY id;

-- The inverse of thread_executing_spans. All the sleeping periods between thread_executing_spans.
CREATE PERFETTO TABLE _sleep
AS
WITH
  x AS (
    SELECT
      id,
      ts,
      prev_end_ts,
      utid,
      state,
      blocked_function
    FROM _wakeup_graph
  )
SELECT
  ts - prev_end_ts AS dur,
  prev_end_ts AS ts,
  id AS root_node_id,
  utid AS critical_path_utid,
  id AS critical_path_id,
  ts - prev_end_ts AS critical_path_blocked_dur,
  state AS critical_path_blocked_state,
  blocked_function AS critical_path_blocked_function
FROM x
WHERE ts IS NOT NULL;

-- Given a set of critical paths identified by their |root_node_ids|, flattens
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- the critical path tasks such that there are no overlapping intervals. The end of a
-- task in the critical path is the start of the following task in the critical path.
CREATE PERFETTO MACRO _flatten_critical_path_tasks(_critical_path_table TableOrSubquery)
RETURNS TableOrSubquery
AS (
  WITH
    x AS (
      SELECT
        LEAD(ts) OVER (PARTITION BY root_node_id ORDER BY node_id) AS ts,
        node_id,
        ts AS node_ts,
        root_node_id,
        utid AS node_utid,
        _wakeup_graph.prev_end_ts
      FROM $_critical_path_table
      JOIN _wakeup_graph
        ON node_id = id
    )
  SELECT node_ts AS ts, root_node_id, node_id, ts - node_ts AS dur, node_utid, prev_end_ts FROM x
);

-- Converts a table with <ts, dur, utid> columns to a unique set of wakeup roots <id> that
-- completely cover the time intervals.
CREATE PERFETTO MACRO _intervals_to_roots(source_table TableOrSubQuery)
RETURNS TableOrSubQuery
AS (
  WITH source AS (
    SELECT * FROM $source_table
  ), thread_bounds AS (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    SELECT utid, MIN(ts) AS min_start, MAX(ts) AS max_start FROM _wakeup_graph GROUP BY utid
  ), start AS (
    SELECT
      _wakeup_graph.utid, max(_wakeup_graph.id) AS start_id, source.ts, source.dur
      FROM _wakeup_graph
      JOIN thread_bounds
        USING (utid)
      JOIN source
        ON source.utid = _wakeup_graph.utid AND MAX(source.ts, min_start) >= _wakeup_graph.ts
     GROUP BY source.ts, source.utid
  ), end AS (
    SELECT
      _wakeup_graph.utid, min(_wakeup_graph.id) AS end_id, source.ts, source.dur
      FROM _wakeup_graph
      JOIN thread_bounds
          USING (utid)
      JOIN source ON source.utid = _wakeup_graph.utid
          AND MIN((source.ts + source.dur), max_start) <= _wakeup_graph.ts
     GROUP BY source.ts, source.utid
  ), bound AS (
    SELECT start.utid, start.ts, start.dur, start_id, end_id
      FROM start
      JOIN end ON start.ts = end.ts AND start.dur = end.dur AND start.utid = end.utid
  )
  SELECT DISTINCT _wakeup_graph.id FROM bound
  JOIN _wakeup_graph ON _wakeup_graph.id BETWEEN start_id AND end_id
)_d3l1m1t3r_"
R"_d3l1m1t3r_();

-- Flattens overlapping tasks within a critical path and flattens overlapping critical paths.
CREATE PERFETTO MACRO _flatten_critical_paths(critical_path_table TableOrSubquery, sleeping_table TableOrSubquery)
RETURNS TableOrSubquery
AS (
  WITH
    span_starts AS (
      SELECT
        cr.node_utid AS utid,
        MAX(cr.ts, sleep.ts) AS ts,
        sleep.ts + sleep.dur AS sleep_end_ts,
        cr.ts + cr.dur AS cr_end_ts,
        cr.node_id AS id,
        cr.root_node_id AS root_id,
        cr.prev_end_ts AS prev_end_ts,
        critical_path_utid,
        critical_path_id,
        critical_path_blocked_dur,
        critical_path_blocked_state,
        critical_path_blocked_function
      FROM
        _flatten_critical_path_tasks!($critical_path_table) cr
      JOIN $sleeping_table sleep
        USING (root_node_id)
    )
  SELECT
    ts,
    MIN(cr_end_ts, sleep_end_ts) - ts AS dur,
    utid,
    id,
    root_id,
    prev_end_ts,
    critical_path_utid,
    critical_path_id,
    critical_path_blocked_dur,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    critical_path_blocked_state,
    critical_path_blocked_function
  FROM span_starts
  WHERE MIN(sleep_end_ts, cr_end_ts) - ts > 0
);

-- Generates a critical path.
CREATE PERFETTO MACRO _critical_path(
        graph_table TableOrSubquery, root_table TableOrSubquery, sleeping_table TableOrSubquery)
RETURNS TableOrSubquery
AS (
  WITH
    critical_path AS (
      SELECT * FROM graph_reachable_weight_bounded_dfs !($graph_table, $root_table, 1)
    )
  SELECT
    ts,
    dur,
    root_id,
    id,
    utid,
    critical_path_utid,
    critical_path_id,
    critical_path_blocked_dur,
    critical_path_blocked_state,
    critical_path_blocked_function
  FROM _flatten_critical_paths!(critical_path, $sleeping_table)
  UNION ALL
  -- Add roots
  SELECT
    ts,
    end_ts - ts AS dur,
    id AS root_id,
    id,
    utid,
    utid AS critical_path_utid,
    NULL AS critical_path_id,
    NULL AS critical_path_blocked_dur,
    NULL AS critical_path_blocked_state,
    NULL AS critical_path_blocked_function
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  FROM $root_table
  ORDER BY root_id
);

-- Generates the critical path for only the set of roots <id> passed in.
-- _intervals_to_roots can be used to generate root ids from a given time interval.
-- This can be used to genrate the critical path over sparse regions of a trace, e.g
-- binder transactions. It might be more efficient to generate the _critical_path
-- for the entire trace, see _thread_executing_span_critical_path_all, but for a
-- per-process susbset of binder txns for instance, this is likely faster.
CREATE PERFETTO MACRO _critical_path_by_roots(roots_table TableOrSubQuery)
RETURNS TableOrSubQuery
AS (
  WITH roots AS (
    SELECT * FROM $roots_table
  ), root_bounds AS (
    SELECT MIN(id) AS min_root_id, MAX(id) AS max_root_id FROM roots
  ), wakeup_bounds AS (
    SELECT COALESCE(_wakeup_graph.prev_id, min_root_id) AS min_wakeup, max_root_id AS max_wakeup
    FROM root_bounds
    JOIN _wakeup_graph ON id = min_root_id
  ) SELECT
      id,
      ts,
      dur,
      utid,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      critical_path_id,
      critical_path_blocked_dur,
      critical_path_blocked_state,
      critical_path_blocked_function,
      critical_path_utid
      FROM
        _critical_path
        !(
          (
            SELECT
              id AS source_node_id,
              COALESCE(waker_id, id) AS dest_node_id,
              id - COALESCE(waker_id, id) AS edge_weight
            FROM _wakeup_graph
            JOIN wakeup_bounds WHERE id BETWEEN min_wakeup AND max_wakeup
          ),
          (
            SELECT
              _wakeup_graph.id AS root_node_id,
              _wakeup_graph.id - COALESCE(prev_id, _wakeup_graph.id) AS root_target_weight,
              id,
              ts,
              end_ts,
              utid
            FROM _wakeup_graph
            JOIN (SELECT * FROM roots) USING (id)
          ),
          _sleep));

-- Generates the critical path for only the time intervals for the utids given.
-- Currently expensive because of naive interval_intersect implementation.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- Prefer _critical_paths_by_roots for performance. This is useful for a small
-- set of intervals, e.g app startups in a trace.
CREATE PERFETTO MACRO _critical_path_by_intervals(intervals_table TableOrSubQuery)
RETURNS TableOrSubQuery AS (
WITH span_starts AS (
    SELECT
      id,
      MAX(span.ts, intervals.ts) AS ts,
      MIN(span.ts + span.dur, intervals.ts + intervals.dur) AS end_ts,
      span.utid,
      critical_path_id,
      critical_path_blocked_dur,
      critical_path_blocked_state,
      critical_path_blocked_function,
      critical_path_utid
    FROM _critical_path_by_roots!(_intervals_to_roots!($intervals_table)) span
    -- TODO(zezeozue): Replace with interval_intersect when partitions are supported
    JOIN (SELECT * FROM $intervals_table) intervals ON span.critical_path_utid = intervals.utid
        AND ((span.ts BETWEEN intervals.ts AND intervals.ts + intervals.dur)
             OR (intervals.ts BETWEEN span.ts AND span.ts + span.dur))
) SELECT
      id,
      ts,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      end_ts - ts AS dur,
      utid,
      critical_path_id,
      critical_path_blocked_dur,
      critical_path_blocked_state,
      critical_path_blocked_function,
      critical_path_utid
   FROM span_starts);

-- Generates the critical path for a given utid over the <ts, dur> interval.
-- The duration of a thread executing span in the critical path is the range between the
-- start of the thread_executing_span and the start of the next span in the critical path.
CREATE PERFETTO FUNCTION _thread_executing_span_critical_path(
  -- Utid of the thread to compute the critical path for.
  critical_path_utid INT,
  -- Timestamp.
  ts LONG,
  -- Duration.
  dur LONG)
RETURNS TABLE(
  -- Id of the first (runnable) thread state in thread_executing_span.
  id INT,
  -- Timestamp of first thread_state in thread_executing_span.
  ts LONG,
  -- Duration of thread_executing_span.
  dur LONG,
  -- Utid of thread with thread_state.
  utid INT,
  -- Id of thread executing span following the sleeping thread state for which the critical path is computed.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  critical_path_id INT,
  -- Critical path duration.
  critical_path_blocked_dur LONG,
  -- Sleeping thread state in critical path.
  critical_path_blocked_state STRING,
  -- Kernel blocked_function of the critical path.
  critical_path_blocked_function STRING,
  -- Thread Utid the critical path was filtered to.
  critical_path_utid INT
) AS
SELECT * FROM _critical_path_by_intervals!((SELECT $critical_path_utid AS utid, $ts as ts, $dur AS dur));

-- Generates the critical path for all threads for the entire trace duration.
-- The duration of a thread executing span in the critical path is the range between the
-- start of the thread_executing_span and the start of the next span in the critical path.
CREATE PERFETTO FUNCTION _thread_executing_span_critical_path_all()
RETURNS
  TABLE(
    -- Id of the first (runnable) thread state in thread_executing_span.
    id INT,
    -- Timestamp of first thread_state in thread_executing_span.
    ts LONG,
    -- Duration of thread_executing_span.
    dur LONG,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    -- Utid of thread with thread_state.
    utid INT,
    -- Id of thread executing span following the sleeping thread state for which the critical path is computed.
    critical_path_id INT,
    -- Critical path duration.
    critical_path_blocked_dur LONG,
    -- Sleeping thread state in critical path.
    critical_path_blocked_state STRING,
    -- Kernel blocked_function of the critical path.
    critical_path_blocked_function STRING,
    -- Thread Utid the critical path was filtered to.
    critical_path_utid INT)
AS
SELECT
  id,
  ts,
  dur,
  utid,
  critical_path_id,
  critical_path_blocked_dur,
  critical_path_blocked_state,
  critical_path_blocked_function,
  critical_path_utid
FROM _critical_path_by_roots!((SELECT id FROM _wakeup_graph));

)_d3l1m1t3r_"
;

const char kSchedThreadExecutingSpanWithSlice[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE slices.flat_slices;
INCLUDE PERFETTO MODULE sched.thread_executing_span;

CREATE PERFETTO TABLE _critical_path_all AS
SELECT * FROM  _thread_executing_span_critical_path_all();

-- Limited thread_state view that will later be span joined with the |_thread_executing_span_graph|.
CREATE PERFETTO VIEW _span_thread_state_view
AS SELECT id AS thread_state_id, ts, dur, utid, state, blocked_function as function, io_wait, cpu FROM thread_state;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Limited slice_view that will later be span joined with the |_thread_executing_span_graph|.
CREATE PERFETTO VIEW _span_slice_view
AS
SELECT
  slice_id,
  depth AS slice_depth,
  name AS slice_name,
  CAST(ts AS INT) AS ts,
  CAST(dur AS INT) AS dur,
  utid
FROM _slice_flattened;

CREATE VIRTUAL TABLE _span_thread_state_slice_view
USING
  SPAN_LEFT_JOIN(
    _span_thread_state_view PARTITIONED utid,
    _span_slice_view PARTITIONED utid);

-- |_thread_executing_span_graph| span joined with thread_state information.
CREATE VIRTUAL TABLE _span_critical_path_thread_state_slice_sp
USING
  SPAN_JOIN(
    _critical_path_all PARTITIONED utid,
    _span_thread_state_slice_view PARTITIONED utid);

-- |_thread_executing_span_graph| + thread_state view joined with critical_path information.
CREATE PERFETTO TABLE _critical_path_thread_state_slice AS
WITH span_starts AS (
    SELECT
      span.id,
      span.utid,
      span.critical_path_id,
      span.critical_path_blocked_dur,
      span.critical_path_blocked_state,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      span.critical_path_blocked_function,
      span.critical_path_utid,
      thread_state_id,
      MAX(thread_state.ts, span.ts) AS ts,
      span.ts + span.dur AS span_end_ts,
      thread_state.ts + thread_state.dur AS thread_state_end_ts,
      thread_state.state,
      thread_state.function,
      thread_state.cpu,
      thread_state.io_wait,
      thread_state.slice_id,
      thread_state.slice_name,
      thread_state.slice_depth
    FROM _critical_path_all span
    JOIN _span_critical_path_thread_state_slice_sp thread_state USING(id)
  )
SELECT
  id,
  thread_state_id,
  ts,
  MIN(span_end_ts, thread_state_end_ts) - ts AS dur,
  utid,
  state,
  function,
  cpu,
  io_wait,
  slice_id,
  slice_name,
  slice_depth,
  critical_path_id,
  critical_path_blocked_dur,
  critical_path_blocked_state,
  critical_path_blocked_function,
  critical_path_utid
FROM span_starts
WHERE MIN(span_end_ts, thread_state_end_ts) - ts > 0;

-- Flattened slices span joined with their thread_states. This contains the 'self' information
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- without 'critical_path' (blocking) information.
CREATE VIRTUAL TABLE _self_sp USING
  SPAN_LEFT_JOIN(thread_state PARTITIONED utid, _slice_flattened PARTITIONED utid);

-- Limited view of |_self_sp|.
CREATE PERFETTO VIEW _self_view
  AS
  SELECT
    id AS self_thread_state_id,
    slice_id AS self_slice_id,
    ts,
    dur,
    utid AS critical_path_utid,
    state AS self_state,
    blocked_function AS self_function,
    cpu AS self_cpu,
    io_wait AS self_io_wait,
    name AS self_slice_name,
    depth AS self_slice_depth
    FROM _self_sp;

-- Self and critical path span join. This contains the union of the time intervals from the following:
--  a. Self slice stack + thread_state.
--  b. Critical path stack + thread_state.
CREATE VIRTUAL TABLE _self_and_critical_path_sp
USING
  SPAN_JOIN(
    _self_view PARTITIONED critical_path_utid,
    _critical_path_thread_state_slice PARTITIONED critical_path_utid);

-- Returns a view of |_self_and_critical_path_sp| unpivoted over the following columns:
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- self thread_state.
-- self blocked_function (if one exists).
-- self process_name (enabled with |enable_process_name|).
-- self thread_name (enabled with |enable_thread_name|).
-- self slice_stack (enabled with |enable_self_slice|).
-- critical_path thread_state.
-- critical_path process_name.
-- critical_path thread_name.
-- critical_path slice_stack (enabled with |enable_critical_path_slice|).
-- running cpu (if one exists).
-- A 'stack' is the group of resulting unpivoted rows sharing the same timestamp.
CREATE PERFETTO FUNCTION _critical_path_stack(critical_path_utid INT, ts LONG, dur LONG, enable_process_name INT, enable_thread_name INT, enable_self_slice INT, enable_critical_path_slice INT)
RETURNS
  TABLE(
    id INT,
    ts LONG,
    dur LONG,
    utid INT,
    stack_depth INT,
    name STRING,
    table_name STRING,
    critical_path_utid INT) AS
  -- Spans filtered to the query time window and critical_path_utid.
  -- This is a preliminary step that gets the start and end ts of all the rows
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- so that we can chop the ends of each interval correctly if it overlaps with the query time interval.
  WITH relevant_spans_starts AS (
    SELECT
      self_thread_state_id,
      self_state,
      self_slice_id,
      self_slice_name,
      self_slice_depth,
      self_function,
      self_io_wait,
      thread_state_id,
      state,
      function,
      io_wait,
      slice_id,
      slice_name,
      slice_depth,
      cpu,
      utid,
      MAX(ts, $ts) AS ts,
      MIN(ts + dur, $ts + $dur) AS end_ts,
      critical_path_utid
    FROM _self_and_critical_path_sp
    WHERE dur > 0 AND critical_path_utid = $critical_path_utid
  ),
  -- This is the final step that gets the |dur| of each span from the start and
  -- and end ts of the previous step.
  -- Now we manually unpivot the result with 3 key steps: 1) Self 2) Critical path 3) CPU
  -- This CTE is heavily used throughout the entire function so materializing it is
  -- very important.
  relevant_spans AS MATERIALIZED (
    SELECT
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      self_thread_state_id,
      self_state,
      self_slice_id,
      self_slice_name,
      self_slice_depth,
      self_function,
      self_io_wait,
      thread_state_id,
      state,
      function,
      io_wait,
      slice_id,
      slice_name,
      slice_depth,
      cpu,
      utid,
      ts,
      end_ts - ts AS dur,
      critical_path_utid,
      utid
    FROM relevant_spans_starts
    WHERE dur > 0
  ),
  -- 1. Builds the 'self' stack of items as an ordered UNION ALL
  self_stack AS MATERIALIZED (
    -- Builds the self thread_state
    SELECT
      self_thread_state_id AS id,
      ts,
      dur,
      critical_path_utid AS utid,
      0 AS stack_depth,
      'thread_state: ' || self_state AS name,
      'thread_state' AS table_name,
      critical_path_utid
    FROM relevant_spans
    UNION ALL
    -- Builds the self kernel blocked_function
    SELECT
      self_thread_state_id AS id,
      ts,
      dur,
      critical_path_utid AS utid,
      1 AS stack_depth,
      IIF(self_state GLOB 'R*', NULL, 'kernel function: ' || self_function) AS name,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      'thread_state' AS table_name,
      critical_path_utid
    FROM relevant_spans
    UNION ALL
    -- Builds the self kernel io_wait
    SELECT
      self_thread_state_id AS id,
      ts,
      dur,
      critical_path_utid AS utid,
      2 AS stack_depth,
      IIF(self_state GLOB 'R*', NULL, 'io_wait: ' || self_io_wait) AS name,
      'thread_state' AS table_name,
      critical_path_utid
    FROM relevant_spans
    UNION ALL
    -- Builds the self process_name
    SELECT
      self_thread_state_id AS id,
      ts,
      dur,
      thread.utid,
      3 AS stack_depth,
      IIF($enable_process_name, 'process_name: ' || process.name, NULL) AS name,
      'thread_state' AS table_name,
      critical_path_utid
    FROM relevant_spans
    LEFT JOIN thread
      ON thread.utid = critical_path_utid
    LEFT JOIN process
      USING (upid)
    -- Builds the self thread_name
    UNION ALL
    SELECT
      self_thread_state_id AS id,
      ts,
      dur,
      thread.utid,
      4 AS stack_depth,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      IIF($enable_thread_name, 'thread_name: ' || thread.name, NULL) AS name,
      'thread_state' AS table_name,
      critical_path_utid
    FROM relevant_spans
    LEFT JOIN thread
      ON thread.utid = critical_path_utid
    JOIN process
      USING (upid)
    UNION ALL
    -- Builds the self 'ancestor' slice stack
    SELECT
      anc.id,
      slice.ts,
      slice.dur,
      critical_path_utid AS utid,
      anc.depth + 5 AS stack_depth,
      IIF($enable_self_slice, anc.name, NULL) AS name,
      'slice' AS table_name,
      critical_path_utid
    FROM relevant_spans slice
    JOIN ancestor_slice(self_slice_id) anc WHERE anc.dur != -1
    UNION ALL
    -- Builds the self 'deepest' ancestor slice stack
    SELECT
      self_slice_id AS id,
      ts,
      dur,
      critical_path_utid AS utid,
      self_slice_depth + 5 AS stack_depth,
      IIF($enable_self_slice, self_slice_name, NULL) AS name,
      'slice' AS table_name,
      critical_path_utid
    FROM relevant_spans slice
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    -- Ordering by stack depth is important to ensure the items can
    -- be renedered in the UI as a debug track in the order in which
    -- the sub-queries were 'unioned'.
    ORDER BY stack_depth
  ),
  -- Prepares for stage 2 in building the entire stack.
  -- Computes the starting depth for each stack. This is necessary because
  -- each self slice stack has variable depth and the depth in each stack
  -- most be contiguous in order to efficiently generate a pprof in the future.
  critical_path_start_depth AS MATERIALIZED (
    SELECT critical_path_utid, ts, MAX(stack_depth) + 1 AS start_depth
    FROM self_stack
    GROUP BY critical_path_utid, ts
  ),
  critical_path_span AS MATERIALIZED (
    SELECT
      thread_state_id,
      state,
      function,
      io_wait,
      slice_id,
      slice_name,
      slice_depth,
      spans.ts,
      spans.dur,
      spans.critical_path_utid,
      utid,
      start_depth
    FROM relevant_spans spans
    JOIN critical_path_start_depth
      ON
)_d3l1m1t3r_"
R"_d3l1m1t3r_(        critical_path_start_depth.critical_path_utid = spans.critical_path_utid
        AND critical_path_start_depth.ts = spans.ts
    WHERE critical_path_start_depth.critical_path_utid = $critical_path_utid AND spans.critical_path_utid != spans.utid
  ),
  -- 2. Builds the 'critical_path' stack of items as an ordered UNION ALL
  critical_path_stack AS MATERIALIZED (
    -- Builds the critical_path thread_state
    SELECT
      thread_state_id AS id,
      ts,
      dur,
      utid,
      start_depth AS stack_depth,
      'blocking thread_state: ' || state AS name,
      'thread_state' AS table_name,
      critical_path_utid
    FROM critical_path_span
    UNION ALL
    -- Builds the critical_path process_name
    SELECT
      thread_state_id AS id,
      ts,
      dur,
      thread.utid,
      start_depth + 1 AS stack_depth,
      'blocking process_name: ' || process.name,
      'thread_state' AS table_name,
      critical_path_utid
    FROM critical_path_span
    JOIN thread USING (utid)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    LEFT JOIN process USING (upid)
    UNION ALL
    -- Builds the critical_path thread_name
    SELECT
      thread_state_id AS id,
      ts,
      dur,
      thread.utid,
      start_depth + 2 AS stack_depth,
      'blocking thread_name: ' || thread.name,
      'thread_state' AS table_name,
      critical_path_utid
    FROM critical_path_span
    JOIN thread USING (utid)
    UNION ALL
    -- Builds the critical_path kernel blocked_function
    SELECT
      thread_state_id AS id,
      ts,
      dur,
      thread.utid,
      start_depth + 3 AS stack_depth,
      'blocking kernel_function: ' || function,
      'thread_state' AS table_name,
      critical_path_utid
    FROM critical_path_span
    JOIN thread USING (utid)
    UNION ALL
    -- Builds the critical_path kernel io_wait
    SELECT
      thread_state_id AS id,
      ts,
      dur,
      thread.utid,
      start_depth + 4 AS stack_depth,
      'blocking io_wait: ' || io_wait,
      'thread_state' AS table_name,
      critical_path_utid
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    FROM critical_path_span
    JOIN thread USING (utid)
    UNION ALL
    -- Builds the critical_path 'ancestor' slice stack
    SELECT
      anc.id,
      slice.ts,
      slice.dur,
      slice.utid,
      anc.depth + start_depth + 5 AS stack_depth,
      IIF($enable_critical_path_slice, anc.name, NULL) AS name,
      'slice' AS table_name,
      critical_path_utid
    FROM critical_path_span slice
    JOIN ancestor_slice(slice_id) anc WHERE anc.dur != -1
    UNION ALL
    -- Builds the critical_path 'deepest' slice
    SELECT
      slice_id AS id,
      ts,
      dur,
      utid,
      slice_depth + start_depth + 5 AS stack_depth,
      IIF($enable_critical_path_slice, slice_name, NULL) AS name,
      'slice' AS table_name,
      critical_path_utid
    FROM critical_path_span slice
    -- Ordering is also important as in the 'self' step above.
    ORDER BY stack_depth
  ),
  -- Prepares for stage 3 in building the entire stack.
  -- Computes the starting depth for each stack using the deepest stack_depth between
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- the critical_path stack and self stack. The self stack depth is
  -- already computed and materialized in |critical_path_start_depth|.
  cpu_start_depth_raw AS (
    SELECT critical_path_utid, ts, MAX(stack_depth) + 1 AS start_depth
    FROM critical_path_stack
    GROUP BY critical_path_utid, ts
    UNION ALL
    SELECT * FROM critical_path_start_depth
  ),
  cpu_start_depth AS (
    SELECT critical_path_utid, ts, MAX(start_depth) AS start_depth
    FROM cpu_start_depth_raw
    GROUP BY critical_path_utid, ts
  ),
  -- 3. Builds the 'CPU' stack for 'Running' states in either the self or critical path stack.
  cpu_stack AS (
    SELECT
      thread_state_id AS id,
      spans.ts,
      spans.dur,
      utid,
      start_depth AS stack_depth,
      'cpu: ' || cpu AS name,
      'thread_state' AS table_name,
      spans.critical_path_utid
    FROM relevant_spans spans
    JOIN cpu_start_depth
      ON
        cpu_start_depth.critical_path_utid = spans.critical_path_utid
        AND cpu_start_depth.ts = spans.ts
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    WHERE cpu_start_depth.critical_path_utid = $critical_path_utid AND state = 'Running' OR self_state = 'Running'
  ),
  merged AS (
    SELECT * FROM self_stack
    UNION ALL
    SELECT * FROM critical_path_stack
    UNION ALL
    SELECT * FROM cpu_stack
  )
SELECT * FROM merged WHERE id IS NOT NULL;

-- Critical path stack of thread_executing_spans with the following entities in the critical path
-- stacked from top to bottom: self thread_state, self blocked_function, self process_name,
-- self thread_name, slice stack, critical_path thread_state, critical_path process_name,
-- critical_path thread_name, critical_path slice_stack, running_cpu.
CREATE PERFETTO FUNCTION _thread_executing_span_critical_path_stack(
  -- Thread utid to filter critical paths to.
  critical_path_utid INT,
  -- Timestamp of start of time range to filter critical paths to.
  ts LONG,
  -- Duration of time range to filter critical paths to.
  dur LONG)
RETURNS
  TABLE(
    -- Id of the thread_state or slice in the thread_executing_span.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    id INT,
    -- Timestamp of slice in the critical path.
    ts LONG,
    -- Duration of slice in the critical path.
    dur LONG,
    -- Utid of thread that emitted the slice.
    utid INT,
    -- Stack depth of the entitity in the debug track.
    stack_depth INT,
    -- Name of entity in the critical path (could be a thread_state, kernel blocked_function, process_name, thread_name, slice name or cpu).
    name STRING,
    -- Table name of entity in the critical path (could be either slice or thread_state).
    table_name STRING,
    -- Utid of the thread the critical path was filtered to.
    critical_path_utid INT
) AS
SELECT * FROM _critical_path_stack($critical_path_utid, $ts, $dur, 1, 1, 1, 1);

-- Returns a pprof aggregation of the stacks in |_critical_path_stack|.
CREATE PERFETTO FUNCTION _critical_path_graph(graph_title STRING, critical_path_utid INT, ts LONG, dur LONG, enable_process_name INT, enable_thread_name INT, enable_self_slice INT, enable_critical_path_slice INT)
RETURNS TABLE(pprof BYTES)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(AS
WITH
  stack AS MATERIALIZED (
    SELECT
      ts,
      dur - IFNULL(LEAD(dur) OVER (PARTITION BY critical_path_utid, ts ORDER BY stack_depth), 0) AS dur,
      name,
      utid,
      critical_path_utid,
      stack_depth
    FROM
      _critical_path_stack($critical_path_utid, $ts, $dur, $enable_process_name, $enable_thread_name, $enable_self_slice, $enable_critical_path_slice)
  ),
  graph AS (
    SELECT CAT_STACKS($graph_title) AS stack
  ),
  parent AS (
    SELECT
      cr.ts,
      cr.dur,
      cr.name,
      cr.utid,
      cr.stack_depth,
      CAT_STACKS(graph.stack, cr.name) AS stack,
      cr.critical_path_utid
    FROM stack cr, graph
    WHERE stack_depth = 0
    UNION ALL
    SELECT
      child.ts,
      child.dur,
      child.name,
      child.utid,
      child.stack_depth,
      CAT_STACKS(stack, child.name) AS stack,
      child.critical_path_utid
    FROM stack child
    JOIN parent
      ON
        parent.critical_path_utid = child.critical_path_utid
        AND parent.ts = child.ts
)_d3l1m1t3r_"
R"_d3l1m1t3r_(        AND child.stack_depth = parent.stack_depth + 1
  ),
  stacks AS (
    SELECT dur, stack FROM parent
  )
SELECT EXPERIMENTAL_PROFILE(stack, 'duration', 'ns', dur) AS pprof FROM stacks;

-- Returns a pprof aggreagation of the stacks in |_thread_executing_span_critical_path_stack|
CREATE PERFETTO FUNCTION _thread_executing_span_critical_path_graph(
  -- Descriptive name for the graph.
  graph_title STRING,
  -- Thread utid to filter critical paths to.
  critical_path_utid INT,
  -- Timestamp of start of time range to filter critical paths to.
  ts INT,
  -- Duration of time range to filter critical paths to.
  dur INT)
RETURNS TABLE(
  -- Pprof of critical path stacks.
  pprof BYTES
)
AS
SELECT * FROM _critical_path_graph($graph_title, $critical_path_utid, $ts, $dur, 1, 1, 1, 1);

)_d3l1m1t3r_"
;

const char kSchedThreadLevelParallelism[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- This module contains helpers for computing the thread-level parallelism counters,
-- including how many threads were runnable at a given time and how many threads
-- where running at a given point in time.

INCLUDE PERFETTO MODULE intervals.overlap;
INCLUDE PERFETTO MODULE cpu.cpus;

-- The count of runnable threads over time.
CREATE PERFETTO TABLE sched_runnable_thread_count(
  -- Timestamp when the runnable thread count changed to the current value.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ts INT,
  -- Number of runnable threads, covering the range from this timestamp to the
  -- next row's timestamp.
  runnable_thread_count INT
) AS
WITH
runnable AS (
  SELECT ts, dur FROM thread_state
  where state = 'R'
)
SELECT
  ts, value as runnable_thread_count
FROM intervals_overlap_count!(runnable, ts, dur)
ORDER BY ts;

-- The count of active CPUs over time.
CREATE PERFETTO TABLE sched_active_cpu_count(
  -- Timestamp when the number of active CPU changed.
  ts INT,
  -- Number of active CPUs, covering the range from this timestamp to the next
  -- row's timestamp.
  active_cpu_count INT
) AS
WITH
-- Filter sched events corresponding to running tasks.
-- utid=0 is the swapper thread / idle task.
tasks AS (
  SELECT ts, dur
  FROM sched
  WHERE utid != 0
)
SELECT
  ts, value as active_cpu_count
FROM intervals_overlap_count!(tasks, ts, dur)
ORDER BY ts;

-- The count of active CPUs with a given core type over time.
CREATE PERFETTO FUNCTION sched_active_cpu_count_for_core_type(
  -- Type of the CPU core as reported by GUESS_CPU_SIZE. Usually 'big', 'mid' or 'little'.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  core_type STRING
) RETURNS TABLE(
  -- Timestamp when the number of active CPU changed.
  ts LONG,
  -- Number of active CPUs, covering the range from this timestamp to the next
  -- row's timestamp.
  active_cpu_count LONG
) AS
WITH
-- Materialise the relevant cores to avoid calling a function for each row of the sched table.
cores AS MATERIALIZED (
  SELECT cpu_index
  FROM cpu_core_types
  WHERE size = $core_type
),
-- Filter sched events corresponding to running tasks.
-- utid=0 is the swapper thread / idle task.
tasks AS (
  SELECT ts, dur
  FROM sched
  WHERE
    cpu IN (SELECT cpu_index FROM cores)
    AND utid != 0
)
SELECT
  ts, value as active_cpu_count
FROM intervals_overlap_count!(tasks, ts, dur)
ORDER BY ts;

)_d3l1m1t3r_"
;

const char kSchedThreadStateFlattened[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE slices.flat_slices;

-- Create a table which joins the thread state across the flattened slices.
CREATE VIRTUAL TABLE __span_joined_thread USING
  SPAN_JOIN(_slice_flattened PARTITIONED utid, thread_state PARTITIONED utid);

-- Get the thread state breakdown of a flattened slice from its slice id.
-- This table pivoted and summed for better visualization and aggregation.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- The concept of a "flat slice" is to take the data in the slice table and
-- remove all notion of nesting. For more information, read the description
-- of _slice_flattened.
CREATE PERFETTO FUNCTION _get_flattened_thread_state(
  -- Id of the slice of interest.
  slice_id LONG,
  -- Utid.
  utid LONG)
RETURNS
  TABLE(
    -- Timestamp.
    ts LONG,
    -- Duration.
    dur LONG,
    -- Utid.
    utid LONG,
    -- Depth.
    depth LONG,
    -- Name.
    name STRING,
    -- Slice id.
    slice_id LONG,
    -- Track id.
    track_id LONG,
    -- CPU.
    cpu INT,
    -- State.
    state STRING,
    -- IO wait.
    io_wait INT,
    -- Thread state's blocked_function.
    blocked_function STRING,
    -- Thread state's waker utid.
    waker_utid LONG,
    -- Thread state's IRQ context.
    irq_context LONG
) AS
WITH
interesting_slice AS (
  SELECT ts, dur, slice.track_id AS track_id
  FROM slice
  JOIN thread_track
    ON slice.track_id = thread_track.id
  JOIN thread
    USING (utid)
  WHERE
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    (($slice_id IS NOT NULL AND slice.id = $slice_id) OR ($slice_id IS NULL))
    AND (($utid IS NOT NULL AND utid = $utid) OR ($utid IS NULL))
)
SELECT
  ts,
  dur,
  utid,
  depth,
  name,
  slice_id,
  track_id,
  cpu,
  state,
  io_wait,
  blocked_function,
  waker_utid,
  irq_context
FROM __span_joined_thread
WHERE
  track_id = (SELECT track_id FROM interesting_slice)
  AND ts >= (SELECT ts FROM interesting_slice)
  AND ts < (SELECT ts + dur FROM interesting_slice);

-- Get the thread state breakdown of a flattened slice from slice id.
-- This table pivoted and summed for better visualization and aggragation.
-- The concept of a "flat slice" is to take the data in the slice table and
-- remove all notion of nesting. For more information, read the description
-- of _slice_flattened.
CREATE PERFETTO FUNCTION _get_flattened_thread_state_aggregated(
  -- Slice id.
  slice_id LONG,
  -- Utid.
  utid LONG)
RETURNS TABLE(
  -- Id of a slice.
  slice_id LONG,
  -- Name of the slice.
  slice_name STRING,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Time (ns) spent in Uninterruptible Sleep (non-IO)
  Uninterruptible_Sleep_nonIO LONG,
  -- Time (ns) spent in Uninterruptible Sleep (IO)
  Uninterruptible_Sleep_IO LONG,
  -- Time (ns) spent in Runnable
  Runnable LONG,
  -- Time (ns) spent in Sleeping
  Sleeping LONG,
  -- Time (ns) spent in Stopped
  Stopped LONG,
  -- Time (ns) spent in Traced
  Traced LONG,
  -- Time (ns) spent in Exit (Dead)
  Exit_Dead LONG,
  -- Time (ns) spent in Exit (Zombie)
  Exit_Zombie LONG,
  -- Time (ns) spent in Task Dead
  Task_Dead LONG,
  -- Time (ns) spent in Wake Kill
  Wake_Kill LONG,
  -- Time (ns) spent in Waking
  Waking LONG,
  -- Time (ns) spent in Parked
  Parked LONG,
  -- Time (ns) spent in No Load
  No_Load LONG,
  -- Time (ns) spent in Runnable (Preempted)
  Runnable_Preempted LONG,
  -- Time (ns) spent in Running
  Running LONG,
  -- Time (ns) spent in Idle
  Idle LONG,
  -- Total duration of the slice
  dur LONG,
  -- Depth of the slice in Perfetto
  depth LONG)
AS
WITH
final_table AS (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  SELECT *
  FROM _get_flattened_thread_state($slice_id, $utid)
)
SELECT
fs.slice_id,
fs.name AS slice_name,
SUM(CASE WHEN fs.state = 'D' AND io_wait = 0 THEN fs.dur END)
  Uninterruptible_Sleep_nonIO,
SUM(CASE WHEN fs.state = 'D' AND io_wait = 1 THEN fs.dur END)
  Uninterruptible_Sleep_IO,
SUM(CASE WHEN fs.state = 'R' THEN fs.dur END) Runnable,
SUM(CASE WHEN fs.state = 'S' THEN fs.dur END) Sleeping,
SUM(CASE WHEN fs.state = 'T' THEN fs.dur END) Stopped,
SUM(CASE WHEN fs.state = 't' THEN fs.dur END) Traced,
SUM(CASE WHEN fs.state = 'X' THEN fs.dur END) Exit_Dead,
SUM(CASE WHEN fs.state = 'Z' THEN fs.dur END) Exit_Zombie,
SUM(CASE WHEN fs.state = 'x' THEN fs.dur END) Task_Dead,
SUM(CASE WHEN fs.state = 'K' THEN fs.dur END) Wake_Kill,
SUM(CASE WHEN fs.state = 'W' THEN fs.dur END) Waking,
SUM(CASE WHEN fs.state = 'P' THEN fs.dur END) Parked,
SUM(CASE WHEN fs.state = 'N' THEN fs.dur END) No_Load,
SUM(CASE WHEN fs.state = 'R+' THEN fs.dur END) Runnable_Preempted,
SUM(CASE WHEN fs.state = 'Running' THEN fs.dur END) Running,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SUM(CASE WHEN fs.state = 'I' THEN fs.dur END) Idle,
SUM(fs.dur) dur,
fs.depth
FROM final_table fs
GROUP BY fs.slice_id;
)_d3l1m1t3r_"
;

const char kSchedTimeInState[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE intervals.intersect;

-- The time a thread spent in each scheduling state during it's lifetime.
CREATE PERFETTO TABLE sched_time_in_state_for_thread(
  -- Utid of the thread.
  utid INT,
  -- Total runtime of thread.
  total_runtime INT,
  -- One of the scheduling states of kernel thread.
  state STRING,
  -- Total time spent in the scheduling state.
  time_in_state INT,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Percentage of time thread spent in scheduling state in [0-100] range.
  percentage_in_state INT
) AS
WITH total_dur AS (
  SELECT
    utid,
    sum(dur) AS sum_dur
  FROM thread_state
  GROUP BY 1
),
summed AS (
  SELECT
    utid,
    state,
    sum(dur) AS time_in_state
  FROM thread_state group by 1, 2
)
SELECT
  utid,
  sum_dur AS total_runtime,
  state,
  time_in_state,
  (time_in_state*100)/(sum_dur) AS percentage_in_state
FROM summed JOIN total_dur USING (utid);

CREATE PERFETTO MACRO _case_for_state(state Expr)
RETURNS Expr AS
MAX(CASE WHEN state = $state THEN percentage_in_state END);

-- Summary of time spent by thread in each scheduling state, in percentage ([0, 100]
-- ranges). Sum of all states might be smaller than 100, as those values
-- are rounded down.
CREATE PERFETTO TABLE sched_percentage_of_time_in_state(
  -- Utid of the thread.
  utid INT,
  -- Percentage of time thread spent in running ('Running') state in [0, 100]
  -- range.
  running INT,
  -- Percentage of time thread spent in runnable ('R') state in [0, 100]
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- range.
  runnable INT,
  -- Percentage of time thread spent in preempted runnable ('R+') state in
  -- [0, 100] range.
  runnable_preempted INT,
  -- Percentage of time thread spent in sleeping ('S') state in [0, 100] range.
  sleeping INT,
  -- Percentage of time thread spent in uninterruptible sleep ('D') state in
  -- [0, 100] range.
  uninterruptible_sleep INT,
  -- Percentage of time thread spent in other ('T', 't', 'X', 'Z', 'x', 'I',
  -- 'K', 'W', 'P', 'N') states in [0, 100] range.
  other INT
) AS
SELECT
  utid,
  _case_for_state!('Running') AS running,
  _case_for_state!('R') AS runnable,
  _case_for_state!('R+') AS runnable_preempted,
  _case_for_state!('S') AS sleeping,
  _case_for_state!('D') AS uninterruptible_sleep,
  SUM(
    CASE WHEN state IN ('T', 't', 'X', 'Z', 'x', 'I', 'K', 'W', 'P', 'N')
    THEN time_in_state END
  ) * 100/total_runtime AS other
FROM sched_time_in_state_for_thread
GROUP BY utid;

-- Time the thread spent each state in a given interval.
CREATE PERFETTO FUNCTION sched_time_in_state_for_thread_in_interval(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- The start of the interval.
  ts INT,
  -- The duration of the interval.
  dur INT,
  -- The utid of the thread.
  utid INT)
RETURNS TABLE(
  -- Thread state (from the `thread_state` table).
  -- Use `sched_state_to_human_readable_string` function to get full name.
  state INT,
  -- A (posssibly NULL) boolean indicating, if the device was in uninterruptible
  -- sleep, if it was an IO sleep.
  io_wait BOOL,
  -- Some states can specify the blocked function. Usually NULL.
  blocked_function INT,
  -- Total time spent with this state, cpu and blocked function.
  dur INT) AS
SELECT
  state,
  io_wait,
  blocked_function,
  sum(ii.dur) as dur
FROM thread_state
JOIN
  (SELECT * FROM _interval_intersect_single!(
    $ts, $dur,
    (SELECT id, ts, dur
    FROM thread_state
    WHERE utid = $utid))) ii USING (id)
GROUP BY 1, 2, 3
ORDER BY 4 DESC;

-- Time the thread spent each state and cpu in a given interval.
CREATE PERFETTO FUNCTION sched_time_in_state_and_cpu_for_thread_in_interval(
  -- The start of the interval.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ts INT,
  -- The duration of the interval.
  dur INT,
  -- The utid of the thread.
  utid INT)
RETURNS TABLE(
  -- Thread state (from the `thread_state` table).
  -- Use `sched_state_to_human_readable_string` function to get full name.
  state INT,
  -- A (posssibly NULL) boolean indicating, if the device was in uninterruptible
  -- sleep, if it was an IO sleep.
  io_wait BOOL,
  -- Id of the CPU.
  -- Use `cpu_guess_core_type` to get the CPU size (little/mid/big).
  cpu INT,
  -- Some states can specify the blocked function. Usually NULL.
  blocked_function INT,
  -- Total time spent with this state, cpu and blocked function.
  dur INT) AS
SELECT
  state,
  io_wait,
  cpu,
  blocked_function,
  sum(ii.dur) as dur
FROM thread_state
JOIN
  (SELECT * FROM _interval_intersect_single!(
    $ts, $dur,
    (SELECT id, ts, dur
    FROM thread_state
    WHERE utid = $utid))) ii USING (id)
GROUP BY 1, 2, 3, 4
ORDER BY 5 DESC;

-- Time spent by CPU in each scheduling state in a provided interval.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO FUNCTION sched_time_in_state_for_cpu_in_interval(
    -- CPU id.
    cpu INT,
    -- Interval start.
    ts INT,
    -- Interval duration.
    dur INT
) RETURNS TABLE (
    -- End state. From `sched.end_state`.
    end_state STRING,
    -- Duration in state.
    dur INT
) AS
WITH sched_for_cpu AS (
  SELECT id, ts, dur
  FROM sched
  WHERE cpu = $cpu AND dur != -1
)
SELECT
    end_state,
    sum(ii.dur) AS dur
FROM sched
JOIN _interval_intersect_single!($ts, $dur, sched_for_cpu) ii
USING (id)
GROUP BY end_state;




)_d3l1m1t3r_"
;

const char kSlicesCpuTime[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- TODO(mayzner): Replace with good implementation of interval intersect.
CREATE PERFETTO MACRO _interval_intersect_partition_utid(
  left_table TableOrSubquery,
  right_table TableOrSubquery
)
RETURNS TableOrSubquery AS
(
  WITH on_left AS (
    SELECT
      B.ts,
      IIF(
        A.ts + A.dur <= B.ts + B.dur,
        A.ts + A.dur - B.ts, B.dur) AS dur,
      A.id AS left_id,
      B.id as right_id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    FROM $left_table A
    JOIN $right_table B ON (A.ts <= B.ts AND A.ts + A.dur > B.ts AND A.utid = B.utid)
  ), on_right AS (
    SELECT
      B.ts,
      IIF(
        A.ts + A.dur <= B.ts + B.dur,
        A.ts + A.dur - B.ts, B.dur) AS dur,
      B.id as left_id,
      A.id AS right_id
    FROM $right_table A
    -- The difference between this table and on_left is the lack of equality on
    -- A.ts <= B.ts. This is to remove the issue of double accounting
    -- timestamps that start at the same time.
    JOIN $left_table B ON (A.ts < B.ts AND A.ts + A.dur > B.ts AND A.utid = B.utid)
  )
  SELECT * FROM on_left
  UNION ALL
  SELECT * FROM on_right
);

-- Time each thread slice spent running on CPU.
-- Requires scheduling data to be available in the trace.
CREATE PERFETTO TABLE thread_slice_cpu_time(
    -- Slice id.
    id INT,
    -- Duration of the time the slice was running.
    cpu_time INT) AS
WITH slice_with_utid AS (
  SELECT
      slice.id,
      slice.ts,
      slice.dur,
      utid
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  FROM slice
  JOIN thread_track ON slice.track_id = thread_track.id
  JOIN thread USING (utid)
  WHERE utid != 0)
SELECT left_id AS id, SUM(dur) AS cpu_time
FROM _interval_intersect_partition_utid!(slice_with_utid, sched)
GROUP BY 1
ORDER BY 1;
)_d3l1m1t3r_"
;

const char kSlicesFlatSlices[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
INCLUDE PERFETTO MODULE slices.with_context;
INCLUDE PERFETTO MODULE intervals.overlap;

-- The concept of a "flat slice" is to take the data in the slice table and
-- remove all notion of nesting; we do this by projecting every slice in a stack to
-- their ancestor slice, i.e at any point in time, taking the  most specific active
-- slice (i.e. the slice at the bottom of the stack) and representing that as the
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- *only* slice that was running during that period.
--
-- This concept becomes very useful when you try and linearise a trace and
-- compare it with other traces spanning the same user action; "self time" (i.e.
-- time spent in a slice but *not* any children) is easily computed and span
-- joins with thread state become possible without limiting to only depth zero
--- slices.
--
-- Note that, no slices will be generated for intervals without without any slices.
--
-- As an example, consider the following slice stack:
-- ```
-- A-------------B.
-- ----C----D----.
-- ```
-- The flattened slice will be:
-- ```
-- A----C----D----B.
-- ```
--
-- @column slice_id           Id of most active slice.
-- @column ts                 Timestamp when `slice.id` became the most active slice.
-- @column dur                Duration of `slice.id` as the most active slice until the next active slice.
-- @column depth              Depth of `slice.id` in the original stack.
-- @column name               Name of `slice.id`.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column root_name          Name of the top most slice of the stack.
-- @column root_id            Id of of the top most slice of the stack.
-- @column track_id           Alias for `slice.track_id`.
-- @column utid               Alias for `thread.utid`.
-- @column tid                Alias for `thread.tid`
-- @column thread_name        Alias for `thread.name`.
-- @column upid               Alias for `process.upid`.
-- @column pid                Alias for `process.pid`.
-- @column process_name       Alias for `process.name`.
CREATE TABLE _slice_flattened
AS
WITH
  root_slices AS (
    SELECT * FROM slice WHERE parent_id IS NULL
  ),
  child_slices AS (
    SELECT anc.id AS root_id, slice.*
    FROM slice
    JOIN ancestor_slice(slice.id) anc
    WHERE slice.parent_id IS NOT NULL
  ),
  flat_slices AS (
    SELECT id, ts, dur
    FROM _intervals_flatten !(_intervals_merge_root_and_children!(root_slices, child_slices))
  )
SELECT
  id AS slice_id,
  flat_slices.ts,
  flat_slices.dur,
  depth,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  name,
  track_id,
  utid,
  tid,
  thread_name,
  upid,
  pid,
  process_name
FROM flat_slices
JOIN thread_slice
  USING (id);

CREATE
  INDEX _slice_flattened_id_idx
ON _slice_flattened(slice_id);

CREATE
  INDEX _slice_flattened_ts_idx
ON _slice_flattened(ts);

)_d3l1m1t3r_"
;

const char kSlicesSlices[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- All slices with related process and thread info if available. Unlike
-- `thread_slice` and `process_slice`, this view contains all slices,
-- with thread- and process-related columns set to NULL if the slice
-- is not associated with a thread or a process.
CREATE PERFETTO VIEW _slice_with_thread_and_process_info(
  -- Alias for `slice.id`.
  id INT,
  -- Alias for `slice.type`.
  type STRING,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Alias for `slice.ts`.
  ts INT,
  -- Alias for `slice.dur`.
  dur INT,
  -- Alias for `slice.category`.
  category STRING,
  -- Alias for `slice.name`.
  name STRING,
  -- Alias for `slice.track_id`.
  track_id INT,
  -- Alias for `track.name`.
  track_name STRING,
  -- Alias for `thread.name`.
  thread_name STRING,
  -- Alias for `thread.utid`.
  utid INT,
  -- Alias for `thread.tid`
  tid INT,
  -- Alias for `process.name`.
  process_name STRING,
  -- Alias for `process.upid`.
  upid INT,
  -- Alias for `process.pid`.
  pid INT,
  -- Alias for `slice.depth`.
  depth INT,
  -- Alias for `slice.parent_id`.
  parent_id INT,
  -- Alias for `slice.arg_set_id`.
  arg_set_id INT,
  -- Alias for `slice.thread_ts`.
  thread_ts INT,
  -- Alias for `slice.thread_dur`.
  thread_dur INT
) AS
SELECT
  slice.id,
  slice.type,
  slice.ts,
  slice.dur,
  slice.category,
  slice.name,
  slice.track_id,
  track.name AS track_name,
  thread.name AS thread_name,
  thread.utid,
  thread.tid,
  COALESCE(process1.name, process2.name) AS process_name,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  COALESCE(process1.upid, process2.upid) AS upid,
  COALESCE(process1.pid, process2.pid) AS pid,
  slice.depth,
  slice.parent_id,
  slice.arg_set_id,
  slice.thread_ts,
  slice.thread_dur
FROM slice
JOIN track ON slice.track_id = track.id
LEFT JOIN thread_track ON slice.track_id = thread_track.id
LEFT JOIN thread USING (utid)
LEFT JOIN process process1 ON thread.upid = process1.upid
LEFT JOIN process_track ON slice.track_id = process_track.id
LEFT JOIN process process2 ON process_track.upid = process2.upid;

)_d3l1m1t3r_"
;

const char kSlicesWithContext[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- All thread slices with data about thread, thread track and process.
-- Where possible, use available view functions which filter this view.
CREATE PERFETTO VIEW thread_slice(
  -- Alias for `slice.id`.
  id INT,
  -- Alias for `slice.type`.
  type STRING,
  -- Alias for `slice.ts`.
  ts INT,
  -- Alias for `slice.dur`.
  dur INT,
  -- Alias for `slice.category`.
  category STRING,
  -- Alias for `slice.name`.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  name STRING,
  -- Alias for `slice.track_id`.
  track_id INT,
  -- Alias for `thread_track.name`.
  track_name STRING,
  -- Alias for `thread.name`.
  thread_name STRING,
  -- Alias for `thread.utid`.
  utid INT,
  -- Alias for `thread.tid`.
  tid INT,
  -- Alias for `thread.is_main_thread`.
  is_main_thread BOOL,
  -- Alias for `process.name`.
  process_name STRING,
  -- Alias for `process.upid`.
  upid INT,
  -- Alias for `process.pid`.
  pid INT,
  -- Alias for `slice.depth`.
  depth INT,
  -- Alias for `slice.parent_id`.
  parent_id INT,
  -- Alias for `slice.arg_set_id`.
  arg_set_id INT,
  -- Alias for `slice.thread_ts`.
  thread_ts INT,
  -- Alias for `slice.thread_dur`.
  thread_dur INT
) AS
SELECT
  slice.id,
  slice.type,
  slice.ts,
  slice.dur,
  slice.category,
  slice.name,
  slice.track_id,
  thread_track.name AS track_name,
  thread.name AS thread_name,
  thread.utid,
  thread.tid,
  thread.is_main_thread,
  process.name AS process_name,
  process.upid,
  process.pid,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  slice.depth,
  slice.parent_id,
  slice.arg_set_id,
  slice.thread_ts,
  slice.thread_dur
FROM slice
JOIN thread_track ON slice.track_id = thread_track.id
JOIN thread USING (utid)
LEFT JOIN process USING (upid);

-- All process slices with data about process track and process.
-- Where possible, use available view functions which filter this view.
CREATE PERFETTO VIEW process_slice(
  -- Alias for `slice.id`.
  id INT,
  -- Alias for `slice.type`.
  type STRING,
  -- Alias for `slice.ts`.
  ts INT,
  -- Alias for `slice.dur`.
  dur INT,
  -- Alias for `slice.category`.
  category STRING,
  -- Alias for `slice.name`.
  name STRING,
  -- Alias for `slice.track_id`.
  track_id INT,
  -- Alias for `process_track.name`.
  track_name STRING,
  -- Alias for `process.name`.
  process_name STRING,
  -- Alias for `process.upid`.
  upid INT,
  -- Alias for `process.pid`.
  pid INT,
  -- Alias for `slice.depth`.
  depth INT,
  -- Alias for `slice.parent_id`.
  parent_id INT,
  -- Alias for `slice.arg_set_id`.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  arg_set_id INT,
  -- Alias for `slice.thread_ts`.
  thread_ts INT,
  -- Alias for `slice.thread_dur`.
  thread_dur INT
) AS
SELECT
  slice.id,
  slice.type,
  slice.ts,
  slice.dur,
  slice.category,
  slice.name,
  slice.track_id,
  process_track.name AS track_name,
  process.name AS process_name,
  process.upid,
  process.pid,
  slice.depth,
  slice.parent_id,
  slice.arg_set_id,
  slice.thread_ts,
  slice.thread_dur
FROM slice
JOIN process_track ON slice.track_id = process_track.id
JOIN process USING (upid);
)_d3l1m1t3r_"
;

const char kStackTraceJit[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.


-- Represents a jitted code snippet.
-- TODO(carlscab): Make public
CREATE PERFETTO VIEW _jit_code (
  -- Unique jit code id.
  jit_code_id UINT,
  -- Time this code was created / allocated.
  create_ts LONG,
  -- Time this code was destroyed / deallocated. This is a upper bound, as we
  -- can only detect deletions indirectly when new code is allocated overlapping
  -- existing one.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  estimated_delete_ts LONG,
  -- Thread that generated the code.
  utid UINT,
  -- Start address for the generated code.
  start_address LONG,
  -- Size in bytes of the generated code.
  size LONG,
  -- Function name.
  function_name STRING,
  -- Jitted code (binary data).
  native_code BYTES
) AS
SELECT
  id AS jit_code_id,
  create_ts,
  estimated_delete_ts,
  utid,
  start_address,
  size,
  function_name,
  base64_decode(native_code_base64) AS native_code
FROM __intrinsic_jit_code;

-- Represents a jitted frame.
-- TODO(carlscab): Make public
CREATE PERFETTO VIEW _jit_frame (
  -- Jitted code snipped the frame is in (joins with _jit_code.jit_code_id).
  jit_code_id UINT,
  -- Jitted frame (joins with stack_profile_frame.id).
  frame_id UINT
) AS
SELECT
  jit_code_id,
  frame_id
FROM
  __intrinsic_jit_frame;

)_d3l1m1t3r_"
;

const char kTimeConversion[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Returns the provided nanosecond duration, which is the default
-- representation of time durations in trace processor. Provided for
-- consistency with other functions.
CREATE PERFETTO FUNCTION time_from_ns(
  -- Time duration in nanoseconds.
  nanos INT
)
-- Time duration in nanoseconds.
RETURNS INT AS
SELECT $nanos;

-- Converts a duration in microseconds to nanoseconds, which is the default
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- representation of time durations in trace processor.
CREATE PERFETTO FUNCTION time_from_us(
  -- Time duration in microseconds.
  micros INT
)
-- Time duration in nanoseconds.
RETURNS INT AS
SELECT $micros * 1000;

-- Converts a duration in millseconds to nanoseconds, which is the default
-- representation of time durations in trace processor.
CREATE PERFETTO FUNCTION time_from_ms(
  -- Time duration in milliseconds.
  millis INT
)
-- Time duration in nanoseconds.
RETURNS INT AS
SELECT $millis * 1000 * 1000;

-- Converts a duration in seconds to nanoseconds, which is the default
-- representation of time durations in trace processor.
CREATE PERFETTO FUNCTION time_from_s(
  -- Time duration in seconds.
  seconds INT
)
-- Time duration in nanoseconds.
RETURNS INT AS
SELECT $seconds * 1000 * 1000 * 1000;

-- Converts a duration in minutes to nanoseconds, which is the default
-- representation of time durations in trace processor.
CREATE PERFETTO FUNCTION time_from_min(
  -- Time duration in minutes.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  minutes INT
)
-- Time duration in nanoseconds.
RETURNS INT AS
SELECT $minutes * 60 * 1000 * 1000 * 1000;

-- Converts a duration in hours to nanoseconds, which is the default
-- representation of time durations in trace processor.
CREATE PERFETTO FUNCTION time_from_hours(
  -- Time duration in hours.
  hours INT
)
-- Time duration in nanoseconds.
RETURNS INT AS
SELECT $hours * 60 * 60 * 1000 * 1000 * 1000;

-- Converts a duration in days to nanoseconds, which is the default
-- representation of time durations in trace processor.
CREATE PERFETTO FUNCTION time_from_days(
  -- Time duration in days.
  days INT
)
-- Time duration in nanoseconds.
RETURNS INT AS
SELECT $days * 24 * 60 * 60 * 1000 * 1000 * 1000;

-- Returns the provided nanosecond duration, which is the default
-- representation of time durations in trace processor. Provided for
-- consistency with other functions.
CREATE PERFETTO FUNCTION time_to_ns(
  -- Time duration in nanoseconds.
  nanos INT
)
-- Time duration in nanoseconds.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(RETURNS INT AS
SELECT $nanos;

-- Converts a duration in nanoseconds to microseconds. Nanoseconds is the default
-- representation of time durations in trace processor.
CREATE PERFETTO FUNCTION time_to_us(
-- Time duration in nanoseconds.
  nanos INT
)
-- Time duration in microseconds.
RETURNS INT AS
SELECT $nanos / 1000;

-- Converts a duration in nanoseconds to millseconds. Nanoseconds is the default
-- representation of time durations in trace processor.
CREATE PERFETTO FUNCTION time_to_ms(
  -- Time duration in nanoseconds.
  nanos INT
)
-- Time duration in milliseconds.
RETURNS INT AS
SELECT $nanos / (1000 * 1000);

-- Converts a duration in nanoseconds to seconds. Nanoseconds is the default
-- representation of time durations in trace processor.
CREATE PERFETTO FUNCTION time_to_s(
  -- Time duration in nanoseconds.
  nanos INT
)
-- Time duration in seconds.
RETURNS INT AS
SELECT $nanos / (1000 * 1000 * 1000);

-- Converts a duration in nanoseconds to minutes. Nanoseconds is the default
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- representation of time durations in trace processor.
CREATE PERFETTO FUNCTION time_to_min(
  -- Time duration in nanoseconds.
  nanos INT
)
-- Time duration in minutes.
RETURNS INT AS
SELECT $nanos / (60 * 1000 * 1000 * 1000);

-- Converts a duration in nanoseconds to hours. Nanoseconds is the default
-- representation of time durations in trace processor.
CREATE PERFETTO FUNCTION time_to_hours(
  -- Time duration in nanoseconds.
  nanos INT
)
-- Time duration in hours.
RETURNS INT AS
SELECT $nanos / (60 * 60 * 1000 * 1000 * 1000);

-- Converts a duration in nanoseconds to days. Nanoseconds is the default
-- representation of time durations in trace processor.
CREATE PERFETTO FUNCTION time_to_days(
  -- Time duration in nanoseconds.
  nanos INT
)
-- Time duration in days.
RETURNS INT AS
SELECT $nanos / (24 * 60 * 60 * 1000 * 1000 * 1000);


)_d3l1m1t3r_"
;

const char kV8Jit[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- These are the tables for the V8 jit data source
-- (protos/perfetto/trace/chrome/v8.proto).
--
-- All events are associated to a V8 isolate instance. There can be multiple
-- instances associated to a given thread, although this is rare.
--
-- Generated code in V8 is allocated in the V8 heap (in a special executeable
-- section), this means that code can be garbage collected (when no longer used)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- or can be moved around (e.g. during heap compactation). This means that a
-- given callsite might correspond to function `A` at one point in time and to
-- function `B` later on.
-- In addition V8 code has various levels of optimization, so a function might
-- have multiple associated code snippets.
--
-- V8 does not track code deletion, so we have to indirectly infer it by
-- detecting code overlaps, if a newer code creation event overlaps with older
-- code we need to asume that the old code was deleted. Code moves are logged,
-- and there is an event to track those.

-- A V8 Isolate instance. A V8 Isolate represents an isolated instance of the V8
-- engine.
CREATE PERFETTO VIEW v8_isolate(
  -- Unique V8 isolate id.
  v8_isolate_id UINT,
  -- Process the isolate was created in.
  upid UINT,
  -- Internal id used by the v8 engine. Unique in a process.
  internal_isolate_id UINT,
  -- Absolute start address of the embedded code blob.
  embedded_blob_code_start_address LONG,
  -- Size in bytes of the embedded code blob.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  embedded_blob_code_size LONG,
  -- Base address of the code range if the isolate defines one.
  code_range_base_address LONG,
  -- Size of a code range if the isolate defines one.
  code_range_size LONG,
  -- Whether the code range for this Isolate is shared with others in the same
  -- process. There is at max one such shared code range per process.
  shared_code_range LONG,
  -- Used when short builtin calls are enabled, where embedded builtins are
  -- copied into the CodeRange so calls can be nearer.
  embedded_blob_code_copy_start_address LONG
) AS
SELECT
  id AS v8_isolate_id,
  upid,
  internal_isolate_id,
  embedded_blob_code_start_address,
  embedded_blob_code_size,
  code_range_base_address,
  code_range_size,
  shared_code_range,
  embedded_blob_code_copy_start_address
FROM
  __intrinsic_v8_isolate;


-- Represents a script that was compiled to generate code. Some V8 code is
-- generated out of scripts and will reference a V8Script other types of code
-- will not (e.g. builtins).
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO VIEW v8_js_script (
  -- Unique V8 JS script id.
  v8_js_script_id UINT,
  -- V8 isolate this script belongs to (joinable with
  -- `v8_isolate.v8_isolate_id`).
  v8_isolate_id UINT,
  -- Script id used by the V8 engine.
  internal_script_id UINT,
  -- Script type.
  script_type STRING,
  -- Script name.
  name STRING,
  -- Actual contents of the script.
  source STRING
) AS
SELECT
  id AS v8_js_script_id,
  v8_isolate_id,
  internal_script_id,
  script_type,
  name,
  source
FROM
  __intrinsic_v8_js_script;


-- Represents one WASM script.
CREATE PERFETTO VIEW v8_wasm_script (
  -- Unique V8 WASM script id.
  v8_wasm_script_id UINT,
  -- V8 Isolate this script belongs to (joinable with
  -- `v8_isolate.v8_isolate_id`).
  v8_isolate_id UINT,
  -- Script id used by the V8 engine.
  internal_script_id UINT,
  -- URL of the source.
  url STRING,
  -- Actual contents of the script.
  source STRING
) AS
SELECT
  id AS v8_wasm_script_id,
  v8_isolate_id,
  internal_script_id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  url,
  source
FROM
  __intrinsic_v8_wasm_script;


-- Represents a v8 Javascript function.
CREATE PERFETTO VIEW v8_js_function (
  -- Unique V8 JS function id.
  v8_js_function_id UINT,
  -- Function name.
  name STRING,
  -- Script where the function is defined (joinable with
  -- `v8_js_script.v8_js_script_id`).
  v8_js_script_id UINT,
  -- Whether this function represents the top level script.
  is_toplevel BOOL,
  -- Function kind (e.g. regular function or constructor).
  kind STRING,
  -- Line in script where function is defined. Starts at 1.
  line UINT,
  -- Column in script where function is defined. Starts at 1.
  col UINT
) AS
SELECT
  id AS v8_js_function_id,
  name,
  v8_js_script_id,
  is_toplevel,
  kind,
  line,
  col
FROM
  __intrinsic_v8_js_function;


-- Represents a v8 code snippet for a Javascript function. A given function can
-- have multiple code snippets (e.g. for different compilation tiers, or as the
-- function moves around the heap).
-- TODO(carlscab): Make public once `_jit_code` is public too
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO VIEW _v8_js_code(
  -- Unique id
  id UINT,
  -- Associated jit code. Set for all tiers except IGNITION. Joinable with
  -- `_jit_code.jit_code_id`.
  jit_code_id UINT,
  -- JS function for this snippet. Joinable with
  -- `v8_js_function.v8_js_function_id`.
  v8_js_function_id UINT,
  -- Compilation tier
  tier STRING,
  -- V8 VM bytecode. Set only for the IGNITION tier.
  bytecode BYTES
) AS
SELECT
  id,
  jit_code_id,
  v8_js_function_id,
  tier,
  base64_decode(bytecode_base64) AS bytecode
FROM
  __intrinsic_v8_js_code;


-- Represents a v8 code snippet for a v8 internal function.
-- TODO(carlscab): Make public once `_jit_code` is public too
CREATE PERFETTO VIEW _v8_internal_code(
  -- Unique id
  id UINT,
  -- Associated jit code. Joinable with `_jit_code.jit_code_id`.
  jit_code_id UINT,
  -- V8 Isolate this code was created in. Joinable with
  -- `v8_isolate.v8_isolate_id`.
  v8_isolate_id UINT,
  -- Function name.
  function_name STRING,
  -- Type of internal code.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  code_type STRING
) AS
SELECT
  id,
  jit_code_id,
  v8_isolate_id,
  function_name,
  code_type
FROM
  __intrinsic_v8_internal_code;

-- Represents the code associated to a WASM function.
-- TODO(carlscab): Make public once `_jit_code` is public too
CREATE PERFETTO VIEW _v8_wasm_code(
  -- Unique id
  id UINT,
  -- Associated jit code. Joinable with `_jit_code.jit_code_id`.
  jit_code_id UINT,
  -- V8 Isolate this code was created in. Joinable with
  -- `v8_isolate.v8_isolate_id`.
  v8_isolate_id UINT,
  -- Script where the function is defined. Joinable with
  -- `v8_wasm_script.v8_wasm_script_id`.
  v8_wasm_script_id UINT,
  -- Function name.
  function_name STRING,
  -- Compilation tier.
  tier STRING,
  -- Offset into the WASM module where the function starts.
  code_offset_in_module INT
 ) AS
SELECT
  id,
  jit_code_id,
  v8_isolate_id,
  v8_wasm_script_id,
  function_name,
  tier,
  code_offset_in_module
FROM
  __intrinsic_v8_wasm_code;

-- Represents the code associated to a regular expression
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- TODO(carlscab): Make public once `_jit_code` is public too
CREATE PERFETTO VIEW _v8_regexp_code(
  -- Unique id
  id UINT,
  -- Associated jit code. Joinable with `_jit_code.jit_code_id`.
  jit_code_id UINT,
  -- V8 Isolate this code was created in. Joinable with
  -- `v8_isolate.v8_isolate_id`.
  v8_isolate_id UINT,
  -- The pattern the this regular expression was compiled from.
  pattern STRING
) AS
SELECT
  id,
  jit_code_id,
  v8_isolate_id,
  pattern
FROM
  __intrinsic_v8_regexp_code;

)_d3l1m1t3r_"
;

const char kVizSummaryCounters[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

CREATE PERFETTO TABLE _counter_track_summary AS
SELECT DISTINCT track_id as id
FROM counter;

)_d3l1m1t3r_"
;

const char kVizSummaryProcesses[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE viz.summary.slices;
INCLUDE PERFETTO MODULE viz.summary.threads;

CREATE PERFETTO TABLE _process_track_summary AS
SELECT upid, SUM(cnt) AS slice_count
FROM process_track
JOIN _slice_track_summary USING (id)
GROUP BY upid;

CREATE PERFETTO TABLE _heap_profile_allocation_summary AS
SELECT upid, COUNT() AS allocation_count
FROM heap_profile_allocation
GROUP BY upid;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
CREATE PERFETTO TABLE _heap_profile_graph_summary AS
SELECT upid, COUNT() AS graph_object_count
FROM heap_graph_object;

CREATE PERFETTO TABLE _thread_process_grouped_summary AS
SELECT
  upid,
  MAX(max_running_dur) AS max_running_dur,
  SUM(sum_running_dur) AS sum_running_dur,
  SUM(running_count) AS running_count,
  SUM(slice_count) AS slice_count,
  SUM(perf_sample_count) AS perf_sample_count
FROM _thread_available_info_summary
JOIN thread USING (utid)
WHERE upid IS NOT NULL
GROUP BY upid;

CREATE PERFETTO TABLE _process_available_info_summary AS
WITH r AS (
  SELECT
    upid,
    t_summary.upid as summary_upid,
    t_summary.max_running_dur AS max_running_dur,
    t_summary.sum_running_dur,
    t_summary.running_count,
    t_summary.slice_count AS thread_slice_count,
    t_summary.perf_sample_count AS perf_sample_count,
    (
      SELECT slice_count
      FROM _process_track_summary
      WHERE upid = p.upid
    ) AS process_slice_count,
    (
      SELECT allocation_count
      FROM _heap_profile_allocation_summary
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      WHERE upid = p.upid
    ) AS allocation_count,
    (
      SELECT graph_object_count
      FROM _heap_profile_graph_summary
      WHERE upid = p.upid
    ) AS graph_object_count
  FROM process p
  LEFT JOIN _thread_process_grouped_summary t_summary USING (upid)
)
SELECT
  upid,
  IFNULL(max_running_dur, 0) AS max_running_dur,
  IFNULL(sum_running_dur, 0) AS sum_running_dur,
  IFNULL(running_count, 0) AS running_count,
  IFNULL(thread_slice_count, 0) AS thread_slice_count,
  IFNULL(perf_sample_count, 0) AS perf_sample_count,
  IFNULL(process_slice_count, 0) AS process_slice_count,
  IFNULL(allocation_count, 0) AS allocation_count,
  IFNULL(graph_object_count, 0) AS graph_object_count
FROM r
WHERE
  NOT(
    r.summary_upid IS NULL
    AND process_slice_count IS NULL
    AND allocation_count IS NULL
    AND graph_object_count IS NULL
  )
  OR upid IN (SELECT upid FROM process_counter_track);

)_d3l1m1t3r_"
;

const char kVizSummarySlices[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

CREATE PERFETTO TABLE _slice_track_summary AS
SELECT
  track_id as id,
  COUNT() AS cnt,
  MIN(dur) AS min_dur,
  MAX(dur) AS max_dur,
  MAX(depth) AS max_depth
FROM slice
GROUP BY track_id;

)_d3l1m1t3r_"
;

const char kVizSummaryThreads[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE viz.summary.slices;

CREATE PERFETTO TABLE _sched_summary AS
SELECT
  utid,
  MAX(dur) AS max_running_dur,
  SUM(dur) AS sum_running_dur,
  COUNT() AS running_count
FROM sched
WHERE utid != 0 AND dur != -1
GROUP BY utid;

CREATE PERFETTO TABLE _thread_track_summary AS
SELECT utid, SUM(cnt) AS slice_count
FROM thread_track
JOIN _slice_track_summary USING (id)
GROUP BY utid;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
CREATE PERFETTO TABLE _perf_sample_summary AS
SELECT utid, count() AS perf_sample_cnt
FROM perf_sample
WHERE callsite_id IS NOT NULL
GROUP BY utid;

CREATE PERFETTO TABLE _thread_available_info_summary AS
WITH raw AS (
  SELECT
    utid,
    ss.max_running_dur,
    ss.sum_running_dur,
    ss.running_count,
    (
      SELECT slice_count
      FROM _thread_track_summary
      WHERE utid = t.utid
    ) AS slice_count,
    (
      SELECT perf_sample_cnt
      FROM _perf_sample_summary
      WHERE utid = t.utid
    ) AS perf_sample_count
  FROM thread t
  LEFT JOIN _sched_summary ss USING (utid)
)
SELECT
  utid,
  IFNULL(max_running_dur, 0) AS max_running_dur,
  IFNULL(sum_running_dur, 0) AS sum_running_dur,
  IFNULL(running_count, 0) AS running_count,
  IFNULL(slice_count, 0) AS slice_count,
  IFNULL(perf_sample_count, 0) AS perf_sample_count
FROM raw r
WHERE
  NOT (
    r.max_running_dur IS NULL
    AND r.sum_running_dur IS NULL
    AND r.running_count IS NULL
    AND r.slice_count IS NULL
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    AND r.perf_sample_count IS NULL
  )
  OR utid IN (SELECT utid FROM cpu_profile_stack_sample)
  OR utid IN (SELECT utid FROM thread_counter_track);

)_d3l1m1t3r_"
;

const char kVizSummaryTracks[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE viz.summary.slices;

CREATE PERFETTO TABLE _process_track_summary_by_upid_and_name AS
SELECT
  upid,
  name,
  GROUP_CONCAT(id) AS track_ids,
  COUNT() AS track_count
FROM process_track
JOIN _slice_track_summary USING (id)
GROUP BY upid, name;

CREATE PERFETTO TABLE _uid_track_track_summary_by_uid_and_name AS
SELECT
  uid,
  name,
  GROUP_CONCAT(id) AS track_ids,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  COUNT() AS track_count
FROM uid_track
JOIN _slice_track_summary USING (id)
GROUP BY uid, name;

)_d3l1m1t3r_"
;

const char kWattsonArmDsu[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Converts event counter from count to rate (num of accesses per ns).
CREATE PERFETTO FUNCTION _get_rate(event STRING)
RETURNS TABLE(ts LONG, dur INT, access_rate INT)
AS
SELECT
  ts,
  lead(ts) OVER (PARTITION BY track_id ORDER BY ts) - ts AS dur,
  -- Rate of event accesses in a section (i.e. count / dur).
  value / (lead(ts) OVER (PARTITION BY track_id ORDER BY ts) - ts) AS access_rate
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM counter AS c
JOIN counter_track AS t
  ON c.track_id = t.id
WHERE t.name = $event;

-- The rate of L3 misses for each time slice based on the ARM DSU PMU counter's
-- bus_access event. Units will be in number of L3 misses per ns. The number of
-- accesses in a given duration can be calculated by multiplying the appropriate
-- rate with the time in the window of interest.
CREATE PERFETTO TABLE _arm_l3_miss_rate
AS
SELECT
  ts, dur, access_rate AS l3_miss_rate
FROM _get_rate("arm_dsu_0/bus_access/_cpu0");

-- The rate of L3 accesses for each time slice based on the ARM DSU PMU
-- counter's l3d_cache event. Units will be in number of DDR accesses per ns.
-- The number of accesses in a given duration can be calculated by multiplying
-- the appropriate rate with the time in the window of interest.
CREATE PERFETTO TABLE _arm_l3_hit_rate
AS
SELECT
  ts, dur, access_rate AS l3_hit_rate
FROM _get_rate("arm_dsu_0/l3d_cache/_cpu0");


)_d3l1m1t3r_"
;

const char kWattsonCpuIdle[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE cpu.idle;
INCLUDE PERFETTO MODULE wattson.device_infos;

-- Get the corresponding deep idle time offset based on device and CPU.
CREATE PERFETTO TABLE _filtered_deep_idle_offsets
AS
SELECT cpu, offset_ns
FROM _device_cpu_deep_idle_offsets as offsets
JOIN _wattson_device as device
ON offsets.device = device.name;

-- Adjust duration of active portion to be slightly longer to account for
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- overhead cost of transitioning out of deep idle. This is done because the
-- device is active and consumes power for longer than the logs actually report.
CREATE PERFETTO TABLE _adjusted_deep_idle
AS
WITH
  idle_prev AS (
    SELECT
      ts,
      dur,
      idle,
      lag(idle) OVER (PARTITION BY track_id ORDER BY ts) AS idle_prev,
      cpu
    FROM cpu_idle_counters
  ),
  -- Adjusted ts if applicable, which makes the current deep idle state
  -- slightly shorter.
  idle_mod AS (
    SELECT
      IIF(
        idle_prev = -1 AND idle = 1,
        IIF(dur > offset_ns, ts + offset_ns, ts + dur),
        ts
      ) as ts,
      -- ts_next is the starting timestamp of the next slice (i.e. end ts of
      -- current slice)
      ts + dur as ts_next,
      cpu,
      idle
    FROM idle_prev
    JOIN _filtered_deep_idle_offsets using (cpu)
  )
SELECT
  ts,
  lead(ts, 1, trace_end()) OVER (PARTITION BY cpu ORDER by ts) - ts as dur,
  cpu,
  idle
FROM idle_mod
WHERE ts != ts_next;


)_d3l1m1t3r_"
;

const char kWattsonCpuSplit[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE cpu.freq;
INCLUDE PERFETTO MODULE time.conversion;
INCLUDE PERFETTO MODULE wattson.arm_dsu;
INCLUDE PERFETTO MODULE wattson.cpu_idle;
INCLUDE PERFETTO MODULE wattson.curves.utils;
INCLUDE PERFETTO MODULE wattson.device_infos;

CREATE PERFETTO TABLE _cpu_freq
AS
SELECT
  ts,
  dur,
  freq,
  cf.cpu,
  d_map.policy
FROM cpu_freq_counters as cf
JOIN _dev_cpu_policy_map as d_map
)_d3l1m1t3r_"
R"_d3l1m1t3r_(ON cf.cpu = d_map.cpu;

-- Combines idle and freq tables of all CPUs to create system state.
CREATE VIRTUAL TABLE _idle_freq
USING
  SPAN_OUTER_JOIN(
    _cpu_freq partitioned cpu, _adjusted_deep_idle partitioned cpu
  );

-- Add extra column indicating that frequency info are present
CREATE PERFETTO TABLE _valid_window
AS
WITH window_start AS (
  SELECT ts as start_ts
  FROM _idle_freq
  WHERE cpu = 0 and freq GLOB '*[0-9]*'
  ORDER BY ts ASC
  LIMIT 1
),
window_end AS (
  SELECT ts + dur as end_ts
  FROM cpu_freq_counters
  ORDER by ts DESC
  LIMIT 1
)
SELECT
  start_ts as ts,
  end_ts - start_ts as dur
FROM window_start, window_end;

CREATE VIRTUAL TABLE _idle_freq_filtered
USING
  SPAN_JOIN(_valid_window, _idle_freq);

-- Start matching split CPUs with curves
CREATE PERFETTO TABLE _idle_freq_materialized
AS
SELECT
  iff.ts, iff.dur, iff.cpu, iff.policy, iff.freq, iff.idle, lut.curve_value
FROM _idle_freq_filtered iff
-- Left join since some CPUs may only match the 2D LUT
LEFT JOIN _filtered_curves_1d lut ON
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  iff.policy = lut.policy AND
  iff.idle = lut.idle AND
  iff.freq = lut.freq_khz;

CREATE PERFETTO TABLE _stats_cpu0
AS
SELECT
  ts,
  dur,
  curve_value as cpu0_curve,
  freq as freq_0,
  idle as idle_0
FROM _idle_freq_materialized
WHERE cpu = 0;

CREATE PERFETTO TABLE _stats_cpu1
AS
SELECT
  ts,
  dur,
  curve_value as cpu1_curve,
  freq as freq_1,
  idle as idle_1
FROM _idle_freq_materialized
WHERE cpu = 1;

CREATE PERFETTO TABLE _stats_cpu2
AS
SELECT
  ts,
  dur,
  curve_value as cpu2_curve,
  freq as freq_2,
  idle as idle_2
FROM _idle_freq_materialized
WHERE cpu = 2;

CREATE PERFETTO TABLE _stats_cpu3
AS
SELECT
  ts,
  dur,
  curve_value as cpu3_curve,
  freq as freq_3,
  idle as idle_3
FROM _idle_freq_materialized
WHERE cpu = 3;

CREATE PERFETTO TABLE _stats_cpu4
AS
SELECT
  ts,
  dur,
  policy as policy_4,
  curve_value as cpu4_curve,
  freq as freq_4,
  idle as idle_4
FROM _idle_freq_materialized
WHERE cpu = 4;

CREATE PERFETTO TABLE _stats_cpu5
AS
SELECT
  ts,
  dur,
  policy as policy_5,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  curve_value as cpu5_curve,
  freq as freq_5,
  idle as idle_5
FROM _idle_freq_materialized
WHERE cpu = 5;

CREATE PERFETTO TABLE _stats_cpu6
AS
SELECT
  ts,
  dur,
  policy as policy_6,
  curve_value as cpu6_curve,
  freq as freq_6,
  idle as idle_6
FROM _idle_freq_materialized
WHERE cpu = 6;

CREATE PERFETTO TABLE _stats_cpu7
AS
SELECT
  ts,
  dur,
  policy as policy_7,
  curve_value as cpu7_curve,
  freq as freq_7,
  idle as idle_7
FROM _idle_freq_materialized
WHERE cpu = 7;

CREATE VIRTUAL TABLE _stats_cpu01
USING
  SPAN_OUTER_JOIN(_stats_cpu1, _stats_cpu0);

CREATE VIRTUAL TABLE _stats_cpu012
USING
  SPAN_OUTER_JOIN(_stats_cpu2, _stats_cpu01);

CREATE VIRTUAL TABLE _stats_cpu0123
USING
  SPAN_OUTER_JOIN(_stats_cpu3, _stats_cpu012);

CREATE VIRTUAL TABLE _stats_cpu01234
USING
  SPAN_OUTER_JOIN(_stats_cpu4, _stats_cpu0123);

CREATE VIRTUAL TABLE _stats_cpu012345
USING
  SPAN_OUTER_JOIN(_stats_cpu5, _stats_cpu01234);

CREATE VIRTUAL TABLE _stats_cpu0123456
USING
  SPAN_OUTER_JOIN(_stats_cpu6, _stats_cpu012345);
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
CREATE VIRTUAL TABLE _stats_cpu01234567
USING
  SPAN_OUTER_JOIN(_stats_cpu7, _stats_cpu0123456);

-- get suspend resume state as logged by ftrace.
CREATE PERFETTO TABLE _suspend_slice
AS
SELECT
  ts, dur, TRUE AS suspended
FROM slice
WHERE name GLOB "timekeeping_freeze(0)";

-- Combine suspend information with CPU idle and frequency system states.
CREATE VIRTUAL TABLE _idle_freq_suspend_slice
USING
  SPAN_OUTER_JOIN(_stats_cpu01234567, _suspend_slice);

-- Combine system state so that it has idle, freq, and L3 hit info.
CREATE VIRTUAL TABLE _idle_freq_l3_hit_slice
USING
  SPAN_OUTER_JOIN(_idle_freq_suspend_slice, _arm_l3_hit_rate);

-- Combine system state so that it has idle, freq, L3 hit, and L3 miss info.
CREATE VIRTUAL TABLE _idle_freq_l3_hit_l3_miss_slice
USING
  SPAN_OUTER_JOIN(_idle_freq_l3_hit_slice, _arm_l3_miss_rate);

)_d3l1m1t3r_"
;

const char kWattsonCurvesDevice[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Device specific device curves with 1D dependency (i.e. curve characteristics
-- are dependent only on one CPU policy). See go/wattson for more info.
CREATE PERFETTO TABLE _device_curves_1d
AS
WITH data(device, policy, freq_khz, static, active, idle0, idle1) AS (
  VALUES
  -- 255 represents static curve; needs to be same type as rest
  ("monaco", 0, 614400, 4.8, 9.41, 0.76, 0),
  ("monaco", 0, 864000, 6.68, 13.64, 0.83, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("monaco", 0, 1363200, 12.6, 24.83, 1.1, 0),
  ("monaco", 0, 1708800, 18.39, 39.69, 1.34, 0),
  ("Tensor", 4, 400000, 0, 28.51, 5.24, 0),
  ("Tensor", 4, 553000, 0, 43.63, 6.1, 0),
  ("Tensor", 4, 696000, 0, 54.73, 6.76, 0),
  ("Tensor", 4, 799000, 0, 65.01, 6.89, 0),
  ("Tensor", 4, 910000, 0, 80.33, 7.61, 0),
  ("Tensor", 4, 1024000, 0, 92.91, 8.32, 0),
  ("Tensor", 4, 1197000, 0, 132.46, 8.09, 0),
  ("Tensor", 4, 1328000, 0, 146.82, 9.6, 0),
  ("Tensor", 4, 1491000, 0, 183.2, 11.58, 0),
  ("Tensor", 4, 1663000, 0, 238.55, 12.02, 0),
  ("Tensor", 4, 1836000, 0, 259.04, 16.11, 0),
  ("Tensor", 4, 1999000, 0, 361.98, 15.7, 0),
  ("Tensor", 4, 2130000, 0, 428.51, 18.94, 0),
  ("Tensor", 4, 2253000, 0, 527.05, 23.5, 0),
  ("Tensor", 6, 500000, 0, 87.31, 16.14, 0),
  ("Tensor", 6, 851000, 0, 170.29, 19.88, 0),
  ("Tensor", 6, 984000, 0, 207.43, 20.55, 0),
  ("Tensor", 6, 1106000, 0, 251.88, 23.06, 0),
  ("Tensor", 6, 1277000, 0, 306.57, 25.12, 0),
  ("Tensor", 6, 1426000, 0, 382.61, 26.76, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 6, 1582000, 0, 465.9, 29.74, 0),
  ("Tensor", 6, 1745000, 0, 556.25, 32.87, 0),
  ("Tensor", 6, 1826000, 0, 613.51, 36.01, 0),
  ("Tensor", 6, 2048000, 0, 758.89, 41.67, 0),
  ("Tensor", 6, 2188000, 0, 874.03, 47.92, 0),
  ("Tensor", 6, 2252000, 0, 949.55, 51.07, 0),
  ("Tensor", 6, 2401000, 0, 1099.53, 57.42, 0),
  ("Tensor", 6, 2507000, 0, 1267.19, 66.14, 0),
  ("Tensor", 6, 2630000, 0, 1500.6, 82.36, 0),
  ("Tensor", 6, 2704000, 0, 1660.81, 95.11, 0),
  ("Tensor", 6, 2802000, 0, 1942.89, 121.43, 0)
)
select * from data;

-- Device specific device curves with 2D dependency (i.e. curve characteristics
-- are dependent on another CPU policy). See go/wattson for more info.
CREATE PERFETTO TABLE _device_curves_2d
AS
WITH data(device, freq_khz, other_policy, other_freq_khz, static, active, idle0, idle1)
AS (
  VALUES
  -- 255 represents static curve; needs to be same type as rest
  ("Tensor", 300000, 4, 400000, 3.73, 21.84, 0.47, 0),
  ("Tensor", 300000, 4, 553000, 5.66, 18.97, 0.99, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 300000, 6, 500000, 2.61, 22.89, 0.76, 0),
  ("Tensor", 574000, 4, 400000, 5.73, 35.85, 0.93, 0),
  ("Tensor", 574000, 4, 553000, 5.41, 36.54, 0.98, 0),
  ("Tensor", 574000, 4, 696000, 5.61, 32.98, 0.99, 0),
  ("Tensor", 574000, 4, 799000, 9.7, 40.29, 1.33, 0),
  ("Tensor", 574000, 4, 910000, 9.81, 44.42, 1.24, 0),
  ("Tensor", 574000, 4, 1024000, 9.71, 43.95, 1.31, 0),
  ("Tensor", 574000, 6, 500000, 5.6, 34.69, 1.03, 0),
  ("Tensor", 574000, 6, 851000, 5.57, 33.66, 1.02, 0),
  ("Tensor", 574000, 6, 984000, 5.68, 36.2, 0.98, 0),
  ("Tensor", 574000, 6, 1106000, 5.59, 36.27, 1.02, 0),
  ("Tensor", 738000, 4, 400000, 6.62, 47.66, 1.08, 0),
  ("Tensor", 738000, 4, 553000, 6.7, 45.71, 1.03, 0),
  ("Tensor", 738000, 4, 696000, 6.7, 46.21, 1.04, 0),
  ("Tensor", 738000, 4, 799000, 9.8, 55.47, 1.23, 0),
  ("Tensor", 738000, 4, 910000, 9.69, 52.58, 1.31, 0),
  ("Tensor", 738000, 4, 1024000, 9.77, 54.81, 1.3, 0),
  ("Tensor", 738000, 4, 1197000, 18.75, 75.3, 2.05, 0),
  ("Tensor", 738000, 4, 1328000, 18.98, 75.84, 1.91, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 738000, 6, 500000, 6.63, 44.56, 1.11, 0),
  ("Tensor", 738000, 6, 851000, 6.65, 46.62, 1.08, 0),
  ("Tensor", 738000, 6, 984000, 6.63, 50.28, 1.08, 0),
  ("Tensor", 738000, 6, 1106000, 6.74, 44.83, 1.07, 0),
  ("Tensor", 738000, 6, 1277000, 6.6, 44.15, 1.09, 0),
  ("Tensor", 738000, 6, 1426000, 18.97, 74.73, 1.94, 0),
  ("Tensor", 930000, 4, 400000, 9.64, 81.16, 1.27, 0),
  ("Tensor", 930000, 4, 553000, 9.88, 67.4, 1.28, 0),
  ("Tensor", 930000, 4, 696000, 9.69, 67.33, 1.3, 0),
  ("Tensor", 930000, 4, 799000, 9.69, 67.82, 1.3, 0),
  ("Tensor", 930000, 4, 910000, 9.79, 67.52, 1.29, 0),
  ("Tensor", 930000, 4, 1024000, 9.75, 65.44, 1.28, 0),
  ("Tensor", 930000, 4, 1197000, 18.84, 83.73, 2.0, 0),
  ("Tensor", 930000, 4, 1328000, 18.88, 101.57, 1.97, 0),
  ("Tensor", 930000, 4, 1491000, 18.86, 94.45, 1.99, 0),
  ("Tensor", 930000, 4, 1663000, 35.46, 134.93, 3.29, 0),
  ("Tensor", 930000, 4, 1836000, 35.34, 135.55, 3.36, 0),
  ("Tensor", 930000, 6, 500000, 9.76, 66.0, 1.28, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 930000, 6, 851000, 9.8, 73.08, 1.24, 0),
  ("Tensor", 930000, 6, 984000, 9.75, 74.87, 1.25, 0),
  ("Tensor", 930000, 6, 1106000, 9.68, 77.31, 1.3, 0),
  ("Tensor", 930000, 6, 1277000, 9.83, 80.03, 1.25, 0),
  ("Tensor", 930000, 6, 1426000, 19.01, 98.31, 1.94, 0),
  ("Tensor", 930000, 6, 1582000, 18.94, 94.51, 1.98, 0),
  ("Tensor", 930000, 6, 1745000, 19.0, 94.38, 1.93, 0),
  ("Tensor", 930000, 6, 1826000, 18.98, 100.84, 1.92, 0),
  ("Tensor", 1098000, 4, 400000, 12.93, 109.45, 1.47, 0),
  ("Tensor", 1098000, 4, 553000, 12.92, 120.82, 1.48, 0),
  ("Tensor", 1098000, 4, 696000, 13.09, 107.17, 1.41, 0),
  ("Tensor", 1098000, 4, 799000, 12.82, 91.84, 1.56, 0),
  ("Tensor", 1098000, 4, 910000, 12.88, 99.1, 1.52, 0),
  ("Tensor", 1098000, 4, 1024000, 12.81, 87.32, 1.57, 0),
  ("Tensor", 1098000, 4, 1197000, 18.92, 115.83, 1.97, 0),
  ("Tensor", 1098000, 4, 1328000, 18.97, 137.08, 1.93, 0),
  ("Tensor", 1098000, 4, 1491000, 18.94, 120.36, 1.94, 0),
  ("Tensor", 1098000, 4, 1663000, 35.21, 156.0, 3.43, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1098000, 4, 1836000, 35.21, 155.3, 3.42, 0),
  ("Tensor", 1098000, 4, 1999000, 35.49, 157.04, 3.24, 0),
  ("Tensor", 1098000, 4, 2130000, 35.17, 156.91, 3.41, 0),
  ("Tensor", 1098000, 6, 500000, 13.0, 93.54, 1.45, 0),
  ("Tensor", 1098000, 6, 851000, 13.12, 104.28, 1.4, 0),
  ("Tensor", 1098000, 6, 984000, 12.85, 94.73, 1.52, 0),
  ("Tensor", 1098000, 6, 1106000, 12.68, 95.73, 1.6, 0),
  ("Tensor", 1098000, 6, 1277000, 12.94, 92.78, 1.46, 0),
  ("Tensor", 1098000, 6, 1426000, 18.81, 128.5, 2.03, 0),
  ("Tensor", 1098000, 6, 1582000, 19.0, 124.51, 1.89, 0),
  ("Tensor", 1098000, 6, 1745000, 18.75, 121.84, 2.0, 0),
  ("Tensor", 1098000, 6, 1826000, 19.01, 117.69, 1.9, 0),
  ("Tensor", 1098000, 6, 2048000, 18.97, 107.49, 1.89, 0),
  ("Tensor", 1098000, 6, 2188000, 18.95, 124.24, 1.92, 0),
  ("Tensor", 1197000, 4, 400000, 14.5, 128.64, 1.54, 0),
  ("Tensor", 1197000, 4, 553000, 14.41, 126.94, 1.58, 0),
  ("Tensor", 1197000, 4, 696000, 14.43, 123.96, 1.63, 0),
  ("Tensor", 1197000, 4, 799000, 14.39, 125.32, 1.59, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1197000, 4, 910000, 14.42, 126.37, 1.55, 0),
  ("Tensor", 1197000, 4, 1024000, 14.5, 110.43, 1.54, 0),
  ("Tensor", 1197000, 4, 1197000, 19.0, 121.68, 1.9, 222.0),
  ("Tensor", 1197000, 4, 1328000, 18.88, 122.27, 1.96, 0),
  ("Tensor", 1197000, 4, 1491000, 18.84, 118.62, 1.98, 0),
  ("Tensor", 1197000, 4, 1663000, 35.35, 175.31, 3.32, 0),
  ("Tensor", 1197000, 4, 1836000, 35.37, 178.17, 3.38, 0),
  ("Tensor", 1197000, 4, 1999000, 35.34, 186.68, 3.38, 0),
  ("Tensor", 1197000, 4, 2130000, 35.37, 176.06, 3.34, 0),
  ("Tensor", 1197000, 4, 2253000, 35.29, 169.24, 3.38, 111.0),
  ("Tensor", 1197000, 6, 500000, 14.47, 95.77, 1.55, 0),
  ("Tensor", 1197000, 6, 851000, 14.42, 101.17, 1.6, 0),
  ("Tensor", 1197000, 6, 984000, 14.21, 116.52, 1.68, 0),
  ("Tensor", 1197000, 6, 1106000, 14.32, 111.16, 1.62, 0),
  ("Tensor", 1197000, 6, 1277000, 14.42, 84.46, 1.6, 0),
  ("Tensor", 1197000, 6, 1426000, 18.83, 130.44, 2.01, 0),
  ("Tensor", 1197000, 6, 1582000, 18.98, 140.9, 1.9, 0),
  ("Tensor", 1197000, 6, 1745000, 18.82, 143.87, 1.94, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1197000, 6, 1826000, 18.91, 131.75, 1.96, 0),
  ("Tensor", 1197000, 6, 2048000, 18.99, 128.36, 1.96, 0),
  ("Tensor", 1197000, 6, 2188000, 18.71, 132.46, 2.07, 0),
  ("Tensor", 1197000, 6, 2252000, 18.82, 130.95, 2.0, 0),
  ("Tensor", 1328000, 4, 400000, 17.0, 135.89, 1.84, 0),
  ("Tensor", 1328000, 4, 553000, 17.1, 161.84, 1.78, 0),
  ("Tensor", 1328000, 4, 696000, 16.99, 142.03, 1.87, 0),
  ("Tensor", 1328000, 4, 799000, 17.07, 169.36, 1.83, 0),
  ("Tensor", 1328000, 4, 910000, 17.19, 111.73, 1.81, 0),
  ("Tensor", 1328000, 4, 1024000, 17.21, 128.66, 1.78, 0),
  ("Tensor", 1328000, 4, 1197000, 18.83, 129.66, 2.02, 0),
  ("Tensor", 1328000, 4, 1328000, 18.88, 132.55, 1.96, 0),
  ("Tensor", 1328000, 4, 1491000, 18.87, 146.14, 2.0, 0),
  ("Tensor", 1328000, 4, 1663000, 35.43, 185.94, 3.27, 0),
  ("Tensor", 1328000, 4, 1836000, 35.46, 165.55, 3.27, 0),
  ("Tensor", 1328000, 4, 1999000, 35.37, 186.76, 3.29, 0),
  ("Tensor", 1328000, 4, 2130000, 35.35, 207.2, 3.34, 0),
  ("Tensor", 1328000, 4, 2253000, 35.31, 209.73, 3.42, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1328000, 6, 500000, 17.15, 130.76, 1.77, 0),
  ("Tensor", 1328000, 6, 851000, 17.06, 123.6, 1.84, 0),
  ("Tensor", 1328000, 6, 984000, 17.21, 130.23, 1.77, 0),
  ("Tensor", 1328000, 6, 1106000, 17.16, 139.65, 1.84, 0),
  ("Tensor", 1328000, 6, 1277000, 17.14, 123.95, 1.83, 0),
  ("Tensor", 1328000, 6, 1426000, 19.15, 141.04, 1.91, 0),
  ("Tensor", 1328000, 6, 1582000, 19.13, 108.29, 1.91, 0),
  ("Tensor", 1328000, 6, 1745000, 19.12, 133.38, 1.9, 0),
  ("Tensor", 1328000, 6, 1826000, 18.87, 137.51, 2.06, 0),
  ("Tensor", 1328000, 6, 2048000, 19.02, 145.9, 1.96, 0),
  ("Tensor", 1328000, 6, 2188000, 19.06, 129.5, 1.94, 0),
  ("Tensor", 1328000, 6, 2252000, 19.05, 125.72, 1.91, 0),
  ("Tensor", 1328000, 6, 2401000, 35.57, 187.29, 3.33, 0),
  ("Tensor", 1328000, 6, 2507000, 35.38, 213.14, 3.44, 0),
  ("Tensor", 1328000, 6, 2630000, 35.47, 181.15, 3.41, 0),
  ("Tensor", 1401000, 4, 400000, 18.85, 184.12, 2.06, 0),
  ("Tensor", 1401000, 4, 553000, 18.91, 168.23, 1.98, 0),
  ("Tensor", 1401000, 4, 696000, 19.11, 184.69, 1.92, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1401000, 4, 799000, 19.16, 175.13, 1.91, 0),
  ("Tensor", 1401000, 4, 910000, 19.02, 161.7, 1.97, 0),
  ("Tensor", 1401000, 4, 1024000, 18.97, 156.68, 2.01, 0),
  ("Tensor", 1401000, 4, 1197000, 19.07, 155.0, 1.97, 0),
  ("Tensor", 1401000, 4, 1328000, 18.95, 159.64, 1.96, 0),
  ("Tensor", 1401000, 4, 1491000, 19.13, 136.78, 1.95, 0),
  ("Tensor", 1401000, 4, 1663000, 35.67, 186.73, 3.29, 0),
  ("Tensor", 1401000, 4, 1836000, 35.51, 220.26, 3.45, 0),
  ("Tensor", 1401000, 4, 1999000, 35.75, 249.18, 3.3, 0),
  ("Tensor", 1401000, 4, 2130000, 35.65, 217.48, 3.4, 0),
  ("Tensor", 1401000, 4, 2253000, 35.66, 248.9, 3.41, 0),
  ("Tensor", 1401000, 6, 500000, 19.05, 152.39, 1.98, 0),
  ("Tensor", 1401000, 6, 851000, 19.0, 148.12, 2.03, 0),
  ("Tensor", 1401000, 6, 984000, 19.01, 128.71, 2.0, 0),
  ("Tensor", 1401000, 6, 1106000, 18.18, 132.83, 2.01, 0),
  ("Tensor", 1401000, 6, 1277000, 19.07, 138.09, 1.95, 0),
  ("Tensor", 1401000, 6, 1426000, 18.92, 144.69, 2.05, 0),
  ("Tensor", 1401000, 6, 1582000, 18.95, 151.34, 2.05, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1401000, 6, 1745000, 18.98, 152.04, 2.01, 0),
  ("Tensor", 1401000, 6, 1826000, 19.11, 151.71, 1.95, 0),
  ("Tensor", 1401000, 6, 2048000, 19.04, 136.69, 1.98, 0),
  ("Tensor", 1401000, 6, 2188000, 18.97, 152.56, 2.0, 0),
  ("Tensor", 1401000, 6, 2252000, 19.09, 149.02, 1.97, 0),
  ("Tensor", 1401000, 6, 2401000, 35.91, 210.3, 3.23, 0),
  ("Tensor", 1401000, 6, 2507000, 35.64, 188.64, 3.32, 0),
  ("Tensor", 1401000, 6, 2630000, 35.41, 202.75, 3.5, 0),
  ("Tensor", 1401000, 6, 2704000, 35.69, 204.49, 3.4, 0),
  ("Tensor", 1401000, 6, 2802000, 35.64, 208.14, 3.45, 0),
  ("Tensor", 1598000, 4, 400000, 24.83, 196.05, 2.36, 0),
  ("Tensor", 1598000, 4, 553000, 24.68, 234.53, 2.37, 0),
  ("Tensor", 1598000, 4, 696000, 24.71, 230.15, 2.34, 0),
  ("Tensor", 1598000, 4, 799000, 24.87, 175.64, 2.34, 0),
  ("Tensor", 1598000, 4, 910000, 24.76, 228.23, 2.36, 0),
  ("Tensor", 1598000, 4, 1024000, 24.6, 228.37, 2.47, 0),
  ("Tensor", 1598000, 4, 1197000, 24.77, 201.12, 2.43, 0),
  ("Tensor", 1598000, 4, 1328000, 24.68, 202.37, 2.41, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1598000, 4, 1491000, 24.58, 199.78, 2.52, 0),
  ("Tensor", 1598000, 4, 1663000, 35.59, 210.2, 3.46, 0),
  ("Tensor", 1598000, 4, 1836000, 35.74, 315.02, 3.33, 0),
  ("Tensor", 1598000, 4, 1999000, 35.65, 285.37, 3.44, 0),
  ("Tensor", 1598000, 4, 2130000, 35.31, 256.84, 3.7, 0),
  ("Tensor", 1598000, 4, 2253000, 35.91, 255.65, 3.37, 0),
  ("Tensor", 1598000, 6, 500000, 24.78, 184.21, 2.34, 0),
  ("Tensor", 1598000, 6, 851000, 24.73, 175.69, 2.41, 0),
  ("Tensor", 1598000, 6, 984000, 24.68, 195.14, 2.43, 0),
  ("Tensor", 1598000, 6, 1106000, 24.65, 194.89, 2.46, 0),
  ("Tensor", 1598000, 6, 1277000, 24.63, 167.1, 2.49, 0),
  ("Tensor", 1598000, 6, 1426000, 24.7, 190.42, 2.45, 0),
  ("Tensor", 1598000, 6, 1582000, 24.79, 190.72, 2.39, 0),
  ("Tensor", 1598000, 6, 1745000, 24.73, 180.52, 2.44, 0),
  ("Tensor", 1598000, 6, 1826000, 24.72, 203.15, 2.4, 0),
  ("Tensor", 1598000, 6, 2048000, 24.82, 197.7, 2.39, 0),
  ("Tensor", 1598000, 6, 2188000, 24.7, 185.45, 2.47, 0),
  ("Tensor", 1598000, 6, 2252000, 24.83, 155.38, 2.35, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1598000, 6, 2401000, 36.0, 237.12, 3.25, 0),
  ("Tensor", 1598000, 6, 2507000, 35.89, 253.55, 3.34, 0),
  ("Tensor", 1598000, 6, 2630000, 35.76, 208.38, 3.45, 0),
  ("Tensor", 1598000, 6, 2704000, 35.7, 218.73, 3.46, 0),
  ("Tensor", 1598000, 6, 2802000, 35.65, 248.51, 3.47, 0),
  ("Tensor", 1704000, 4, 400000, 28.98, 234.84, 2.73, 0),
  ("Tensor", 1704000, 4, 553000, 29.01, 210.31, 2.66, 0),
  ("Tensor", 1704000, 4, 696000, 28.95, 300.74, 2.73, 0),
  ("Tensor", 1704000, 4, 799000, 28.77, 270.96, 2.79, 0),
  ("Tensor", 1704000, 4, 910000, 28.84, 284.84, 2.76, 0),
  ("Tensor", 1704000, 4, 1024000, 28.76, 251.86, 2.85, 0),
  ("Tensor", 1704000, 4, 1197000, 28.75, 256.3, 2.78, 0),
  ("Tensor", 1704000, 4, 1328000, 28.65, 246.88, 2.86, 0),
  ("Tensor", 1704000, 4, 1491000, 28.73, 267.07, 2.88, 0),
  ("Tensor", 1704000, 4, 1663000, 35.81, 266.03, 3.49, 0),
  ("Tensor", 1704000, 4, 1836000, 35.78, 274.06, 3.35, 0),
  ("Tensor", 1704000, 4, 1999000, 35.67, 268.14, 3.46, 0),
  ("Tensor", 1704000, 4, 2130000, 35.75, 273.4, 3.41, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1704000, 4, 2253000, 35.42, 276.92, 3.72, 0),
  ("Tensor", 1704000, 6, 500000, 29.1, 239.74, 2.65, 0),
  ("Tensor", 1704000, 6, 851000, 28.79, 216.53, 2.74, 0),
  ("Tensor", 1704000, 6, 984000, 28.9, 259.03, 2.76, 0),
  ("Tensor", 1704000, 6, 1106000, 28.71, 211.76, 2.82, 0),
  ("Tensor", 1704000, 6, 1277000, 28.79, 216.77, 2.8, 0),
  ("Tensor", 1704000, 6, 1426000, 28.94, 207.8, 2.71, 0),
  ("Tensor", 1704000, 6, 1582000, 28.96, 232.83, 2.67, 0),
  ("Tensor", 1704000, 6, 1745000, 28.67, 237.37, 2.85, 0),
  ("Tensor", 1704000, 6, 1826000, 29.0, 224.71, 2.71, 0),
  ("Tensor", 1704000, 6, 2048000, 28.86, 239.69, 2.73, 0),
  ("Tensor", 1704000, 6, 2188000, 28.88, 218.8, 2.76, 0),
  ("Tensor", 1704000, 6, 2252000, 28.87, 272.23, 2.76, 0),
  ("Tensor", 1704000, 6, 2401000, 35.74, 258.98, 3.33, 0),
  ("Tensor", 1704000, 6, 2507000, 35.74, 276.92, 3.4, 0),
  ("Tensor", 1704000, 6, 2630000, 35.71, 249.7, 3.45, 0),
  ("Tensor", 1704000, 6, 2704000, 36.01, 253.04, 3.29, 0),
  ("Tensor", 1704000, 6, 2802000, 35.91, 266.15, 3.4, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1803000, 4, 400000, 35.71, 342.95, 3.49, 0),
  ("Tensor", 1803000, 4, 553000, 35.76, 330.57, 3.41, 0),
  ("Tensor", 1803000, 4, 696000, 35.71, 355.0, 3.41, 0),
  ("Tensor", 1803000, 4, 799000, 35.67, 310.42, 3.45, 0),
  ("Tensor", 1803000, 4, 910000, 35.95, 309.22, 3.38, 0),
  ("Tensor", 1803000, 4, 1024000, 35.6, 303.94, 3.55, 0),
  ("Tensor", 1803000, 4, 1197000, 36.0, 346.31, 3.26, 0),
  ("Tensor", 1803000, 4, 1328000, 35.9, 300.16, 3.36, 0),
  ("Tensor", 1803000, 4, 1491000, 35.88, 215.33, 3.33, 0),
  ("Tensor", 1803000, 4, 1663000, 35.72, 284.35, 3.47, 0),
  ("Tensor", 1803000, 4, 1836000, 35.9, 289.0, 3.32, 0),
  ("Tensor", 1803000, 4, 1999000, 34.96, 293.38, 3.33, 0),
  ("Tensor", 1803000, 4, 2130000, 35.07, 359.86, 3.19, 0),
  ("Tensor", 1803000, 4, 2253000, 35.07, 295.24, 3.23, 0),
  ("Tensor", 1803000, 6, 500000, 34.68, 223.89, 3.4, 0),
  ("Tensor", 1803000, 6, 851000, 34.74, 261.39, 3.4, 0),
  ("Tensor", 1803000, 6, 984000, 35.08, 269.51, 3.26, 0),
  ("Tensor", 1803000, 6, 1106000, 35.06, 269.58, 3.21, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1803000, 6, 1277000, 34.87, 218.3, 3.39, 0),
  ("Tensor", 1803000, 6, 1426000, 34.86, 264.34, 3.36, 0),
  ("Tensor", 1803000, 6, 1582000, 34.9, 263.56, 3.36, 0),
  ("Tensor", 1803000, 6, 1745000, 35.09, 210.36, 3.29, 0),
  ("Tensor", 1803000, 6, 1826000, 35.06, 256.1, 3.34, 0),
  ("Tensor", 1803000, 6, 2048000, 35.18, 269.91, 3.16, 0),
  ("Tensor", 1803000, 6, 2188000, 35.16, 261.04, 3.25, 0),
  ("Tensor", 1803000, 6, 2252000, 34.84, 272.92, 3.49, 0),
  ("Tensor", 1803000, 6, 2401000, 35.2, 260.24, 3.38, 0),
  ("Tensor", 1803000, 6, 2507000, 34.89, 240.7, 3.58, 0),
  ("Tensor", 1803000, 6, 2630000, 35.21, 150.76, 3.42, 0),
  ("Tensor", 1803000, 6, 2704000, 35.2, 277.28, 3.44, 0),
  ("Tensor", 1803000, 6, 2802000, 35.12, 269.2, 3.62, 0)
)
select * from data;

CREATE PERFETTO TABLE _device_curves_l3
AS
WITH data(device, freq_khz, other_policy, other_freq_khz, l3_hit, l3_miss) AS (
  VALUES
  ("Tensor", 300000, 4, 400000, 0.3989, 0.0629),
  ("Tensor", 300000, 4, 553000, 0.4119, 0.0656),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 300000, 6, 500000, 0.3298, 0.1029),
  ("Tensor", 574000, 4, 400000, 0.4894, 0.0239),
  ("Tensor", 574000, 4, 553000, 0.4991, 0.0960),
  ("Tensor", 574000, 4, 696000, 0.4949, 0.0971),
  ("Tensor", 574000, 4, 799000, 0.6116, 0.1266),
  ("Tensor", 574000, 4, 910000, 0.5897, 0.1385),
  ("Tensor", 574000, 4, 1024000, 0.5619, 0.0635),
  ("Tensor", 574000, 6, 500000, 0.5377, 0.1210),
  ("Tensor", 574000, 6, 851000, 0.5271, 0.1591),
  ("Tensor", 574000, 6, 984000, 0.5395, 0.1599),
  ("Tensor", 574000, 6, 1106000, 0.5552, 0.1393),
  ("Tensor", 738000, 4, 400000, 0.5825, 0.1271),
  ("Tensor", 738000, 4, 553000, 0.5751, 0.0396),
  ("Tensor", 738000, 4, 696000, 0.6433, 0.1050),
  ("Tensor", 738000, 4, 799000, 0.6401, 0.1293),
  ("Tensor", 738000, 4, 910000, 0.7069, 0.1252),
  ("Tensor", 738000, 4, 1024000, 0.6999, 0.1143),
  ("Tensor", 738000, 4, 1197000, 0.9076, 0.1960),
  ("Tensor", 738000, 4, 1328000, 0.9708, 0.1953),
  ("Tensor", 738000, 6, 500000, 0.6437, 0.2086),
  ("Tensor", 738000, 6, 851000, 0.6274, 0.1852),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 738000, 6, 984000, 0.6231, 0.2066),
  ("Tensor", 738000, 6, 1106000, 0.6256, 0.2199),
  ("Tensor", 738000, 6, 1277000, 0.6719, 0.2485),
  ("Tensor", 738000, 6, 1426000, 1.1072, 0.3483),
  ("Tensor", 930000, 4, 400000, 0.7812, 0.1727),
  ("Tensor", 930000, 4, 553000, 0.7343, 0.1846),
  ("Tensor", 930000, 4, 696000, 0.7551, 0.2006),
  ("Tensor", 930000, 4, 799000, 0.7330, 0.1864),
  ("Tensor", 930000, 4, 910000, 0.8250, 0.1451),
  ("Tensor", 930000, 4, 1024000, 0.7331, 0.2092),
  ("Tensor", 930000, 4, 1197000, 1.0791, 0.4804),
  ("Tensor", 930000, 4, 1328000, 1.0172, 0.0844),
  ("Tensor", 930000, 4, 1491000, 1.0396, 0.2614),
  ("Tensor", 930000, 4, 1663000, 1.6492, 0.3497),
  ("Tensor", 930000, 4, 1836000, 1.5561, 0.3407),
  ("Tensor", 930000, 6, 500000, 0.8530, 0.4182),
  ("Tensor", 930000, 6, 851000, 0.8694, 0.2854),
  ("Tensor", 930000, 6, 984000, 0.8620, 0.2568),
  ("Tensor", 930000, 6, 1106000, 0.8763, 0.2336),
  ("Tensor", 930000, 6, 1277000, 0.8717, 0.3756),
  ("Tensor", 930000, 6, 1426000, 1.1774, 0.5021),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 930000, 6, 1582000, 1.1264, 0.5799),
  ("Tensor", 930000, 6, 1745000, 1.2303, 0.5421),
  ("Tensor", 930000, 6, 1826000, 1.2330, 0.4498),
  ("Tensor", 1098000, 4, 400000, 0.9744, 0.2106),
  ("Tensor", 1098000, 4, 553000, 0.9980, 0.0500),
  ("Tensor", 1098000, 4, 696000, 0.9500, 0.1928),
  ("Tensor", 1098000, 4, 799000, 0.9132, 0.2391),
  ("Tensor", 1098000, 4, 910000, 0.9922, 0.2576),
  ("Tensor", 1098000, 4, 1024000, 0.9607, 0.2397),
  ("Tensor", 1098000, 4, 1197000, 1.1253, 0.6195),
  ("Tensor", 1098000, 4, 1328000, 1.1609, 0.0960),
  ("Tensor", 1098000, 4, 1491000, 1.1783, 0.0851),
  ("Tensor", 1098000, 4, 1663000, 1.6941, 0.4295),
  ("Tensor", 1098000, 4, 1836000, 1.7152, 0.4610),
  ("Tensor", 1098000, 4, 1999000, 1.7941, 0.4293),
  ("Tensor", 1098000, 4, 2130000, 1.6758, 0.4437),
  ("Tensor", 1098000, 6, 500000, 1.0485, 0.4038),
  ("Tensor", 1098000, 6, 851000, 1.0510, 0.2815),
  ("Tensor", 1098000, 6, 984000, 1.0785, 0.4137),
  ("Tensor", 1098000, 6, 1106000, 1.0909, 0.3933),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1098000, 6, 1277000, 1.1533, 0.3811),
  ("Tensor", 1098000, 6, 1426000, 1.2718, 0.3814),
  ("Tensor", 1098000, 6, 1582000, 1.3463, 0.4100),
  ("Tensor", 1098000, 6, 1745000, 1.3065, 0.5207),
  ("Tensor", 1098000, 6, 1826000, 1.3456, 0.4903),
  ("Tensor", 1098000, 6, 2048000, 1.3466, 0.7218),
  ("Tensor", 1098000, 6, 2188000, 1.3132, 0.4923),
  ("Tensor", 1197000, 4, 400000, 1.0507, 0.2411),
  ("Tensor", 1197000, 4, 553000, 1.0387, 0.2875),
  ("Tensor", 1197000, 4, 696000, 1.0173, 0.2232),
  ("Tensor", 1197000, 4, 799000, 1.0160, 0.2418),
  ("Tensor", 1197000, 4, 910000, 1.0555, 0.0966),
  ("Tensor", 1197000, 4, 1024000, 1.0663, 0.0987),
  ("Tensor", 1197000, 4, 1197000, 1.1885, 0.2852),
  ("Tensor", 1197000, 4, 1328000, 1.2442, 0.2724),
  ("Tensor", 1197000, 4, 1491000, 1.2474, 0.3269),
  ("Tensor", 1197000, 4, 1663000, 1.8142, 0.3429),
  ("Tensor", 1197000, 4, 1836000, 1.7692, 1.0737),
  ("Tensor", 1197000, 4, 1999000, 1.7939, 0.1120),
  ("Tensor", 1197000, 4, 2130000, 1.8126, 0.3744),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1197000, 4, 2253000, 1.7413, 0.5198),
  ("Tensor", 1197000, 6, 500000, 1.1288, 0.6817),
  ("Tensor", 1197000, 6, 851000, 1.1779, 0.5681),
  ("Tensor", 1197000, 6, 984000, 1.1835, 0.3389),
  ("Tensor", 1197000, 6, 1106000, 1.2115, 0.4506),
  ("Tensor", 1197000, 6, 1277000, 1.1726, 0.8719),
  ("Tensor", 1197000, 6, 1426000, 1.3825, 0.5140),
  ("Tensor", 1197000, 6, 1582000, 1.4179, 0.3585),
  ("Tensor", 1197000, 6, 1745000, 1.3804, 0.3197),
  ("Tensor", 1197000, 6, 1826000, 1.3379, 0.5614),
  ("Tensor", 1197000, 6, 2048000, 1.3335, 0.5443),
  ("Tensor", 1197000, 6, 2188000, 1.4382, 0.5255),
  ("Tensor", 1197000, 6, 2252000, 1.3961, 0.5423),
  ("Tensor", 1328000, 4, 400000, 1.2307, 0.5565),
  ("Tensor", 1328000, 4, 553000, 1.2186, 0.2366),
  ("Tensor", 1328000, 4, 696000, 1.2243, 0.4145),
  ("Tensor", 1328000, 4, 799000, 1.2620, 0.0973),
  ("Tensor", 1328000, 4, 910000, 1.2462, 0.5669),
  ("Tensor", 1328000, 4, 1024000, 1.2787, 0.2332),
  ("Tensor", 1328000, 4, 1197000, 1.4364, 0.3260),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1328000, 4, 1328000, 1.3636, 0.3354),
  ("Tensor", 1328000, 4, 1491000, 1.3733, 0.0512),
  ("Tensor", 1328000, 4, 1663000, 1.9295, 0.4588),
  ("Tensor", 1328000, 4, 1836000, 1.8278, 0.9316),
  ("Tensor", 1328000, 4, 1999000, 1.9043, 0.4921),
  ("Tensor", 1328000, 4, 2130000, 1.9144, 0.1139),
  ("Tensor", 1328000, 4, 2253000, 1.9550, 0.0603),
  ("Tensor", 1328000, 6, 500000, 1.3772, 0.5737),
  ("Tensor", 1328000, 6, 851000, 1.3985, 0.6368),
  ("Tensor", 1328000, 6, 984000, 1.3933, 0.5311),
  ("Tensor", 1328000, 6, 1106000, 1.3932, 0.4567),
  ("Tensor", 1328000, 6, 1277000, 1.3984, 0.6616),
  ("Tensor", 1328000, 6, 1426000, 1.5067, 0.5776),
  ("Tensor", 1328000, 6, 1582000, 1.5167, 1.0309),
  ("Tensor", 1328000, 6, 1745000, 1.5021, 0.6845),
  ("Tensor", 1328000, 6, 1826000, 1.4775, 0.6285),
  ("Tensor", 1328000, 6, 2048000, 1.5237, 0.5402),
  ("Tensor", 1328000, 6, 2188000, 1.5349, 0.7490),
  ("Tensor", 1328000, 6, 2252000, 1.5436, 0.7984),
  ("Tensor", 1328000, 6, 2401000, 2.1755, 1.0387),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1328000, 6, 2507000, 2.2320, 0.7382),
  ("Tensor", 1328000, 6, 2630000, 2.2489, 1.1762),
  ("Tensor", 1401000, 4, 400000, 1.3279, 0.2793),
  ("Tensor", 1401000, 4, 553000, 1.3065, 0.3853),
  ("Tensor", 1401000, 4, 696000, 1.3290, 0.3016),
  ("Tensor", 1401000, 4, 799000, 1.2483, 0.3683),
  ("Tensor", 1401000, 4, 910000, 1.4059, 0.2825),
  ("Tensor", 1401000, 4, 1024000, 1.3702, 0.3389),
  ("Tensor", 1401000, 4, 1197000, 1.3920, 0.3614),
  ("Tensor", 1401000, 4, 1328000, 1.3752, 0.3310),
  ("Tensor", 1401000, 4, 1491000, 1.4015, 0.6546),
  ("Tensor", 1401000, 4, 1663000, 1.8982, 1.0324),
  ("Tensor", 1401000, 4, 1836000, 1.9447, 0.5336),
  ("Tensor", 1401000, 4, 1999000, 2.1219, 0.0662),
  ("Tensor", 1401000, 4, 2130000, 1.9576, 0.5584),
  ("Tensor", 1401000, 4, 2253000, 2.0221, 0.1254),
  ("Tensor", 1401000, 6, 500000, 1.5283, 0.5764),
  ("Tensor", 1401000, 6, 851000, 1.5211, 0.5643),
  ("Tensor", 1401000, 6, 984000, 1.5574, 0.7558),
  ("Tensor", 1401000, 6, 1106000, 1.5492, 0.7862),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1401000, 6, 1277000, 1.5389, 0.7523),
  ("Tensor", 1401000, 6, 1426000, 1.6449, 0.5993),
  ("Tensor", 1401000, 6, 1582000, 1.5953, 0.5512),
  ("Tensor", 1401000, 6, 1745000, 1.5672, 0.5489),
  ("Tensor", 1401000, 6, 1826000, 1.5639, 0.5507),
  ("Tensor", 1401000, 6, 2048000, 1.5878, 0.7536),
  ("Tensor", 1401000, 6, 2188000, 1.5562, 0.5431),
  ("Tensor", 1401000, 6, 2252000, 1.5908, 0.6087),
  ("Tensor", 1401000, 6, 2401000, 2.2693, 0.8953),
  ("Tensor", 1401000, 6, 2507000, 2.3182, 1.2289),
  ("Tensor", 1401000, 6, 2630000, 2.3090, 1.0687),
  ("Tensor", 1401000, 6, 2704000, 2.2751, 0.9966),
  ("Tensor", 1401000, 6, 2802000, 2.3278, 0.9065),
  ("Tensor", 1598000, 4, 400000, 1.7424, 0.8926),
  ("Tensor", 1598000, 4, 553000, 1.7003, 0.4482),
  ("Tensor", 1598000, 4, 696000, 1.6099, 0.5281),
  ("Tensor", 1598000, 4, 799000, 1.8018, 0.9634),
  ("Tensor", 1598000, 4, 910000, 1.7615, 0.3445),
  ("Tensor", 1598000, 4, 1024000, 1.7317, 0.3396),
  ("Tensor", 1598000, 4, 1197000, 1.7293, 0.5079),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1598000, 4, 1328000, 1.8771, 0.4685),
  ("Tensor", 1598000, 4, 1491000, 1.8724, 0.4693),
  ("Tensor", 1598000, 4, 1663000, 1.9587, 1.2295),
  ("Tensor", 1598000, 4, 1836000, 2.2287, 0.5220),
  ("Tensor", 1598000, 4, 1999000, 2.1786, 0.1494),
  ("Tensor", 1598000, 4, 2130000, 2.1631, 0.4924),
  ("Tensor", 1598000, 4, 2253000, 2.1703, 0.5427),
  ("Tensor", 1598000, 6, 500000, 1.9632, 0.9534),
  ("Tensor", 1598000, 6, 851000, 1.9820, 0.9433),
  ("Tensor", 1598000, 6, 984000, 1.9745, 0.8002),
  ("Tensor", 1598000, 6, 1106000, 1.9514, 0.8323),
  ("Tensor", 1598000, 6, 1277000, 1.9796, 1.1016),
  ("Tensor", 1598000, 6, 1426000, 1.9432, 0.8556),
  ("Tensor", 1598000, 6, 1582000, 2.0700, 0.8211),
  ("Tensor", 1598000, 6, 1745000, 2.0052, 0.9492),
  ("Tensor", 1598000, 6, 1826000, 2.0165, 0.7016),
  ("Tensor", 1598000, 6, 2048000, 2.0881, 0.6641),
  ("Tensor", 1598000, 6, 2188000, 2.1239, 0.8702),
  ("Tensor", 1598000, 6, 2252000, 2.0952, 1.1728),
  ("Tensor", 1598000, 6, 2401000, 2.4810, 0.9498),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1598000, 6, 2507000, 2.4644, 0.9131),
  ("Tensor", 1598000, 6, 2630000, 2.4030, 1.3728),
  ("Tensor", 1598000, 6, 2704000, 2.4271, 1.2680),
  ("Tensor", 1598000, 6, 2802000, 2.4761, 0.9789),
  ("Tensor", 1704000, 4, 400000, 1.9466, 0.9753),
  ("Tensor", 1704000, 4, 553000, 1.9336, 1.0846),
  ("Tensor", 1704000, 4, 696000, 1.9280, 0.2116),
  ("Tensor", 1704000, 4, 799000, 1.9616, 0.4219),
  ("Tensor", 1704000, 4, 910000, 1.9627, 0.1957),
  ("Tensor", 1704000, 4, 1024000, 1.9763, 0.5599),
  ("Tensor", 1704000, 4, 1197000, 1.9514, 0.4326),
  ("Tensor", 1704000, 4, 1328000, 2.0093, 0.4861),
  ("Tensor", 1704000, 4, 1491000, 1.9438, 0.1584),
  ("Tensor", 1704000, 4, 1663000, 2.3012, 0.6019),
  ("Tensor", 1704000, 4, 1836000, 2.2896, 0.5019),
  ("Tensor", 1704000, 4, 1999000, 2.2292, 0.6076),
  ("Tensor", 1704000, 4, 2130000, 2.2087, 0.5726),
  ("Tensor", 1704000, 4, 2253000, 2.2317, 0.4878),
  ("Tensor", 1704000, 6, 500000, 2.3606, 0.7822),
  ("Tensor", 1704000, 6, 851000, 2.2564, 0.9656),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1704000, 6, 984000, 2.2618, 0.9988),
  ("Tensor", 1704000, 6, 1106000, 2.2796, 0.9681),
  ("Tensor", 1704000, 6, 1277000, 2.2224, 0.8812),
  ("Tensor", 1704000, 6, 1426000, 2.2368, 1.0353),
  ("Tensor", 1704000, 6, 1582000, 2.3125, 0.8402),
  ("Tensor", 1704000, 6, 1745000, 2.3199, 0.7728),
  ("Tensor", 1704000, 6, 1826000, 2.3633, 0.8597),
  ("Tensor", 1704000, 6, 2048000, 2.2779, 0.6885),
  ("Tensor", 1704000, 6, 2188000, 2.2575, 1.0289),
  ("Tensor", 1704000, 6, 2252000, 2.2798, 0.9689),
  ("Tensor", 1704000, 6, 2401000, 2.5202, 1.0626),
  ("Tensor", 1704000, 6, 2507000, 2.4070, 0.8463),
  ("Tensor", 1704000, 6, 2630000, 2.5998, 1.0795),
  ("Tensor", 1704000, 6, 2704000, 2.6273, 1.0329),
  ("Tensor", 1704000, 6, 2802000, 2.6179, 0.7569),
  ("Tensor", 1803000, 4, 400000, 2.2197, 0.4673),
  ("Tensor", 1803000, 4, 553000, 2.3144, 0.5120),
  ("Tensor", 1803000, 4, 696000, 2.2720, 0.1952),
  ("Tensor", 1803000, 4, 799000, 2.3472, 0.5479),
  ("Tensor", 1803000, 4, 910000, 2.3035, 0.5622),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1803000, 4, 1024000, 2.2129, 0.6828),
  ("Tensor", 1803000, 4, 1197000, 2.3176, 0.1645),
  ("Tensor", 1803000, 4, 1328000, 2.3127, 0.4992),
  ("Tensor", 1803000, 4, 1491000, 2.1449, 1.4705),
  ("Tensor", 1803000, 4, 1663000, 2.3243, 0.6256),
  ("Tensor", 1803000, 4, 1836000, 2.1328, 0.6293),
  ("Tensor", 1803000, 4, 1999000, 2.3165, 0.5265),
  ("Tensor", 1803000, 4, 2130000, 2.2775, 0.6412),
  ("Tensor", 1803000, 4, 2253000, 2.4124, 0.5151),
  ("Tensor", 1803000, 6, 500000, 2.5536, 1.5678),
  ("Tensor", 1803000, 6, 851000, 2.5831, 1.1737),
  ("Tensor", 1803000, 6, 984000, 2.6063, 1.0591),
  ("Tensor", 1803000, 6, 1106000, 2.6951, 0.9158),
  ("Tensor", 1803000, 6, 1277000, 2.5400, 1.5096),
  ("Tensor", 1803000, 6, 1426000, 2.6623, 1.1037),
  ("Tensor", 1803000, 6, 1582000, 2.6996, 1.0774),
  ("Tensor", 1803000, 6, 1745000, 2.6692, 1.6543),
  ("Tensor", 1803000, 6, 1826000, 2.7288, 1.1255),
  ("Tensor", 1803000, 6, 2048000, 2.6649, 1.1010),
  ("Tensor", 1803000, 6, 2188000, 2.6489, 1.1485),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1803000, 6, 2252000, 2.6389, 1.0942),
  ("Tensor", 1803000, 6, 2401000, 2.6256, 1.0997),
  ("Tensor", 1803000, 6, 2507000, 2.6630, 1.2641),
  ("Tensor", 1803000, 6, 2630000, 2.7385, 2.3263),
  ("Tensor", 1803000, 6, 2704000, 2.6901, 1.0629),
  ("Tensor", 1803000, 6, 2802000, 2.7476, 1.0673)
)
select * from data;


)_d3l1m1t3r_"
;

const char kWattsonCurvesGrouped[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE wattson.curves.ungrouped;

-- Wattson's estimated usage of the system, split out into cpu cluster based on
-- the natural grouping of the hardware.
CREATE PERFETTO TABLE wattson_estimate_per_component(
  -- Starting timestamp of the slice
  ts LONG,
  -- Duration of the slice
  dur INT,
  -- Total L3 estimated usage in mW during this slice
  l3 FLOAT,
  -- Total little CPU estimated usage in mW during this slice
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  little_cpus FLOAT,
  -- Total mid CPU cluster estimated usage in mW during this slice
  mid_cpus FLOAT,
  -- Total big CPU cluster estimated usage in mW during this slice
  big_cpus FLOAT
)
AS
SELECT
  ts,
  dur,
  IFNULL(l3_hit_value, 0.0) + IFNULL(l3_miss_value, 0.0) as l3,
  IFNULL(cpu0_curve, 0.0) + IFNULL(cpu1_curve, 0.0) + IFNULL(cpu2_curve, 0.0) +
    IFNULL(cpu3_curve, 0.0) + static_curve as little_cpus,
  cpu4_curve + cpu5_curve as mid_cpus,
  cpu6_curve + cpu7_curve as big_cpus
FROM _system_state_curves;

-- Gives total contribution of each HW component for the entire trace, bringing
-- the output of the table to parity with the Python version of Wattson
CREATE PERFETTO TABLE _wattson_entire_trace
AS
WITH _individual_totals AS (
  SELECT
    -- LUT for l3 is scaled by 10^6 to save resolution, so do the inversion
    -- scaling by 10^6 after the summation to minimize losing resolution
    SUM(l3) / 1000000 as total_l3,
    SUM(dur * little_cpus) / 1000000000 as total_little_cpus,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    SUM(dur * mid_cpus) / 1000000000 as total_mid_cpus,
    SUM(dur * big_cpus) / 1000000000 as total_big_cpus
  FROM wattson_estimate_per_component
  )
SELECT
  ROUND(total_l3, 2) as total_l3,
  ROUND(total_little_cpus, 2) as total_little_cpus,
  ROUND(total_mid_cpus, 2) as total_mid_cpus,
  ROUND(total_big_cpus, 2) as total_big_cpus,
  ROUND(total_l3 + total_little_cpus + total_mid_cpus + total_big_cpus, 2) as total
FROM _individual_totals;


)_d3l1m1t3r_"
;

const char kWattsonCurvesUngrouped[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE time.conversion;
INCLUDE PERFETTO MODULE wattson.arm_dsu;
INCLUDE PERFETTO MODULE wattson.cpu_split;
INCLUDE PERFETTO MODULE wattson.curves.utils;
INCLUDE PERFETTO MODULE wattson.device_infos;

-- System state table with LUT for CPUs and intermediate values for calculations
CREATE PERFETTO TABLE _w_independent_cpus_calc
AS
SELECT
  ts,
  dur,
  cast_int!(l3_hit_rate * dur) as l3_hit_count,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  cast_int!(l3_miss_rate * dur) as l3_miss_count,
  freq_0,
  idle_0,
  freq_1,
  idle_1,
  freq_2,
  idle_2,
  freq_3,
  idle_3,
  freq_4,
  idle_4,
  freq_5,
  idle_5,
  freq_6,
  idle_6,
  freq_7,
  idle_7,
  policy_4,
  policy_5,
  policy_6,
  policy_7,
  IIF(
    suspended = 1,
    1,
    MIN(
      IFNULL(idle_0, 1),
      IFNULL(idle_1, 1),
      IFNULL(idle_2, 1),
      IFNULL(idle_3, 1)
    )
  ) as no_static,
  IIF(suspended = 1, 0, cpu0_curve) as cpu0_curve,
  IIF(suspended = 1, 0, cpu1_curve) as cpu1_curve,
  IIF(suspended = 1, 0, cpu2_curve) as cpu2_curve,
  IIF(suspended = 1, 0, cpu3_curve) as cpu3_curve,
  IIF(suspended = 1, 0, cpu4_curve) as cpu4_curve,
  IIF(suspended = 1, 0, cpu5_curve) as cpu5_curve,
  IIF(suspended = 1, 0, cpu6_curve) as cpu6_curve,
  IIF(suspended = 1, 0, cpu7_curve) as cpu7_curve,
  -- If dependency CPUs are active, then that CPU could contribute static power
  IIF(idle_4 = -1, lut4.curve_value, -1) as static_4,
  IIF(idle_5 = -1, lut5.curve_value, -1) as static_5,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  IIF(idle_6 = -1, lut6.curve_value, -1) as static_6,
  IIF(idle_7 = -1, lut7.curve_value, -1) as static_7
FROM _idle_freq_l3_hit_l3_miss_slice as base
LEFT JOIN _filtered_curves_2d lut4 ON
  base.freq_0 = lut4.freq_khz AND
  base.freq_4 = lut4.other_freq_khz AND
  base.policy_4 = lut4.other_policy AND
  lut4.idle = 255
LEFT JOIN _filtered_curves_2d lut5 ON
  base.freq_0 = lut5.freq_khz AND
  base.freq_5 = lut5.other_freq_khz AND
  base.policy_5 = lut5.other_policy AND
  lut5.idle = 255
LEFT JOIN _filtered_curves_2d lut6 ON
  base.freq_0 = lut6.freq_khz AND
  base.freq_6 = lut6.other_freq_khz AND
  base.policy_6 = lut6.other_policy AND
  lut6.idle = 255
LEFT JOIN _filtered_curves_2d lut7 ON
  base.freq_0 = lut7.freq_khz AND
  base.freq_7 = lut7.other_freq_khz AND
  base.policy_7 = lut7.other_policy AND
  lut7.idle = 255
-- Needs to be at least 1us to reduce inconsequential rows.
WHERE dur > time_from_us(1);

-- Find the CPU states creating the max vote
CREATE PERFETTO TABLE _get_max_vote
)_d3l1m1t3r_"
R"_d3l1m1t3r_(AS
WITH max_power_tbl AS (
  SELECT
    *,
    -- Indicates if all CPUs are in deep idle
    MIN(
      no_static,
      IFNULL(idle_4, 1),
      IFNULL(idle_5, 1),
      IFNULL(idle_6, 1),
      IFNULL(idle_7, 1)
    ) as all_cpu_deep_idle,
    -- Determines which CPU has highest vote
    MAX(
      static_4,
      static_5,
      static_6,
      static_7
    ) as max_static_vote
  FROM _w_independent_cpus_calc
)
SELECT
  *,
  CASE max_static_vote
    WHEN -1 THEN _get_min_freq_vote()
    WHEN static_4 THEN freq_4
    WHEN static_5 THEN freq_5
    WHEN static_6 THEN freq_6
    WHEN static_7 THEN freq_7
    ELSE 400000
  END max_freq_vote,
  CASE max_static_vote
    WHEN -1 THEN _get_min_policy_vote()
    WHEN static_4 THEN policy_4
    WHEN static_5 THEN policy_5
    WHEN static_6 THEN policy_6
    WHEN static_7 THEN policy_7
    ELSE 4
  END max_policy_vote
FROM max_power_tbl;

-- Final table showing the curves per CPU per slice
CREATE PERFETTO TABLE _system_state_curves
AS
SELECT
  base.ts,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  base.dur,
  COALESCE(lut0.curve_value, cpu0_curve) as cpu0_curve,
  COALESCE(lut1.curve_value, cpu1_curve) as cpu1_curve,
  COALESCE(lut2.curve_value, cpu2_curve) as cpu2_curve,
  COALESCE(lut3.curve_value, cpu3_curve) as cpu3_curve,
  COALESCE(base.cpu4_curve, 0.0) as cpu4_curve,
  COALESCE(base.cpu5_curve, 0.0) as cpu5_curve,
  COALESCE(base.cpu6_curve, 0.0) as cpu6_curve,
  COALESCE(base.cpu7_curve, 0.0) as cpu7_curve,
  IIF(
    no_static = 1,
    0.0,
    COALESCE(static_1d.curve_value, static_2d.curve_value)
  ) as static_curve,
  IIF(
    all_cpu_deep_idle = 1,
    0,
    base.l3_hit_count * l3_hit_lut.curve_value
  ) as l3_hit_value,
  IIF(
    all_cpu_deep_idle = 1,
    0,
    base.l3_miss_count * l3_miss_lut.curve_value
  ) as l3_miss_value
FROM _get_max_vote as base
-- LUT for 2D dependencies
LEFT JOIN _filtered_curves_2d lut0 ON
  lut0.idle = base.idle_0 AND
  lut0.freq_khz = base.freq_0 AND
  lut0.other_freq_khz = base.max_freq_vote AND
  lut0.other_policy = base.max_policy_vote
)_d3l1m1t3r_"
R"_d3l1m1t3r_(LEFT JOIN _filtered_curves_2d lut1 ON
  lut1.idle = base.idle_1 AND
  lut1.freq_khz = base.freq_1 AND
  lut1.other_freq_khz = base.max_freq_vote AND
  lut1.other_policy = base.max_policy_vote
LEFT JOIN _filtered_curves_2d lut2 ON
  lut2.idle = base.idle_2 AND
  lut2.freq_khz = base.freq_2 AND
  lut2.other_freq_khz = base.max_freq_vote AND
  lut2.other_policy = base.max_policy_vote
LEFT JOIN _filtered_curves_2d lut3 ON
  lut3.idle = base.idle_3 AND
  lut3.freq_khz = base.freq_3 AND
  lut3.other_freq_khz = base.max_freq_vote AND
  lut3.other_policy = base.max_policy_vote
-- LUT for static curve lookup
LEFT JOIN _filtered_curves_2d static_2d ON
  static_2d.freq_khz = base.freq_0 AND
  static_2d.other_freq_khz = base.max_freq_vote AND
  static_2d.other_policy = base.max_policy_vote AND
  static_2d.idle = 255
LEFT JOIN _filtered_curves_1d static_1d ON
  static_1d.freq_khz = base.freq_0 AND
  static_1d.policy = 0 AND
  static_1d.idle = 255
-- LUT joins for L3 cache
LEFT JOIN _filtered_curves_l3 l3_hit_lut ON
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  l3_hit_lut.action= 'hit' AND
  l3_hit_lut.freq_khz = base.freq_0 AND
  l3_hit_lut.other_freq_khz = base.max_freq_vote AND
  l3_hit_lut.other_policy = base.max_policy_vote
LEFT JOIN _filtered_curves_l3 l3_miss_lut ON
  l3_miss_lut.action = 'miss' AND
  l3_miss_lut.freq_khz = base.freq_0 AND
  l3_miss_lut.other_freq_khz = base.max_freq_vote AND
  l3_miss_lut.other_policy = base.max_policy_vote;


)_d3l1m1t3r_"
;

const char kWattsonCurvesUtils[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE wattson.curves.device;
INCLUDE PERFETTO MODULE wattson.device_infos;

-- 1D LUT
CREATE PERFETTO TABLE _filtered_curves_1d_raw AS
SELECT cp.policy, freq_khz, active, idle0, idle1, static
FROM _device_curves_1d as dc
JOIN _wattson_device as device ON dc.device = device.name
JOIN _dev_cpu_policy_map as cp ON dc.policy = cp.policy;

CREATE TABLE _filtered_curves_1d AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT policy, freq_khz, -1 as idle, active as curve_value
FROM _filtered_curves_1d_raw
UNION
SELECT policy, freq_khz, 0, idle0
FROM _filtered_curves_1d_raw
UNION
SELECT policy, freq_khz, 1, idle1
FROM _filtered_curves_1d_raw
UNION
SELECT policy, freq_khz, 255, static
FROM _filtered_curves_1d_raw;

CREATE INDEX freq_1d ON _filtered_curves_1d(policy, freq_khz, idle);

-- 2D LUT; with dependency on another CPU
CREATE PERFETTO TABLE _filtered_curves_2d_raw AS
SELECT
  cp.policy as other_policy,
  dc.freq_khz,
  dc.other_freq_khz,
  dc.active,
  dc.idle0,
  dc.idle1,
  dc.static
FROM _device_curves_2d as dc
JOIN _wattson_device as device ON dc.device = device.name
JOIN _dev_cpu_policy_map as cp ON dc.other_policy = cp.policy;

CREATE TABLE _filtered_curves_2d AS
SELECT freq_khz, other_policy, other_freq_khz, -1 as idle, active as curve_value
FROM _filtered_curves_2d_raw
UNION
SELECT freq_khz, other_policy, other_freq_khz, 0, idle0
FROM _filtered_curves_2d_raw
UNION
SELECT freq_khz, other_policy, other_freq_khz, 1, idle1
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM _filtered_curves_2d_raw
UNION
SELECT freq_khz, other_policy, other_freq_khz, 255, static
FROM _filtered_curves_2d_raw;

CREATE INDEX freq_2d
ON _filtered_curves_2d(freq_khz, other_policy, other_freq_khz, idle);

-- L3 cache LUT
CREATE PERFETTO TABLE _filtered_curves_l3_raw AS
SELECT
  cp.policy as other_policy,
  dc.freq_khz,
  dc.other_freq_khz,
  dc.l3_hit,
  dc.l3_miss
FROM _device_curves_l3 as dc
JOIN _wattson_device as device ON dc.device = device.name
JOIN _dev_cpu_policy_map as cp ON dc.other_policy = cp.policy;

CREATE TABLE _filtered_curves_l3 AS
SELECT
  freq_khz, other_policy, other_freq_khz, 'hit' as action, l3_hit as curve_value
FROM _filtered_curves_l3_raw
UNION
SELECT
  freq_khz, other_policy, other_freq_khz, 'miss', l3_miss
FROM _filtered_curves_l3_raw;

CREATE INDEX freq_l3
ON _filtered_curves_l3(freq_khz, other_policy, other_freq_khz, action);

)_d3l1m1t3r_"
;

const char kWattsonDeviceInfos[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE android.device;

-- Device specific info for deep idle time offsets
CREATE PERFETTO TABLE _device_cpu_deep_idle_offsets
AS
WITH data(device, cpu, offset_ns) AS (
  VALUES
  ("Tensor", 0, 0),
  ("Tensor", 1, 0),
  ("Tensor", 2, 0),
  ("Tensor", 3, 0),
  ("Tensor", 4, 0),
  ("Tensor", 5, 0),
  ("Tensor", 6, 200000),
  ("Tensor", 7, 200000),
  ("monaco", 0, 450000),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("monaco", 1, 450000),
  ("monaco", 2, 450000),
  ("monaco", 3, 450000)
)
select * from data;

CREATE PERFETTO TABLE _wattson_device_map
AS
WITH data(device, wattson_device) AS (
  VALUES
  ("oriole", "Tensor"),
  ("raven", "Tensor"),
  ("bluejay", "Tensor"),
  ("eos", "monaco")
)
select * from data;

CREATE PERFETTO TABLE _wattson_device
AS
WITH soc AS (
  SELECT str_value as model
  FROM metadata
  WHERE name = 'android_soc_model'
)
SELECT
  COALESCE(soc.model, map.wattson_device) as name
FROM _wattson_device_map as map
CROSS JOIN android_device_name as ad
LEFT JOIN soc ON TRUE
WHERE ad.name = map.device;

-- Device specific mapping from CPU to policy
CREATE PERFETTO TABLE _cpu_to_policy_map
AS
WITH data(device, cpu, policy) AS (
  VALUES
  ("monaco", 0, 0),
  ("monaco", 1, 0),
  ("monaco", 2, 0),
  ("monaco", 3, 0),
  ("Tensor", 0, 0),
  ("Tensor", 1, 0),
  ("Tensor", 2, 0),
  ("Tensor", 3, 0),
  ("Tensor", 4, 4),
  ("Tensor", 5, 4),
  ("Tensor", 6, 6),
  ("Tensor", 7, 6)
)
select * from data;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Prefilter table based on device
CREATE PERFETTO TABLE _dev_cpu_policy_map
AS
SELECT
  cpu, policy
FROM _cpu_to_policy_map as cp_map
JOIN _wattson_device as device
ON cp_map.device = device.name
ORDER by cpu;

-- Policy and freq that will give minimum volt vote
CREATE PERFETTO TABLE _device_min_volt_vote
AS
WITH data(device, policy, freq) AS (
  VALUES
  ("monaco", 0, 614400),
  ("Tensor", 4, 400000)
)
select * from data;

-- Get policy corresponding to minimum volt vote
CREATE PERFETTO FUNCTION _get_min_policy_vote()
RETURNS INT AS
SELECT
  vote_tbl.policy
FROM _device_min_volt_vote as vote_tbl
JOIN _wattson_device as device
WHERE vote_tbl.device = device.name;

-- Get frequency corresponding to minimum volt vote
CREATE PERFETTO FUNCTION _get_min_freq_vote()
RETURNS INT AS
SELECT
 vote_tbl.freq
FROM _device_min_volt_vote as vote_tbl
JOIN _wattson_device as device
WHERE vote_tbl.device = device.name;

)_d3l1m1t3r_"
;

const char kWattsonSystemState[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE wattson.cpu_split;

-- The final system state for the CPU subsystem, which has all the information
-- needed by Wattson to estimate energy for the CPU subsystem.
CREATE PERFETTO TABLE wattson_system_states(
  -- Starting timestamp of the current counter where system state is constant.
  ts LONG,
  -- Duration of the current counter where system state is constant.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  dur INT,
  -- Number of L3 hits the current system state.
  l3_hit_count INT,
  -- Number of L3 misses in the current system state.
  l3_miss_count INT,
  -- Frequency of CPU0.
  freq_0 INT,
  -- Idle state of CPU0.
  idle_0 INT,
  -- Frequency of CPU1.
  freq_1 INT,
  -- Idle state of CPU1.
  idle_1 INT,
  -- Frequency of CPU2.
  freq_2 INT,
  -- Idle state of CPU2.
  idle_2 INT,
  -- Frequency of CPU3.
  freq_3 INT,
  -- Idle state of CPU3.
  idle_3 INT,
  -- Frequency of CPU4.
  freq_4 INT,
  -- Idle state of CPU4.
  idle_4 INT,
  -- Frequency of CPU5.
  freq_5 INT,
  -- Idle state of CPU5.
  idle_5 INT,
  -- Frequency of CPU6.
  freq_6 INT,
  -- Idle state of CPU6.
  idle_6 INT,
  -- Frequency of CPU7.
  freq_7 INT,
  -- Idle state of CPU7.
  idle_7 INT,
  -- Flag indicating if current system state is suspended.
  suspended BOOL
)
AS
SELECT
  ts,
  dur,
  cast_int!(round(l3_hit_rate * dur, 0)) as l3_hit_count,
  cast_int!(round(l3_miss_rate * dur, 0)) as l3_miss_count,
  freq_0,
  idle_0,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  freq_1,
  idle_1,
  freq_2,
  idle_2,
  freq_3,
  idle_3,
  freq_4,
  idle_4,
  freq_5,
  idle_5,
  freq_6,
  idle_6,
  freq_7,
  idle_7,
  IFNULL(suspended, FALSE) as suspended
FROM _idle_freq_l3_hit_l3_miss_slice
-- Needs to be at least 1us to reduce inconsequential rows.
WHERE dur > time_from_us(1);


)_d3l1m1t3r_"
;

struct FileToSql {
  const char* path;
  const char* sql;
};

const FileToSql kFileToSql[] = {
  {"android/auto/multiuser.sql", kAndroidAutoMultiuser},

  {"android/frames/per_frame_metrics.sql", kAndroidFramesPerFrameMetrics},

  {"android/frames/timeline.sql", kAndroidFramesTimeline},

  {"android/frames/timeline_maxsdk28.sql", kAndroidFramesTimelineMaxsdk28},

  {"android/startup/startup_events.sql", kAndroidStartupStartupEvents},

  {"android/startup/startups.sql", kAndroidStartupStartups},

  {"android/startup/startups_maxsdk28.sql", kAndroidStartupStartupsMaxsdk28},

  {"android/startup/startups_minsdk29.sql", kAndroidStartupStartupsMinsdk29},

  {"android/startup/startups_minsdk33.sql", kAndroidStartupStartupsMinsdk33},

  {"android/startup/time_to_display.sql", kAndroidStartupTimeToDisplay},

  {"android/winscope/inputmethod.sql", kAndroidWinscopeInputmethod},

  {"android/winscope/viewcapture.sql", kAndroidWinscopeViewcapture},

  {"android/anrs.sql", kAndroidAnrs},

  {"android/app_process_starts.sql", kAndroidAppProcessStarts},

  {"android/battery.sql", kAndroidBattery},

  {"android/battery_stats.sql", kAndroidBatteryStats},

  {"android/binder.sql", kAndroidBinder},

  {"android/broadcasts.sql", kAndroidBroadcasts},

  {"android/critical_blocking_calls.sql", kAndroidCriticalBlockingCalls},

  {"android/device.sql", kAndroidDevice},

  {"android/dvfs.sql", kAndroidDvfs},

  {"android/freezer.sql", kAndroidFreezer},

  {"android/garbage_collection.sql", kAndroidGarbageCollection},

  {"android/input.sql", kAndroidInput},

  {"android/io.sql", kAndroidIo},

  {"android/job_scheduler.sql", kAndroidJobScheduler},

  {"android/monitor_contention.sql", kAndroidMonitorContention},

  {"android/network_packets.sql", kAndroidNetworkPackets},

  {"android/oom_adjuster.sql", kAndroidOomAdjuster},

  {"android/power_rails.sql", kAndroidPowerRails},

  {"android/process_metadata.sql", kAndroidProcessMetadata},

  {"android/screenshots.sql", kAndroidScreenshots},

  {"android/services.sql", kAndroidServices},

  {"android/slices.sql", kAndroidSlices},

  {"android/statsd.sql", kAndroidStatsd},

  {"android/suspend.sql", kAndroidSuspend},

  {"android/thread.sql", kAndroidThread},

  {"chrome/chrome_scrolls.sql", kChromeChromeScrolls},

  {"chrome/cpu_powerups.sql", kChromeCpuPowerups},

  {"chrome/event_latency_description.sql", kChromeEventLatencyDescription},

  {"chrome/histograms.sql", kChromeHistograms},

  {"chrome/interactions.sql", kChromeInteractions},

  {"chrome/metadata.sql", kChromeMetadata},

  {"chrome/page_loads.sql", kChromePageLoads},

  {"chrome/speedometer.sql", kChromeSpeedometer},

  {"chrome/speedometer_2_1.sql", kChromeSpeedometer21},

  {"chrome/speedometer_3.sql", kChromeSpeedometer3},

  {"chrome/startups.sql", kChromeStartups},

  {"chrome/tasks.sql", kChromeTasks},

  {"chrome/vsync_intervals.sql", kChromeVsyncIntervals},

  {"chrome/web_content_interactions.sql", kChromeWebContentInteractions},

  {"chrome/scroll_jank/scroll_jank_cause_map.sql", kChromeScrollJankScrollJankCauseMap},

  {"chrome/scroll_jank/scroll_jank_cause_utils.sql", kChromeScrollJankScrollJankCauseUtils},

  {"chrome/scroll_jank/scroll_jank_intervals.sql", kChromeScrollJankScrollJankIntervals},

  {"chrome/scroll_jank/scroll_jank_v3_cause.sql", kChromeScrollJankScrollJankV3Cause},

  {"chrome/scroll_jank/scroll_jank_v3.sql", kChromeScrollJankScrollJankV3},

  {"chrome/scroll_jank/scroll_offsets.sql", kChromeScrollJankScrollOffsets},

  {"chrome/scroll_jank/utils.sql", kChromeScrollJankUtils},

  {"common/args.sql", kCommonArgs},

  {"common/counters.sql", kCommonCounters},

  {"common/cpus.sql", kCommonCpus},

  {"common/metadata.sql", kCommonMetadata},

  {"common/percentiles.sql", kCommonPercentiles},

  {"common/slices.sql", kCommonSlices},

  {"common/thread_states.sql", kCommonThreadStates},

  {"common/timestamps.sql", kCommonTimestamps},

  {"counters/intervals.sql", kCountersIntervals},

  {"cpu/utilization/general.sql", kCpuUtilizationGeneral},

  {"cpu/utilization/process.sql", kCpuUtilizationProcess},

  {"cpu/utilization/system.sql", kCpuUtilizationSystem},

  {"cpu/utilization/thread.sql", kCpuUtilizationThread},

  {"cpu/cpus.sql", kCpuCpus},

  {"cpu/freq.sql", kCpuFreq},

  {"cpu/idle.sql", kCpuIdle},

  {"cpu/size.sql", kCpuSize},

  {"deprecated/v42/common/args.sql", kDeprecatedV42CommonArgs},

  {"deprecated/v42/common/counters.sql", kDeprecatedV42CommonCounters},

  {"deprecated/v42/common/cpus.sql", kDeprecatedV42CommonCpus},

  {"deprecated/v42/common/metadata.sql", kDeprecatedV42CommonMetadata},

  {"deprecated/v42/common/percentiles.sql", kDeprecatedV42CommonPercentiles},

  {"deprecated/v42/common/slices.sql", kDeprecatedV42CommonSlices},

  {"deprecated/v42/common/thread_states.sql", kDeprecatedV42CommonThreadStates},

  {"deprecated/v42/common/timestamps.sql", kDeprecatedV42CommonTimestamps},

  {"gpu/frequency.sql", kGpuFrequency},

  {"graphs/dominator_tree.sql", kGraphsDominatorTree},

  {"graphs/partition.sql", kGraphsPartition},

  {"graphs/search.sql", kGraphsSearch},

  {"intervals/intersect.sql", kIntervalsIntersect},

  {"intervals/overlap.sql", kIntervalsOverlap},

  {"linux/cpu_idle.sql", kLinuxCpuIdle},

  {"memory/android/gpu.sql", kMemoryAndroidGpu},

  {"memory/linux/general.sql", kMemoryLinuxGeneral},

  {"memory/linux/high_watermark.sql", kMemoryLinuxHighWatermark},

  {"memory/linux/process.sql", kMemoryLinuxProcess},

  {"memory/heap_graph_dominator_tree.sql", kMemoryHeapGraphDominatorTree},

  {"pkvm/hypervisor.sql", kPkvmHypervisor},

  {"prelude/casts.sql", kPreludeCasts},

  {"prelude/slices.sql", kPreludeSlices},

  {"prelude/tables_views.sql", kPreludeTablesViews},

  {"prelude/trace_bounds.sql", kPreludeTraceBounds},

  {"sched/runnable.sql", kSchedRunnable},

  {"sched/states.sql", kSchedStates},

  {"sched/thread_executing_span.sql", kSchedThreadExecutingSpan},

  {"sched/thread_executing_span_with_slice.sql", kSchedThreadExecutingSpanWithSlice},

  {"sched/thread_level_parallelism.sql", kSchedThreadLevelParallelism},

  {"sched/thread_state_flattened.sql", kSchedThreadStateFlattened},

  {"sched/time_in_state.sql", kSchedTimeInState},

  {"slices/cpu_time.sql", kSlicesCpuTime},

  {"slices/flat_slices.sql", kSlicesFlatSlices},

  {"slices/slices.sql", kSlicesSlices},

  {"slices/with_context.sql", kSlicesWithContext},

  {"stack_trace/jit.sql", kStackTraceJit},

  {"time/conversion.sql", kTimeConversion},

  {"v8/jit.sql", kV8Jit},

  {"viz/summary/counters.sql", kVizSummaryCounters},

  {"viz/summary/processes.sql", kVizSummaryProcesses},

  {"viz/summary/slices.sql", kVizSummarySlices},

  {"viz/summary/threads.sql", kVizSummaryThreads},

  {"viz/summary/tracks.sql", kVizSummaryTracks},

  {"wattson/arm_dsu.sql", kWattsonArmDsu},

  {"wattson/cpu_idle.sql", kWattsonCpuIdle},

  {"wattson/cpu_split.sql", kWattsonCpuSplit},

  {"wattson/curves/device.sql", kWattsonCurvesDevice},

  {"wattson/curves/grouped.sql", kWattsonCurvesGrouped},

  {"wattson/curves/ungrouped.sql", kWattsonCurvesUngrouped},

  {"wattson/curves/utils.sql", kWattsonCurvesUtils},

  {"wattson/device_infos.sql", kWattsonDeviceInfos},

  {"wattson/system_state.sql", kWattsonSystemState},
};

}  // namespace stdlib
}  // namespace trace_processor
}  // namespace perfetto
