// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_DESCRIPTOR_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_DESCRIPTOR_PROTO_H_

#include <stddef.h>
#include <stdint.h>

#include "perfetto/protozero/field_writer.h"
#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {
class DescriptorProto;
class DescriptorProto_ReservedRange;
class EnumDescriptorProto;
class EnumValueDescriptorProto;
class FieldDescriptorProto;
class FieldOptions;
class FileDescriptorProto;
class OneofDescriptorProto;
class OneofOptions;
class UninterpretedOption;
class UninterpretedOption_NamePart;
namespace perfetto_pbzero_enum_FieldDescriptorProto {
enum Label : int32_t;
}  // namespace perfetto_pbzero_enum_FieldDescriptorProto
using FieldDescriptorProto_Label = perfetto_pbzero_enum_FieldDescriptorProto::Label;
namespace perfetto_pbzero_enum_FieldDescriptorProto {
enum Type : int32_t;
}  // namespace perfetto_pbzero_enum_FieldDescriptorProto
using FieldDescriptorProto_Type = perfetto_pbzero_enum_FieldDescriptorProto::Type;
} // Namespace pbzero.
} // Namespace protos.
} // Namespace perfetto.

namespace perfetto {
namespace protos {
namespace pbzero {

namespace perfetto_pbzero_enum_FieldDescriptorProto {
enum Type : int32_t {
  TYPE_DOUBLE = 1,
  TYPE_FLOAT = 2,
  TYPE_INT64 = 3,
  TYPE_UINT64 = 4,
  TYPE_INT32 = 5,
  TYPE_FIXED64 = 6,
  TYPE_FIXED32 = 7,
  TYPE_BOOL = 8,
  TYPE_STRING = 9,
  TYPE_GROUP = 10,
  TYPE_MESSAGE = 11,
  TYPE_BYTES = 12,
  TYPE_UINT32 = 13,
  TYPE_ENUM = 14,
  TYPE_SFIXED32 = 15,
  TYPE_SFIXED64 = 16,
  TYPE_SINT32 = 17,
  TYPE_SINT64 = 18,
};
} // namespace perfetto_pbzero_enum_FieldDescriptorProto
using FieldDescriptorProto_Type = perfetto_pbzero_enum_FieldDescriptorProto::Type;


constexpr FieldDescriptorProto_Type FieldDescriptorProto_Type_MIN = FieldDescriptorProto_Type::TYPE_DOUBLE;
constexpr FieldDescriptorProto_Type FieldDescriptorProto_Type_MAX = FieldDescriptorProto_Type::TYPE_SINT64;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* FieldDescriptorProto_Type_Name(::perfetto::protos::pbzero::FieldDescriptorProto_Type value) {
  switch (value) {
  case ::perfetto::protos::pbzero::FieldDescriptorProto_Type::TYPE_DOUBLE:
    return "TYPE_DOUBLE";

  case ::perfetto::protos::pbzero::FieldDescriptorProto_Type::TYPE_FLOAT:
    return "TYPE_FLOAT";

  case ::perfetto::protos::pbzero::FieldDescriptorProto_Type::TYPE_INT64:
    return "TYPE_INT64";

  case ::perfetto::protos::pbzero::FieldDescriptorProto_Type::TYPE_UINT64:
    return "TYPE_UINT64";

  case ::perfetto::protos::pbzero::FieldDescriptorProto_Type::TYPE_INT32:
    return "TYPE_INT32";

  case ::perfetto::protos::pbzero::FieldDescriptorProto_Type::TYPE_FIXED64:
    return "TYPE_FIXED64";

  case ::perfetto::protos::pbzero::FieldDescriptorProto_Type::TYPE_FIXED32:
    return "TYPE_FIXED32";

  case ::perfetto::protos::pbzero::FieldDescriptorProto_Type::TYPE_BOOL:
    return "TYPE_BOOL";

  case ::perfetto::protos::pbzero::FieldDescriptorProto_Type::TYPE_STRING:
    return "TYPE_STRING";

  case ::perfetto::protos::pbzero::FieldDescriptorProto_Type::TYPE_GROUP:
    return "TYPE_GROUP";

  case ::perfetto::protos::pbzero::FieldDescriptorProto_Type::TYPE_MESSAGE:
    return "TYPE_MESSAGE";

  case ::perfetto::protos::pbzero::FieldDescriptorProto_Type::TYPE_BYTES:
    return "TYPE_BYTES";

  case ::perfetto::protos::pbzero::FieldDescriptorProto_Type::TYPE_UINT32:
    return "TYPE_UINT32";

  case ::perfetto::protos::pbzero::FieldDescriptorProto_Type::TYPE_ENUM:
    return "TYPE_ENUM";

  case ::perfetto::protos::pbzero::FieldDescriptorProto_Type::TYPE_SFIXED32:
    return "TYPE_SFIXED32";

  case ::perfetto::protos::pbzero::FieldDescriptorProto_Type::TYPE_SFIXED64:
    return "TYPE_SFIXED64";

  case ::perfetto::protos::pbzero::FieldDescriptorProto_Type::TYPE_SINT32:
    return "TYPE_SINT32";

  case ::perfetto::protos::pbzero::FieldDescriptorProto_Type::TYPE_SINT64:
    return "TYPE_SINT64";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_FieldDescriptorProto {
enum Label : int32_t {
  LABEL_OPTIONAL = 1,
  LABEL_REQUIRED = 2,
  LABEL_REPEATED = 3,
};
} // namespace perfetto_pbzero_enum_FieldDescriptorProto
using FieldDescriptorProto_Label = perfetto_pbzero_enum_FieldDescriptorProto::Label;


constexpr FieldDescriptorProto_Label FieldDescriptorProto_Label_MIN = FieldDescriptorProto_Label::LABEL_OPTIONAL;
constexpr FieldDescriptorProto_Label FieldDescriptorProto_Label_MAX = FieldDescriptorProto_Label::LABEL_REPEATED;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* FieldDescriptorProto_Label_Name(::perfetto::protos::pbzero::FieldDescriptorProto_Label value) {
  switch (value) {
  case ::perfetto::protos::pbzero::FieldDescriptorProto_Label::LABEL_OPTIONAL:
    return "LABEL_OPTIONAL";

  case ::perfetto::protos::pbzero::FieldDescriptorProto_Label::LABEL_REQUIRED:
    return "LABEL_REQUIRED";

  case ::perfetto::protos::pbzero::FieldDescriptorProto_Label::LABEL_REPEATED:
    return "LABEL_REPEATED";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

class OneofOptions_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/0, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  OneofOptions_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit OneofOptions_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit OneofOptions_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
};

class OneofOptions : public ::protozero::Message {
 public:
  using Decoder = OneofOptions_Decoder;
  static constexpr const char* GetName() { return ".perfetto.protos.OneofOptions"; }

};

class EnumValueDescriptorProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  EnumValueDescriptorProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit EnumValueDescriptorProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit EnumValueDescriptorProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_number() const { return at<2>().valid(); }
  int32_t number() const { return at<2>().as_int32(); }
};

class EnumValueDescriptorProto : public ::protozero::Message {
 public:
  using Decoder = EnumValueDescriptorProto_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kNumberFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.EnumValueDescriptorProto"; }


  using FieldMetadata_Name =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      EnumValueDescriptorProto>;

  static constexpr FieldMetadata_Name kName{};
  void set_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Name::kFieldId, data, size);
  }
  void set_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Name::kFieldId, chars.data, chars.size);
  }
  void set_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Name::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Number =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      EnumValueDescriptorProto>;

  static constexpr FieldMetadata_Number kNumber{};
  void set_number(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Number::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

class EnumDescriptorProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  EnumDescriptorProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit EnumDescriptorProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit EnumDescriptorProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_value() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> value() const { return GetRepeated<::protozero::ConstBytes>(2); }
  bool has_reserved_name() const { return at<5>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> reserved_name() const { return GetRepeated<::protozero::ConstChars>(5); }
};

class EnumDescriptorProto : public ::protozero::Message {
 public:
  using Decoder = EnumDescriptorProto_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
    kReservedNameFieldNumber = 5,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.EnumDescriptorProto"; }


  using FieldMetadata_Name =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      EnumDescriptorProto>;

  static constexpr FieldMetadata_Name kName{};
  void set_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Name::kFieldId, data, size);
  }
  void set_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Name::kFieldId, chars.data, chars.size);
  }
  void set_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Name::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Value =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      EnumValueDescriptorProto,
      EnumDescriptorProto>;

  static constexpr FieldMetadata_Value kValue{};
  template <typename T = EnumValueDescriptorProto> T* add_value() {
    return BeginNestedMessage<T>(2);
  }


  using FieldMetadata_ReservedName =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      EnumDescriptorProto>;

  static constexpr FieldMetadata_ReservedName kReservedName{};
  void add_reserved_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_ReservedName::kFieldId, data, size);
  }
  void add_reserved_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_ReservedName::kFieldId, chars.data, chars.size);
  }
  void add_reserved_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_ReservedName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }
};

class OneofDescriptorProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  OneofDescriptorProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit OneofDescriptorProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit OneofDescriptorProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_options() const { return at<2>().valid(); }
  ::protozero::ConstBytes options() const { return at<2>().as_bytes(); }
};

class OneofDescriptorProto : public ::protozero::Message {
 public:
  using Decoder = OneofDescriptorProto_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kOptionsFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.OneofDescriptorProto"; }


  using FieldMetadata_Name =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      OneofDescriptorProto>;

  static constexpr FieldMetadata_Name kName{};
  void set_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Name::kFieldId, data, size);
  }
  void set_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Name::kFieldId, chars.data, chars.size);
  }
  void set_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Name::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Options =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      OneofOptions,
      OneofDescriptorProto>;

  static constexpr FieldMetadata_Options kOptions{};
  template <typename T = OneofOptions> T* set_options() {
    return BeginNestedMessage<T>(2);
  }

};

class FieldDescriptorProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/9, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  FieldDescriptorProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FieldDescriptorProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FieldDescriptorProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_number() const { return at<3>().valid(); }
  int32_t number() const { return at<3>().as_int32(); }
  bool has_label() const { return at<4>().valid(); }
  int32_t label() const { return at<4>().as_int32(); }
  bool has_type() const { return at<5>().valid(); }
  int32_t type() const { return at<5>().as_int32(); }
  bool has_type_name() const { return at<6>().valid(); }
  ::protozero::ConstChars type_name() const { return at<6>().as_string(); }
  bool has_extendee() const { return at<2>().valid(); }
  ::protozero::ConstChars extendee() const { return at<2>().as_string(); }
  bool has_default_value() const { return at<7>().valid(); }
  ::protozero::ConstChars default_value() const { return at<7>().as_string(); }
  bool has_options() const { return at<8>().valid(); }
  ::protozero::ConstBytes options() const { return at<8>().as_bytes(); }
  bool has_oneof_index() const { return at<9>().valid(); }
  int32_t oneof_index() const { return at<9>().as_int32(); }
};

class FieldDescriptorProto : public ::protozero::Message {
 public:
  using Decoder = FieldDescriptorProto_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kNumberFieldNumber = 3,
    kLabelFieldNumber = 4,
    kTypeFieldNumber = 5,
    kTypeNameFieldNumber = 6,
    kExtendeeFieldNumber = 2,
    kDefaultValueFieldNumber = 7,
    kOptionsFieldNumber = 8,
    kOneofIndexFieldNumber = 9,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.FieldDescriptorProto"; }


  using Type = ::perfetto::protos::pbzero::FieldDescriptorProto_Type;
  static inline const char* Type_Name(Type value) {
    return ::perfetto::protos::pbzero::FieldDescriptorProto_Type_Name(value);
  }

  using Label = ::perfetto::protos::pbzero::FieldDescriptorProto_Label;
  static inline const char* Label_Name(Label value) {
    return ::perfetto::protos::pbzero::FieldDescriptorProto_Label_Name(value);
  }
  static inline const Type TYPE_DOUBLE = Type::TYPE_DOUBLE;
  static inline const Type TYPE_FLOAT = Type::TYPE_FLOAT;
  static inline const Type TYPE_INT64 = Type::TYPE_INT64;
  static inline const Type TYPE_UINT64 = Type::TYPE_UINT64;
  static inline const Type TYPE_INT32 = Type::TYPE_INT32;
  static inline const Type TYPE_FIXED64 = Type::TYPE_FIXED64;
  static inline const Type TYPE_FIXED32 = Type::TYPE_FIXED32;
  static inline const Type TYPE_BOOL = Type::TYPE_BOOL;
  static inline const Type TYPE_STRING = Type::TYPE_STRING;
  static inline const Type TYPE_GROUP = Type::TYPE_GROUP;
  static inline const Type TYPE_MESSAGE = Type::TYPE_MESSAGE;
  static inline const Type TYPE_BYTES = Type::TYPE_BYTES;
  static inline const Type TYPE_UINT32 = Type::TYPE_UINT32;
  static inline const Type TYPE_ENUM = Type::TYPE_ENUM;
  static inline const Type TYPE_SFIXED32 = Type::TYPE_SFIXED32;
  static inline const Type TYPE_SFIXED64 = Type::TYPE_SFIXED64;
  static inline const Type TYPE_SINT32 = Type::TYPE_SINT32;
  static inline const Type TYPE_SINT64 = Type::TYPE_SINT64;
  static inline const Label LABEL_OPTIONAL = Label::LABEL_OPTIONAL;
  static inline const Label LABEL_REQUIRED = Label::LABEL_REQUIRED;
  static inline const Label LABEL_REPEATED = Label::LABEL_REPEATED;

  using FieldMetadata_Name =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      FieldDescriptorProto>;

  static constexpr FieldMetadata_Name kName{};
  void set_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Name::kFieldId, data, size);
  }
  void set_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Name::kFieldId, chars.data, chars.size);
  }
  void set_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Name::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Number =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      FieldDescriptorProto>;

  static constexpr FieldMetadata_Number kNumber{};
  void set_number(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Number::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Label =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      FieldDescriptorProto_Label,
      FieldDescriptorProto>;

  static constexpr FieldMetadata_Label kLabel{};
  void set_label(FieldDescriptorProto_Label value) {
    static constexpr uint32_t field_id = FieldMetadata_Label::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Type =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      FieldDescriptorProto_Type,
      FieldDescriptorProto>;

  static constexpr FieldMetadata_Type kType{};
  void set_type(FieldDescriptorProto_Type value) {
    static constexpr uint32_t field_id = FieldMetadata_Type::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_TypeName =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      FieldDescriptorProto>;

  static constexpr FieldMetadata_TypeName kTypeName{};
  void set_type_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_TypeName::kFieldId, data, size);
  }
  void set_type_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_TypeName::kFieldId, chars.data, chars.size);
  }
  void set_type_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_TypeName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Extendee =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      FieldDescriptorProto>;

  static constexpr FieldMetadata_Extendee kExtendee{};
  void set_extendee(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Extendee::kFieldId, data, size);
  }
  void set_extendee(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Extendee::kFieldId, chars.data, chars.size);
  }
  void set_extendee(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Extendee::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_DefaultValue =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      FieldDescriptorProto>;

  static constexpr FieldMetadata_DefaultValue kDefaultValue{};
  void set_default_value(const char* data, size_t size) {
    AppendBytes(FieldMetadata_DefaultValue::kFieldId, data, size);
  }
  void set_default_value(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_DefaultValue::kFieldId, chars.data, chars.size);
  }
  void set_default_value(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_DefaultValue::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Options =
    ::protozero::proto_utils::FieldMetadata<
      8,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      FieldOptions,
      FieldDescriptorProto>;

  static constexpr FieldMetadata_Options kOptions{};
  template <typename T = FieldOptions> T* set_options() {
    return BeginNestedMessage<T>(8);
  }


  using FieldMetadata_OneofIndex =
    ::protozero::proto_utils::FieldMetadata<
      9,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      FieldDescriptorProto>;

  static constexpr FieldMetadata_OneofIndex kOneofIndex{};
  void set_oneof_index(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_OneofIndex::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

class FieldOptions_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/999, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  FieldOptions_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FieldOptions_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FieldOptions_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_packed() const { return at<2>().valid(); }
  bool packed() const { return at<2>().as_bool(); }
  bool has_uninterpreted_option() const { return at<999>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> uninterpreted_option() const { return GetRepeated<::protozero::ConstBytes>(999); }
};

class FieldOptions : public ::protozero::Message {
 public:
  using Decoder = FieldOptions_Decoder;
  enum : int32_t {
    kPackedFieldNumber = 2,
    kUninterpretedOptionFieldNumber = 999,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.FieldOptions"; }


  using FieldMetadata_Packed =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      FieldOptions>;

  static constexpr FieldMetadata_Packed kPacked{};
  void set_packed(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_Packed::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_UninterpretedOption =
    ::protozero::proto_utils::FieldMetadata<
      999,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      UninterpretedOption,
      FieldOptions>;

  static constexpr FieldMetadata_UninterpretedOption kUninterpretedOption{};
  template <typename T = UninterpretedOption> T* add_uninterpreted_option() {
    return BeginNestedMessage<T>(999);
  }

};

class UninterpretedOption_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  UninterpretedOption_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit UninterpretedOption_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit UninterpretedOption_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> name() const { return GetRepeated<::protozero::ConstBytes>(2); }
  bool has_identifier_value() const { return at<3>().valid(); }
  ::protozero::ConstChars identifier_value() const { return at<3>().as_string(); }
  bool has_positive_int_value() const { return at<4>().valid(); }
  uint64_t positive_int_value() const { return at<4>().as_uint64(); }
  bool has_negative_int_value() const { return at<5>().valid(); }
  int64_t negative_int_value() const { return at<5>().as_int64(); }
  bool has_double_value() const { return at<6>().valid(); }
  double double_value() const { return at<6>().as_double(); }
  bool has_string_value() const { return at<7>().valid(); }
  ::protozero::ConstBytes string_value() const { return at<7>().as_bytes(); }
  bool has_aggregate_value() const { return at<8>().valid(); }
  ::protozero::ConstChars aggregate_value() const { return at<8>().as_string(); }
};

class UninterpretedOption : public ::protozero::Message {
 public:
  using Decoder = UninterpretedOption_Decoder;
  enum : int32_t {
    kNameFieldNumber = 2,
    kIdentifierValueFieldNumber = 3,
    kPositiveIntValueFieldNumber = 4,
    kNegativeIntValueFieldNumber = 5,
    kDoubleValueFieldNumber = 6,
    kStringValueFieldNumber = 7,
    kAggregateValueFieldNumber = 8,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.UninterpretedOption"; }

  using NamePart = ::perfetto::protos::pbzero::UninterpretedOption_NamePart;

  using FieldMetadata_Name =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      UninterpretedOption_NamePart,
      UninterpretedOption>;

  static constexpr FieldMetadata_Name kName{};
  template <typename T = UninterpretedOption_NamePart> T* add_name() {
    return BeginNestedMessage<T>(2);
  }


  using FieldMetadata_IdentifierValue =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      UninterpretedOption>;

  static constexpr FieldMetadata_IdentifierValue kIdentifierValue{};
  void set_identifier_value(const char* data, size_t size) {
    AppendBytes(FieldMetadata_IdentifierValue::kFieldId, data, size);
  }
  void set_identifier_value(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_IdentifierValue::kFieldId, chars.data, chars.size);
  }
  void set_identifier_value(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_IdentifierValue::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_PositiveIntValue =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      UninterpretedOption>;

  static constexpr FieldMetadata_PositiveIntValue kPositiveIntValue{};
  void set_positive_int_value(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_PositiveIntValue::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_NegativeIntValue =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      UninterpretedOption>;

  static constexpr FieldMetadata_NegativeIntValue kNegativeIntValue{};
  void set_negative_int_value(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_NegativeIntValue::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_DoubleValue =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kDouble,
      double,
      UninterpretedOption>;

  static constexpr FieldMetadata_DoubleValue kDoubleValue{};
  void set_double_value(double value) {
    static constexpr uint32_t field_id = FieldMetadata_DoubleValue::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kDouble>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_StringValue =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBytes,
      std::string,
      UninterpretedOption>;

  static constexpr FieldMetadata_StringValue kStringValue{};
  void set_string_value(const uint8_t* data, size_t size) {
    AppendBytes(FieldMetadata_StringValue::kFieldId, data, size);
  }
  void set_string_value(::protozero::ConstBytes bytes) {
    AppendBytes(FieldMetadata_StringValue::kFieldId, bytes.data, bytes.size);
  }
  void set_string_value(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_StringValue::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBytes>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_AggregateValue =
    ::protozero::proto_utils::FieldMetadata<
      8,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      UninterpretedOption>;

  static constexpr FieldMetadata_AggregateValue kAggregateValue{};
  void set_aggregate_value(const char* data, size_t size) {
    AppendBytes(FieldMetadata_AggregateValue::kFieldId, data, size);
  }
  void set_aggregate_value(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_AggregateValue::kFieldId, chars.data, chars.size);
  }
  void set_aggregate_value(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_AggregateValue::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }
};

class UninterpretedOption_NamePart_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  UninterpretedOption_NamePart_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit UninterpretedOption_NamePart_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit UninterpretedOption_NamePart_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name_part() const { return at<1>().valid(); }
  ::protozero::ConstChars name_part() const { return at<1>().as_string(); }
  bool has_is_extension() const { return at<2>().valid(); }
  bool is_extension() const { return at<2>().as_bool(); }
};

class UninterpretedOption_NamePart : public ::protozero::Message {
 public:
  using Decoder = UninterpretedOption_NamePart_Decoder;
  enum : int32_t {
    kNamePartFieldNumber = 1,
    kIsExtensionFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.UninterpretedOption.NamePart"; }


  using FieldMetadata_NamePart =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      UninterpretedOption_NamePart>;

  static constexpr FieldMetadata_NamePart kNamePart{};
  void set_name_part(const char* data, size_t size) {
    AppendBytes(FieldMetadata_NamePart::kFieldId, data, size);
  }
  void set_name_part(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_NamePart::kFieldId, chars.data, chars.size);
  }
  void set_name_part(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_NamePart::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IsExtension =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      UninterpretedOption_NamePart>;

  static constexpr FieldMetadata_IsExtension kIsExtension{};
  void set_is_extension(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsExtension::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }
};

class DescriptorProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  DescriptorProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DescriptorProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DescriptorProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_field() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> field() const { return GetRepeated<::protozero::ConstBytes>(2); }
  bool has_extension() const { return at<6>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> extension() const { return GetRepeated<::protozero::ConstBytes>(6); }
  bool has_nested_type() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> nested_type() const { return GetRepeated<::protozero::ConstBytes>(3); }
  bool has_enum_type() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> enum_type() const { return GetRepeated<::protozero::ConstBytes>(4); }
  bool has_oneof_decl() const { return at<8>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> oneof_decl() const { return GetRepeated<::protozero::ConstBytes>(8); }
  bool has_reserved_range() const { return at<9>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> reserved_range() const { return GetRepeated<::protozero::ConstBytes>(9); }
  bool has_reserved_name() const { return at<10>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> reserved_name() const { return GetRepeated<::protozero::ConstChars>(10); }
};

class DescriptorProto : public ::protozero::Message {
 public:
  using Decoder = DescriptorProto_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kFieldFieldNumber = 2,
    kExtensionFieldNumber = 6,
    kNestedTypeFieldNumber = 3,
    kEnumTypeFieldNumber = 4,
    kOneofDeclFieldNumber = 8,
    kReservedRangeFieldNumber = 9,
    kReservedNameFieldNumber = 10,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.DescriptorProto"; }

  using ReservedRange = ::perfetto::protos::pbzero::DescriptorProto_ReservedRange;

  using FieldMetadata_Name =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      DescriptorProto>;

  static constexpr FieldMetadata_Name kName{};
  void set_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Name::kFieldId, data, size);
  }
  void set_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Name::kFieldId, chars.data, chars.size);
  }
  void set_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Name::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Field =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      FieldDescriptorProto,
      DescriptorProto>;

  static constexpr FieldMetadata_Field kField{};
  template <typename T = FieldDescriptorProto> T* add_field() {
    return BeginNestedMessage<T>(2);
  }


  using FieldMetadata_Extension =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      FieldDescriptorProto,
      DescriptorProto>;

  static constexpr FieldMetadata_Extension kExtension{};
  template <typename T = FieldDescriptorProto> T* add_extension() {
    return BeginNestedMessage<T>(6);
  }


  using FieldMetadata_NestedType =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DescriptorProto,
      DescriptorProto>;

  static constexpr FieldMetadata_NestedType kNestedType{};
  template <typename T = DescriptorProto> T* add_nested_type() {
    return BeginNestedMessage<T>(3);
  }


  using FieldMetadata_EnumType =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      EnumDescriptorProto,
      DescriptorProto>;

  static constexpr FieldMetadata_EnumType kEnumType{};
  template <typename T = EnumDescriptorProto> T* add_enum_type() {
    return BeginNestedMessage<T>(4);
  }


  using FieldMetadata_OneofDecl =
    ::protozero::proto_utils::FieldMetadata<
      8,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      OneofDescriptorProto,
      DescriptorProto>;

  static constexpr FieldMetadata_OneofDecl kOneofDecl{};
  template <typename T = OneofDescriptorProto> T* add_oneof_decl() {
    return BeginNestedMessage<T>(8);
  }


  using FieldMetadata_ReservedRange =
    ::protozero::proto_utils::FieldMetadata<
      9,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DescriptorProto_ReservedRange,
      DescriptorProto>;

  static constexpr FieldMetadata_ReservedRange kReservedRange{};
  template <typename T = DescriptorProto_ReservedRange> T* add_reserved_range() {
    return BeginNestedMessage<T>(9);
  }


  using FieldMetadata_ReservedName =
    ::protozero::proto_utils::FieldMetadata<
      10,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      DescriptorProto>;

  static constexpr FieldMetadata_ReservedName kReservedName{};
  void add_reserved_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_ReservedName::kFieldId, data, size);
  }
  void add_reserved_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_ReservedName::kFieldId, chars.data, chars.size);
  }
  void add_reserved_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_ReservedName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }
};

class DescriptorProto_ReservedRange_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  DescriptorProto_ReservedRange_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DescriptorProto_ReservedRange_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DescriptorProto_ReservedRange_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_start() const { return at<1>().valid(); }
  int32_t start() const { return at<1>().as_int32(); }
  bool has_end() const { return at<2>().valid(); }
  int32_t end() const { return at<2>().as_int32(); }
};

class DescriptorProto_ReservedRange : public ::protozero::Message {
 public:
  using Decoder = DescriptorProto_ReservedRange_Decoder;
  enum : int32_t {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.DescriptorProto.ReservedRange"; }


  using FieldMetadata_Start =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      DescriptorProto_ReservedRange>;

  static constexpr FieldMetadata_Start kStart{};
  void set_start(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Start::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_End =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      DescriptorProto_ReservedRange>;

  static constexpr FieldMetadata_End kEnd{};
  void set_end(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_End::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

class FileDescriptorProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/11, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  FileDescriptorProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FileDescriptorProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FileDescriptorProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_package() const { return at<2>().valid(); }
  ::protozero::ConstChars package() const { return at<2>().as_string(); }
  bool has_dependency() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> dependency() const { return GetRepeated<::protozero::ConstChars>(3); }
  bool has_public_dependency() const { return at<10>().valid(); }
  ::protozero::RepeatedFieldIterator<int32_t> public_dependency() const { return GetRepeated<int32_t>(10); }
  bool has_weak_dependency() const { return at<11>().valid(); }
  ::protozero::RepeatedFieldIterator<int32_t> weak_dependency() const { return GetRepeated<int32_t>(11); }
  bool has_message_type() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> message_type() const { return GetRepeated<::protozero::ConstBytes>(4); }
  bool has_enum_type() const { return at<5>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> enum_type() const { return GetRepeated<::protozero::ConstBytes>(5); }
  bool has_extension() const { return at<7>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> extension() const { return GetRepeated<::protozero::ConstBytes>(7); }
};

class FileDescriptorProto : public ::protozero::Message {
 public:
  using Decoder = FileDescriptorProto_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kPackageFieldNumber = 2,
    kDependencyFieldNumber = 3,
    kPublicDependencyFieldNumber = 10,
    kWeakDependencyFieldNumber = 11,
    kMessageTypeFieldNumber = 4,
    kEnumTypeFieldNumber = 5,
    kExtensionFieldNumber = 7,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.FileDescriptorProto"; }


  using FieldMetadata_Name =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      FileDescriptorProto>;

  static constexpr FieldMetadata_Name kName{};
  void set_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Name::kFieldId, data, size);
  }
  void set_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Name::kFieldId, chars.data, chars.size);
  }
  void set_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Name::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Package =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      FileDescriptorProto>;

  static constexpr FieldMetadata_Package kPackage{};
  void set_package(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Package::kFieldId, data, size);
  }
  void set_package(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Package::kFieldId, chars.data, chars.size);
  }
  void set_package(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Package::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Dependency =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      FileDescriptorProto>;

  static constexpr FieldMetadata_Dependency kDependency{};
  void add_dependency(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Dependency::kFieldId, data, size);
  }
  void add_dependency(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Dependency::kFieldId, chars.data, chars.size);
  }
  void add_dependency(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Dependency::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_PublicDependency =
    ::protozero::proto_utils::FieldMetadata<
      10,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      FileDescriptorProto>;

  static constexpr FieldMetadata_PublicDependency kPublicDependency{};
  void add_public_dependency(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_PublicDependency::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_WeakDependency =
    ::protozero::proto_utils::FieldMetadata<
      11,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      FileDescriptorProto>;

  static constexpr FieldMetadata_WeakDependency kWeakDependency{};
  void add_weak_dependency(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_WeakDependency::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_MessageType =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DescriptorProto,
      FileDescriptorProto>;

  static constexpr FieldMetadata_MessageType kMessageType{};
  template <typename T = DescriptorProto> T* add_message_type() {
    return BeginNestedMessage<T>(4);
  }


  using FieldMetadata_EnumType =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      EnumDescriptorProto,
      FileDescriptorProto>;

  static constexpr FieldMetadata_EnumType kEnumType{};
  template <typename T = EnumDescriptorProto> T* add_enum_type() {
    return BeginNestedMessage<T>(5);
  }


  using FieldMetadata_Extension =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      FieldDescriptorProto,
      FileDescriptorProto>;

  static constexpr FieldMetadata_Extension kExtension{};
  template <typename T = FieldDescriptorProto> T* add_extension() {
    return BeginNestedMessage<T>(7);
  }

};

class FileDescriptorSet_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  FileDescriptorSet_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FileDescriptorSet_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FileDescriptorSet_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_file() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> file() const { return GetRepeated<::protozero::ConstBytes>(1); }
};

class FileDescriptorSet : public ::protozero::Message {
 public:
  using Decoder = FileDescriptorSet_Decoder;
  enum : int32_t {
    kFileFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.FileDescriptorSet"; }


  using FieldMetadata_File =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      FileDescriptorProto,
      FileDescriptorSet>;

  static constexpr FieldMetadata_File kFile{};
  template <typename T = FileDescriptorProto> T* add_file() {
    return BeginNestedMessage<T>(1);
  }

};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
