// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_CHROME_SCENARIO_CONFIG_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_CHROME_SCENARIO_CONFIG_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

#include "perfetto/protozero/cpp_message_obj.h"
#include "perfetto/protozero/copyable_ptr.h"
#include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class TracingTriggerRulesConfig;
class TriggerRule;
class TriggerRule_RepeatingInterval;
class TriggerRule_HistogramTrigger;
class ChromeFieldTracingConfig;
class ScenarioConfig;
class NestedScenarioConfig;
class TraceConfig;
class TraceConfig_SessionSemaphore;
class TraceConfig_CmdTraceStartDelay;
class TraceConfig_AndroidReportConfig;
class TraceConfig_TraceFilter;
class TraceConfig_TraceFilter_StringFilterChain;
class TraceConfig_TraceFilter_StringFilterRule;
class TraceConfig_IncidentReportConfig;
class TraceConfig_IncrementalStateConfig;
class TraceConfig_TriggerConfig;
class TraceConfig_TriggerConfig_Trigger;
class TraceConfig_GuardrailOverrides;
class TraceConfig_StatsdMetadata;
class TraceConfig_ProducerConfig;
class TraceConfig_BuiltinDataSource;
class TraceConfig_DataSource;
class DataSourceConfig;
class TestConfig;
class TestConfig_DummyFields;
class InterceptorConfig;
class ConsoleConfig;
class ChromeConfig;
class SystemInfoConfig;
class TraceConfig_BufferConfig;
enum TraceConfig_LockdownModeOperation : int;
enum TraceConfig_CompressionType : int;
enum TraceConfig_StatsdLogging : int;
enum TraceConfig_TraceFilter_StringFilterPolicy : int;
enum TraceConfig_TriggerConfig_TriggerMode : int;
enum BuiltinClock : int;
enum DataSourceConfig_SessionInitiator : int;
enum ConsoleConfig_Output : int;
enum ChromeConfig_ClientPriority : int;
enum TraceConfig_BufferConfig_FillPolicy : int;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {

class PERFETTO_EXPORT_COMPONENT TracingTriggerRulesConfig : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kRulesFieldNumber = 1,
  };

  TracingTriggerRulesConfig();
  ~TracingTriggerRulesConfig() override;
  TracingTriggerRulesConfig(TracingTriggerRulesConfig&&) noexcept;
  TracingTriggerRulesConfig& operator=(TracingTriggerRulesConfig&&);
  TracingTriggerRulesConfig(const TracingTriggerRulesConfig&);
  TracingTriggerRulesConfig& operator=(const TracingTriggerRulesConfig&);
  bool operator==(const TracingTriggerRulesConfig&) const;
  bool operator!=(const TracingTriggerRulesConfig& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  const std::vector<TriggerRule>& rules() const { return rules_; }
  std::vector<TriggerRule>* mutable_rules() { return &rules_; }
  int rules_size() const;
  void clear_rules();
  TriggerRule* add_rules();

 private:
  std::vector<TriggerRule> rules_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT TriggerRule : public ::protozero::CppMessageObj {
 public:
  using HistogramTrigger = TriggerRule_HistogramTrigger;
  using RepeatingInterval = TriggerRule_RepeatingInterval;
  enum FieldNumbers {
    kNameFieldNumber = 1,
    kTriggerChanceFieldNumber = 2,
    kDelayMsFieldNumber = 3,
    kActivationDelayMsFieldNumber = 8,
    kManualTriggerNameFieldNumber = 4,
    kHistogramFieldNumber = 5,
    kRepeatingIntervalFieldNumber = 6,
  };

  TriggerRule();
  ~TriggerRule() override;
  TriggerRule(TriggerRule&&) noexcept;
  TriggerRule& operator=(TriggerRule&&);
  TriggerRule(const TriggerRule&);
  TriggerRule& operator=(const TriggerRule&);
  bool operator==(const TriggerRule&) const;
  bool operator!=(const TriggerRule& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_name() const { return _has_field_[1]; }
  const std::string& name() const { return name_; }
  void set_name(const std::string& value) { name_ = value; _has_field_.set(1); }

  bool has_trigger_chance() const { return _has_field_[2]; }
  float trigger_chance() const { return trigger_chance_; }
  void set_trigger_chance(float value) { trigger_chance_ = value; _has_field_.set(2); }

  bool has_delay_ms() const { return _has_field_[3]; }
  uint64_t delay_ms() const { return delay_ms_; }
  void set_delay_ms(uint64_t value) { delay_ms_ = value; _has_field_.set(3); }

  bool has_activation_delay_ms() const { return _has_field_[8]; }
  uint64_t activation_delay_ms() const { return activation_delay_ms_; }
  void set_activation_delay_ms(uint64_t value) { activation_delay_ms_ = value; _has_field_.set(8); }

  bool has_manual_trigger_name() const { return _has_field_[4]; }
  const std::string& manual_trigger_name() const { return manual_trigger_name_; }
  void set_manual_trigger_name(const std::string& value) { manual_trigger_name_ = value; _has_field_.set(4); }

  bool has_histogram() const { return _has_field_[5]; }
  const TriggerRule_HistogramTrigger& histogram() const { return *histogram_; }
  TriggerRule_HistogramTrigger* mutable_histogram() { _has_field_.set(5); return histogram_.get(); }

  bool has_repeating_interval() const { return _has_field_[6]; }
  const TriggerRule_RepeatingInterval& repeating_interval() const { return *repeating_interval_; }
  TriggerRule_RepeatingInterval* mutable_repeating_interval() { _has_field_.set(6); return repeating_interval_.get(); }

 private:
  std::string name_{};
  float trigger_chance_{};
  uint64_t delay_ms_{};
  uint64_t activation_delay_ms_{};
  std::string manual_trigger_name_{};
  ::protozero::CopyablePtr<TriggerRule_HistogramTrigger> histogram_;
  ::protozero::CopyablePtr<TriggerRule_RepeatingInterval> repeating_interval_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<9> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT TriggerRule_RepeatingInterval : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kPeriodMsFieldNumber = 1,
    kRandomizedFieldNumber = 2,
  };

  TriggerRule_RepeatingInterval();
  ~TriggerRule_RepeatingInterval() override;
  TriggerRule_RepeatingInterval(TriggerRule_RepeatingInterval&&) noexcept;
  TriggerRule_RepeatingInterval& operator=(TriggerRule_RepeatingInterval&&);
  TriggerRule_RepeatingInterval(const TriggerRule_RepeatingInterval&);
  TriggerRule_RepeatingInterval& operator=(const TriggerRule_RepeatingInterval&);
  bool operator==(const TriggerRule_RepeatingInterval&) const;
  bool operator!=(const TriggerRule_RepeatingInterval& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_period_ms() const { return _has_field_[1]; }
  uint64_t period_ms() const { return period_ms_; }
  void set_period_ms(uint64_t value) { period_ms_ = value; _has_field_.set(1); }

  bool has_randomized() const { return _has_field_[2]; }
  bool randomized() const { return randomized_; }
  void set_randomized(bool value) { randomized_ = value; _has_field_.set(2); }

 private:
  uint64_t period_ms_{};
  bool randomized_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT TriggerRule_HistogramTrigger : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kHistogramNameFieldNumber = 1,
    kMinValueFieldNumber = 2,
    kMaxValueFieldNumber = 3,
  };

  TriggerRule_HistogramTrigger();
  ~TriggerRule_HistogramTrigger() override;
  TriggerRule_HistogramTrigger(TriggerRule_HistogramTrigger&&) noexcept;
  TriggerRule_HistogramTrigger& operator=(TriggerRule_HistogramTrigger&&);
  TriggerRule_HistogramTrigger(const TriggerRule_HistogramTrigger&);
  TriggerRule_HistogramTrigger& operator=(const TriggerRule_HistogramTrigger&);
  bool operator==(const TriggerRule_HistogramTrigger&) const;
  bool operator!=(const TriggerRule_HistogramTrigger& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_histogram_name() const { return _has_field_[1]; }
  const std::string& histogram_name() const { return histogram_name_; }
  void set_histogram_name(const std::string& value) { histogram_name_ = value; _has_field_.set(1); }

  bool has_min_value() const { return _has_field_[2]; }
  int64_t min_value() const { return min_value_; }
  void set_min_value(int64_t value) { min_value_ = value; _has_field_.set(2); }

  bool has_max_value() const { return _has_field_[3]; }
  int64_t max_value() const { return max_value_; }
  void set_max_value(int64_t value) { max_value_ = value; _has_field_.set(3); }

 private:
  std::string histogram_name_{};
  int64_t min_value_{};
  int64_t max_value_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT ChromeFieldTracingConfig : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kScenariosFieldNumber = 1,
  };

  ChromeFieldTracingConfig();
  ~ChromeFieldTracingConfig() override;
  ChromeFieldTracingConfig(ChromeFieldTracingConfig&&) noexcept;
  ChromeFieldTracingConfig& operator=(ChromeFieldTracingConfig&&);
  ChromeFieldTracingConfig(const ChromeFieldTracingConfig&);
  ChromeFieldTracingConfig& operator=(const ChromeFieldTracingConfig&);
  bool operator==(const ChromeFieldTracingConfig&) const;
  bool operator!=(const ChromeFieldTracingConfig& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  const std::vector<ScenarioConfig>& scenarios() const { return scenarios_; }
  std::vector<ScenarioConfig>* mutable_scenarios() { return &scenarios_; }
  int scenarios_size() const;
  void clear_scenarios();
  ScenarioConfig* add_scenarios();

 private:
  std::vector<ScenarioConfig> scenarios_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT ScenarioConfig : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kScenarioNameFieldNumber = 1,
    kStartRulesFieldNumber = 2,
    kStopRulesFieldNumber = 3,
    kUploadRulesFieldNumber = 4,
    kSetupRulesFieldNumber = 5,
    kTraceConfigFieldNumber = 6,
    kNestedScenariosFieldNumber = 7,
  };

  ScenarioConfig();
  ~ScenarioConfig() override;
  ScenarioConfig(ScenarioConfig&&) noexcept;
  ScenarioConfig& operator=(ScenarioConfig&&);
  ScenarioConfig(const ScenarioConfig&);
  ScenarioConfig& operator=(const ScenarioConfig&);
  bool operator==(const ScenarioConfig&) const;
  bool operator!=(const ScenarioConfig& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_scenario_name() const { return _has_field_[1]; }
  const std::string& scenario_name() const { return scenario_name_; }
  void set_scenario_name(const std::string& value) { scenario_name_ = value; _has_field_.set(1); }

  const std::vector<TriggerRule>& start_rules() const { return start_rules_; }
  std::vector<TriggerRule>* mutable_start_rules() { return &start_rules_; }
  int start_rules_size() const;
  void clear_start_rules();
  TriggerRule* add_start_rules();

  const std::vector<TriggerRule>& stop_rules() const { return stop_rules_; }
  std::vector<TriggerRule>* mutable_stop_rules() { return &stop_rules_; }
  int stop_rules_size() const;
  void clear_stop_rules();
  TriggerRule* add_stop_rules();

  const std::vector<TriggerRule>& upload_rules() const { return upload_rules_; }
  std::vector<TriggerRule>* mutable_upload_rules() { return &upload_rules_; }
  int upload_rules_size() const;
  void clear_upload_rules();
  TriggerRule* add_upload_rules();

  const std::vector<TriggerRule>& setup_rules() const { return setup_rules_; }
  std::vector<TriggerRule>* mutable_setup_rules() { return &setup_rules_; }
  int setup_rules_size() const;
  void clear_setup_rules();
  TriggerRule* add_setup_rules();

  bool has_trace_config() const { return _has_field_[6]; }
  const TraceConfig& trace_config() const { return *trace_config_; }
  TraceConfig* mutable_trace_config() { _has_field_.set(6); return trace_config_.get(); }

  const std::vector<NestedScenarioConfig>& nested_scenarios() const { return nested_scenarios_; }
  std::vector<NestedScenarioConfig>* mutable_nested_scenarios() { return &nested_scenarios_; }
  int nested_scenarios_size() const;
  void clear_nested_scenarios();
  NestedScenarioConfig* add_nested_scenarios();

 private:
  std::string scenario_name_{};
  std::vector<TriggerRule> start_rules_;
  std::vector<TriggerRule> stop_rules_;
  std::vector<TriggerRule> upload_rules_;
  std::vector<TriggerRule> setup_rules_;
  ::protozero::CopyablePtr<TraceConfig> trace_config_;
  std::vector<NestedScenarioConfig> nested_scenarios_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<8> _has_field_{};
};


class PERFETTO_EXPORT_COMPONENT NestedScenarioConfig : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kScenarioNameFieldNumber = 1,
    kStartRulesFieldNumber = 2,
    kStopRulesFieldNumber = 3,
    kUploadRulesFieldNumber = 4,
  };

  NestedScenarioConfig();
  ~NestedScenarioConfig() override;
  NestedScenarioConfig(NestedScenarioConfig&&) noexcept;
  NestedScenarioConfig& operator=(NestedScenarioConfig&&);
  NestedScenarioConfig(const NestedScenarioConfig&);
  NestedScenarioConfig& operator=(const NestedScenarioConfig&);
  bool operator==(const NestedScenarioConfig&) const;
  bool operator!=(const NestedScenarioConfig& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;

  bool has_scenario_name() const { return _has_field_[1]; }
  const std::string& scenario_name() const { return scenario_name_; }
  void set_scenario_name(const std::string& value) { scenario_name_ = value; _has_field_.set(1); }

  const std::vector<TriggerRule>& start_rules() const { return start_rules_; }
  std::vector<TriggerRule>* mutable_start_rules() { return &start_rules_; }
  int start_rules_size() const;
  void clear_start_rules();
  TriggerRule* add_start_rules();

  const std::vector<TriggerRule>& stop_rules() const { return stop_rules_; }
  std::vector<TriggerRule>* mutable_stop_rules() { return &stop_rules_; }
  int stop_rules_size() const;
  void clear_stop_rules();
  TriggerRule* add_stop_rules();

  const std::vector<TriggerRule>& upload_rules() const { return upload_rules_; }
  std::vector<TriggerRule>* mutable_upload_rules() { return &upload_rules_; }
  int upload_rules_size() const;
  void clear_upload_rules();
  TriggerRule* add_upload_rules();

 private:
  std::string scenario_name_{};
  std::vector<TriggerRule> start_rules_;
  std::vector<TriggerRule> stop_rules_;
  std::vector<TriggerRule> upload_rules_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_CHROME_SCENARIO_CONFIG_PROTO_CPP_H_
